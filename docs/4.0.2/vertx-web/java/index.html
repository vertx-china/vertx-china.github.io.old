<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="description" content="Vert.x | Reactive applications on the JVM"/><meta name="robots" content="index,follow"/><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,400" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&amp;display=swap" rel="stylesheet"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48x48.png"/><link rel="alternate" type="application/rss+xml" href="/feed/rss.xml"/><link rel="alternate" type="application/atom+xml" href="/feed/atom.xml"/><link rel="alternate" type="application/json" href="/feed/feed.json"/><title>Vert.x Web | Eclipse Vert.x</title><link rel="preload" href="https://api.github.com/repos/vert-x3/vertx-web" as="fetch" crossorigin="anonymous"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/styles.f20dca63.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.f20dca63.chunk.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-b6e20584df76f29b6f35.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.fcef98db13e2318579fb.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.5b8771ac6e8a338f82f1.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.7064a0f84b2a7c13404a.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3dbbc9c041333077c167.js" as="script"/><link rel="preload" href="/_next/static/chunks/5df0631eea625b022d3730b3f1bf573e1b8deb37.3b9874ba65db13e7d868.js" as="script"/><link rel="preload" href="/_next/static/chunks/31acfd8439b7c9eee4abe9f59c7500d6c943ee0d.0c2b12aac197391070e2.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/docs/%5B%5B...slug%5D%5D-f144718c033f8d0b431b.js" as="script"/></head><body><div id="__next"><main class="page docs"><header><div class="navbar"><div class="navbar-content container"><div class="navbar-logo"><a href="/"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAxMTI1LjYgMzE1LjIiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZT4uc3Qwe2ZpbGw6Izc4MmE5MX08L3N0eWxlPjxwYXRoIGQ9Ik0xMjAuOSAyMTQuMkwxOTAuNSAwaDUyLjNsLTk4LjUgMjczLjhIOTguMkwwIDBoNTIuMWw2OC44IDIxNC4yem0yOTEuMi02Mi42SDI5OS42djg0LjJINDMxdjM4SDI1MlYwaDE3Ny43djM4LjRIMjk5LjZWMTE0aDExMi41djM3LjZ6bTgzLjctMTEzLjJINTQ2YzE2LjUuMyAyOSA0LjQgMzcuMyAxMi40IDguMyA4IDEyLjUgMTkuNCAxMi41IDM0IDAgMTQtNC41IDI1LjEtMTMuNSAzMy4yLTkgOC4xLTIxLjYgMTIuMS0zNy42IDEyLjFoLTI3LjF2MjQuMmw4Ni4xIDExOS41aDUxdi0yLjRsLTc3LjItMTA2LjdjMjQuOS01LjUgNDMuMy0yMS43IDUyLjYtMzUuOSA4LjItMTIuNiAxMy4zLTI3LjcgMTMuMy00NiAwLTI2LjgtOC42LTQ3LjQtMjUuOC02MS41QzYwMC41IDcuMSA1NzYuMSAwIDU0NC41IDBoLTk2LjN2MjczLjhoNDcuNiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDUyLjMgMTU3LjdsLTQxLjUgNjIuNyAyOS43IDUzLjRoODUuMXoiLz48Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSI4MjcuOSIgY3k9IjI3NC43IiByPSI0MC41Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTEwMzcgMGwtNDcuNiA3NC4yTDk0OSAwaC04NGw4NS4zIDEzNS44LTY3LjEgMTA1LjdjNS43IDkuNSA5LjEgMjAuNSA5LjIgMzIuNGg1MC4xTDExMjEuMyAwSDEwMzd6Ii8+PHBhdGggZD0iTTc2My41IDI3My44Yy4xLTkuOSAyLjUtMTkuMiA2LjYtMjcuNVYzOC40aDg1LjRWMEg2MzguMnYzOC40aDg0LjZ2MjM1LjRoNDAuN3oiLz48L3N2Zz4=" alt="Vert.x Logo"/></a></div><div class="navbar-collapse-button"><span></span><span></span><span></span></div><div class="navbar-right"><div class="navbar-menu"><span class="navbar-menu-item with-drop-down"><div class="dropdown"><a class="dropdown-title">开始<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu"><a href="/introduction-to-vertx-and-reactive/"><li class="dropdown-item">简介</li></a><a href="/get-started/"><li class="dropdown-item">开始</li></a><a href="https://start.vertx.io/" target="_blank" rel="noreferrer"><li class="dropdown-item">App generator <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a></ul></div></span><a class="navbar-menu-item" href="/docs/">文档</a><span class="navbar-menu-item with-drop-down"><div class="dropdown"><a class="dropdown-title">资源<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu"><a href="/faq/"><li class="dropdown-item">答疑</li></a><a href="/channels/"><li class="dropdown-item">Channels</li></a><a href="https://how-to.vertx.io/" target="_blank" rel="noreferrer"><li class="dropdown-item">How-To’s <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a><a href="https://github.com/vert-x3/vertx-eventbus-bridge-clients" target="_blank" rel="noreferrer"><li class="dropdown-item">EventBus Bridge Clients <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a></ul></div></span><a class="navbar-menu-item" href="/blog/">博客</a><a class="navbar-menu-item" href="/community/">社区</a><a class="navbar-menu-item" href="/translation/">翻译团队</a></div><div class="navbar-social"><a href="https://github.com/vert-x3/vertx-awesome" class="navbar-social-link" title="Awesome Vert.x" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="List of awesome Vert.x projects"><title>Awesome Vert.x</title><path d="M24 11.438l-6.154-5.645-.865.944 5.128 4.7H1.895l5.128-4.705-.865-.943-6.154 5.649H0v3.72c0 1.683 1.62 3.053 3.61 3.053h3.795c1.99 0 3.61-1.37 3.61-3.051v-2.446h1.97v2.446c0 1.68 1.62 3.051 3.61 3.051h3.794c1.99 0 3.61-1.37 3.61-3.051v-3.721z"></path></svg></a><a href="https://stackoverflow.com/questions/tagged/vert.x" class="navbar-social-link" title="Stack Overflow" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Stack Overflow questions related to Vert.x"><title>Stack Overflow</title><path d="M18.986 21.865v-6.404h2.134V24H1.844v-8.539h2.13v6.404h15.012zM6.111 19.731H16.85v-2.137H6.111v2.137zm.259-4.852l10.48 2.189.451-2.07-10.478-2.187-.453 2.068zm1.359-5.056l9.705 4.53.903-1.95-9.706-4.53-.902 1.936v.014zm2.715-4.785l8.217 6.855 1.359-1.62-8.216-6.853-1.35 1.617-.01.001zM15.751 0l-1.746 1.294 6.405 8.604 1.746-1.294L15.749 0h.002z"></path></svg></a><a href="https://www.youtube.com/channel/UCGN6L3tRhs92Uer3c6VxOSA" class="navbar-social-link" title="YouTube" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="YouTube channel of Vert.x"><title>YouTube</title><path d="M23.499 6.203a3.008 3.008 0 00-2.089-2.089c-1.87-.501-9.4-.501-9.4-.501s-7.509-.01-9.399.501a3.008 3.008 0 00-2.088 2.09A31.258 31.26 0 000 12.01a31.258 31.26 0 00.523 5.785 3.008 3.008 0 002.088 2.089c1.869.502 9.4.502 9.4.502s7.508 0 9.399-.502a3.008 3.008 0 002.089-2.09 31.258 31.26 0 00.5-5.784 31.258 31.26 0 00-.5-5.808zm-13.891 9.4V8.407l6.266 3.604z"></path></svg></a><a href="https://discord.gg/KzEMwP2" class="navbar-social-link" title="Discord" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Eclipse Vert.x channel on Discord"><title>Discord</title><path d="M20.222 0c1.406 0 2.54 1.137 2.607 2.475V24l-2.677-2.273-1.47-1.338-1.604-1.398.67 2.205H3.71c-1.402 0-2.54-1.065-2.54-2.476V2.48C1.17 1.142 2.31.003 3.715.003h16.5L20.222 0zm-6.118 5.683h-.03l-.202.2c2.073.6 3.076 1.537 3.076 1.537-1.336-.668-2.54-1.002-3.744-1.137-.87-.135-1.74-.064-2.475 0h-.2c-.47 0-1.47.2-2.81.735-.467.203-.735.336-.735.336s1.002-1.002 3.21-1.537l-.135-.135s-1.672-.064-3.477 1.27c0 0-1.805 3.144-1.805 7.02 0 0 1 1.74 3.743 1.806 0 0 .4-.533.805-1.002-1.54-.468-2.14-1.404-2.14-1.404s.134.066.335.2h.06c.03 0 .044.015.06.03v.006c.016.016.03.03.06.03.33.136.66.27.93.4.466.202 1.065.403 1.8.536.93.135 1.996.2 3.21 0 .6-.135 1.2-.267 1.8-.535.39-.2.87-.4 1.397-.737 0 0-.6.936-2.205 1.404.33.466.795 1 .795 1 2.744-.06 3.81-1.8 3.87-1.726 0-3.87-1.815-7.02-1.815-7.02-1.635-1.214-3.165-1.26-3.435-1.26l.056-.02zm.168 4.413c.703 0 1.27.6 1.27 1.335 0 .74-.57 1.34-1.27 1.34-.7 0-1.27-.6-1.27-1.334.002-.74.573-1.338 1.27-1.338zm-4.543 0c.7 0 1.266.6 1.266 1.335 0 .74-.57 1.34-1.27 1.34-.7 0-1.27-.6-1.27-1.334 0-.74.57-1.338 1.27-1.338z"></path></svg></a><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx" class="navbar-social-link" title="Vert.x User Group" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="A Google group for Vert.x users"><title>Vert.x User Group</title><path d="M.92 3.332c-.776 0-1.216.67-.692 1.383l2.537 4.403v7.86c0 2.013 1.467 3.69 3.459 3.69H20.31a3.75 3.75 0 003.69-3.69V7.043a3.723 3.723 0 00-3.668-3.71zm5.786 3.71H20.1c.587 0 1.153.357 1.153.923 0 .566-.566.922-1.153.922H6.706c-.587 0-1.153-.356-1.153-.922 0-.566.566-.923 1.153-.923zm0 3.69H20.1c.587 0 1.153.356 1.153.922 0 .566-.566.922-1.153.922H6.706c-.587 0-1.153-.356-1.153-.922 0-.566.566-.922 1.153-.922zm-.021 3.71h9.705c.587 0 1.153.356 1.153.922 0 .566-.566.923-1.153.923H6.685c-.587 0-1.153-.357-1.153-.923 0-.566.566-.922 1.153-.922Z"></path></svg></a><a href="https://shang.qq.com/wpa/qunwpa?idkey=587f58cacb9557e3291b46098e0fe09427b98a1c0f866da23c04c2762bc7e2ad" class="navbar-social-link" title="Vert.x中国用户组QQ群" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Vert.x中国用户组QQ群"><title>Vert.x中国用户组QQ群</title><path d="M21.395 15.035a39.548 39.548 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a38.97 38.97 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673zM12.662 4.846c.039-1.052.659-1.878 1.385-1.846s1.281.912 1.242 1.964c-.039 1.051-.659 1.878-1.385 1.846s-1.282-.912-1.242-1.964zM9.954 3c.725-.033 1.345.794 1.384 1.846.04 1.052-.517 1.931-1.242 1.963-.726.033-1.346-.794-1.385-1.845C8.672 3.912 9.228 3.033 9.954 3zM7.421 8.294c.194-.43 2.147-.908 4.566-.908h.026c2.418 0 4.372.479 4.566.908a.14.14 0 0 1 .014.061c0 .031-.01.059-.026.083-.163.238-2.333 1.416-4.553 1.416h-.026c-2.221 0-4.39-1.178-4.553-1.416a.136.136 0 0 1-.014-.144zm10.422 8.622c-.22 3.676-2.403 5.987-5.774 6.021h-.137c-3.37-.033-5.554-2.345-5.773-6.021-.081-1.35.001-2.496.147-3.43.318.063.638.122.958.176v3.506s1.658.334 3.318.103v-3.225c.488.027.96.04 1.406.034h.025c1.678.021 3.714-.204 5.683-.594.146.934.227 2.08.147 3.43zM10.48 5.804c.313-.041.542-.409.508-.825-.033-.415-.314-.72-.629-.679-.313.04-.541.409-.508.824.034.417.315.72.629.68zM14.479 5.156c.078.037.221.042.289-.146.035-.095.025-.165-.009-.214-.023-.033-.133-.118-.371-.176-.904-.22-1.341.384-1.405.499-.04.072-.012.176.056.227.067.051.139.037.179-.006.58-.628 1.21-.208 1.261-.184z"></path></svg></a></div></div></div></div></header><div class="page-content docs-content"><div class="container"><div class="docs-content-wrapper"><aside class=""><div class="docs-content-wrapper-sidebar"><div class="search-panel"><div class="search"><input type="text" placeholder="Search..." value=""/><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon-delete"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg></div><ul class="search-results"></ul><div class="search-results-none">No results.</div></div><div class="docs-content-toc"><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_using_vert_x_web">使用 Vert.x Web</a>
<ul class="sectlevel2">
<li><a href="#_development_mode">开发模式</a></li>
</ul>
</li>
<li><a href="#_re_cap_on_vert_x_core_http_servers">回顾 Vert.x Core 的 HTTP 服务端</a></li>
<li><a href="#_basic_vert_x_web_concepts">Vert.x Web 的基本概念</a></li>
<li><a href="#_handling_requests_and_calling_the_next_handler">处理请求并调用下一个处理器</a></li>
<li><a href="#_simple_responses">简单的响应</a></li>
<li><a href="#_using_blocking_handlers">使用阻塞式处理器</a></li>
<li><a href="#_routing_by_exact_path">基于精确路径的路由</a></li>
<li><a href="#_routing_by_paths_that_begin_with_something">基于路径前缀的路由</a></li>
<li><a href="#_capturing_path_parameters">捕捉路径参数</a></li>
<li><a href="#_routing_with_regular_expressions">基于正则表达式的路由</a></li>
<li><a href="#_capturing_path_parameters_with_regular_expressions">通过正则表达式捕捉路径参数</a></li>
<li><a href="#_using_named_capture_groups">使用命名的捕捉组</a></li>
<li><a href="#_routing_by_http_method">基于 HTTP 方法的路由</a></li>
<li><a href="#_route_order">Route order</a></li>
<li><a href="#_routing_based_on_mime_type_of_request">Routing based on MIME type of request</a></li>
<li><a href="#_routing_based_on_mime_types_acceptable_by_the_client">Routing based on MIME types acceptable by the client</a></li>
<li><a href="#_routing_based_on_virtualhost">Routing based on VirtualHost</a></li>
<li><a href="#_combining_routing_criteria">Combining routing criteria</a></li>
<li><a href="#_enabling_and_disabling_routes">Enabling and disabling routes</a></li>
<li><a href="#_forward_support">Forward Support</a></li>
<li><a href="#_context_data">Context data</a></li>
<li><a href="#_helper_functions">Helper functions</a></li>
<li><a href="#_reroute">Reroute</a></li>
<li><a href="#_sub_routers">Sub-routers</a></li>
<li><a href="#_localization">Localization</a></li>
<li><a href="#_route_match_failures">Route match failures</a></li>
<li><a href="#_error_handling">Error handling</a></li>
<li><a href="#_request_body_handling">Request body handling</a>
<ul class="sectlevel2">
<li><a href="#_getting_the_request_body">Getting the request body</a></li>
<li><a href="#_limiting_body_size">Limiting body size</a></li>
<li><a href="#_merging_form_attributes">Merging form attributes</a></li>
<li><a href="#_handling_file_uploads">Handling file uploads</a></li>
</ul>
</li>
<li><a href="#_handling_cookies">Handling cookies</a>
<ul class="sectlevel2">
<li><a href="#_manipulating_cookies">Manipulating cookies</a></li>
</ul>
</li>
<li><a href="#_handling_sessions">Handling sessions</a>
<ul class="sectlevel2">
<li><a href="#_session_stores">Session stores</a></li>
<li><a href="#_creating_the_session_handler">Creating the session handler</a></li>
<li><a href="#_using_the_session">Using the session</a></li>
<li><a href="#_session_timeout">Session timeout</a></li>
</ul>
</li>
<li><a href="#_authentication_authorization">Authentication / authorization</a>
<ul class="sectlevel2">
<li><a href="#_creating_an_authentication_handler">Creating an Authentication handler</a></li>
<li><a href="#_handling_authentication_in_your_application">Handling authentication in your application</a></li>
<li><a href="#_http_basic_authentication">HTTP Basic Authentication</a></li>
<li><a href="#_redirect_authentication_handler">Redirect authentication handler</a></li>
<li><a href="#_jwt_authentication">JWT authentication</a></li>
<li><a href="#_configuring_authorization">Configuring authorization</a></li>
<li><a href="#_chaining_multiple_authentication_handlers">Chaining multiple authentication handlers</a></li>
</ul>
</li>
<li><a href="#_serving_static_resources">Serving static resources</a>
<ul class="sectlevel2">
<li><a href="#_configuring_caching">Configuring caching</a></li>
<li><a href="#_configuring_the_index_page">Configuring the index page</a></li>
<li><a href="#_changing_the_web_root">Changing the web root</a></li>
<li><a href="#_serving_hidden_files">Serving hidden files</a></li>
<li><a href="#_directory_listing">Directory listing</a></li>
<li><a href="#_disabling_file_caching_on_disk">Disabling file caching on disk</a></li>
</ul>
</li>
<li><a href="#_cors_handling">CORS handling</a></li>
<li><a href="#_multi_tenant">Multi Tenant</a></li>
<li><a href="#_templates">模板</a>
<ul class="sectlevel2">
<li><a href="#_mvel_template_engine">MVEL 模版引擎</a></li>
<li><a href="#_jade_template_engine">Jade 模版引擎（译者注：Jade 已更名为 Pug)</a></li>
<li><a href="#_handlebars_template_engine">Handlebars 模板引擎</a></li>
<li><a href="#_thymeleaf_template_engine">Thymeleaf 模板引擎</a></li>
<li><a href="#_apache_freemarker_template_engine">Apache FreeMarker 模版引擎</a></li>
<li><a href="#_pebble_template_engine">Pebble 模版引擎</a></li>
<li><a href="#_rocker_template_engine">Rocker 模版引擎</a></li>
<li><a href="#_httl_template_engine">HTTL 模版引擎</a></li>
<li><a href="#_rythm_template_engine">Rythm 模版引擎</a></li>
<li><a href="#_caching">缓存</a></li>
</ul>
</li>
<li><a href="#_error_handler">错误处理器</a></li>
<li><a href="#_request_logger">请求日志</a></li>
<li><a href="#_serving_favicons">提供网页图标</a></li>
<li><a href="#_timeout_handler">超时处理器</a></li>
<li><a href="#_response_time_handler">响应时间处理器</a></li>
<li><a href="#_content_type_handler">内容类型（Content type）处理器</a></li>
<li><a href="#_sockjs">SockJS</a>
<ul class="sectlevel2">
<li><a href="#_sockjs_handler">SockJS 处理器</a></li>
<li><a href="#_handling_sockjs_sockets">处理 SockJS 套接字</a></li>
<li><a href="#_the_client_side">客户端</a></li>
<li><a href="#_configuring_the_sockjs_handler">配置 SockJS 处理器</a></li>
<li><a href="#_writing_to_a_sockjs_socket_over_the_event_bus">通过 event bus 写入 SockJS 套接字</a></li>
</ul>
</li>
<li><a href="#_sockjs_event_bus_bridge">SockJS 桥接 Event Bus</a>
<ul class="sectlevel2">
<li><a href="#_securing_the_bridge">守护连接桥</a></li>
<li><a href="#_requiring_authorization_for_messages">消息授权</a></li>
<li><a href="#_handling_event_bus_bridge_events">Handling event bus bridge events</a></li>
</ul>
</li>
<li><a href="#_csrf_cross_site_request_forgery">CSRF Cross Site Request Forgery</a>
<ul class="sectlevel2">
<li><a href="#_using_ajax">Using AJAX</a></li>
</ul>
</li>
<li><a href="#_hsts_handler">HSTS Handler</a></li>
<li><a href="#_csp_handler">CSP Handler</a></li>
<li><a href="#_xframe_handler">XFrame Handler</a></li>
<li><a href="#_oauth2authhandler_handler">OAuth2AuthHandler Handler</a>
<ul class="sectlevel2">
<li><a href="#_a_real_world_example">A real world example</a></li>
<li><a href="#_mixing_oauth2_and_jwt">Mixing OAuth2 and JWT</a></li>
<li><a href="#_webauthn">WebAuthn</a></li>
<li><a href="#_handling_http_method_overriding">Handling HTTP Method overriding</a></li>
</ul>
</li>
</ul>
</div></div></div></aside><div class="docs-content-sidebar-toggle"><div style="position:relative"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></div></div><div class="docs-content-inner"><div class="docs-content-metadata"><div class="docs-content-metadata-left"><div class="docs-content-metadata-repo"><div class="github-stars"><a href="https://github.com/vert-x3/vertx-web"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>null stars</a></div></div><div><a href="https://vertx.io/docs/apidocs"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg> API</a></div><div class="docs-content-metadata-examples"><a href="https://github.com/vert-x3/vertx-examples/tree/4.x/web-examples"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg> Examples</a></div><div class="docs-content-metadata-edit"><a href="https://github.com/vertx-china/vertx-web-site/tree/master/docs/translation/vertx-web/java"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg> 改进翻译</a></div><span class="docs-content-metadata-version"><div class="dropdown"><a class="dropdown-title">v4.0.3<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu align-right"><a href="/docs/vertx-web/java/"><li class="dropdown-item active has-active-siblings"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="dropdown-check-icon"><polyline points="20 6 9 17 4 12"></polyline></svg>Latest (v<!-- -->4.0.3<!-- -->)</li></a><a href="/docs/3.9.6/vertx-web/java/"><li class="dropdown-item has-active-siblings">v<!-- -->3.9.6</li></a></ul></div></span></div></div><div><h1>Vert.x-Web</h1>

<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x-Web是基于Vert.x的，用于构建Web应用程序的一系列构建模块。 可以将其视为一把构建现代的，可扩展的Web应用的瑞士军刀。</p>
</div>
<div class="paragraph">
<p>Vert.x Core 提供了一系列相对底层的功能用于操作HTTP，对于一部分应用是足够的。</p>
</div>
<div class="paragraph">
<p>Vert.x Web 基于 Vert.x Core 提供了一系列更丰富的功能，以便更容易地开发实际的 Web 应用。</p>
</div>
<div class="paragraph">
<p>它继承了 Vert.x 2.x 里的 <a href="http://pmlopes.github.io/yoke/">Yoke</a> 的特点，灵感来自于 Node.js 的框架 <a href="http://expressjs.com/">Express</a> 和 Ruby 的框架 <a href="http://www.sinatrarb.com/">Sinatra</a> 等等。</p>
</div>
<div class="paragraph">
<p>Vert.x Web 的设计是强大的，非侵入式的, 并且是完全可插拔的。您可以只使用您需要的部分。 Vert.x Web 不是一个容器。</p>
</div>
<div class="paragraph">
<p>您可以使用 Vert.x Web 来构建经典的服务端 Web 应用， RESTful 应用， 实时的（服务端推送)Web 应用, 或任何您所能想到的 Web 应用类型。应用类型的选择取决于您的喜好，而不是 Vert.x Web。</p>
</div>
<div class="paragraph">
<p>Vert.x-Web is a great fit for writing RESTful HTTP micro-services, but we don’t force you to write apps like that。
Vert.x Web 非常适合编写 RESTful HTTP 微服务，<strong> 但我们不强制 </strong> 您必须把应用实现成这样。</p>
</div>
<div class="paragraph">
<p>Vert.x Web 的一部分关键特性有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>路由(基于方法,路径等)</p>
</li>
<li>
<p>基于正则表达式的路径匹配</p>
</li>
<li>
<p>从路径中提取参数</p>
</li>
<li>
<p>内容协商</p>
</li>
<li>
<p>处理消息体</p>
</li>
<li>
<p>消息体的长度限制</p>
</li>
<li>
<p>Multipart 表单</p>
</li>
<li>
<p>Multipart 文件上传</p>
</li>
<li>
<p>子路由</p>
</li>
<li>
<p>支持本地会话和集群会话</p>
</li>
<li>
<p>支持 CORS(跨域资源共享)</p>
</li>
<li>
<p>错误页面处理器</p>
</li>
<li>
<p>HTTP基本/摘要认证</p>
</li>
<li>
<p>基于重定向的认证</p>
</li>
<li>
<p>授权处理器</p>
</li>
<li>
<p>基于 JWT 的授权</p>
</li>
<li>
<p>用户/角色/权限授权</p>
</li>
<li>
<p>网页图标处理器</p>
</li>
<li>
<p>支持服务端模板渲染，包括以下开箱即用的模板引擎:</p>
<div class="ulist">
<ul>
<li>
<p>Handlebars</p>
</li>
<li>
<p>Jade</p>
</li>
<li>
<p>MVEL</p>
</li>
<li>
<p>Thymeleaf</p>
</li>
<li>
<p>Apache FreeMarker</p>
</li>
<li>
<p>Pebble</p>
</li>
<li>
<p>Rocker</p>
</li>
</ul>
</div>
</li>
<li>
<p>响应时间处理器</p>
</li>
<li>
<p>静态文件服务，包括缓存逻辑以及目录监听</p>
</li>
<li>
<p>支持请求超时</p>
</li>
<li>
<p>支持 SockJS</p>
</li>
<li>
<p>桥接 Event-bus</p>
</li>
<li>
<p>CSRF 跨域请求伪造</p>
</li>
<li>
<p>虚拟主机</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Vert.x Web 的大部分特性是使用Handler实现的， 而且您随时可以实现您自己的处理器。我们预计随着时间的推移会有更多的处理器被实现。</p>
</div>
<div class="paragraph">
<p>我们会在本手册里讨论所有上述的特性。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_vert_x_web"><a class="anchor" href="#_using_vert_x_web"></a>使用 Vert.x Web</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在使用 Vert.x Web 之前，需要为您的构建工具在描述文件中添加  <em>dependencies</em> 依赖项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在您的 <code>pom.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vertx-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在您的 <code>build.gradle</code> 文件中)：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
 compile <span class="hljs-string">'io.vertx:vertx-web:4.0.2'</span>
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_development_mode"><a class="anchor" href="#_development_mode"></a>开发模式</h3>
<div class="paragraph">
<p>Vert.x Web 默认使用生产模式。
您可以通过设置 <code>dev</code> 值到下面的其中一个来切换开发模式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VERTXWEB_ENVIRONMENT</code> 环境变量，或</p>
</li>
<li>
<p><code>vertxweb.environment</code> 系统属性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在开发模式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模板引擎缓存被禁用</p>
</li>
<li>
<p><code>ErrorHandler</code> 不显示异常详细信息</p>
</li>
<li>
<p><code>StaticHandler</code> 不处理缓存头</p>
</li>
<li>
<p>GraphQL开发工具被禁用</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_re_cap_on_vert_x_core_http_servers"><a class="anchor" href="#_re_cap_on_vert_x_core_http_servers"></a>回顾 Vert.x Core 的 HTTP 服务端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Web 使用并暴露了 Vert.x Core 的 API，所以熟悉基于 Vert.x Core 编写 HTTP 服务端的基本概念是很有价值的。</p>
</div>
<div class="paragraph">
<p>Vert.x core HTTP文档对此进行了详细介绍。</p>
</div>
<div class="paragraph">
<p>这是一个用 Vert.x core 编写的 Hello World Web服务。暂不涉及Vert.x-Web：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpServer server = vertx.createHttpServer();

server.requestHandler(request -&gt; {

  <span class="hljs-comment">// 所有的请求都会调用这个处理器处理</span>
  HttpServerResponse response = request.response();
  response.putHeader(<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"text/plain"</span>);

  <span class="hljs-comment">// 写入响应并结束处理</span>
  response.end(<span class="hljs-string">"Hello World!"</span>);
});

server.listen(<span class="hljs-number">8080</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们创建了一个 HTTP 服务器实例，并设置了一个请求处理器。所有的请求都会调用这个处理器处理。</p>
</div>
<div class="paragraph">
<p>当请求到达时，我们设置响应的 Content Type 为 <code>text/plain</code> ， 并写入了 <code>Hello World!</code> 然后结束了处理。</p>
</div>
<div class="paragraph">
<p>之后，我们告诉服务器监听 <code>8080</code> 端口(默认的主机名是 <code>localhost</code> )。</p>
</div>
<div class="paragraph">
<p>您可以执行这段代码，并打开浏览器访问 <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code> 来验证它是否如预期一样工作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_vert_x_web_concepts"><a class="anchor" href="#_basic_vert_x_web_concepts"></a>Vert.x Web 的基本概念</h2>
<div class="sectionbody">
<div class="paragraph">
<p>高屋建瓴 (Here&#8217;s the 10000 foot view)：</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/web/Router.html">路由器 Router</a></code> 是 Vert.x Web 的核心概念之一。 它是一个维护了零或多个
<code><a href="../../apidocs/io/vertx/ext/web/Route.html">路由 Routes</a></code> 的对象。</p>
</div>
<div class="paragraph">
<p>一个 router 接收 HTTP 请求，并查找首个匹配该请求的route, 然后将请求传递给这个route</p>
</div>
<div class="paragraph">
<p><code>Route</code> 可以持有一个与之关联的 <em>handler</em> 用于接收请求。 您可以通过这个处理器对请求 <em>做一些事情</em>, 然后结束响应或者把请求传递给下一个匹配的处理器。</p>
</div>
<div class="paragraph">
<p>以下是一个简单的路由示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpServer server = vertx.createHttpServer();

Router router = Router.router(vertx);

router.route().handler(ctx -&gt; {

  <span class="hljs-comment">// 所有的请求都会调用这个处理器处理</span>
  HttpServerResponse response = ctx.response();
  response.putHeader(<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"text/plain"</span>);

  <span class="hljs-comment">// 写入响应并结束处理</span>
  response.end(<span class="hljs-string">"Hello World from Vert.x-Web!"</span>);
});

server.requestHandler(router).listen(<span class="hljs-number">8080</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它做了和上文使用 Vert.x Core 实现的 hello world HTTP 服务基本相同的事情，只是这一次换成了 Vert.x Web。</p>
</div>
<div class="paragraph">
<p>我们像以前一样创建一个HTTP服务器，然后我们创建一个 router。当我们完成这些之后,我们创建一个简单的没有匹配条件的 rout，它能够匹配 <em>全部</em> 到来的请求。</p>
</div>
<div class="paragraph">
<p>然后，我们为该路由指定一个处理器。该处理器将处理所有到来的请求。</p>
</div>
<div class="paragraph">
<p>传递给处理器的对象是 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> - 它包含标准的 Vert.x <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html">HttpServerRequest</a></code> 和 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html">HttpServerResponse</a></code>
还有其他各种有用的东西，让使用Vert.x-Web变得更加简单。</p>
</div>
<div class="paragraph">
<p>处理器调用的参数是一个 <a href="http://vertx.io/docs/apidocs/io/vertx/ext/web/RoutingContext.html"> <code>RoutingContext</code> </a> 对象。 它不仅包含了 Vert.x 中标准的 <a href="http://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerRequest.html"> <code>HttpServerRequest</code> </a> 和
<a href="http://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerResponse.html"> <code>HttpServerResponse</code> </a>，还包含了各种用于简化 Vert.x Web 使用的东西。</p>
</div>
<div class="paragraph">
<p>每个被路由的请求， 都有一个唯一的路由上下文实例， 并将这个实例传递给该请求的所有处理器。</p>
</div>
<div class="paragraph">
<p>当我们建立了处理器之后，我们设置 HTTP 服务器的请求处理器，使所有的请求都通过 <code><a href="../../apidocs/io/vertx/core/Handler。html#handle-java.lang.Object-">handle</a></code> 处理。</p>
</div>
<div class="paragraph">
<p>这些是最基本的，下面我们来看一下更多的细节：</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_requests_and_calling_the_next_handler"><a class="anchor" href="#_handling_requests_and_calling_the_next_handler"></a>处理请求并调用下一个处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当 Vert.x Web 决定路由一个请求到匹配的route，它会调用对应处理器并将一个 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> 实例传递给它. route可以具有不同的处理器， 您可以叠加使用 <code><a href="../../apidocs/io/vertx/ext/web/Route。html#handler-io.vertx.core.Handler-">handler</a></code></p>
</div>
<div class="paragraph">
<p>如果您不在处理器里结束这个响应，您需要调用 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#next--">next</a></code> 方法让其他匹配的 route 来处理请求(如果有)。</p>
</div>
<div class="paragraph">
<p>您不需要在处理器执行完毕时调用 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#next--">next</a></code> 。 您可以在之后需要的时间点调用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route(<span class="hljs-string">"/some/path/"</span>);
route.handler(ctx -&gt; {

  HttpServerResponse response = ctx.response();
  <span class="hljs-comment">// 开启分块响应，因为我们将在执行其他处理器时添加数据</span>
  <span class="hljs-comment">// 仅当有多个处理器输出时</span>
  response.setChunked(<span class="hljs-keyword">true</span>);

  response.write(<span class="hljs-string">"route1\n"</span>);

  <span class="hljs-comment">// 延迟5秒后调用下一匹配route</span>
  ctx.vertx().setTimer(<span class="hljs-number">5000</span>, tid -&gt; ctx.next());
});

route.handler(ctx -&gt; {

  HttpServerResponse response = ctx.response();
  response.write(<span class="hljs-string">"route2\n"</span>);

  <span class="hljs-comment">// 延迟5秒后调用下一匹配route</span>
  ctx.vertx().setTimer(<span class="hljs-number">5000</span>, tid -&gt; ctx.next());
});

route.handler(ctx -&gt; {

  HttpServerResponse response = ctx.response();
  response.write(<span class="hljs-string">"route3"</span>);

  <span class="hljs-comment">// 现在结束响应</span>
  ctx.response().end();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述的例子中， <code>route1</code> 向响应里写入了数据， 5秒之后 <code>route2</code> 向响应里写入了数据，再5秒之后 <code>route3</code> 向响应里写入了数据并结束了响应。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
所有发生的这些没有线程阻塞。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_simple_responses"><a class="anchor" href="#_simple_responses"></a>简单的响应</h2>
<div class="sectionbody">
<div class="paragraph">
<p>处理器非常强大， 因为它们允许您构建非常复杂的应用程序。 为了保证简单的响应，例如直接从vert.x API返回异步响应，router 包含一个快捷的处理器：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>响应返回JSON。</p>
</li>
<li>
<p>如果处理过程中发生错误，一个适当的错误会返回。</p>
</li>
<li>
<p>如果序列化JSON中发生错误，一个适当的错误会返回。</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router
  .get(<span class="hljs-string">"/some/path"</span>)
  <span class="hljs-comment">// 这个处理器将保证这个响应会被序列化成json</span>
  <span class="hljs-comment">// content type被设置成 "application/json"</span>
  .respond(
    ctx -&gt; Future.succeededFuture(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)));

router
  .get(<span class="hljs-string">"/some/path"</span>)
  <span class="hljs-comment">// 这个处理器将保证这个Pojo会被序列化成json</span>
  <span class="hljs-comment">// content type被设置成 "application/json"</span>
  .respond(
    ctx -&gt; Future.succeededFuture(<span class="hljs-keyword">new</span> Pojo()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过， 如果提供的函数支持调用 <code>write</code> 或 <code>end</code> ， 您还可以将其用于非JSON响应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router
  .get(<span class="hljs-string">"/some/path"</span>)
  .respond(
    ctx -&gt; ctx
      .response()
        .putHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"text/plain"</span>)
        .end(<span class="hljs-string">"hello world!"</span>));

router
  .get(<span class="hljs-string">"/some/path"</span>)
  <span class="hljs-comment">// 在这种情况下，处理器确保连接被终止</span>
  .respond(
    ctx -&gt; ctx
      .response()
        .setChunked(<span class="hljs-keyword">true</span>)
        .write(<span class="hljs-string">"Write some text..."</span>));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_blocking_handlers"><a class="anchor" href="#_using_blocking_handlers"></a>使用阻塞式处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>某些时候您可能需要在处理器里执行一些需要阻塞 Event Loop 的操作，比如调用某个传统的阻塞式 API 或者执行密集计算。</p>
</div>
<div class="paragraph">
<p>您不能在普通的处理器里执行这些操作， 因此我们提供了将route设置成阻塞式处理器的功能。</p>
</div>
<div class="paragraph">
<p>阻塞式处理器和普通处理器很像， 区别是 Vert.x 会使用 Worker Pool 中的线程而不是 Event Loop 线程来处理请求。
您可以使用 <code><a href="../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-">blockingHandler</a></code>
方法来建立阻塞式处理器。 以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().blockingHandler(ctx -&gt; {

  <span class="hljs-comment">// 执行某些同步的耗时操作</span>
  service.doSomethingThatBlocks();

  <span class="hljs-comment">// 调用下一个处理器</span>
  ctx.next();

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，在同一个 Context (例如同一个 Verticle 实例) 上执行的所有阻塞式处理器是顺序的， 也就意味着只有一个处理器执行完了才会继续执行下一个。 如果您不关心执行的顺序，并且不介意阻塞式处理器以并行的方式执行， 您可以在使用 <code><a href="../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-boolean-">blockingHandler</a></code> 时，设置阻塞式处理器的 <code>ordered</code> 为 false。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
如果您需要在一个阻塞处理器中处理一个 multipart 类型的表单数据，您需要首先使用一个非阻塞的处理器来调用 <code>setExpectMultipart(true)</code> 。以下是例子：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.post(<span class="hljs-string">"/some/endpoint"</span>).handler(ctx -&gt; {
  ctx.request().setExpectMultipart(<span class="hljs-keyword">true</span>);
  ctx.next();
}).blockingHandler(ctx -&gt; {
  <span class="hljs-comment">// ... 执行某些阻塞操作</span>
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routing_by_exact_path"><a class="anchor" href="#_routing_by_exact_path"></a>基于精确路径的路由</h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以将 <code>Route</code> 设置为根据需要所匹配的 URI。在这种情况下它只会匹配路径一致的请求。</p>
</div>
<div class="paragraph">
<p>在下面这个例子中，处理器会被路径为 <code>/some/path/</code> 的请求调用。我们会忽略结尾的 <code>/</code> ， 所以路径 <code>/some/path</code> 或者 <code>/some/path//</code> 的请求也是匹配的</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route().path(<span class="hljs-string">"/some/path/"</span>);

route.handler(ctx -&gt; {
  <span class="hljs-comment">// 这个处理器会被以下路径的请求调用：</span>

  <span class="hljs-comment">// `/some/path/`</span>
  <span class="hljs-comment">// `/some/path//`</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 但不包括:</span>
  <span class="hljs-comment">// `/some/path` 路径末尾的斜线会被严格限制</span>
  <span class="hljs-comment">// `/some/path/subdir`</span>
});

<span class="hljs-comment">// 路径结尾没有斜线的不会被严格限制</span>
<span class="hljs-comment">// 这意味着结尾的斜线是可选的</span>
<span class="hljs-comment">// 无论怎样都会匹配</span>
Route route2 = router.route().path(<span class="hljs-string">"/some/path"</span>);

route2.handler(ctx -&gt; {
  <span class="hljs-comment">// 这个处理器会被以下路径的请求调用：</span>

  <span class="hljs-comment">// `/some/path`</span>
  <span class="hljs-comment">// `/some/path/`</span>
  <span class="hljs-comment">// `/some/path//`</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 但不包括:</span>
  <span class="hljs-comment">// `/some/path/subdir`</span>
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routing_by_paths_that_begin_with_something"><a class="anchor" href="#_routing_by_paths_that_begin_with_something"></a>基于路径前缀的路由</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您经常需要为所有以某些路径开始的请求设置 <code>Route</code> 。 您可以使用正则表达式来实现， 但更简单的方式是在声明 <code>Route</code> 的路径时使用一个 <code>*</code> 作为结尾。</p>
</div>
<div class="paragraph">
<p>在下面的例子中处理器会匹配所有 URI 以 <code>/some/path</code> 开头的请求。</p>
</div>
<div class="paragraph">
<p>例如 <code>/some/path/foo.html</code> 和 <code>/some/path/otherdir/blah.css</code> 都会匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route().path(<span class="hljs-string">"/some/path/*"</span>);

route.handler(ctx -&gt; {
  <span class="hljs-comment">// 这个处理器处理会被所有以 `/some/path/` 开头的请求调用， 例如：</span>

  <span class="hljs-comment">// `/some/path/`</span>
  <span class="hljs-comment">// `/some/path/subdir`</span>
  <span class="hljs-comment">// `/some/path/subdir/blah.html`</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 但不包括:</span>
  <span class="hljs-comment">// `/some/path` 这个路径被限制因为以斜线结尾</span>
  <span class="hljs-comment">// `/some/bath`</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以在创建 <code>Route</code> 的时候指定任意的路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route(<span class="hljs-string">"/some/path/*"</span>);

route.handler(ctx -&gt; {
  <span class="hljs-comment">// 这个处理器的调用规则和上面的例子一样</span>
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capturing_path_parameters"><a class="anchor" href="#_capturing_path_parameters"></a>捕捉路径参数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以通过占位符声明路径参数并在处理请求时通过 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#pathParam-java.lang.String-">pathParam</a></code> 。 方法获取</p>
</div>
<div class="paragraph">
<p>以下是一个例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router
  .route(HttpMethod.POST, <span class="hljs-string">"/catalogue/products/:productType/:productID/"</span>)
  .handler(ctx -&gt; {

    String productType = ctx.pathParam(<span class="hljs-string">"productType"</span>);
    String productID = ctx.pathParam(<span class="hljs-string">"productID"</span>);

    <span class="hljs-comment">// 执行某些操作...</span>
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>占位符由 <code>:</code> 和参数名构成. 参数名由字母， 数字和下划线构成。</p>
</div>
<div class="paragraph">
<p>在上面的例子中， 如果一个 POST 请求的路径为  <code>/catalogue/products/tools/drill123/</code> ， 那么会匹配这个 <code>Route</code> ， 并且会接收参数 <code>productType</code> 的值为 <code>tools</code> ，参数 <code>productID</code> 的值为 <code>drill123</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
您也可以将 * 捕获为路径参数 * 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routing_with_regular_expressions"><a class="anchor" href="#_routing_with_regular_expressions"></a>基于正则表达式的路由</h2>
<div class="sectionbody">
<div class="paragraph">
<p>同样也可用正则表达式匹配路由的 URI 路径。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route().pathRegex(<span class="hljs-string">".*foo"</span>);

route.handler(ctx -&gt; {

  <span class="hljs-comment">// 以下路径的请求都会调用这个处理器：</span>

  <span class="hljs-comment">// /some/path/foo</span>
  <span class="hljs-comment">// /foo</span>
  <span class="hljs-comment">// /foo/bar/wibble/foo</span>
  <span class="hljs-comment">// /bar/foo</span>

  <span class="hljs-comment">// 但不包括：</span>
  <span class="hljs-comment">// /bar/wibble</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在创建 route 时指定正则表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.routeWithRegex(<span class="hljs-string">".*foo"</span>);

route.handler(ctx -&gt; {

  <span class="hljs-comment">// 这个路由器的调用规则和上面的例子一样</span>

});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capturing_path_parameters_with_regular_expressions"><a class="anchor" href="#_capturing_path_parameters_with_regular_expressions"></a>通过正则表达式捕捉路径参数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您也可以通过正则表达式声明捕捉路径参数，以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.routeWithRegex(<span class="hljs-string">".*foo"</span>);

<span class="hljs-comment">// 这个正则表达式可以匹配路径类似于：</span>
<span class="hljs-comment">// `/foo/bar` 的请求</span>
<span class="hljs-comment">// `foo` 可以通过参数 param0 获取，`bar` 可以通过参数 param1 获取</span>
route.pathRegex(<span class="hljs-string">"\\/([^\\/]+)\\/([^\\/]+)"</span>).handler(ctx -&gt; {

  String productType = ctx.pathParam(<span class="hljs-string">"param0"</span>);
  String productID = ctx.pathParam(<span class="hljs-string">"param1"</span>);

  <span class="hljs-comment">// 执行某些操作……</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述的例子中，如果一个请求的路径为 <code>/tools/drill123/</code>，那么会匹配这个 <code>route</code>，
并且会接收到参数 <code>productType</code> 的值为 <code>tools</code>，参数 <code>productID</code> 的值为 <code>drill123</code>。</p>
</div>
<div class="paragraph">
<p>捕捉（译者注：这里指的是捕捉参数这一行为）在正则表达式中用捕捉组表示（即用圆括号括住捕捉）</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_named_capture_groups"><a class="anchor" href="#_using_named_capture_groups"></a>使用命名的捕捉组</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用序号参数名在某些场景下可能会比较麻烦。
亦可在正则表达式路径中使用命名的捕捉组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router
  .routeWithRegex(<span class="hljs-string">"\\/(?&lt;productType&gt;[^\\/]+)\\/(?&lt;productID&gt;[^\\/]+)"</span>)
  .handler(ctx -&gt; {

    String productType = ctx.pathParam(<span class="hljs-string">"productType"</span>);
    String productID = ctx.pathParam(<span class="hljs-string">"productID"</span>);

    <span class="hljs-comment">// 执行某些操作……</span>
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述的例子中，命名捕捉组将路径参数映射到同名的捕捉组中。</p>
</div>
<div class="paragraph">
<p>此外，您仍可以使用普通捕捉组访问组参数（例如：<code>params0, params1&#8230;&#8203;</code>）</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routing_by_http_method"><a class="anchor" href="#_routing_by_http_method"></a>基于 HTTP 方法的路由</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Route 默认会匹配所有的 HTTP 方法。</p>
</div>
<div class="paragraph">
<p>如果您只想让 route 匹配特定的 HTTP 方法，那么您可以使用 <code><a href="../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-">method</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route().method(HttpMethod.POST);

route.handler(ctx -&gt; {

  <span class="hljs-comment">// 所有的 POST 请求都会调用这个处理器</span>

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您可以在创建 Route 时和路径一起指定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route(HttpMethod.POST, <span class="hljs-string">"/some/path/"</span>);

route.handler(ctx -&gt; {
  <span class="hljs-comment">// 所有路径为 `/some/path/`</span>
  <span class="hljs-comment">// 的 POST 请求都会调用这个处理器</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想让 Route 指定 HTTP 方法，您也可以使用对应的 <code><a href="../../apidocs/io/vertx/ext/web/Router.html#get--">get</a></code>，
<code><a href="../../apidocs/io/vertx/ext/web/Router.html#post--">post</a></code> 以及 <code><a href="../../apidocs/io/vertx/ext/web/Router.html#put--">put</a></code> 等方法。
例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.get().handler(ctx -&gt; {

  <span class="hljs-comment">// 所有 GET 请求都会调用这个处理器</span>

});

router.get(<span class="hljs-string">"/some/path/"</span>).handler(ctx -&gt; {

  <span class="hljs-comment">// 所有路径以 `/some/path/` 开始的</span>
  <span class="hljs-comment">// GET 请求都会调用这个处理器</span>

});

router.getWithRegex(<span class="hljs-string">".*foo"</span>).handler(ctx -&gt; {

  <span class="hljs-comment">// 所有路径以 `foo` 结尾的</span>
  <span class="hljs-comment">// GET 请求都会调用这个处理器</span>

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想要让 route 匹配不止一个 HTTP 方法，
您可多次调用 <code><a href="../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-">method</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route().method(HttpMethod.POST).method(HttpMethod.PUT);

route.handler(ctx -&gt; {

  <span class="hljs-comment">// 所有 GET 或 POST 请求都会调用这个处理器</span>

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您的应用程序需要自定义 HTTP 动词，例如，在一个 <code>基于Web的分布式编写和版本控制（WebDAV）</code> 服务器中，
您可这样自定义动词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.route()
  .method(HttpMethod.valueOf(<span class="hljs-string">"MKCOL"</span>))
  .handler(ctx -&gt; {
    <span class="hljs-comment">// 所有 MKCOL 请求都会调用这个处理器</span>
  });</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
请务必留意，像 rerouting 等特性不接受自定义 http 方法，
这些操作在检测到自定义动词时将会使用 <code>OTHER</code> 值以替代自定义名。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_route_order"><a class="anchor" href="#_route_order"></a>Route order</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default routes are matched in the order they are added to the router.</p>
</div>
<div class="paragraph">
<p>When a request arrives the router will step through each route and check if it matches, if it matches then
the handler for that route will be called.</p>
</div>
<div class="paragraph">
<p>If the handler subsequently calls <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#next--">next</a></code> the handler for the next
matching route (if any) will be called. And so on.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example to illustrate this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router
  .route(<span class="hljs-string">"/some/path/"</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();
    <span class="hljs-comment">// enable chunked responses because we will be adding data as</span>
    <span class="hljs-comment">// we execute over other handlers. This is only required once and</span>
    <span class="hljs-comment">// only if several handlers do output.</span>
    response.setChunked(<span class="hljs-keyword">true</span>);

    response.write(<span class="hljs-string">"route1\n"</span>);

    <span class="hljs-comment">// Now call the next matching route</span>
    ctx.next();
  });

router
  .route(<span class="hljs-string">"/some/path/"</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();
    response.write(<span class="hljs-string">"route2\n"</span>);

    <span class="hljs-comment">// Now call the next matching route</span>
    ctx.next();
  });

router
  .route(<span class="hljs-string">"/some/path/"</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();
    response.write(<span class="hljs-string">"route3"</span>);

    <span class="hljs-comment">// Now end the response</span>
    ctx.response().end();
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example the response will contain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>route1
route2
route3</pre>
</div>
</div>
<div class="paragraph">
<p>As the routes have been called in that order for any request that starts with <code>/some/path</code>.</p>
</div>
<div class="paragraph">
<p>If you want to override the default ordering for routes, you can do so using <code><a href="../../apidocs/io/vertx/ext/web/Route.html#order-int-">order</a></code>,
specifying an integer value.</p>
</div>
<div class="paragraph">
<p>Routes are assigned an order at creation time corresponding to the order in which they were added to the router, with
the first route numbered <code>0</code>, the second route numbered <code>1</code>, and so on.</p>
</div>
<div class="paragraph">
<p>By specifying an order for the route you can override the default ordering. Order can also be negative, e.g. if you
want to ensure a route is evaluated before route number <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s change the ordering of route2 so it runs before route1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router
  .route(<span class="hljs-string">"/some/path/"</span>)
  .order(<span class="hljs-number">1</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();
    response.write(<span class="hljs-string">"route1\n"</span>);

    <span class="hljs-comment">// Now call the next matching route</span>
    ctx.next();
  });

router
  .route(<span class="hljs-string">"/some/path/"</span>)
  .order(<span class="hljs-number">0</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();
    <span class="hljs-comment">// enable chunked responses because we will be adding data as</span>
    <span class="hljs-comment">// we execute over other handlers. This is only required once and</span>
    <span class="hljs-comment">// only if several handlers do output.</span>
    response.setChunked(<span class="hljs-keyword">true</span>);

    response.write(<span class="hljs-string">"route2\n"</span>);

    <span class="hljs-comment">// Now call the next matching route</span>
    ctx.next();
  });

router
  .route(<span class="hljs-string">"/some/path/"</span>)
  .order(<span class="hljs-number">2</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();
    response.write(<span class="hljs-string">"route3"</span>);

    <span class="hljs-comment">// Now end the response</span>
    ctx.response().end();
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>then the response will now contain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>route2
route1
route3</pre>
</div>
</div>
<div class="paragraph">
<p>If two matching routes have the same value of order, then they will be called in the order they were added.</p>
</div>
<div class="paragraph">
<p>You can also specify that a route is handled last, with <code><a href="../../apidocs/io/vertx/ext/web/Route.html#last--">last</a></code></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
Route order can be specified only before you configure an handler!
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routing_based_on_mime_type_of_request"><a class="anchor" href="#_routing_based_on_mime_type_of_request"></a>Routing based on MIME type of request</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can specify that a route will match against matching request MIME types using <code><a href="../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-">consumes</a></code>.</p>
</div>
<div class="paragraph">
<p>In this case, the request will contain a <code>content-type</code> header specifying the MIME type of the request body.
This will be matched against the value specified in <code><a href="../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-">consumes</a></code>.</p>
</div>
<div class="paragraph">
<p>Basically, <code>consumes</code> is describing which MIME types the handler can <em>consume</em>.</p>
</div>
<div class="paragraph">
<p>Matching can be done on exact MIME type matches:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .consumes(<span class="hljs-string">"text/html"</span>)
  .handler(ctx -&gt; {

    <span class="hljs-comment">// This handler will be called for any request with</span>
    <span class="hljs-comment">// content-type header set to `text/html`</span>

  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple exact matches can also be specified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .consumes(<span class="hljs-string">"text/html"</span>)
  .consumes(<span class="hljs-string">"text/plain"</span>)
  .handler(ctx -&gt; {

    <span class="hljs-comment">// This handler will be called for any request with</span>
    <span class="hljs-comment">// content-type header set to `text/html` or `text/plain`.</span>

  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Matching on wildcards for the sub-type is supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .consumes(<span class="hljs-string">"text/*"</span>)
  .handler(ctx -&gt; {

    <span class="hljs-comment">// This handler will be called for any request</span>
    <span class="hljs-comment">// with top level type `text` e.g. content-type</span>
    <span class="hljs-comment">// header set to `text/html` or `text/plain`</span>
    <span class="hljs-comment">// will both match</span>

  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>And you can also match on the top level type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .consumes(<span class="hljs-string">"*/json"</span>)
  .handler(ctx -&gt; {

    <span class="hljs-comment">// This handler will be called for any request with sub-type json</span>
    <span class="hljs-comment">// e.g. content-type header set to `text/json` or</span>
    <span class="hljs-comment">// `application/json` will both match</span>

  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t specify a <code>/</code> in the consumers, it will assume you meant the sub-type.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routing_based_on_mime_types_acceptable_by_the_client"><a class="anchor" href="#_routing_based_on_mime_types_acceptable_by_the_client"></a>Routing based on MIME types acceptable by the client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The HTTP <code>accept</code> header is used to signify which MIME types of the response are acceptable to the client.</p>
</div>
<div class="paragraph">
<p>An <code>accept</code> header can have multiple MIME types separated by &#8216;,&#8217;.</p>
</div>
<div class="paragraph">
<p>MIME types can also have a <code>q</code> value appended to them* which signifies a weighting to apply if more than one
response MIME type is available matching the accept header. The q value is a number between 0 and 1.0.
If omitted it defaults to 1.0.</p>
</div>
<div class="paragraph">
<p>For example, the following <code>accept</code> header signifies the client will accept a MIME type of only <code>text/plain</code>:</p>
</div>
<div class="paragraph">
<p>Accept: text/plain</p>
</div>
<div class="paragraph">
<p>With the following the client will accept <code>text/plain</code> or <code>text/html</code> with no preference.</p>
</div>
<div class="paragraph">
<p>Accept: text/plain, text/html</p>
</div>
<div class="paragraph">
<p>With the following the client will accept <code>text/plain</code> or <code>text/html</code> but prefers <code>text/html</code> as it has a higher
<code>q</code> value (the default value is q=1.0)</p>
</div>
<div class="paragraph">
<p>Accept: text/plain; q=0.9, text/html</p>
</div>
<div class="paragraph">
<p>If the server can provide both text/plain and text/html it should provide the text/html in this case.</p>
</div>
<div class="paragraph">
<p>By using <code><a href="../../apidocs/io/vertx/ext/web/Route.html#produces-java.lang.String-">produces</a></code> you define which MIME type(s) the route produces, e.g. the
following handler produces a response with MIME type <code>application/json</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .produces(<span class="hljs-string">"application/json"</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();
    response.putHeader(<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"application/json"</span>);
    response.end(someJSON);

  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the route will match with any request with an <code>accept</code> header that matches <code>application/json</code>.</p>
</div>
<div class="paragraph">
<p>Here are some examples of <code>accept</code> headers that will match:</p>
</div>
<div class="paragraph">
<p>Accept: application/json
Accept: application/*
Accept: application/json, text/html
Accept: application/json;q=0.7, text/html;q=0.8, text/plain</p>
</div>
<div class="paragraph">
<p>You can also mark your route as producing more than one MIME type. If this is the case, then you use
<code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--">getAcceptableContentType</a></code> to find out the actual MIME type that
was accepted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .produces(<span class="hljs-string">"application/json"</span>)
  .produces(<span class="hljs-string">"text/html"</span>)
  .handler(ctx -&gt; {

    HttpServerResponse response = ctx.response();

    <span class="hljs-comment">// Get the actual MIME type acceptable</span>
    String acceptableContentType = ctx.getAcceptableContentType();

    response.putHeader(<span class="hljs-string">"content-type"</span>, acceptableContentType);
    response.end(whatever);
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, if you sent a request with the following <code>accept</code> header:</p>
</div>
<div class="paragraph">
<p>Accept: application/json; q=0.7, text/html</p>
</div>
<div class="paragraph">
<p>Then the route would match and <code>acceptableContentType</code> would contain <code>text/html</code> as both are
acceptable but that has a higher <code>q</code> value.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_routing_based_on_virtualhost"><a class="anchor" href="#_routing_based_on_virtualhost"></a>Routing based on VirtualHost</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can configure that a <code>Route</code> will match against the request hostname.</p>
</div>
<div class="paragraph">
<p>Request are checked against the <code>Host</code> header to a match and patterns allow the usage of <code><strong></code> wildcards, as for
example <code></strong>.vertx.io</code> or fully domain names as <code>www.vertx.io</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().virtualHost(<span class="hljs-string">"*.vertx.io"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do something if the request is for *.vertx.io</span>
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_combining_routing_criteria"><a class="anchor" href="#_combining_routing_criteria"></a>Combining routing criteria</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can combine all the above routing criteria in many different ways, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route(HttpMethod.PUT, <span class="hljs-string">"myapi/orders"</span>)
  .consumes(<span class="hljs-string">"application/json"</span>)
  .produces(<span class="hljs-string">"application/json"</span>)
  .handler(ctx -&gt; {

    <span class="hljs-comment">// This would be match for any PUT method to paths starting</span>
    <span class="hljs-comment">// with "myapi/orders" with a content-type of "application/json"</span>
    <span class="hljs-comment">// and an accept header matching "application/json"</span>

  });</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_enabling_and_disabling_routes"><a class="anchor" href="#_enabling_and_disabling_routes"></a>Enabling and disabling routes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can disable a route with <code><a href="../../apidocs/io/vertx/ext/web/Route.html#disable--">disable</a></code>. A disabled route will be ignored when matching.</p>
</div>
<div class="paragraph">
<p>You can re-enable a disabled route with <code><a href="../../apidocs/io/vertx/ext/web/Route.html#enable--">enable</a></code></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_forward_support"><a class="anchor" href="#_forward_support"></a>Forward Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your application may be behind a proxy server, <code>HAProxy</code> for example. When working under this setup accessing the
client connection details will not properly return the expected results. For example the client host ip address will
be the proxy server ip address, not the client&#8217;s one.</p>
</div>
<div class="paragraph">
<p>In order to get the right connection information, a special header <code>Forward</code> has been standardized to include the right
information. However this standard is not very old, so many proxies out there have been using other headers that usually
start with the prefix: <code>X-Forward</code>. Vert.x web allows the usage and parsing of these headers but not by default.</p>
</div>
<div class="paragraph">
<p>The reason why these headers are disabled by default is to prevent malicious applications to forge their origin and hide
where they are really coming from.</p>
</div>
<div class="paragraph">
<p>As previously mentioned forward is disabled by default, to enable you should use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.allowForward(AllowForwardHeaders.FORWARD);

<span class="hljs-comment">// we can now allow forward header parsing</span>
<span class="hljs-comment">// and in this case only the "X-Forward" headers will be considered</span>
router.allowForward(AllowForwardHeaders.X_FORWARD);

<span class="hljs-comment">// we can now allow forward header parsing</span>
<span class="hljs-comment">// and in this case both the "Forward" header and "X-Forward" headers</span>
<span class="hljs-comment">// will be considered, yet the values from "Forward" take precedence</span>
<span class="hljs-comment">// this means if case of a conflict (2 headers for the same value)</span>
<span class="hljs-comment">// the "Forward" value will be taken and the "X-Forward" ignored.</span>
router.allowForward(AllowForwardHeaders.ALL);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Same rule applies to explicitly disable the parsing of the headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.allowForward(AllowForwardHeaders.NONE);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To read more about the format of the header format, please consult:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7239#section-4" class="bare">https://tools.ietf.org/html/rfc7239#section-4</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded" class="bare">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Behind the scenes, what this feature does is changing the following values of your connection (either HTTP or WebSocket):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>protocol</p>
</li>
<li>
<p>host name</p>
</li>
<li>
<p>host port</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_context_data"><a class="anchor" href="#_context_data"></a>Context data</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use the context data in the <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> to maintain any data that you
want to share between handlers for the lifetime of the request.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example where one handler sets some data in the context data and a subsequent handler retrieves it:</p>
</div>
<div class="paragraph">
<p>You can use the <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#put-java.lang.String-java.lang.Object-">put</a></code> to put any object, and
<code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#get-java.lang.String-">get</a></code> to retrieve any object from the context data.</p>
</div>
<div class="paragraph">
<p>A request sent to path <code>/some/path/other</code> will match both routes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.get(<span class="hljs-string">"/some/path"</span>).handler(ctx -&gt; {

  ctx.put(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);
  ctx.next();

});

router.get(<span class="hljs-string">"/some/path/other"</span>).handler(ctx -&gt; {

  String bar = ctx.get(<span class="hljs-string">"foo"</span>);
  <span class="hljs-comment">// Do something with bar</span>
  ctx.response().end();

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively you can access the entire context data map with <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#data--">data</a></code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_helper_functions"><a class="anchor" href="#_helper_functions"></a>Helper functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While the routing context will allow you to access the underlying request and response objects, sometimes it will be
more productive if a few shortcuts would be present to help with common tasks. A few helpers are present in the context
to facilitate with this task.</p>
</div>
<div class="paragraph">
<p>Serve an "attachment", an attachment is a response that will trigger the browser to open the response on the OS
application configured to handle a specific mime type. Imagine you&#8217;re generating a PDF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ctx
  .attachment(<span class="hljs-string">"weekly-report.pdf"</span>)
  .end(pdfBuffer);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perform a redirect to a different page or host. One example is to redirect to an HTTPS variant of the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ctx.redirect(<span class="hljs-string">"https://securesite.com/"</span>);

<span class="hljs-comment">// there is a special handling for the target "back".</span>
<span class="hljs-comment">// In this case the redirect would send the user to the</span>
<span class="hljs-comment">// referrer url or "/" if there's no referrer.</span>

ctx.redirect(<span class="hljs-string">"back"</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Send a JSON response to the client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ctx.json(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"vert.x"</span>));
<span class="hljs-comment">// also applies to arrays</span>
ctx.json(<span class="hljs-keyword">new</span> JsonArray().add(<span class="hljs-string">"vertx"</span>).add(<span class="hljs-string">"web"</span>));
<span class="hljs-comment">// or any object that will be converted according</span>
<span class="hljs-comment">// to the json encoder available at runtime.</span>
ctx.json(someObject);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simple content type check:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ctx.is(<span class="hljs-string">"html"</span>); <span class="hljs-comment">// =&gt; true</span>
ctx.is(<span class="hljs-string">"text/html"</span>); <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// When Content-Type is application/json</span>
ctx.is(<span class="hljs-string">"application/json"</span>); <span class="hljs-comment">// =&gt; true</span>
ctx.is(<span class="hljs-string">"html"</span>); <span class="hljs-comment">// =&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Verify if a request is "fresh" with respect to the cache headers and the current values of last modified/ etag.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ctx.lastModified(<span class="hljs-string">"Wed, 13 Jul 2011 18:30:00 GMT"</span>);
<span class="hljs-comment">// this will now be used to verify the freshness of the request</span>
<span class="hljs-keyword">if</span> (ctx.isFresh()) {
  <span class="hljs-comment">// client cache value is fresh perhaps we</span>
  <span class="hljs-comment">// can stop and return 304?</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And a few other simple self explanatory shortcuts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ctx.etag(<span class="hljs-string">"W/123456789"</span>);

<span class="hljs-comment">// set the last modified value</span>
ctx.lastModified(<span class="hljs-string">"Wed, 13 Jul 2011 18:30:00 GMT"</span>);

<span class="hljs-comment">// quickly end</span>
ctx.end();
ctx.end(<span class="hljs-string">"body"</span>);
ctx.end(buffer);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reroute"><a class="anchor" href="#_reroute"></a>Reroute</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Until now all routing mechanism allow you to handle your requests in a sequential way, however there might be times
where you will want to go back. Since the context does not expose any information about the previous or next handler,
mostly because this information is dynamic there is a way to restart the whole routing from the start of the current
Router.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.get(<span class="hljs-string">"/some/path"</span>).handler(ctx -&gt; {

  ctx.put(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);
  ctx.next();

});

router
  .get(<span class="hljs-string">"/some/path/B"</span>)
  .handler(ctx -&gt; ctx.response().end());

router
  .get(<span class="hljs-string">"/some/path"</span>)
  .handler(ctx -&gt; ctx.reroute(<span class="hljs-string">"/some/path/B"</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>So from the code you can see that if a request arrives at <code>/some/path</code> if first add a value to the context, then
moves to the next handler that re routes the request to <code>/some/path/B</code> which terminates the request.</p>
</div>
<div class="paragraph">
<p>You can reroute based on a new path or based on a new path and method. Note however that rerouting based on method
might introduce security issues since for example a usually safe GET request can become a DELETE.</p>
</div>
<div class="paragraph">
<p>Reroute is also allowed on the failure handler, however due to the nature of re router when called the current status
code and failure reason are reset. In order the rerouted handler should generate the correct status code if needed,
for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.get(<span class="hljs-string">"/my-pretty-notfound-handler"</span>).handler(ctx -&gt; ctx.response()
  .setStatusCode(<span class="hljs-number">404</span>)
  .end(<span class="hljs-string">"NOT FOUND fancy html here!!!"</span>));

router.get().failureHandler(ctx -&gt; {
  <span class="hljs-keyword">if</span> (ctx.statusCode() == <span class="hljs-number">404</span>) {
    ctx.reroute(<span class="hljs-string">"/my-pretty-notfound-handler"</span>);
  } <span class="hljs-keyword">else</span> {
    ctx.next();
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>It should be clear that reroute works on <code>paths</code>, so if you need to preserve and or add state across reroutes, one
should use the <code>RoutingContext</code> object. For example you want to reroute to a new path with a extra parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.get(<span class="hljs-string">"/final-target"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// continue from here...</span>
});

<span class="hljs-comment">// (Will reroute to /final-target including the query string)</span>
router.get().handler(ctx -&gt; ctx.reroute(<span class="hljs-string">"/final-target?variable=value"</span>));

<span class="hljs-comment">// A safer way would be to add the variable to the context</span>
router.get().handler(ctx -&gt; ctx
  .put(<span class="hljs-string">"variable"</span>, <span class="hljs-string">"value"</span>)
  .reroute(<span class="hljs-string">"/final-target"</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reroute will re-parse the query params too. Be aware that previously query params will be discarded. The method
will also silently discard and ignore any html fragment from the path. This is to keep the semantics of reroute
consistent between a regular request and a re route.</p>
</div>
<div class="paragraph">
<p>If more information is required to be passed to the new request, it should use the context that is preserved all the
lifetime of the HTTP transaction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sub_routers"><a class="anchor" href="#_sub_routers"></a>Sub-routers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes if you have a lot of handlers it can make sense to split them up into multiple routers. This is also useful
if you want to reuse a set of handlers in a different application, rooted at a different path root.</p>
</div>
<div class="paragraph">
<p>To do this you can mount a router at a <em>mount point</em> in another router. The router that is mounted is called a
<em>sub-router</em>. Sub routers can mount other sub routers so you can have several levels of sub-routers if you like.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at a simple example of a sub-router mounted with another router.</p>
</div>
<div class="paragraph">
<p>This sub-router will maintain the set of handlers that corresponds to a simple fictional REST API. We will mount that on another
router. The full implementation of the REST API is not shown.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the sub-router:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router restAPI = Router.router(vertx);

restAPI.get(<span class="hljs-string">"/products/:productID"</span>).handler(ctx -&gt; {

  <span class="hljs-comment">// TODO Handle the lookup of the product....</span>
  ctx.response().write(productJSON);

});

restAPI.put(<span class="hljs-string">"/products/:productID"</span>).handler(ctx -&gt; {

  <span class="hljs-comment">// TODO Add a new product...</span>
  ctx.response().end();

});

restAPI.delete(<span class="hljs-string">"/products/:productID"</span>).handler(ctx -&gt; {

  <span class="hljs-comment">// TODO delete the product...</span>
  ctx.response().end();

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this router was used as a top level router, then GET/PUT/DELETE requests to urls like <code>/products/product1234</code>
would invoke the  API.</p>
</div>
<div class="paragraph">
<p>However, let&#8217;s say we already have a web-site as described by another router:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router mainRouter = Router.router(vertx);

<span class="hljs-comment">// Handle static resources</span>
mainRouter.route(<span class="hljs-string">"/static/*"</span>).handler(myStaticHandler);

mainRouter.route(<span class="hljs-string">".*\\.templ"</span>).handler(myTemplateHandler);</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now mount the sub router on the main router, against a mount point, in this case <code>/productsAPI</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mainRouter.mountSubRouter(<span class="hljs-string">"/productsAPI"</span>, restAPI);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means the REST API is now accessible via paths like: <code>/productsAPI/products/product1234</code>.</p>
</div>
<div class="paragraph">
<p>There are a couple of rules that must be fulfilled before sub routers can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The route path must end with a wild card</p>
</li>
<li>
<p>Parameters are allowed but full regex patterns not</p>
</li>
<li>
<p>Only 1 handler can be registered before or after this call (but they can on a new route object for the same path)</p>
</li>
<li>
<p>Only 1 router per path object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Validation happens at the time the router is added to the http server. This means that you cannot get any validation
error during the build time because of the dynamic nature of sub routers. They depend on the context to be validated.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_localization"><a class="anchor" href="#_localization"></a>Localization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Web parses the <code>Accept-Language</code> header and provides some helper methods to identify which is the preferred
locale for a client or the sorted list of preferred locales by quality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.get(<span class="hljs-string">"/localized"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// although it might seem strange by running a loop with a switch we</span>
  <span class="hljs-comment">// make sure that the locale order of preference is preserved when</span>
  <span class="hljs-comment">// replying in the users language.</span>
  <span class="hljs-keyword">for</span> (LanguageHeader language : ctx.acceptableLanguages()) {
    <span class="hljs-keyword">switch</span> (language.tag()) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"en"</span>:
        ctx.response().end(<span class="hljs-string">"Hello!"</span>);
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"fr"</span>:
        ctx.response().end(<span class="hljs-string">"Bonjour!"</span>);
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"pt"</span>:
        ctx.response().end(<span class="hljs-string">"Olá!"</span>);
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"es"</span>:
        ctx.response().end(<span class="hljs-string">"Hola!"</span>);
        <span class="hljs-keyword">return</span>;
    }
  }
  <span class="hljs-comment">// we do not know the user language so lets just inform that back:</span>
  ctx.response().end(<span class="hljs-string">"Sorry we don't speak: "</span> + ctx.preferredLanguage());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main method <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#acceptableLanguages--">acceptableLanguages</a></code> will return the ordered list of locales the
user understands, if you&#8217;re only interested in the user prefered locale then the helper:
<code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#preferredLanguage--">preferredLanguage</a></code> will return the 1st element of the list or <code>null</code> if no
locale was provided by the user.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_route_match_failures"><a class="anchor" href="#_route_match_failures"></a>Route match failures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If no routes match for any particular request, Vert.x-Web will signal an error depending on match failure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>404 If no route matches the path</p>
</li>
<li>
<p>405 If a route matches the path but don&#8217;t match the HTTP Method</p>
</li>
<li>
<p>406 If a route matches the path and the method but It can&#8217;t provide a response with a content type matching <code>Accept</code> header</p>
</li>
<li>
<p>415 If a route matches the path and the method but It can&#8217;t accept the <code>Content-type</code></p>
</li>
<li>
<p>400 If a route matches the path and the method but It can&#8217;t accept an empty body</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can manually manage those failures using <code><a href="../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-">errorHandler</a></code></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_error_handling"><a class="anchor" href="#_error_handling"></a>Error handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As well as setting handlers to handle requests you can also set handlers to handle failures in routing.</p>
</div>
<div class="paragraph">
<p>Failure handlers are used with the exact same route matching criteria that you use with normal handlers.</p>
</div>
<div class="paragraph">
<p>For example you can provide a failure handler that will only handle failures on certain paths, or for certain HTTP methods.</p>
</div>
<div class="paragraph">
<p>This allows you to set different failure handlers for different parts of your application.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example failure handler that will only be called for failure that occur when routing to GET requests
to paths that start with <code>/somepath/</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route = router.get(<span class="hljs-string">"/somepath/*"</span>);

route.failureHandler(ctx -&gt; {

  <span class="hljs-comment">// This will be called for failures that occur</span>
  <span class="hljs-comment">// when routing requests to paths starting with</span>
  <span class="hljs-comment">// '/somepath/'</span>

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Failure routing will occur if a handler throws an exception, or if a handler calls
<code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#fail-int-">fail</a></code> specifying an HTTP status code to deliberately signal a failure.</p>
</div>
<div class="paragraph">
<p>If an exception is caught from a handler this will result in a failure with status code <code>500</code> being signalled.</p>
</div>
<div class="paragraph">
<p>When handling the failure, the failure handler is passed the routing context which also allows the failure or failure code
to be retrieved so the failure handler can use that to generate a failure response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Route route1 = router.get(<span class="hljs-string">"/somepath/path1/"</span>);

route1.handler(ctx -&gt; {

  <span class="hljs-comment">// Let's say this throws a RuntimeException</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"something happened!"</span>);

});

Route route2 = router.get(<span class="hljs-string">"/somepath/path2"</span>);

route2.handler(ctx -&gt; {

  <span class="hljs-comment">// This one deliberately fails the request passing in the status code</span>
  <span class="hljs-comment">// E.g. 403 - Forbidden</span>
  ctx.fail(<span class="hljs-number">403</span>);

});

<span class="hljs-comment">// Define a failure handler</span>
<span class="hljs-comment">// This will get called for any failures in the above handlers</span>
Route route3 = router.get(<span class="hljs-string">"/somepath/*"</span>);

route3.failureHandler(failureRoutingContext -&gt; {

  <span class="hljs-keyword">int</span> statusCode = failureRoutingContext.statusCode();

  <span class="hljs-comment">// Status code will be 500 for the RuntimeException</span>
  <span class="hljs-comment">// or 403 for the other failure</span>
  HttpServerResponse response = failureRoutingContext.response();
  response.setStatusCode(statusCode).end(<span class="hljs-string">"Sorry! Not today"</span>);

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the eventuality that an error occurs when running the error handler related usage of not allowed characters in
status message header, then the original status message will be changed to the default message from the error code.
This is a tradeoff to keep the semantics of the HTTP protocol working instead of abruptly creash and close the socket
without properly completing the protocol.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_request_body_handling"><a class="anchor" href="#_request_body_handling"></a>Request body handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code><a href="../../apidocs/io/vertx/ext/web/handler/BodyHandler.html">BodyHandler</a></code> allows you to retrieve request bodies, limit body sizes and handle
file uploads.</p>
</div>
<div class="paragraph">
<p>You should make sure a body handler is on a matching route for any requests that require this functionality.</p>
</div>
<div class="paragraph">
<p>The usage of this handler requires that it is installed as soon as possible in the router since it needs
to install handlers to consume the HTTP request body and this must be done before executing any async call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(BodyHandler.create());</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an async call is required before, the <code>HttpServerRequest</code> should be paused and then resumed so that the request
events are not delivered until the body handler is ready to process them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(ctx -&gt; {

  HttpServerRequest request = ctx.request();

  <span class="hljs-comment">// Pause the request</span>
  request.pause();

  someAsyncCall(result -&gt; {

    <span class="hljs-comment">// Resume the request</span>
    request.resume();

    <span class="hljs-comment">// And continue processing</span>
    ctx.next();
  });
});

<span class="hljs-comment">// This body handler will be called for all routes</span>
router.route().handler(BodyHandler.create());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
Uploads can be a source of DDoS attacks, in order to reduce the attack surface, it is recommended to
set sensible limits on <code><a href="../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-">setBodyLimit</a></code> (e.g.: 10mb for general uploads or
100kb for JSON).
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_getting_the_request_body"><a class="anchor" href="#_getting_the_request_body"></a>Getting the request body</h3>
<div class="paragraph">
<p>If you know the request body is JSON, then you can use <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsJson-int-">getBodyAsJson</a></code>,
if you know it&#8217;s a string you can use <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsString--">getBodyAsString</a></code>, or to
retrieve it as a buffer use <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#getBody--">getBody</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_limiting_body_size"><a class="anchor" href="#_limiting_body_size"></a>Limiting body size</h3>
<div class="paragraph">
<p>To limit the size of a request body, create the body handler then use <code><a href="../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-">setBodyLimit</a></code>
to specifying the maximum body size, in bytes. This is useful to avoid running out of memory with very large bodies.</p>
</div>
<div class="paragraph">
<p>If an attempt to send a body greater than the maximum size is made, an HTTP status code of 413 - <code>Request Entity Too Large</code>,
will be sent.</p>
</div>
<div class="paragraph">
<p>There is no body limit by default.</p>
</div>
</div>
<div class="sect2">
<h3 id="_merging_form_attributes"><a class="anchor" href="#_merging_form_attributes"></a>Merging form attributes</h3>
<div class="paragraph">
<p>By default, the body handler will merge any form attributes into the request parameters. If you don&#8217;t want this behaviour
you can use disable it with <code><a href="../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setMergeFormAttributes-boolean-">setMergeFormAttributes</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_handling_file_uploads"><a class="anchor" href="#_handling_file_uploads"></a>Handling file uploads</h3>
<div class="paragraph">
<p>Body handler is also used to handle multi-part file uploads.</p>
</div>
<div class="paragraph">
<p>If a body handler is on a matching route for the request, any file uploads will be automatically streamed to the
uploads directory, which is <code>file-uploads</code> by default.</p>
</div>
<div class="paragraph">
<p>Each file will be given an automatically generated file name, and the file uploads will be available on the routing
context with <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#fileUploads--">fileUploads</a></code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(BodyHandler.create());

router.post(<span class="hljs-string">"/some/path/uploads"</span>).handler(ctx -&gt; {

  Set&lt;FileUpload&gt; uploads = ctx.fileUploads();
  <span class="hljs-comment">// Do something with uploads....</span>

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each file upload is described by a <code><a href="../../apidocs/io/vertx/ext/web/FileUpload.html">FileUpload</a></code> instance, which allows various properties
such as the name, file-name and size to be accessed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_cookies"><a class="anchor" href="#_handling_cookies"></a>Handling cookies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x-Web has out of the box cookies support.</p>
</div>
<div class="sect2">
<h3 id="_manipulating_cookies"><a class="anchor" href="#_manipulating_cookies"></a>Manipulating cookies</h3>
<div class="paragraph">
<p>You use <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#getCookie-java.lang.String-">getCookie</a></code> to retrieve
a cookie by name, or use <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#cookieMap--">cookieMap</a></code> to retrieve the entire set.</p>
</div>
<div class="paragraph">
<p>To remove a cookie, use <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#removeCookie-java.lang.String-">removeCookie</a></code>.</p>
</div>
<div class="paragraph">
<p>To add a cookie use <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#addCookie-io.vertx.core.http.Cookie-">addCookie</a></code>.</p>
</div>
<div class="paragraph">
<p>The set of cookies will be written back in the response automatically when the response headers are written so the
browser can store them.</p>
</div>
<div class="paragraph">
<p>Cookies are described by instances of <code><a href="../../apidocs/io/vertx/core/http/Cookie.html">Cookie</a></code>. This allows you to retrieve the name,
value, domain, path and other normal cookie properties.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of querying and adding cookies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Cookie someCookie = ctx.getCookie(<span class="hljs-string">"mycookie"</span>);
String cookieValue = someCookie.getValue();

<span class="hljs-comment">// Do something with cookie...</span>

<span class="hljs-comment">// Add a cookie - this will get written back in the response automatically</span>
ctx.addCookie(Cookie.cookie(<span class="hljs-string">"othercookie"</span>, <span class="hljs-string">"somevalue"</span>));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_sessions"><a class="anchor" href="#_handling_sessions"></a>Handling sessions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x-Web provides out of the box support for sessions.</p>
</div>
<div class="paragraph">
<p>Sessions last between HTTP requests for the length of a browser session and give you a place where you can add
session-scope information, such as a shopping basket.</p>
</div>
<div class="paragraph">
<p>Vert.x-Web uses session cookies to identify a session. The session cookie is temporary and will be deleted by your browser
when it&#8217;s closed.</p>
</div>
<div class="paragraph">
<p>We don&#8217;t put the actual data of your session in the session cookie - the cookie simply uses an identifier to look-up
the actual session on the server. The identifier is a random UUID generated using a secure random, so it should
be effectively unguessable.</p>
</div>
<div class="paragraph">
<p>Cookies are passed across the wire in HTTP requests and responses so it&#8217;s always wise to make sure you are using
HTTPS when sessions are being used. Vert.x will warn you if you attempt to use sessions over straight HTTP.</p>
</div>
<div class="paragraph">
<p>To enable sessions in your application you must have a <code><a href="../../apidocs/io/vertx/ext/web/handler/SessionHandler.html">SessionHandler</a></code>
on a matching route before your application logic.</p>
</div>
<div class="paragraph">
<p>The session handler handles the creation of session cookies and the lookup of the session so you don&#8217;t have to do
that yourself.</p>
</div>
<div class="paragraph">
<p>Sessions data is saved to a session store automatically after the response headers have been sent to the client.
But note that, with this mechanism, there is no guarantee the data is fully persisted before the client receives the response.
There are occasions though when this guarantee is needed.
In this case you can force a flush.
This will disable the automatic saving process, unless the flushing operation failed.
This allows to control the state before completing the response like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ChainAuthHandler chain =
  ChainAuthHandler.any()
    .add(authNHandlerA)
    .add(ChainAuthHandler.all()
      .add(authNHandlerB)
      .add(authNHandlerC));

<span class="hljs-comment">// secure your route</span>
router.route(<span class="hljs-string">"/secure/resource"</span>).handler(chain);
<span class="hljs-comment">// your app</span>
router.route(<span class="hljs-string">"/secure/resource"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do something...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x Session Handler state by default uses a cookie to store session ID. Session ID is a unique string, used to
recognize individual visitor between visits. But, if client&#8217;s web browser doesn&#8217;t support cookies or visitor has
disabled cookies in web browser&#8217;s settings, we can&#8217;t store session id on client&#8217;s machine. In this case, new session
will be created for every request. This behavior is useless because we can&#8217;t remember information for certain visitor
between two requests. We can say that, by default, sessions can&#8217;t work if browser doesn&#8217;t support cookies.</p>
</div>
<div class="paragraph">
<p>Vert.x Web supports sessions without cookies, known as "cookieless" sessions. As an alternative, Vert.x Web can embed
session id inside of page URL. On this way, all page links will contain session id string. When visitor clicks on some
of these links, it will read session id from page URL, so we don&#8217;t need cookies support to have functional sessions.</p>
</div>
<div class="paragraph">
<p>To enable cookieless sessions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .handler(SessionHandler.create(store).setCookieless(<span class="hljs-keyword">true</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important to know that in this mode the session ID should be passed by the application to the end user, usually by
rendering it on the HTML page or script. There are some important rules. The session id is identified by the following
pattern on the path <code>/optional/path/prefix/'('sessionId')'/path/suffix</code>.</p>
</div>
<div class="paragraph">
<p>As an example, given the path: <code><a href="http://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/" class="bare">http://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/</a></code> the session Id will
be: <code>3abhbgwjg33aqrt3uat2kh4d</code>.</p>
</div>
<div class="paragraph">
<p>Main security problem when working with sessions is a possibility that malicious user will find out others' session id.
If two users share same session id, they share same session variables too and website is considering them as one
visitor. This could be a security risk if session is used for any private or sensitive data, or to allow access to
restricted areas of web site. When cookies are used, session id can be protected using SSL and by marking a cookie as
secure. But, in case of cookieless session, session id is part of URL and is much more vulnerable.</p>
</div>
<div class="sect2">
<h3 id="_session_stores"><a class="anchor" href="#_session_stores"></a>Session stores</h3>
<div class="paragraph">
<p>To create a session handler you need to have a session store instance. The session store is the object that
holds the actual sessions for your application.</p>
</div>
<div class="paragraph">
<p>The session store is responsible for holding a secure pseudo random number generator in order to guarantee secure session
ids. This PRNG is independent of the store which means that given a session id from store A one cannot derive the
session id of store B since they have different seeds and states.</p>
</div>
<div class="paragraph">
<p>By default this PRNG uses a mixed mode, blocking for seeding, non blocking for generating. The PRNG will also reseed
every 5 minutes with 64bits of new entropy. However this can all be configured using the system properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>io.vertx.ext.auth.prng.algorithm e.g.: SHA1PRNG</p>
</li>
<li>
<p>io.vertx.ext.auth.prng.seed.interval e.g.: 1000 (every second)</p>
</li>
<li>
<p>io.vertx.ext.auth.prng.seed.bits e.g.: 128</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most users should not need to configure these values unless if you notice that the performance of your application is
being affected by the PRNG algorithm.</p>
</div>
<div class="paragraph">
<p>Vert.x-Web comes with two session store implementations out of the box, and you can also write your own if you prefer.</p>
</div>
<div class="paragraph">
<p>The implementations are expected to follow the <code>ServiceLoader</code> conventions and all stores that are available at runtime
from the classpath will be exposed. When more than 1 implementations are available the first one that can be
instantiated and configured with success becomes the default. If none is available, then the default depends on the mode
Vert.x was created. If cluster mode is available the the clustered session store is the default otherwise the local
storage is the default.</p>
</div>
<div class="sect3">
<h4 id="_local_session_store"><a class="anchor" href="#_local_session_store"></a>Local session store</h4>
<div class="paragraph">
<p>With this store, sessions are stored locally in memory and only available in this instance.</p>
</div>
<div class="paragraph">
<p>This store is appropriate if you have just a single Vert.x instance of you are using sticky sessions in your application
and have configured your load balancer to always route HTTP requests to the same Vert.x instance.</p>
</div>
<div class="paragraph">
<p>If you can&#8217;t ensure your requests will all terminate on the same server then don&#8217;t use this store as your
requests might end up on a server which doesn&#8217;t know about your session.</p>
</div>
<div class="paragraph">
<p>Local session stores are implemented by using a shared local map, and have a reaper which clears out expired sessions.</p>
</div>
<div class="paragraph">
<p>The reaper interval can be configured with a json message with the key: <code>reaperInterval</code>.</p>
</div>
<div class="paragraph">
<p>Here are some examples of creating a local <code><a href="../../apidocs/io/vertx/ext/web/sstore/SessionStore.html">SessionStore</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SessionStore store1 = LocalSessionStore.create(vertx);

<span class="hljs-comment">// Create a local session store specifying the local shared map name to use</span>
<span class="hljs-comment">// This might be useful if you have more than one application in the same</span>
<span class="hljs-comment">// Vert.x instance and want to use different maps for different applications</span>
SessionStore store2 = LocalSessionStore.create(
  vertx,
  <span class="hljs-string">"myapp3.sessionmap"</span>);

<span class="hljs-comment">// Create a local session store specifying the local shared map name to use and</span>
<span class="hljs-comment">// setting the reaper interval for expired sessions to 10 seconds</span>
SessionStore store3 = LocalSessionStore.create(
  vertx,
  <span class="hljs-string">"myapp3.sessionmap"</span>,
  <span class="hljs-number">10000</span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_clustered_session_store"><a class="anchor" href="#_clustered_session_store"></a>Clustered session store</h4>
<div class="paragraph">
<p>With this store, sessions are stored in a distributed map which is accessible across the Vert.x cluster.</p>
</div>
<div class="paragraph">
<p>This store is appropriate if you&#8217;re <em>not</em> using sticky sessions, i.e. your load balancer is distributing different
requests from the same browser to different servers.</p>
</div>
<div class="paragraph">
<p>Your session is accessible from any node in the cluster using this store.</p>
</div>
<div class="paragraph">
<p>To you use a clustered session store you should make sure your Vert.x instance is clustered.</p>
</div>
<div class="paragraph">
<p>Here are some examples of creating a clustered <code><a href="../../apidocs/io/vertx/ext/web/sstore/SessionStore.html">SessionStore</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Vertx.clusteredVertx(<span class="hljs-keyword">new</span> VertxOptions(), res -&gt; {

  Vertx vertx = res.result();

  <span class="hljs-comment">// Create a clustered session store using defaults</span>
  SessionStore store1 = ClusteredSessionStore.create(vertx);

  <span class="hljs-comment">// Create a clustered session store specifying the distributed map name to use</span>
  <span class="hljs-comment">// This might be useful if you have more than one application in the cluster</span>
  <span class="hljs-comment">// and want to use different maps for different applications</span>
  SessionStore store2 = ClusteredSessionStore.create(
    vertx,
    <span class="hljs-string">"myclusteredapp3.sessionmap"</span>);
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_other_stores"><a class="anchor" href="#_other_stores"></a>Other stores</h4>
<div class="paragraph">
<p>Other stores are also available, these stores can be used by importing the correct jar
to the project. One example of such stores is the cookie store. This store has the advantage
that it requires no backend or server side state, which can be useful it some situations
<strong>BUT</strong> all session data will be sent back to the client in the Cookie, so if you need to store
private information this should not be used.</p>
</div>
<div class="paragraph">
<p>This store is appropriate if you&#8217;re using sticky sessions, i.e. your load balancer is
distributing different requests from the same browser to different servers.</p>
</div>
<div class="paragraph">
<p>As the session is stored in the Cookie, this means sessions survive server crashes too.</p>
</div>
<div class="paragraph">
<p>A second known implementation is the Redis session store. This store works just like the normal cluster store, however
just like it&#8217;s name suggests, it uses a redis backend to keep the session data centralized.</p>
</div>
<div class="paragraph">
<p>These stores are available with the coordinates:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>groupId: <code>io.vertx</code></p>
</li>
<li>
<p>artifactId: <code>vertx-web-sstore-{cookie|redis}</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_the_session_handler"><a class="anchor" href="#_creating_the_session_handler"></a>Creating the session handler</h3>
<div class="paragraph">
<p>Once you&#8217;ve created a session store you can create a session handler, and add it to a route. You should make sure
your session handler is routed to before your application handlers.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

<span class="hljs-comment">// Create a clustered session store using defaults</span>
SessionStore store = ClusteredSessionStore.create(vertx);

SessionHandler sessionHandler = SessionHandler.create(store);

<span class="hljs-comment">// the session handler controls the cookie used for the session</span>
<span class="hljs-comment">// this includes configuring, for example, the same site policy</span>
<span class="hljs-comment">// like this, for strict same site policy.</span>
sessionHandler.setCookieSameSite(CookieSameSite.STRICT);

<span class="hljs-comment">// Make sure all requests are routed through the session handler too</span>
router.route().handler(sessionHandler);

<span class="hljs-comment">// Now your application handlers</span>
router.route(<span class="hljs-string">"/somepath/blah/"</span>).handler(ctx -&gt; {

  Session session = ctx.session();
  session.put(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);
  <span class="hljs-comment">// etc</span>

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The session handler will ensure that your session is automatically looked up (or created if no session exists)
from the session store and set on the routing context before it gets to your application handlers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_session"><a class="anchor" href="#_using_the_session"></a>Using the session</h3>
<div class="paragraph">
<p>In your handlers you can access the session instance with <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#session--">session</a></code>.</p>
</div>
<div class="paragraph">
<p>You put data into the session with <code><a href="../../apidocs/io/vertx/ext/web/Session.html#put-java.lang.String-java.lang.Object-">put</a></code>,
you get data from the session with <code><a href="../../apidocs/io/vertx/ext/web/Session.html#get-java.lang.String-">get</a></code>, and you remove
data from the session with <code><a href="../../apidocs/io/vertx/ext/web/Session.html#remove-java.lang.String-">remove</a></code>.</p>
</div>
<div class="paragraph">
<p>The keys for items in the session are always strings. The values can be any type for a local session store, and for
a clustered session store they can be any basic type, or <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code>, <code><a href="../../apidocs/io/vertx/core/json/JsonObject.html">JsonObject</a></code>,
<code><a href="../../apidocs/io/vertx/core/json/JsonArray.html">JsonArray</a></code> or a serializable object, as the values have to serialized across the cluster.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of manipulating session data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(sessionHandler);

<span class="hljs-comment">// Now your application handlers</span>
router.route(<span class="hljs-string">"/somepath/blah"</span>).handler(ctx -&gt; {

  Session session = ctx.session();

  <span class="hljs-comment">// Put some data from the session</span>
  session.put(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

  <span class="hljs-comment">// Retrieve some data from a session</span>
  <span class="hljs-keyword">int</span> age = session.get(<span class="hljs-string">"age"</span>);

  <span class="hljs-comment">// Remove some data from a session</span>
  JsonObject obj = session.remove(<span class="hljs-string">"myobj"</span>);

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sessions are automatically written back to the store after after responses are complete.</p>
</div>
<div class="paragraph">
<p>You can manually destroy a session using <code><a href="../../apidocs/io/vertx/ext/web/Session.html#destroy--">destroy</a></code>. This will remove the session
from the context and the session store. Note that if there is no session a new one will be automatically created
for the next request from the browser that&#8217;s routed through the session handler.</p>
</div>
</div>
<div class="sect2">
<h3 id="_session_timeout"><a class="anchor" href="#_session_timeout"></a>Session timeout</h3>
<div class="paragraph">
<p>Sessions will be automatically timed out if they are not accessed for a time greater than the timeout period. When
a session is timed out, it is removed from the store.</p>
</div>
<div class="paragraph">
<p>Sessions are automatically marked as accessed when a request arrives and the session is looked up and and when the
response is complete and the session is stored back in the store.</p>
</div>
<div class="paragraph">
<p>You can also use <code><a href="../../apidocs/io/vertx/ext/web/Session.html#setAccessed--">setAccessed</a></code> to manually mark a session as accessed.</p>
</div>
<div class="paragraph">
<p>The session timeout can be configured when creating the session handler. Default timeout is 30 minutes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_authentication_authorization"><a class="anchor" href="#_authentication_authorization"></a>Authentication / authorization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x comes with some out-of-the-box handlers for handling both authentication and authorization. In vert.x web
the meanings for the 2 words are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Authentication</strong> - Tells who the user is</p>
</li>
<li>
<p><strong>Authorization</strong> - Tells what the user is allowed to do</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While <strong>Authentication</strong> is tightened to a well known protocol, e.g.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP Basic Authentication</p>
</li>
<li>
<p>HTTP Digest Authentication</p>
</li>
<li>
<p>OAuth2 Authentication</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Authorization</strong> in vert.x is quite generic and can be used regardless of the prior. Yet it is also possible and a valid
use case to use the same provider module for both cases.</p>
</div>
<div class="sect2">
<h3 id="_creating_an_authentication_handler"><a class="anchor" href="#_creating_an_authentication_handler"></a>Creating an Authentication handler</h3>
<div class="paragraph">
<p>To create an auth handler you need an instance of <code><a href="../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html">AuthenticationProvider</a></code>.
Authentication provider is used for authentication of users. Vert.x provides several authentication provider instances
out of the box in the vertx-auth project. For full information on auth providers and how to use and configure them
please consult the auth documentation.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a simple example of creating a basic auth handler given an auth provider.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));

AuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_authentication_in_your_application"><a class="anchor" href="#_handling_authentication_in_your_application"></a>Handling authentication in your application</h3>
<div class="paragraph">
<p>Let&#8217;s say you want all requests to paths that start with <code>/private/</code> to be subject to authentication. To do that you
make sure your authentication handler is before your application handlers on those paths:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));

AuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);

<span class="hljs-comment">// All requests to paths starting with '/private/' will be protected</span>
router.route(<span class="hljs-string">"/private/*"</span>).handler(basicAuthHandler);

router.route(<span class="hljs-string">"/someotherpath"</span>).handler(ctx -&gt; {

  <span class="hljs-comment">// This will be public access - no login required</span>

});

router.route(<span class="hljs-string">"/private/somepath"</span>).handler(ctx -&gt; {

  <span class="hljs-comment">// This will require a login</span>

  <span class="hljs-comment">// This will have the value true</span>
  <span class="hljs-keyword">boolean</span> isAuthenticated = ctx.user() != <span class="hljs-keyword">null</span>;

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the authentication handler has successfully authenticated the user it will inject a <code><a href="../../apidocs/io/vertx/ext/auth/User.html">User</a></code>
object into the <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> so it&#8217;s available in your handlers with:
<code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#user--">user</a></code>.</p>
</div>
<div class="paragraph">
<p>If you want your User object to be stored in the session so it&#8217;s available between requests so you don&#8217;t have to
authenticate on each request, then you should make sure you have a session handler before the authentication handler.</p>
</div>
<div class="paragraph">
<p>Once you have your user object you can also programmatically use the methods on it to authorize the user.</p>
</div>
<div class="paragraph">
<p>If you want to cause the user to be logged out you can call <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#clearUser--">clearUser</a></code>
on the routing context.</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_basic_authentication"><a class="anchor" href="#_http_basic_authentication"></a>HTTP Basic Authentication</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic Authentication</a> is a simple means of authentication
that can be appropriate for simple applications.</p>
</div>
<div class="paragraph">
<p>With basic authentication, credentials are sent unencrypted across the wire in HTTP headers so it&#8217;s essential that you
serve your application using HTTPS not HTTP.</p>
</div>
<div class="paragraph">
<p>With basic authentication, if a user requests a resource that requires authentication, the basic auth handler will send
back a <code>401</code> response with the header <code>WWW-Authenticate</code> set. This prompts the browser to show a log-in dialogue and
prompt the user to enter their username and password.</p>
</div>
<div class="paragraph">
<p>The request is made to the resource again, this time with the <code>Authorization</code> header set, containing the username
and password encoded in Base64.</p>
</div>
<div class="paragraph">
<p>When the basic auth handler receives this information, it calls the configured <code><a href="../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html">AuthenticationProvider</a></code>
with the username and password to authenticate the user. If the authentication is successful then the routing of the
request is allowed to continue to the application handlers, otherwise a <code>403</code> response is returned to signify that
access is denied.</p>
</div>
</div>
<div class="sect2">
<h3 id="_redirect_authentication_handler"><a class="anchor" href="#_redirect_authentication_handler"></a>Redirect authentication handler</h3>
<div class="paragraph">
<p>With redirect authentication handling the user is redirected to towards a login page in the case they are trying to
access a protected resource and they are not logged in.</p>
</div>
<div class="paragraph">
<p>The user then fills in the login form and submits it. This is handled by the server which authenticates
the user and, if authenticated redirects the user back to the original resource.</p>
</div>
<div class="paragraph">
<p>To use redirect auth you configure an instance of <code><a href="../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html">RedirectAuthHandler</a></code> instead of a
basic authentication handler.</p>
</div>
<div class="paragraph">
<p>You will also need to setup handlers to serve your actual login page, and a handler to handle the actual login itself.
To handle the login we provide a prebuilt handler <code><a href="../../apidocs/io/vertx/ext/web/handler/FormLoginHandler.html">FormLoginHandler</a></code> for the purpose.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of a simple app, using a redirect auth handler on the default redirect url <code>/loginpage</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));

<span class="hljs-comment">// All requests to paths starting with '/private/' will be protected</span>
router
  .route(<span class="hljs-string">"/private/*"</span>)
  .handler(RedirectAuthHandler.create(authProvider));

<span class="hljs-comment">// Handle the actual login</span>
<span class="hljs-comment">// One of your pages must POST form login data</span>
router.post(<span class="hljs-string">"/login"</span>).handler(FormLoginHandler.create(authProvider));

<span class="hljs-comment">// Set a static server to serve static resources, e.g. the login page</span>
router.route().handler(StaticHandler.create());

router
  .route(<span class="hljs-string">"/someotherpath"</span>)
  .handler(ctx -&gt; {
    <span class="hljs-comment">// This will be public access - no login required</span>
  });

router
  .route(<span class="hljs-string">"/private/somepath"</span>)
  .handler(ctx -&gt; {

    <span class="hljs-comment">// This will require a login</span>

    <span class="hljs-comment">// This will have the value true</span>
    <span class="hljs-keyword">boolean</span> isAuthenticated = ctx.user() != <span class="hljs-keyword">null</span>;

  });</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jwt_authentication"><a class="anchor" href="#_jwt_authentication"></a>JWT authentication</h3>
<div class="paragraph">
<p>With JWT authentication resources can be protected by means of permissions and users without enough rights are denied
access. You need to add the <code>io.vertx:vertx-auth-jwt:4.0.2</code> dependency to use <code>JWTAuthProvider</code></p>
</div>
<div class="paragraph">
<p>To use this handler there are 2 steps involved:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Setup an handler to issue tokens (or rely on a 3rd party)</p>
</li>
<li>
<p>Setup the handler to filter the requests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please note that these 2 handlers should be only available on HTTPS, not doing so allows sniffing the tokens in
transit which leads to session hijacking attacks.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example on how to issue tokens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

JWTAuthOptions authConfig = <span class="hljs-keyword">new</span> JWTAuthOptions()
  .setKeyStore(<span class="hljs-keyword">new</span> KeyStoreOptions()
    .setType(<span class="hljs-string">"jceks"</span>)
    .setPath(<span class="hljs-string">"keystore.jceks"</span>)
    .setPassword(<span class="hljs-string">"secret"</span>));

JWTAuth jwt = JWTAuth.create(vertx, authConfig);

router.route(<span class="hljs-string">"/login"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// this is an example, authentication should be done with another provider...</span>
  <span class="hljs-keyword">if</span> (
    <span class="hljs-string">"paulo"</span>.equals(ctx.request().getParam(<span class="hljs-string">"username"</span>)) &amp;&amp;
      <span class="hljs-string">"secret"</span>.equals(ctx.request().getParam(<span class="hljs-string">"password"</span>))) {
    ctx.response()
      .end(jwt.generateToken(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"sub"</span>, <span class="hljs-string">"paulo"</span>)));
  } <span class="hljs-keyword">else</span> {
    ctx.fail(<span class="hljs-number">401</span>);
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that your client has a token all it is required is that <strong>for all</strong> consequent request the HTTP header
<code>Authorization</code> is filled with: <code>Bearer &lt;token&gt;</code> e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

JWTAuthOptions authConfig = <span class="hljs-keyword">new</span> JWTAuthOptions()
  .setKeyStore(<span class="hljs-keyword">new</span> KeyStoreOptions()
    .setType(<span class="hljs-string">"jceks"</span>)
    .setPath(<span class="hljs-string">"keystore.jceks"</span>)
    .setPassword(<span class="hljs-string">"secret"</span>));

JWTAuth authProvider = JWTAuth.create(vertx, authConfig);

router.route(<span class="hljs-string">"/protected/*"</span>).handler(JWTAuthHandler.create(authProvider));

router.route(<span class="hljs-string">"/protected/somepage"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// some handle code...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>JWT allows you to add any information you like to the token itself. By doing this there is no state in the server
which allows you to scale your applications without need for clustered session data. In order to add data to the
token, during the creation of the token just add data to the JsonObject parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JWTAuthOptions authConfig = <span class="hljs-keyword">new</span> JWTAuthOptions()
  .setKeyStore(<span class="hljs-keyword">new</span> KeyStoreOptions()
    .setType(<span class="hljs-string">"jceks"</span>)
    .setPath(<span class="hljs-string">"keystore.jceks"</span>)
    .setPassword(<span class="hljs-string">"secret"</span>));

JWTAuth authProvider = JWTAuth.create(vertx, authConfig);

authProvider
  .generateToken(
    <span class="hljs-keyword">new</span> JsonObject()
      .put(<span class="hljs-string">"sub"</span>, <span class="hljs-string">"paulo"</span>)
      .put(<span class="hljs-string">"someKey"</span>, <span class="hljs-string">"some value"</span>),
    <span class="hljs-keyword">new</span> JWTOptions());</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the same when consuming:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Handler&lt;RoutingContext&gt; handler = ctx -&gt; {
  String theSubject = ctx.user().principal().getString(<span class="hljs-string">"sub"</span>);
  String someKey = ctx.user().principal().getString(<span class="hljs-string">"someKey"</span>);
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_authorization"><a class="anchor" href="#_configuring_authorization"></a>Configuring authorization</h3>
<div class="paragraph">
<p>Until now all examples were covering authentication. Authorization is the next logical step when dealing with user.
While authentication was really specific to the protocol, <strong>authorization</strong> is independent, all information is extracted
from the <code>User</code> object.</p>
</div>
<div class="paragraph">
<p>Before this is possible there is a need to load the authorizations to this same object. In order to do this the
<code><a href="../../apidocs/io/vertx/ext/web/handler/AuthorizationHandler.html">AuthorizationHandler</a></code> should be used. An authorization handler will load all known
authorizations from a given <code><a href="../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html">AuthorizationProvider</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(
  <span class="hljs-comment">// create the handler that will perform the attestation</span>
  AuthorizationHandler.create(
    <span class="hljs-comment">// what to attest</span>
    PermissionBasedAuthorization.create(<span class="hljs-string">"can-do-work"</span>))
    <span class="hljs-comment">// where to lookup the authorizations for the user</span>
    .addAuthorizationProvider(authProvider));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The lookup can be performed on more than 1 source, just keep adding <code>addAuthorizationProvider(provider)</code> to the handler.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of configuring an app so that different authorities are required for different parts of the
app. Note that the meaning of the authorities is determined by the underlying auth provider that you use. E.g. some
may support a role/permission based model but others might use another model.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route(<span class="hljs-string">"/listproducts/*"</span>).handler(
  <span class="hljs-comment">// create the handler that will perform the attestation</span>
  AuthorizationHandler.create(
    <span class="hljs-comment">// what to attest</span>
    PermissionBasedAuthorization.create(<span class="hljs-string">"list_products"</span>))
    <span class="hljs-comment">// where to lookup the authorizations for the user</span>
    .addAuthorizationProvider(authProvider));

<span class="hljs-comment">// Only "admin" has access to /private/settings</span>
router.route(<span class="hljs-string">"/private/settings/*"</span>).handler(
  <span class="hljs-comment">// create the handler that will perform the attestation</span>
  AuthorizationHandler.create(
    <span class="hljs-comment">// what to attest</span>
    RoleBasedAuthorization.create(<span class="hljs-string">"admin"</span>))
    .addAuthorizationProvider(authProvider));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_chaining_multiple_authentication_handlers"><a class="anchor" href="#_chaining_multiple_authentication_handlers"></a>Chaining multiple authentication handlers</h3>
<div class="paragraph">
<p>There are times when you want to support multiple authentication mechanisms in a single application. For this you can
use the <code><a href="../../apidocs/io/vertx/ext/web/handler/ChainAuthHandler.html">ChainAuthHandler</a></code>. The chain auth handler will attempt to perform
authentication on a chain of handlers.</p>
</div>
<div class="paragraph">
<p>It is important to know that some handlers require specific providers, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code><a href="../../apidocs/io/vertx/ext/web/handler/JWTAuthHandler.html">JWTAuthHandler</a></code> requires <code><a href="../../apidocs/io/vertx/ext/auth/jwt/JWTAuth.html">JWTAuth</a></code>.</p>
</li>
<li>
<p>The <code><a href="../../apidocs/io/vertx/ext/web/handler/DigestAuthHandler.html">DigestAuthHandler</a></code> requires <code><a href="../../apidocs/io/vertx/ext/auth/htdigest/HtdigestAuth.html">HtdigestAuth</a></code>.</p>
</li>
<li>
<p>The <code><a href="../../apidocs/io/vertx/ext/web/handler/OAuth2AuthHandler.html">OAuth2AuthHandler</a></code> requires <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/OAuth2Auth.html">OAuth2Auth</a></code>.</p>
</li>
<li>
<p>The <code><a href="../../apidocs/io/vertx/ext/web/handler/WebAuthnHandler.html">WebAuthnHandler</a></code> requires <code><a href="../../apidocs/io/vertx/ext/auth/webauthn/WebAuthn.html">WebAuthn</a></code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So it is not expected that the providers will be shared across all handlers. There are cases where one can share the
provider across handlers, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code><a href="../../apidocs/io/vertx/ext/web/handler/BasicAuthHandler.html">BasicAuthHandler</a></code> can take any provider.</p>
</li>
<li>
<p>The <code><a href="../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html">RedirectAuthHandler</a></code> can take any provider.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So say that you want to create an application that accepts both <code>HTTP Basic Authentication</code> and <code>Form Redirect</code>. You
would start configuring your chain as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ChainAuthHandler chain = ChainAuthHandler.any();

<span class="hljs-comment">// add http basic auth handler to the chain</span>
chain.add(BasicAuthHandler.create(provider));
<span class="hljs-comment">// add form redirect auth handler to the chain</span>
chain.add(RedirectAuthHandler.create(provider));

<span class="hljs-comment">// secure your route</span>
router.route(<span class="hljs-string">"/secure/resource"</span>).handler(chain);
<span class="hljs-comment">// your app</span>
router.route(<span class="hljs-string">"/secure/resource"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do something...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>So when a user makes a request without a <code>Authorization</code> header, this means that the chain will fail to authenticate
with the basic auth handler and will attempt to authenticate with the redirect handler. Since the redirect handler
always redirects you will be sent to the login form that you configured in that handler.</p>
</div>
<div class="paragraph">
<p>Like the normal routing in vertx-web, auth chaning is a sequence, so if you would prefer to fallback to your browser
asking for the user credentials using HTTP Basic authentication instead of the redirect all you need to to is reverse
the order of appending to the chain.</p>
</div>
<div class="paragraph">
<p>Now assume that you make a request where you provide the header <code>Authorization</code> with the value <code>Basic [token]</code>. In
this case the basic auth handler will attempt to authenticate and if it is sucessful the chain will stop and
vertx-web will continue to process your handlers. If the token is not valid, for example bad username/password, then
the chain will continue to the following entry. In this specific case the redirect auth handler.</p>
</div>
<div class="paragraph">
<p>Complex chaining is also possible, for example, building logic sequences such as: <code>HandlerA</code> OR (<code>HandlerB</code> AND <code>HandlerC</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ChainAuthHandler chain =
  ChainAuthHandler.any()
    .add(authNHandlerA)
    .add(ChainAuthHandler.all()
      .add(authNHandlerB)
      .add(authNHandlerC));

<span class="hljs-comment">// secure your route</span>
router.route(<span class="hljs-string">"/secure/resource"</span>).handler(chain);
<span class="hljs-comment">// your app</span>
router.route(<span class="hljs-string">"/secure/resource"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do something...</span>
});</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serving_static_resources"><a class="anchor" href="#_serving_static_resources"></a>Serving static resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x-Web comes with an out of the box handler for serving static web resources so you can write static web servers
very easily.</p>
</div>
<div class="paragraph">
<p>To serve static resources such as <code>.html</code>, <code>.css</code>, <code>.js</code> or any other static resource, you use an instance of
<code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html">StaticHandler</a></code>.</p>
</div>
<div class="paragraph">
<p>Any requests to paths handled by the static handler will result in files being served from a directory on the file system
or from the classpath. The default static file directory is <code>webroot</code> but this can be configured.</p>
</div>
<div class="paragraph">
<p>In the following example all requests to paths starting with <code>/static/</code> will get served from the directory <code>webroot</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route(<span class="hljs-string">"/static/*"</span>).handler(StaticHandler.create());</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, if there was a request with path <code>/static/css/mystyles.css</code> the static serve will look for a file in the
directory <code>webroot/css/mystyle.css</code>.</p>
</div>
<div class="paragraph">
<p>It will also look for a file on the classpath called <code>webroot/css/mystyle.css</code>. This means you can package up all your
static resources into a jar file (or fatjar) and distribute them like that.</p>
</div>
<div class="paragraph">
<p>When Vert.x finds a resource on the classpath for the first time it extracts it and caches it in a temporary directory
on disk so it doesn&#8217;t have to do this each time.</p>
</div>
<div class="paragraph">
<p>The handler will handle range aware requests. When a client makes a request to a static resource, the handler will
notify that it can handle range aware request by stating the unit on the <code>Accept-Ranges</code> header. Further requests
that contain the <code>Range</code> header with the correct unit and start and end indexes will then receive partial responses
with the correct <code>Content-Range</code> header.</p>
</div>
<div class="sect2">
<h3 id="_configuring_caching"><a class="anchor" href="#_configuring_caching"></a>Configuring caching</h3>
<div class="paragraph">
<p>By default the static handler will set cache headers to enable browsers to effectively cache files.</p>
</div>
<div class="paragraph">
<p>Vert.x-Web sets the headers <code>cache-control</code>,<code>last-modified</code>, and <code>date</code>.</p>
</div>
<div class="paragraph">
<p><code>cache-control</code> is set to <code>max-age=86400</code> by default. This corresponds to one day. This can be configured with
<code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxAgeSeconds-long-">setMaxAgeSeconds</a></code> if required.</p>
</div>
<div class="paragraph">
<p>If a browser sends a GET or a HEAD request with an <code>if-modified-since</code> header and the resource has not been modified
since that date, a <code>304</code> status is returned which tells the browser to use its locally cached resource.</p>
</div>
<div class="paragraph">
<p>If handling of cache headers is not required, it can be disabled with <code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCachingEnabled-boolean-">setCachingEnabled</a></code>.</p>
</div>
<div class="paragraph">
<p>When cache handling is enabled Vert.x-Web will cache the last modified date of resources in memory, this avoids a disk hit
to check the actual last modified date every time.</p>
</div>
<div class="paragraph">
<p>Entries in the cache have an expiry time, and after that time, the file on disk will be checked again and the cache
entry updated.</p>
</div>
<div class="paragraph">
<p>If you know that your files never change on disk, then the cache entry will effectively never expire. This is the
default.</p>
</div>
<div class="paragraph">
<p>If you know that your files might change on disk when the server is running then you can set files read only to false with
<code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setFilesReadOnly-boolean-">setFilesReadOnly</a></code>.</p>
</div>
<div class="paragraph">
<p>To enable the maximum number of entries that can be cached in memory at any one time you can use
<code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxCacheSize-int-">setMaxCacheSize</a></code>.</p>
</div>
<div class="paragraph">
<p>To configure the expiry time of cache entries you can use <code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCacheEntryTimeout-long-">setCacheEntryTimeout</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_index_page"><a class="anchor" href="#_configuring_the_index_page"></a>Configuring the index page</h3>
<div class="paragraph">
<p>Any requests to the root path <code>/</code> will cause the index page to be served. By default the index page is <code>index.html</code>.
This can be configured with <code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIndexPage-java.lang.String-">setIndexPage</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_changing_the_web_root"><a class="anchor" href="#_changing_the_web_root"></a>Changing the web root</h3>
<div class="paragraph">
<p>By default static resources will be served from the directory <code>webroot</code>. To configure this use
<code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setWebRoot-java.lang.String-">setWebRoot</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_serving_hidden_files"><a class="anchor" href="#_serving_hidden_files"></a>Serving hidden files</h3>
<div class="paragraph">
<p>By default the serve will serve hidden files (files starting with <code>.</code>).</p>
</div>
<div class="paragraph">
<p>If you do not want hidden files to be served you can configure it with <code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIncludeHidden-boolean-">setIncludeHidden</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_directory_listing"><a class="anchor" href="#_directory_listing"></a>Directory listing</h3>
<div class="paragraph">
<p>The server can also perform directory listing. By default directory listing is disabled. To enabled it use
<code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryListing-boolean-">setDirectoryListing</a></code>.</p>
</div>
<div class="paragraph">
<p>When directory listing is enabled the content returned depends on the content type in the <code>accept</code> header.</p>
</div>
<div class="paragraph">
<p>For <code>text/html</code> directory listing, the template used to render the directory listing page can be configured with
<code><a href="../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryTemplate-java.lang.String-">setDirectoryTemplate</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_disabling_file_caching_on_disk"><a class="anchor" href="#_disabling_file_caching_on_disk"></a>Disabling file caching on disk</h3>
<div class="paragraph">
<p>By default, Vert.x will cache files that are served from the classpath into a file on disk in a sub-directory of a
directory called <code>.vertx</code> in the current working directory. This is mainly useful when deploying services as
fatjars in production where serving a file from the classpath every time can be slow.</p>
</div>
<div class="paragraph">
<p>In development this can cause a problem, as if you update your static content while the server is running, the
cached file will be served not the updated file.</p>
</div>
<div class="paragraph">
<p>To disable file caching you can provide your vert.x options the property <code>fileResolverCachingEnabled</code> to <code>false</code>. For
backwards compatibility it will also default that value to the system property <code>vertx.disableFileCaching</code>. E.g. you
could set up a run configuration in your IDE to set this when running your main class.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cors_handling"><a class="anchor" href="#_cors_handling"></a>CORS handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross Origin Resource Sharing</a> is a safe mechanism for
allowing resources to be requested from one domain and served from another.</p>
</div>
<div class="paragraph">
<p>Vert.x-Web includes a handler <code><a href="../../apidocs/io/vertx/ext/web/handler/CorsHandler.html">CorsHandler</a></code> that handles the CORS protocol for you.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route()
  .handler(
    CorsHandler.create(<span class="hljs-string">"vertx\\.io"</span>)
      .allowedMethod(HttpMethod.GET));

router.route().handler(ctx -&gt; {

  <span class="hljs-comment">// Your app handlers</span>

});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_tenant"><a class="anchor" href="#_multi_tenant"></a>Multi Tenant</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are cases where your application needs to handle more than just 1 tenant. In this case a helper handler is
provided that simplifies setting up the application.</p>
</div>
<div class="paragraph">
<p>In the case the tenant is identified by a HTTP header, say for example <code>X-Tenant</code>, then creating the handler is as
simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(MultiTenantHandler.create(<span class="hljs-string">"X-Tenant"</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>You now should register what handler should be executed for the given tenant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MultiTenantHandler.create(<span class="hljs-string">"X-Tenant"</span>)
  .addTenantHandler(<span class="hljs-string">"tenant-A"</span>, ctx -&gt; {
    <span class="hljs-comment">// do something for tenant A...</span>
  })
  .addTenantHandler(<span class="hljs-string">"tenant-B"</span>, ctx -&gt; {
    <span class="hljs-comment">// do something for tenant B...</span>
  })
  <span class="hljs-comment">// optionally</span>
  .addDefaultHandler(ctx -&gt; {
    <span class="hljs-comment">// do something when no tenant matches...</span>
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is useful for security situations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2Auth gitHubAuthProvider = GithubAuth
  .create(vertx, <span class="hljs-string">"CLIENT_ID"</span>, <span class="hljs-string">"CLIENT_SECRET"</span>);

<span class="hljs-comment">// create a oauth2 handler on our running server</span>
<span class="hljs-comment">// the second argument is the full url to the callback</span>
<span class="hljs-comment">// as you entered in your provider management console.</span>
OAuth2AuthHandler githubOAuth2 = OAuth2AuthHandler.create(
  vertx,
  gitHubAuthProvider,
  <span class="hljs-string">"https://myserver.com/github-callback"</span>);

<span class="hljs-comment">// setup the callback handler for receiving the GitHub callback</span>
githubOAuth2.setupCallback(router.route());

<span class="hljs-comment">// create an OAuth2 provider, clientID and clientSecret</span>
<span class="hljs-comment">// should be requested to Google</span>
OAuth2Auth googleAuthProvider = OAuth2Auth.create(vertx, <span class="hljs-keyword">new</span> OAuth2Options()
  .setClientID(<span class="hljs-string">"CLIENT_ID"</span>)
  .setClientSecret(<span class="hljs-string">"CLIENT_SECRET"</span>)
  .setFlow(OAuth2FlowType.AUTH_CODE)
  .setSite(<span class="hljs-string">"https://accounts.google.com"</span>)
  .setTokenPath(<span class="hljs-string">"https://www.googleapis.com/oauth2/v3/token"</span>)
  .setAuthorizationPath(<span class="hljs-string">"/o/oauth2/auth"</span>));

<span class="hljs-comment">// create a oauth2 handler on our domain: "http://localhost:8080"</span>
OAuth2AuthHandler googleOAuth2 = OAuth2AuthHandler.create(
  vertx,
  googleAuthProvider,
  <span class="hljs-string">"https://myserver.com/google-callback"</span>);

<span class="hljs-comment">// setup the callback handler for receiving the Google callback</span>
googleOAuth2.setupCallback(router.route());

<span class="hljs-comment">// At this point the 2 callbacks endpoints are registered:</span>

<span class="hljs-comment">// /github-callback -&gt; handle github Oauth2 callbacks</span>
<span class="hljs-comment">// /google-callback -&gt; handle google Oauth2 callbacks</span>

<span class="hljs-comment">// As the callbacks are made by the IdPs there's no header</span>
<span class="hljs-comment">// to identify the source, hence the need of custom URLs</span>

<span class="hljs-comment">// However for out Application we can control it so later</span>
<span class="hljs-comment">// we can add the right handler for the right tenant</span>

router.route().handler(
  MultiTenantHandler.create(<span class="hljs-string">"X-Tenant"</span>)
    <span class="hljs-comment">// tenants using github should go this way:</span>
    .addTenantHandler(<span class="hljs-string">"github"</span>, githubOAuth2)
    <span class="hljs-comment">// tenants using google should go this way:</span>
    .addTenantHandler(<span class="hljs-string">"google"</span>, googleOAuth2)
    <span class="hljs-comment">// all other should be forbidden</span>
    .addDefaultHandler(ctx -&gt; ctx.fail(<span class="hljs-number">401</span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The tenant id can be read at any moment from the context, for example to decide which resource to load, or which
database to connect to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(ctx -&gt; {
  <span class="hljs-comment">// the default key is "tenant" as defined in</span>
  <span class="hljs-comment">// MultiTenantHandler.TENANT but this value can be</span>
  <span class="hljs-comment">// modified at creation time in the factory method</span>
  String tenant = ctx.get(MultiTenantHandler.TENANT);

  <span class="hljs-keyword">switch</span>(tenant) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"google"</span>:
      <span class="hljs-comment">// do something for google users</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">"github"</span>:
      <span class="hljs-comment">// so something for github users</span>
      <span class="hljs-keyword">break</span>;
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multi tenant is a powerful handler that will allow applications to live side by side, however it provides no sandboxing
for execution. It should not be used as isolation as wrongly written applications may leak state across tenants.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_templates"><a class="anchor" href="#_templates"></a>模板</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Web 为若干流行的模板引擎提供了开箱即用的支持，通过这种方式来提供生成动态页面的能力。
您也可以很容易地添加您自己的实现。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html">TemplateEngine</a></code> 定义了使用模板引擎的接口。
当渲染模板时会调用 <code><a href="../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html#render-io.vertx.core.json.JsonObject-java.lang.String-io.vertx.core.Handler-">render</a></code> 方法。</p>
</div>
<div class="paragraph">
<p>最简单的使用模板的方式不是直接调用模板引擎，而是使用模板处理器
<code><a href="../../apidocs/io/vertx/ext/web/handler/TemplateHandler.html">TemplateHandler</a></code> 。
这个处理器会根据 HTTP 请求的路径来调用模板引擎。</p>
</div>
<div class="paragraph">
<p>缺省情况下，模板处理器会在 <code>templates</code> 目录中查找模板文件。这是可以配置的。</p>
</div>
<div class="paragraph">
<p>该处理器会返回渲染的结果，并默认设置 Content-Type 消息头为 <code>text/html</code> 。这也是可以配置的。</p>
</div>
<div class="paragraph">
<p>您需要在创建模板处理器时提供您想要使用的模板引擎实例。
Vert.x Web 并未嵌入模板引擎的实现，您需要配置项目来访问它们。
Vert.x Web 提供了每一种模板引擎的配置。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TemplateEngine engine = HandlebarsTemplateEngine.create();
TemplateHandler handler = TemplateHandler.create(engine);

<span class="hljs-comment">// 这会将所有以 `/dynamic` 开头的 GET 请求路由到模板处理器上</span>
<span class="hljs-comment">// 例如 /dynamic/graph.hbs 会查找模板 /templates/graph.hbs</span>
router.get(<span class="hljs-string">"/dynamic/*"</span>).handler(handler);

<span class="hljs-comment">// 将所有以 `.hbs` 结尾的 GET 请求路由到模板处理器上</span>
router.getWithRegex(<span class="hljs-string">".+\\.hbs"</span>).handler(handler);</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_mvel_template_engine"><a class="anchor" href="#_mvel_template_engine"></a>MVEL 模版引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 MVEL 模板引擎：
<code>io.vertx:vertx-web-templ-mvel:4.0.2</code>。 并通过此方法以创建 MVEL 模板引擎实例：
<code>io.vertx.ext.web.templ.mvel.MVELTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>
</div>
<div class="paragraph">
<p>在使用 MVEL 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.templ</code> 的文件。</p>
</div>
<div class="paragraph">
<p>在 MVEL 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> 对象。
这意味着您可使用任何基于上下文里的信息来渲染模板，
包括请求、响应、会话或者上下文数据。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The request path is @{context.request().path()}

The variable 'foo' from the session is @{context.session().get('foo')}

The value 'bar' from the context data is @{context.get('bar')}</pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 MVEL 模板，
请参考 <a href="http://mvel.codehaus.org/MVEL+2.0+Templating+Guide">MVEL 模板文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jade_template_engine"><a class="anchor" href="#_jade_template_engine"></a>Jade 模版引擎（译者注：Jade 已更名为 Pug)</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Jade 模板引擎：
<code>io.vertx:vertx-web-templ-jade:4.0.2</code>。 并通过此方法以创建 Jade 模板引擎实例：
<code>io.vertx.ext.web.templ.jade.JadeTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>
</div>
<div class="paragraph">
<p>在使用 Jade 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.jade</code> 的文件。</p>
</div>
<div class="paragraph">
<p>在 Jade 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> 对象。
这意味着您可使用任何基于上下文里的信息来渲染模板，
包括请求、响应、会话或者上下文数据。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! 5
html
 head
   title= context.get('foo') + context.request().path()
 body</pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 Jade 模板，
请参考 <a href="https://github.com/neuland/jade4j">Jade4j 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_handlebars_template_engine"><a class="anchor" href="#_handlebars_template_engine"></a>Handlebars 模板引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Handlebars 模板引擎：
<code>io.vertx:vertx-web-templ-handlebars:4.0.2</code>。 并通过此方法以创建 Handlebars 模板引擎实例：
<code>io.vertx.ext.web.templ.handlebars.HandlebarsTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>
</div>
<div class="paragraph">
<p>在使用 Handlebars 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.hbs</code> 的文件。</p>
</div>
<div class="paragraph">
<p>Handlebars 不允许在模板中随意地调用对象的方法，
因此我们不能像对待其他模板引擎一样将RoutingContext传递到引擎里并让模板来识别它。</p>
</div>
<div class="paragraph">
<p>替代方案是，可以使用模版中的上下文 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#data--">data</a></code> 对象。</p>
</div>
<div class="paragraph">
<p>如果您要访问某些RoutingContext里不存在的信息，
比如请求的路径、请求参数或者会话等，您需要在模板处理器执行之前将他们添加到上下文data里，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TemplateHandler handler = TemplateHandler.create(engine);

router.get(<span class="hljs-string">"/dynamic"</span>).handler(ctx -&gt; {

  ctx.put(<span class="hljs-string">"request_path"</span>, ctx.request().path());
  ctx.put(<span class="hljs-string">"session_data"</span>, ctx.session().data());

  ctx.next();
});

router.get(<span class="hljs-string">"/dynamic/"</span>).handler(handler);</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 Handlebars 模板，
请参考 <a href="https://github.com/jknack/handlebars.java">Handlebars Java 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_thymeleaf_template_engine"><a class="anchor" href="#_thymeleaf_template_engine"></a>Thymeleaf 模板引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Thymeleaf 模板引擎：
<code>io.vertx:vertx-web-templ-thymeleaf:4.0.2</code>。 并通过此方法以创建 Thymeleaf 模板引擎实例：
<code>io.vertx.ext.web.templ.thymeleaf.ThymeleafTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>
</div>
<div class="paragraph">
<p>在使用 Thymeleaf 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.html</code> 的文件。</p>
</div>
<div class="paragraph">
<p>在 Thymeleaf 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> 对象。
这意味着您可使用任何基于上下文里的信息来渲染模板，
包括请求、响应、会话或者上下文数据。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[snip]
&lt;p th:text="${context.get('foo')}"&gt;&lt;/p&gt;
&lt;p th:text="${context.get('bar')}"&gt;&lt;/p&gt;
&lt;p th:text="${context.normalizedPath()}"&gt;&lt;/p&gt;
&lt;p th:text="${context.request().params().get('param1')}"&gt;&lt;/p&gt;
&lt;p th:text="${context.request().params().get('param2')}"&gt;&lt;/p&gt;
[snip]</pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 Thymeleaf 模板，
请参考 <a href="http://www.thymeleaf.org/">Thymeleaf 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_apache_freemarker_template_engine"><a class="anchor" href="#_apache_freemarker_template_engine"></a>Apache FreeMarker 模版引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Apache FreeMarker ：
<code>io.vertx:vertx-web-templ-freemarker:4.0.2</code>。 并通过此方法以创建 Apache FreeMarker 模板引擎实例：
<code>io.vertx.ext.web.templ.Engine#create()</code>。</p>
</div>
<div class="paragraph">
<p>在使用 Apache FreeMarker 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.ftl</code> 的文件。</p>
</div>
<div class="paragraph">
<p>在 Apache FreeMarker 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> 对象。
这意味着您可使用任何基于上下文里的信息来渲染模板，
包括请求、响应、会话或者上下文数据。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[snip]
&lt;p th:text="${context.foo}"&gt;&lt;/p&gt;
&lt;p th:text="${context.bar}"&gt;&lt;/p&gt;
&lt;p th:text="${context.normalizedPath()}"&gt;&lt;/p&gt;
&lt;p th:text="${context.request().params().param1}"&gt;&lt;/p&gt;
&lt;p th:text="${context.request().params().param2}"&gt;&lt;/p&gt;
[snip]</pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 Apache FreeMarker 模板，
请参考 <a href="http://www.freemarker.org/">Apache FreeMarker 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_pebble_template_engine"><a class="anchor" href="#_pebble_template_engine"></a>Pebble 模版引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Pebble ：
<code>io.vertx:vertx-web-templ-pebble:4.0.2</code>。 并通过此方法以创建 Pebble 模板引擎实例：
<code>io.vertx.ext.web.templ.pebble.PebbleTemplateEngine#create(vertx)</code>。</p>
</div>
<div class="paragraph">
<p>在使用 Pebble 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.ped</code> 的文件。</p>
</div>
<div class="paragraph">
<p>在 Pebble 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code> 对象。
这意味着您可使用任何基于上下文里的信息来渲染模板，
包括请求、响应、会话或者上下文数据。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[snip]
&lt;p th:text="{{context.foo}}"&gt;&lt;/p&gt;
&lt;p th:text="{{context.bar}}"&gt;&lt;/p&gt;
&lt;p th:text="{{context.normalizedPath()}}"&gt;&lt;/p&gt;
&lt;p th:text="{{context.request().params().param1}}"&gt;&lt;/p&gt;
&lt;p th:text="{{context.request().params().param2}}"&gt;&lt;/p&gt;
[snip]</pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 Pebble 模板，
请参考 <a href="http://www.mitchellbosecke.com/pebble/home/">Pebble 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rocker_template_engine"><a class="anchor" href="#_rocker_template_engine"></a>Rocker 模版引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Rocker：<code>io.vertx:vertx-web-templ-rocker:4.0.2</code>。
并通过此方法以创建 Rocker 模板引擎实例：<code>io.vertx.ext.web.templ.rocker#create()</code>。</p>
</div>
<div class="paragraph">
<p>Rocker会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。
假定已知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[snip]
final JsonObject context = new JsonObject()
 .put("foo", "badger")
 .put("bar", "fox")
 .put("context", new JsonObject().put("path", "/foo/bar"));

engine.render(context, "somedir/TestRockerTemplate2", render -&gt; {
 // (...)
});
[snip]</pre>
</div>
</div>
<div class="paragraph">
<p>那么相对应的模版文件 <code>somedir/TestRockerTemplate2.rocker.html</code> 可写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@import io.vertx.core.json.JsonObject
@args (JsonObject context, String foo, String bar)
Hello @foo and @bar
Request path is @context.getString("path")</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_httl_template_engine"><a class="anchor" href="#_httl_template_engine"></a>HTTL 模版引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 HTTL ：
<code>io.vertx:vertx-web-templ-httl:4.0.2</code>。 并通过此方法以创建 HTTL 模板引擎实例：
<code>io.vertx.ext.web.templ.httl.HTTLTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>
</div>
<div class="paragraph">
<p>在使用 HTTL 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.httl</code> 的文件。</p>
</div>
<div class="paragraph">
<p>HTTL会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。
假定已知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[snip]
TemplateEngine engine = HTTLTemplateEngine.create(vertx);
final JsonObject context = new JsonObject()
 .put("foo", "badger")
 .put("bar", "fox");

engine.render(context, "somedir/test-httl-template1.httl", render -&gt; {
 // (...)
});
[snip]</pre>
</div>
</div>
<div class="paragraph">
<p>那么相对应的模版文件 <code>somedir/test-httl-template1.httl</code> 可写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;!-- #set(String foo, String bar) --&gt;
Hello ${foo} and ${bar}</pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 HTTL 模板，
请参考 <a href="https://httl.github.io/en/">HTTL 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rythm_template_engine"><a class="anchor" href="#_rythm_template_engine"></a>Rythm 模版引擎</h3>
<div class="paragraph">
<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Rythm ：
<code>io.vertx:vertx-web-templ-rythm:4.0.2</code>。 并通过此方法以创建 Rythm 模板引擎实例：
<code>io.vertx.ext.web.templ.rythm.RythmTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>
</div>
<div class="paragraph">
<p>在使用 Rythm 模板引擎时，如果不指定模板文件的扩展名，
则默认会查找扩展名为 <code>.html</code> 的文件。</p>
</div>
<div class="paragraph">
<p>Rythm会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。
假定已知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[snip]
TemplateEngine engine = RythmTemplateEngine.create(vertx);
final JsonObject context = new JsonObject()
 .put("foo", "badger")
 .put("bar", "fox");

engine.render(context, "somedir/test-rythm-template1.html", render -&gt; {
 // (...)
});
[snip]</pre>
</div>
</div>
<div class="paragraph">
<p>那么相对应的模版文件 <code>somedir/test-rythm-template1.httl</code> 可写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;!-- #set(String foo, String bar) --&gt;
Hello @foo and @bar</pre>
</div>
</div>
<div class="paragraph">
<p>关于如何编写 HTTL 模板，请参考 <a href="http://www.rythmengine.org/">RythmEngine 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_caching"><a class="anchor" href="#_caching"></a>缓存</h3>
<div class="paragraph">
<p>许多引擎支持将编译好的模版存入缓存。该缓存存放在Vert.x的可分享的数据local map里。
这样引擎便可在多个verticle中安全高效地使用该缓存。</p>
</div>
<div class="sect3">
<h4 id="_disabling_caching"><a class="anchor" href="#_disabling_caching"></a>禁用缓存</h4>
<div class="paragraph">
<p>在开发时，为了让每一次请求可以读取最新的模板，您可能希望禁用模板的缓存。
您可通过设置系统变量：<code>vertxweb.environment</code> 或环境变量
<code>VERTXWEB_ENVIRONMENT</code> 为 <code>dev</code> 或 <code>development</code> 将其禁用。缓存默认是启用的。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_error_handler"><a class="anchor" href="#_error_handler"></a>错误处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可使用模版处理器自行渲染错误页面，
但是Vert.x-Web同样为您提供了开箱即用且“好看的”错误处理器，可为您渲染错误页面。</p>
</div>
<div class="paragraph">
<p>该处理器是 <code><a href="../../apidocs/io/vertx/ext/web/handler/ErrorHandler.html">ErrorHandler</a></code>。
要使用该错误处理器，仅需要将其设置为您希望覆盖的错误路径的失败处理器即可（译者注：例如router.route("/*").failureHandler(ErrorHandler.create(vertx))）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_request_logger"><a class="anchor" href="#_request_logger"></a>请求日志</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x-Web通过内置处理器 <code><a href="../../apidocs/io/vertx/ext/web/handler/LoggerHandler.html">LoggerHandler</a></code> 来记录请求日志。
您需在挂载任何可能导致 <code>RoutingContext</code> 失败的处理器之前挂载该处理器。</p>
</div>
<div class="paragraph">
<p>默认情况下，请求日志将会被记录到Vert.x logger中，亦可通过更改配置使用JUL logging, log4j 或 SLF4J记录。</p>
</div>
<div class="paragraph">
<p>详见 <code><a href="../../apidocs/io/vertx/ext/web/handler/LoggerFormat.html">LoggerFormat</a></code>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serving_favicons"><a class="anchor" href="#_serving_favicons"></a>提供网页图标</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x-Web通过内置处理器 <code><a href="../../apidocs/io/vertx/ext/web/handler/FaviconHandler.html">FaviconHandler</a></code> 以提供网页图标。</p>
</div>
<div class="paragraph">
<p>图标可以指定为文件系统上的某个路径，否则 Vert.x Web 默认会在 classpath 上寻找名为 <code>favicon.ico</code> 的文件。
这意味着您可以将图标打包到包含您应用的 jar 包里。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_timeout_handler"><a class="anchor" href="#_timeout_handler"></a>超时处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x-Web内置一个超时处理器以处理超时请求。</p>
</div>
<div class="paragraph">
<p>可通过 <code><a href="../../apidocs/io/vertx/ext/web/handler/TimeoutHandler.html">TimeoutHandler</a></code> 配置。</p>
</div>
<div class="paragraph">
<p>如果一个请求超时，则会给客户端返回一个 503 的响应。</p>
</div>
<div class="paragraph">
<p>下面的例子设置了一个超时处理器。对于所有以 <code>/foo</code> 路径开头的请求，
都会在执行时间超过 5 秒之后自动超时。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route(<span class="hljs-string">"/foo/"</span>).handler(TimeoutHandler.create(<span class="hljs-number">5000</span>));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_response_time_handler"><a class="anchor" href="#_response_time_handler"></a>响应时间处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>该处理器会将从接收到请求到写入响应的消息头之间的毫秒数写入到响应的 <code>x-response-time</code> 里，
例如：</p>
</div>
<div class="paragraph">
<p>x-response-time: 1456ms</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_content_type_handler"><a class="anchor" href="#_content_type_handler"></a>内容类型（Content type）处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>ResponseContentTypeHandler</code> 会自动设置响应的 <code>Content-Type</code> 消息头。
假设我们要构建一个 RESTful 的 Web 应用，我们需要在所有处理器里设置消息类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router
  .get(<span class="hljs-string">"/api/books"</span>)
  .produces(<span class="hljs-string">"application/json"</span>)
  .handler(ctx -&gt; findBooks()
    .onSuccess(books -&gt; ctx.response()
      .putHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)
      .end(toJson(books))).onFailure(ctx::fail));</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着 API 接口数量的增长，设置内容类型会变得很麻烦。
可以通过在相应的 Route 上添加 <code>ResponseContentTypeHandler</code> 来避免这个问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route(<span class="hljs-string">"/api/*"</span>).handler(ResponseContentTypeHandler.create());
router
  .get(<span class="hljs-string">"/api/books"</span>)
  .produces(<span class="hljs-string">"application/json"</span>)
  .handler(ctx -&gt; findBooks()
    .onSuccess(books -&gt; ctx.response()
      .end(toJson(books))).onFailure(ctx::fail));</code></pre>
</div>
</div>
<div class="paragraph">
<p>处理器会通过 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--">getAcceptableContentType</a></code> 方法来选择适当的内容类型。
因此，您可以很容易地使用同一个处理器以提供不同类型的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route(<span class="hljs-string">"/api/*"</span>).handler(ResponseContentTypeHandler.create());

router
  .get(<span class="hljs-string">"/api/books"</span>)
  .produces(<span class="hljs-string">"text/xml"</span>)
  .produces(<span class="hljs-string">"application/json"</span>)
  .handler(ctx -&gt; findBooks()
    .onSuccess(books -&gt; {
      <span class="hljs-keyword">if</span> (ctx.getAcceptableContentType().equals(<span class="hljs-string">"text/xml"</span>)) {
        ctx.response().end(toXML(books));
      } <span class="hljs-keyword">else</span> {
        ctx.response().end(toJson(books));
      }
    })
    .onFailure(ctx::fail));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sockjs"><a class="anchor" href="#_sockjs"></a>SockJS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SockJS 是一个客户端的 JavaScript 库以及协议，它提供了类似 WebSocket 的接口以方便您与 SockJS 服务器创建连接，
而无需您关心浏览器或网络是否允许真正的 WebSocket。</p>
</div>
<div class="paragraph">
<p>它提供了若干不同的传输方式，
并在运行时根据浏览器和网络的兼容性来选择使用哪种传输方式处理。</p>
</div>
<div class="paragraph">
<p>然而这一切对您而言是透明的，您只需要简单地使用类似 WebSocket 的接口 <em>即可</em>。</p>
</div>
<div class="paragraph">
<p>请参阅 <a href="https://github.com/sockjs/sockjs-client"> SockJS 网站</a>以获取更多关于SockJS的信息。</p>
</div>
<div class="sect2">
<h3 id="_sockjs_handler"><a class="anchor" href="#_sockjs_handler"></a>SockJS 处理器</h3>
<div class="paragraph">
<p>Vert.x 提供了一个开箱即用的处理器 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html">SockJSHandler</a></code>
以便您在 Vert.x-Web 应用中使用 SockJS。</p>
</div>
<div class="paragraph">
<p>您需要通过 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#create-io.vertx.core.Vertx-">SockJSHandler.create</a></code> 方法为每一个 SockJS 的应用创建处理器。
您也可以在创建处理器时通过 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html">SockJSHandlerOptions</a></code>
对象来指定配置选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

SockJSHandlerOptions options = <span class="hljs-keyword">new</span> SockJSHandlerOptions()
  .setHeartbeatInterval(<span class="hljs-number">2000</span>);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_sockjs_sockets"><a class="anchor" href="#_handling_sockjs_sockets"></a>处理 SockJS 套接字</h3>
<div class="paragraph">
<p>您可以在服务器端设置一个 SockJS 处理器，
这个处理器会在客户端创建连接时被调用：</p>
</div>
<div class="paragraph">
<p>传递给处理器的是 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html">SockJSSocket</a></code> 对象。
这是一个类似套接字的接口，您可以像使用 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 或
<code><a href="../../apidocs/io/vertx/core/http/WebSocket.html">WebSocket</a></code> 那样通过它来读写数据。它实现了 <code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 和
<code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 接口，因此您可以将它套用（pump）到其他读写流上。
若 SockJS 连接使用 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#routingContext--">routingContext</a></code> 加载，
那么便可在手动管理会话（session）时访问 <code><a href="../../apidocs/io/vertx/ext/web/RoutingContext.html">RoutingContext</a></code>。
由此您可以通过 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webSession--">webSession</a></code> 和
<code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webUser--">webUser</a></code> 管理用户和会话。</p>
</div>
<div class="paragraph">
<p>下面的例子中的 SockJS 处理器直接使用了它读取到的数据进行回写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

SockJSHandlerOptions options = <span class="hljs-keyword">new</span> SockJSHandlerOptions()
  .setHeartbeatInterval(<span class="hljs-number">2000</span>);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);

router.mountSubRouter(<span class="hljs-string">"/myapp"</span>, sockJSHandler.socketHandler(sockJSSocket -&gt; {

  <span class="hljs-comment">// 将数据回写</span>
  sockJSSocket.handler(sockJSSocket::write);

}));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_client_side"><a class="anchor" href="#_the_client_side"></a>客户端</h3>
<div class="paragraph">
<p>在客户端 JavaScript 环境里您需要通过 SockJS 的客户端库来建立连接。
这是SockJS 客户端的地址 <a href="https://www.npmjs.com/package/sockjs-client">https://www.npmjs.com/package/sockjs-client</a>。</p>
</div>
<div class="paragraph">
<p>您可直接在捆绑软件或构建工具中直接引用它。
或者您想在 <code>HTML</code> 文档中直接使用 <code>CDN</code> 版本，那么首先需要引入 sockjs 的依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
 ...
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>完整的使用细节可参阅 <a href="https://github.com/sockjs/sockjs-client">SockJS 网站</a>，
但简而言之可像这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js"><span class="hljs-keyword">var</span> sock = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">'http://mydomain.com/myapp'</span>);

sock.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'open'</span>);
};

sock.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'message'</span>, e.data);
};

sock.onevent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, message</span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'event: %o, message:%o'</span>, event, message);
 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 为了标记消息已被处理了</span>
};

sock.onunhandled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this message has no address:'</span>, json);
};

sock.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'close'</span>);
};

sock.send(<span class="hljs-string">'test'</span>);

sock.close();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_sockjs_handler"><a class="anchor" href="#_configuring_the_sockjs_handler"></a>配置 SockJS 处理器</h3>
<div class="paragraph">
<p>可使用 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html">SockJSHandlerOptions</a></code> 为处理器配置各种选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="_writing_to_a_sockjs_socket_over_the_event_bus"><a class="anchor" href="#_writing_to_a_sockjs_socket_over_the_event_bus"></a>通过 event bus 写入 SockJS 套接字</h3>
<div class="paragraph">
<p>在创建 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html">SockJSSocket</a></code> 的时候，可为其注册一个 event bus 上的事件处理器。
该处理器的地址就是 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#writeHandlerID--">writeHandlerID</a></code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，不允许注册事件处理器。
需要通过 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html">SockJSHandlerOptions</a></code> 以启用该设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

SockJSHandlerOptions options = <span class="hljs-keyword">new</span> SockJSHandlerOptions().setRegisterWriteHandler(<span class="hljs-keyword">true</span>);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);

router.mountSubRouter(<span class="hljs-string">"/myapp"</span>, sockJSHandler.socketHandler(sockJSSocket -&gt; {

  <span class="hljs-comment">// 获取 writeHandlerID 并将其存放 (例如放在本地 map 里)</span>
  String writeHandlerID = sockJSSocket.writeHandlerID();

}));</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
默认情况下，处理器仅在本地注册。
集群可通过配置 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html#setLocalWriteHandler-boolean-">setLocalWriteHandler</a></code> 为false启用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>随后将数据写入 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code> 便可发送给 SockJS 套接字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">eventBus.send(writeHandlerID, Buffer.buffer(<span class="hljs-string">"foo"</span>));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sockjs_event_bus_bridge"><a class="anchor" href="#_sockjs_event_bus_bridge"></a>SockJS 桥接 Event Bus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Web 提供了一个内置的被称为事件总线桥（event bus bridge）的 SockJS 套接字处理器。
该处理器有效地将服务器端的 Vert.x 的事件总线延伸到客户端的 JavaScript 运行环境里。</p>
</div>
<div class="paragraph">
<p>这将创建一个分布式的事件总线。
该 event bus 不仅可以在服务器端多个 Vert.x 实例中使用，还可以通过运行在浏览器里的 JavaScript 访问。</p>
</div>
<div class="paragraph">
<p>由此，我们可以建立起一个连接多个浏览器和服务器群的庞大的分布式 event bus。
浏览器只需与服务器集群建立连接，无需每次都与固定的某个服务器建立连接。</p>
</div>
<div class="paragraph">
<p>这些是通过 Vert.x 提供的一个简单的客户端 JavaScript 库 <code>vertx-eventbus.js</code> 来实现的。
它提供了一系列与服务器端的 Vert.x event-bus 极为类似的 API。
通过这些 API 您可以发送或发布消息，或注册处理器来接收消息。</p>
</div>
<div class="paragraph">
<p>该 JavaScript 库使用了 JavaScript 的 SockJS 客户端，与另外一端的 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html">SockJS 处理器</a></code> 建立起 SockJS 连接，
并将事件总线上的流量通过管道（tunnel）传送至该客户端。</p>
</div>
<div class="paragraph">
<p>一个特殊的 SockJS 套接字处理器因此被安装到 <code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html">SockJS 处理器</a></code> 上，
而该处理器将会处理 SockJS 的数据，并将建立起与服务器端的事件总线的连接桥。</p>
</div>
<div class="paragraph">
<p>启用该连接桥您只需要在
SockJS 处理器中调用
<code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-">bridge</a></code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx);
SockJSBridgeOptions options = <span class="hljs-keyword">new</span> SockJSBridgeOptions();
<span class="hljs-comment">// 将连接桥挂载到路由器上</span>
router.mountSubRouter(<span class="hljs-string">"/eventbus"</span>, sockJSHandler.bridge(options));</code></pre>
</div>
</div>
<div class="paragraph">
<p>在客户端的 JavaScript 中，您可以使用 <a href="http://npmjs.com/package/@vertx/eventbus-bridge-client.js">@vertx/eventbus-bridge-client.js</a>
库以创建跟事件总线的连接，并以此发送和接收消息。 该库可在 <a href="http://npmjs.com/package/@vertx/eventbus-bridge-client.js">NPM</a> 上找到。
您可直接在捆绑软件或构建工具中直接引用它，但同时它亦可以在 CDN 中使用
（就像之前的 sockJS 例子）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">

<span class="hljs-keyword">var</span> eb = <span class="hljs-keyword">new</span> EventBus(<span class="hljs-string">'http://localhost:8080/eventbus'</span>);

eb.onopen = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {

 <span class="hljs-comment">// 设置一个处理器以接收消息</span>
 eb.registerHandler(<span class="hljs-string">'some-address'</span>, (error, message) =&gt; {
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'received a message: '</span> + <span class="hljs-built_in">JSON</span>.stringify(message));
 });

 <span class="hljs-comment">// 发送消息</span>
 eb.send(<span class="hljs-string">'some-address'</span>, {<span class="hljs-attr">name</span>: <span class="hljs-string">'tim'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">587</span>});

}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该例子中首先创建了一个 event bus 实例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript"><span class="hljs-keyword">var</span> eb = <span class="hljs-keyword">new</span> EventBus(<span class="hljs-string">'http://localhost:8080/eventbus'</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>构造器中的参数是连接 event bus 的URI。
因为我们建立的连接桥是以 <code>eventbus</code> 为前缀，所以我们将会成功建立连接。</p>
</div>
<div class="paragraph">
<p>您在连接开启之前无法做任何事。当连接开启时 <code>onopen</code> 处理器将会被调用。</p>
</div>
<div class="paragraph">
<p>连接桥支持自动重连，可设置延迟和退避选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript"><span class="hljs-keyword">var</span> eb = <span class="hljs-keyword">new</span> EventBus(<span class="hljs-string">'http://localhost:8080/eventbus'</span>);
eb.enableReconnect(<span class="hljs-literal">true</span>);
eb.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 在此处设立处理器，每次建立连接或重连时候调用</span>
eb.onreconnect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 可选，仅在重连时被调用</span>

<span class="hljs-comment">// 或者，传入一个 options 对象</span>
<span class="hljs-keyword">var</span> options = {
   <span class="hljs-attr">vertxbus_reconnect_attempts_max</span>: <span class="hljs-literal">Infinity</span>, <span class="hljs-comment">// 重连尝试最多次数</span>
   <span class="hljs-attr">vertxbus_reconnect_delay_min</span>: <span class="hljs-number">1000</span>, <span class="hljs-comment">// 在第一次尝试重连之前的初始延迟（单位为毫秒）</span>
   <span class="hljs-attr">vertxbus_reconnect_delay_max</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 尝试重连之间的最大延迟（单位为毫秒）</span>
   <span class="hljs-attr">vertxbus_reconnect_exponent</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 指数退避因子</span>
   <span class="hljs-attr">vertxbus_randomization_factor</span>: <span class="hljs-number">0.5</span> <span class="hljs-comment">// 介于0和1之间的随机因子</span>
};

<span class="hljs-keyword">var</span> eb2 = <span class="hljs-keyword">new</span> EventBus(<span class="hljs-string">'http://localhost:8080/eventbus'</span>, options);
eb2.enableReconnect(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// 创建处理器……</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_securing_the_bridge"><a class="anchor" href="#_securing_the_bridge"></a>守护连接桥</h3>
<div class="paragraph">
<p>如果您像上面的例子一样建立连接桥但未开启守护机制，此时您试图通过该桥发送消息，
您会发现消息神秘地失踪了。发生了什么？</p>
</div>
<div class="paragraph">
<p>对于大多数的应用，您恐怕不希望客户端的 JavaScript
代码可以发送任何消息到任意服务端处理器或其他所有浏览器上。</p>
</div>
<div class="paragraph">
<p>例如，您可能在事件总线上注册了一个服务，用于访问或删除数据。
我们并不希望出现恶意的行为或有害的客户端能够利用该服务删除数据库中所有的数据！</p>
</div>
<div class="paragraph">
<p>此外，我们恐怕也不希望任意一个客户端都能监听任意一个事件总线地址。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，SockJs连接桥默认会拒绝所有的消息。
您需要告诉连接桥哪些消息是可以通过的。（例外情况是，所有的回复消息都是可以通过的）。</p>
</div>
<div class="paragraph">
<p>换句话说，连接桥的行为就像是配置了缺省策略为 <em>全部拒绝</em> 策略的防火墙。</p>
</div>
<div class="paragraph">
<p>为连接桥配置哪些消息可以通过是很简单的一件事。</p>
</div>
<div class="paragraph">
<p>您可以通过调用连接桥时传入的
<code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSBridgeOptions.html">SockJSBridgeOptions</a></code> 来配置 <em>匹配</em> 规则以指定哪些输入和输出的流量是允许通过的。</p>
</div>
<div class="paragraph">
<p>每一个匹配规则对应一个 <code><a href="../../apidocs/io/vertx/ext/bridge/PermittedOptions.html">PermittedOptions</a></code> 对象：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><a href="../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddress-java.lang.String-">setAddress</a></code></dt>
<dd>
<p>该配置规则精确地定义了消息可以被发送到哪些地址。
如您需要通过精确地址来控制消息的话，使用该选项。</p>
</dd>
<dt class="hdlist1"><code><a href="../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddressRegex-java.lang.String-">setAddressRegex</a></code></dt>
<dd>
<p>该配置规则通过正则表达式来定义消息可以被发送到哪些地址。如您需要通过正则表达式来控制消息的话，请使用这个选项。
如果指定了 <code>address</code> ，则该选项会被忽略。</p>
</dd>
<dt class="hdlist1"><code><a href="../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setMatch-io.vertx.core.json.JsonObject-">setMatch</a></code></dt>
<dd>
<p>该配置规则通过消息的结构来控制消息是否可被发送。该配置中定义的每一个字段必须在消息中存在，且值一致。
目前仅适用于 JSON 格式的消息。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>对于一个 <em>输入</em> 的消息（例如通过客户端 JavaScript 发送到服务器）
当消息抵达时，Vert.x Web 会检查每一条输入许可。如果存在匹配规则，则消息可以通过。</p>
</div>
<div class="paragraph">
<p>对于一个 <em>输出</em> 的消息（例如通过服务器端发送给客户端 JavaScript）
当消息发送时，Vert.x Web 会检查每一条输出许可。如果存在匹配，则消息可以通过。</p>
</div>
<div class="paragraph">
<p>实际的匹配过程如下：</p>
</div>
<div class="paragraph">
<p>如果指定了 <code>address</code> 字段，并且消息的目标地址与 <code>address</code> <em>精确</em> 匹配，
则匹配成功。</p>
</div>
<div class="paragraph">
<p>如果没有指定 <code>address</code> 但指定了 <code>addressRegex</code> 字段，并且消息的目标地址匹配了 <code>address_re</code> 里的正则表达式，
则匹配成功。</p>
</div>
<div class="paragraph">
<p>如果指定了 <code>match</code> 字段，则消息的结构也必须匹配。
消息需包含有 match 对象中的所有键值对，方能匹配成功。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx);


<span class="hljs-comment">// 允许客户端向地址 `demo.orderMgr` 发送消息</span>
PermittedOptions inboundPermitted1 = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddress(<span class="hljs-string">"demo.orderMgr"</span>);

<span class="hljs-comment">// 允许客户端向地址 `demo.persistor` 发送</span>
<span class="hljs-comment">// 包含有 `action` 的值为 `find`、</span>
<span class="hljs-comment">// `collecton` 的值为 `albums` 的消息。</span>
PermittedOptions inboundPermitted2 = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddress(<span class="hljs-string">"demo.persistor"</span>)
  .setMatch(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"action"</span>, <span class="hljs-string">"find"</span>)
    .put(<span class="hljs-string">"collection"</span>, <span class="hljs-string">"albums"</span>));

<span class="hljs-comment">// 允许 `wibble` 值为 `foo` 的消息。</span>
PermittedOptions inboundPermitted3 = <span class="hljs-keyword">new</span> PermittedOptions()
  .setMatch(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"wibble"</span>, <span class="hljs-string">"foo"</span>));

<span class="hljs-comment">// 让我们定义 服务端 -&gt; 客户端 发送消息匹配规则</span>

<span class="hljs-comment">// 允许向客户端发送地址为 `ticker.mystock` 的消息</span>
PermittedOptions outboundPermitted1 = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddress(<span class="hljs-string">"ticker.mystock"</span>);

<span class="hljs-comment">// 允许向客户端发送地址以 `news.` 开头的消息</span>
<span class="hljs-comment">//（例如 news.europe, news.usa, 等）</span>
PermittedOptions outboundPermitted2 = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddressRegex(<span class="hljs-string">"news\\..+"</span>);

<span class="hljs-comment">// 让我们定义 客户端 -&gt; 客户端 发送消息匹配规则</span>
SockJSBridgeOptions options = <span class="hljs-keyword">new</span> SockJSBridgeOptions().
  addInboundPermitted(inboundPermitted1).
  addInboundPermitted(inboundPermitted1).
  addInboundPermitted(inboundPermitted3).
  addOutboundPermitted(outboundPermitted1).
  addOutboundPermitted(outboundPermitted2);

<span class="hljs-comment">// 将连接桥挂载到路由器上</span>
router.mountSubRouter(<span class="hljs-string">"/eventbus"</span>, sockJSHandler.bridge(options));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_requiring_authorization_for_messages"><a class="anchor" href="#_requiring_authorization_for_messages"></a>消息授权</h3>
<div class="paragraph">
<p>连接桥可使用 Vert.x Web 的授权功能以配置消息的访问权限，
同时支持输入和输出的消息。</p>
</div>
<div class="paragraph">
<p>为此，您可通过向上文所述的匹配规则中加入额外的字段
以指定匹配需要哪些权限。</p>
</div>
<div class="paragraph">
<p>通过 <code><a href="../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setRequiredAuthority-java.lang.String-">setRequiredAuthority</a></code>
方法来指定对于登录用户，需要具有哪些权限才允许访问这个消息。</p>
</div>
<div class="paragraph">
<p>以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">PermittedOptions inboundPermitted = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddress(<span class="hljs-string">"demo.orderService"</span>);

<span class="hljs-comment">// 仅限用户已登录并且拥有权限 `place_orders`</span>
inboundPermitted.setRequiredAuthority(<span class="hljs-string">"place_orders"</span>);

SockJSBridgeOptions options = <span class="hljs-keyword">new</span> SockJSBridgeOptions()
  .addInboundPermitted(inboundPermitted);</code></pre>
</div>
</div>
<div class="paragraph">
<p>用户需要登录，并被授权才能够访问消息。</p>
</div>
<div class="paragraph">
<p>因此，您需要配置一个 Vert.x 认证处理器来处理登录和授权。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

<span class="hljs-comment">// 允许客户端向 `demo.orderService` 发送消息</span>
PermittedOptions inboundPermitted = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddress(<span class="hljs-string">"demo.orderService"</span>);

<span class="hljs-comment">// 仅限用户已登录并且拥有权限 `place_orders`</span>
inboundPermitted.setRequiredAuthority(<span class="hljs-string">"place_orders"</span>);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx);

<span class="hljs-comment">// 设置基础认证处理器：</span>

router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));

AuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);

router.route(<span class="hljs-string">"/eventbus/*"</span>).handler(basicAuthHandler);

<span class="hljs-comment">// 将连接桥挂载到路由器上</span>
router.mountSubRouter(
  <span class="hljs-string">"/eventbus"</span>,
  sockJSHandler.bridge(<span class="hljs-keyword">new</span> SockJSBridgeOptions()
    .addInboundPermitted(inboundPermitted)));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_event_bus_bridge_events"><a class="anchor" href="#_handling_event_bus_bridge_events"></a>Handling event bus bridge events</h3>
<div class="paragraph">
<p>If you want to be notified when an event occurs on the bridge you can provide a handler when calling
<code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-io.vertx.core.Handler-">bridge</a></code>.</p>
</div>
<div class="paragraph">
<p>Whenever an event occurs on the bridge it will be passed to the handler. The event is described by an instance of
<code><a href="../../apidocs/io/vertx/ext/web/handler/sockjs/BridgeEvent.html">BridgeEvent</a></code>.</p>
</div>
<div class="paragraph">
<p>The event can be one of the following types:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">SOCKET_CREATED</dt>
<dd>
<p>This event will occur when a new SockJS socket is created.</p>
</dd>
<dt class="hdlist1">SOCKET_IDLE</dt>
<dd>
<p>This event will occur when SockJS socket is on idle for longer period of time than initially configured.</p>
</dd>
<dt class="hdlist1">SOCKET_PING</dt>
<dd>
<p>This event will occur when the last ping timestamp is updated for the SockJS socket.</p>
</dd>
<dt class="hdlist1">SOCKET_CLOSED</dt>
<dd>
<p>This event will occur when a SockJS socket is closed.</p>
</dd>
<dt class="hdlist1">SEND</dt>
<dd>
<p>This event will occur when a message is attempted to be sent from the client to the server.</p>
</dd>
<dt class="hdlist1">PUBLISH</dt>
<dd>
<p>This event will occur when a message is attempted to be published from the client to the server.</p>
</dd>
<dt class="hdlist1">RECEIVE</dt>
<dd>
<p>This event will occur when a message is attempted to be delivered from the server to the client.</p>
</dd>
<dt class="hdlist1">REGISTER</dt>
<dd>
<p>This event will occur when a client attempts to register a handler.</p>
</dd>
<dt class="hdlist1">UNREGISTER</dt>
<dd>
<p>This event will occur when a client attempts to unregister a handler.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The event enables you to retrieve the type using <code><a href="../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#type--">type</a></code> and
inspect the raw message of the event using <code><a href="../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#getRawMessage--">getRawMessage</a></code>.</p>
</div>
<div class="paragraph">
<p>The raw message is a JSON object with the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
 "type": "send"|"publish"|"receive"|"register"|"unregister",
 "address": the event bus address being sent/published/registered/unregistered
 "body": the body of the message
}</pre>
</div>
</div>
<div class="paragraph">
<p>The event is also an instance of <code><a href="../../apidocs/io/vertx/core/Promise.html">Promise</a></code>. When you are finished handling the event you can
complete the promise with <code>true</code> to enable further processing.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want the event to be processed you can complete the promise with <code>false</code>. This is a useful feature that
enables you to do your own filtering on messages passing through the bridge, or perhaps apply some fine grained
authorization or metrics.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example where we reject all messages flowing through the bridge if they contain the word "Armadillos".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

<span class="hljs-comment">// Let through any messages sent to 'demo.orderMgr' from the client</span>
PermittedOptions inboundPermitted = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddress(<span class="hljs-string">"demo.someService"</span>);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx);
SockJSBridgeOptions options = <span class="hljs-keyword">new</span> SockJSBridgeOptions()
  .addInboundPermitted(inboundPermitted);

<span class="hljs-comment">// mount the bridge on the router</span>
router
  .mountSubRouter(<span class="hljs-string">"/eventbus"</span>, sockJSHandler
    .bridge(options, be -&gt; {
      <span class="hljs-keyword">if</span> (be.type() == BridgeEventType.PUBLISH ||
        be.type() == BridgeEventType.RECEIVE) {

        <span class="hljs-keyword">if</span> (be.getRawMessage().getString(<span class="hljs-string">"body"</span>).equals(<span class="hljs-string">"armadillos"</span>)) {
          <span class="hljs-comment">// Reject it</span>
          be.complete(<span class="hljs-keyword">false</span>);
          <span class="hljs-keyword">return</span>;
        }
      }
      be.complete(<span class="hljs-keyword">true</span>);
    }));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an example how to configure and handle SOCKET_IDLE bridge event type.
Notice <code>setPingTimeout(5000)</code> which says that if ping message doesn&#8217;t arrive from client within 5 seconds
then the SOCKET_IDLE bridge event would be triggered.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

<span class="hljs-comment">// Initialize SockJS handler</span>
SockJSHandler sockJSHandler = SockJSHandler.create(vertx);
SockJSBridgeOptions options = <span class="hljs-keyword">new</span> SockJSBridgeOptions()
  .addInboundPermitted(inboundPermitted)
  .setPingTimeout(<span class="hljs-number">5000</span>);

<span class="hljs-comment">// mount the bridge on the router</span>
router
  .mountSubRouter(<span class="hljs-string">"/eventbus"</span>, sockJSHandler.bridge(options, be -&gt; {
    <span class="hljs-keyword">if</span> (be.type() == BridgeEventType.SOCKET_IDLE) {
      <span class="hljs-comment">// Do some custom handling...</span>
    }

    be.complete(<span class="hljs-keyword">true</span>);
  }));</code></pre>
</div>
</div>
<div class="paragraph">
<p>In client side JavaScript you use the 'vertx-eventbus.js` library to create connections to the event bus and to send and receive messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">

<span class="hljs-keyword">var</span> eb = <span class="hljs-keyword">new</span> EventBus(<span class="hljs-string">'http://localhost:8080/eventbus'</span>, {<span class="hljs-string">"vertxbus_ping_interval"</span>: <span class="hljs-number">300000</span>}); <span class="hljs-comment">// sends ping every 5 minutes.</span>

eb.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

<span class="hljs-comment">// set a handler to receive a message</span>
eb.registerHandler(<span class="hljs-string">'some-address'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, message</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'received a message: '</span> + <span class="hljs-built_in">JSON</span>.stringify(message));
});

<span class="hljs-comment">// send a message</span>
eb.send(<span class="hljs-string">'some-address'</span>, {<span class="hljs-attr">name</span>: <span class="hljs-string">'tim'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">587</span>});
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first thing the example does is to create a instance of the event bus</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript"><span class="hljs-keyword">var</span> eb = <span class="hljs-keyword">new</span> EventBus(<span class="hljs-string">'http://localhost:8080/eventbus'</span>, {<span class="hljs-string">"vertxbus_ping_interval"</span>: <span class="hljs-number">300000</span>});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The 2nd parameter to the constructor tells the sockjs library to send ping message every 5 minutes. since the server
was configured to expect ping every 5 seconds &#8594; <code>SOCKET_IDLE</code> would be triggered on the server.</p>
</div>
<div class="paragraph">
<p>You can also amend the raw message, e.g. change the body. For messages that are flowing in from the client you can
also add headers to the message, here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Router router = Router.router(vertx);

<span class="hljs-comment">// Let through any messages sent to 'demo.orderService' from the client</span>
PermittedOptions inboundPermitted = <span class="hljs-keyword">new</span> PermittedOptions()
  .setAddress(<span class="hljs-string">"demo.orderService"</span>);

SockJSHandler sockJSHandler = SockJSHandler.create(vertx);
SockJSBridgeOptions options = <span class="hljs-keyword">new</span> SockJSBridgeOptions()
  .addInboundPermitted(inboundPermitted);

<span class="hljs-comment">// mount the bridge on the router</span>
router.mountSubRouter(
  <span class="hljs-string">"/eventbus"</span>,
  sockJSHandler.bridge(options, be -&gt; {
    <span class="hljs-keyword">if</span> (
      be.type() == BridgeEventType.PUBLISH ||
        be.type() == BridgeEventType.SEND) {

      <span class="hljs-comment">// Add some headers</span>
      JsonObject headers = <span class="hljs-keyword">new</span> JsonObject()
        .put(<span class="hljs-string">"header1"</span>, <span class="hljs-string">"val"</span>)
        .put(<span class="hljs-string">"header2"</span>, <span class="hljs-string">"val2"</span>);

      JsonObject rawMessage = be.getRawMessage();
      rawMessage.put(<span class="hljs-string">"headers"</span>, headers);
      be.setRawMessage(rawMessage);
    }
    be.complete(<span class="hljs-keyword">true</span>);
  }));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_csrf_cross_site_request_forgery"><a class="anchor" href="#_csrf_cross_site_request_forgery"></a>CSRF Cross Site Request Forgery</h2>
<div class="sectionbody">
<div class="paragraph">
<p>CSRF or sometimes also known as XSRF is a technique by which an unauthorized site can gain your user&#8217;s private data.
Vert.x-Web includes a handler <code><a href="../../apidocs/io/vertx/ext/web/handler/CSRFHandler.html">CSRFHandler</a></code> that you can use to prevent cross site
request forgery requests.</p>
</div>
<div class="paragraph">
<p>On each get request under this handler a cookie is added to the response with a unique token. Clients are then
expected to return this token back in a header. Since cookies are sent it is required that the cookie handler is also
present on the router.</p>
</div>
<div class="paragraph">
<p>When developing non single page applications that rely on the User-Agent to perform the <code>POST</code> action, Headers cannot
be specified on HTML Forms. In order to solve this problem the header value will also be checked if and only if no
header was present in the Form attributes under the same name as the header, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/submit"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"X-XSRF-TOKEN"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"abracadabra"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is the responsibility of the user to fill in the right value for the form field. Users who prefer to use an HTML
only solution can fill this value by fetching the the token value from the routing context under the key <code>X-XSRF-TOKEN</code>
or the header name they have chosen during the instantiation of the <code>CSRFHandler</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(CSRFHandler.create(vertx, <span class="hljs-string">"abracadabra"</span>));
router.route().handler(ctx -&gt; {

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this handler is session aware. If there is a session available the form parameter or header might be omited
during the <code>POST</code> action as it will be read from the session. This also implies that tokens will only be regenerated
on session upgrades.</p>
</div>
<div class="paragraph">
<p>Note, for extra security users are advised to rotate the key that signs the tokens. This can be done online by replacing
the handler, or by restarting the application with a new configuration. Clickjacking could still affect applications. If
this is a critical application consider setting the header: <code>X-Frame-Options</code> as described in:
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" class="bare">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options</a></p>
</div>
<div class="sect2">
<h3 id="_using_ajax"><a class="anchor" href="#_using_ajax"></a>Using AJAX</h3>
<div class="paragraph">
<p>When accessing protected routes via ajax both the csrf token will need to be passed in the request. Typically this is
done using a request header, as adding a request header can typically be done at a central location easily without
payload modification.</p>
</div>
<div class="paragraph">
<p>The CSRF token is obtained from the server side context under the key <code>X-XSRF-TOKEN</code> (unless you specified a different
name). This token needs to be exposed to the client-side, typically by including it in the initial page content. One
possibility is to store it in an HTML &lt;meta&gt; tag, where value can then be retrieved at the time of the request by
JavaScript.</p>
</div>
<div class="paragraph">
<p>The following can be included in your view (handlebar example below):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"csrf-token"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"${X-XSRF-TOKEN}"</span>&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of using the Fetch API to post to the /process route with the CSRF token from the &lt;meta&gt;
tag on the page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js"><span class="hljs-comment">// Read the CSRF token from the &lt;meta&gt; tag</span>
<span class="hljs-keyword">var</span> token = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'meta[name="csrf-token"]'</span>).getAttribute(<span class="hljs-string">'content'</span>)

<span class="hljs-comment">// Make a request using the Fetch API</span>
fetch(<span class="hljs-string">'/process'</span>, {
 <span class="hljs-attr">credentials</span>: <span class="hljs-string">'same-origin'</span>, <span class="hljs-comment">// &lt;-- includes cookies in the request</span>
 <span class="hljs-attr">headers</span>: {
   <span class="hljs-string">'X-XSRF-TOKEN'</span>: token <span class="hljs-comment">// &lt;-- is the csrf token as a header</span>
 },
 <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
 <span class="hljs-attr">body</span>: {
   <span class="hljs-attr">key</span>: <span class="hljs-string">'value'</span>
 }
})</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hsts_handler"><a class="anchor" href="#_hsts_handler"></a>HSTS Handler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP Strict Transport Security (HSTS) is a web security policy mechanism that helps to protect websites against
man-in-the-middle attacks such as protocol downgrade attacks and cookie hijacking. It allows web servers to declare that
web browsers (or other complying user agents) should automatically interact with it using only HTTPS connections, which
provide Transport Layer Security (TLS/SSL), unlike the insecure HTTP used alone. HSTS is an IETF standards track
protocol and is specified in RFC 6797.</p>
</div>
<div class="paragraph">
<p>This handler will configure the correct header for your application in a single step:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(HSTSHandler.create());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_csp_handler"><a class="anchor" href="#_csp_handler"></a>CSP Handler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of
attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from
data theft to site defacement to distribution of malware.</p>
</div>
<div class="paragraph">
<p>CSP is designed to be fully backward compatible. Browsers that don&#8217;t support it still work with servers that
implement it, and vice-versa: browsers that don&#8217;t support CSP simply ignore it, functioning as usual, defaulting to
the standard same-origin policy for web content. If the site doesn&#8217;t offer the CSP header, browsers likewise use the
standard same-origin policy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(
  CSPHandler.create()
    .addDirective(<span class="hljs-string">"default-src"</span>, <span class="hljs-string">"*.trusted.com"</span>));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_xframe_handler"><a class="anchor" href="#_xframe_handler"></a>XFrame Handler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>X-Frame-Options</code> HTTP response header can be used to indicate whether or not a browser should be allowed to render
a page in a <code>frame</code>, <code>iframe</code>, <code>embed</code> or <code>object</code>. Sites can use this to avoid click-jacking attacks, by ensuring that
their content is not embedded into other sites.</p>
</div>
<div class="paragraph">
<p>The added security is provided only if the user accessing the document is using a browser that supports
<code>X-Frame-Options</code>.</p>
</div>
<div class="paragraph">
<p>If you specify <code>DENY</code>, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to
do so will fail when loaded from the same site. On the other hand, if you specify <code>SAMEORIGIN</code>, you can still use the
page in a frame as long as the site including it in a frame is the same as the one serving the page.</p>
</div>
<div class="paragraph">
<p>This handler will configure the correct header for your application in a single step:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(XFrameHandler.create(XFrameHandler.DENY));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oauth2authhandler_handler"><a class="anchor" href="#_oauth2authhandler_handler"></a>OAuth2AuthHandler Handler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>OAuth2AuthHandler</code> allows quick setup of secure routes using the OAuth2 protocol. This handler simplifies the
authCode flow. An example of using it to protect some resource and authenticate with GitHub can be implemented as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2Auth authProvider = GithubAuth
  .create(vertx, <span class="hljs-string">"CLIENT_ID"</span>, <span class="hljs-string">"CLIENT_SECRET"</span>);

<span class="hljs-comment">// create a oauth2 handler on our running server</span>
<span class="hljs-comment">// the second argument is the full url to the</span>
<span class="hljs-comment">// callback as you entered in your provider management console.</span>
OAuth2AuthHandler oauth2 = OAuth2AuthHandler
  .create(vertx, authProvider, <span class="hljs-string">"https://myserver.com/callback"</span>);

<span class="hljs-comment">// setup the callback handler for receiving the GitHub callback</span>
oauth2.setupCallback(router.route());

<span class="hljs-comment">// protect everything under /protected</span>
router.route(<span class="hljs-string">"/protected/*"</span>).handler(oauth2);
<span class="hljs-comment">// mount some handler under the protected zone</span>
router
  .route(<span class="hljs-string">"/protected/somepage"</span>)
  .handler(ctx -&gt; ctx.response().end(<span class="hljs-string">"Welcome to the protected resource!"</span>));

<span class="hljs-comment">// welcome page</span>
router
  .get(<span class="hljs-string">"/"</span>)
  .handler(ctx -&gt; ctx.response()
    .putHeader(<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"text/html"</span>)
    .end(<span class="hljs-string">"Hello&lt;br&gt;&lt;a href=\"/protected/somepage\"&gt;Protected by Github&lt;/a&gt;"</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The OAuth2AuthHandler will setup a proper callback OAuth2 handler so the user does not need to deal with validation
of the authority server response. It is quite important to know that authority server responses are only valid once,
this means that if a client issues a reload of the callback URL it will be asserted as a invalid request since the
validation will fail.</p>
</div>
<div class="paragraph">
<p>A rule of thumb is once a valid callback is executed issue a client side redirect to a protected resource. This
redirect should also create a session cookie (or other session mechanism) so the user is not required to authenticate
for every request.</p>
</div>
<div class="paragraph">
<p>Due to the nature of OAuth2 spec there are slight changes required in order to use other OAuth2 providers but
vertx-auth provides you with many out of the box implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Azure Active Directory <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/AzureADAuth.html">AzureADAuth</a></code></p>
</li>
<li>
<p>Box.com <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/BoxAuth.html">BoxAuth</a></code></p>
</li>
<li>
<p>Dropbox <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/DropboxAuth.html">DropboxAuth</a></code></p>
</li>
<li>
<p>Facebook <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/FacebookAuth.html">FacebookAuth</a></code></p>
</li>
<li>
<p>Foursquare <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/FoursquareAuth.html">FoursquareAuth</a></code></p>
</li>
<li>
<p>Github <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/GithubAuth.html">GithubAuth</a></code></p>
</li>
<li>
<p>Google <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/GoogleAuth.html">GoogleAuth</a></code></p>
</li>
<li>
<p>Instagram <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/InstagramAuth.html">InstagramAuth</a></code></p>
</li>
<li>
<p>Keycloak <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/KeycloakAuth.html">KeycloakAuth</a></code></p>
</li>
<li>
<p>LinkedIn <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/LinkedInAuth.html">LinkedInAuth</a></code></p>
</li>
<li>
<p>Mailchimp <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/MailchimpAuth.html">MailchimpAuth</a></code></p>
</li>
<li>
<p>Salesforce <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/SalesforceAuth.html">SalesforceAuth</a></code></p>
</li>
<li>
<p>Shopify <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/ShopifyAuth.html">ShopifyAuth</a></code></p>
</li>
<li>
<p>Soundcloud <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/SoundcloudAuth.html">SoundcloudAuth</a></code></p>
</li>
<li>
<p>Stripe <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/StripeAuth.html">StripeAuth</a></code></p>
</li>
<li>
<p>Twitter <code><a href="../../apidocs/io/vertx/ext/auth/oauth2/providers/TwitterAuth.html">TwitterAuth</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However if you&#8217;re using an unlisted provider you can still do it using the base API like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2Auth authProvider = OAuth2Auth.create(vertx, <span class="hljs-keyword">new</span> OAuth2Options()
  .setClientID(<span class="hljs-string">"CLIENT_ID"</span>)
  .setClientSecret(<span class="hljs-string">"CLIENT_SECRET"</span>)
  .setFlow(OAuth2FlowType.AUTH_CODE)
  .setSite(<span class="hljs-string">"https://accounts.google.com"</span>)
  .setTokenPath(<span class="hljs-string">"https://www.googleapis.com/oauth2/v3/token"</span>)
  .setAuthorizationPath(<span class="hljs-string">"/o/oauth2/auth"</span>));

<span class="hljs-comment">// create a oauth2 handler on our domain: "http://localhost:8080"</span>
OAuth2AuthHandler oauth2 = OAuth2AuthHandler
  .create(vertx, authProvider, <span class="hljs-string">"http://localhost:8080"</span>);

<span class="hljs-comment">// these are the scopes</span>
oauth2.withScope(<span class="hljs-string">"profile"</span>);

<span class="hljs-comment">// setup the callback handler for receiving the Google callback</span>
oauth2.setupCallback(router.get(<span class="hljs-string">"/callback"</span>));

<span class="hljs-comment">// protect everything under /protected</span>
router.route(<span class="hljs-string">"/protected/*"</span>).handler(oauth2);
<span class="hljs-comment">// mount some handler under the protected zone</span>
router
  .route(<span class="hljs-string">"/protected/somepage"</span>)
  .handler(ctx -&gt; ctx.response().end(<span class="hljs-string">"Welcome to the protected resource!"</span>));

<span class="hljs-comment">// welcome page</span>
router
  .get(<span class="hljs-string">"/"</span>)
  .handler(ctx -&gt; ctx.response()
    .putHeader(<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"text/html"</span>)
    .end(<span class="hljs-string">"Hello&lt;br&gt;&lt;a href=\"/protected/somepage\"&gt;Protected by Google&lt;/a&gt;"</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will need to provide all the details of your provider manually but the end result is the same.</p>
</div>
<div class="paragraph">
<p>The handler will pin your application the the configured callback url. The usage is simple as providing the handler
a route instance and all setup will be done for you. In a typical use case your provider will ask you what is the
callback url to your application, your then enter a url like: <code><a href="https://myserver.com/callback" class="bare">https://myserver.com/callback</a></code>. This is the second
argument to the handler now you just need to set it up. To make it easier to the end user all you need to do is call
the setupCallback method.</p>
</div>
<div class="paragraph">
<p>This is how you pin your handler to the server <code><a href="https://myserver.com:8447/callback" class="bare">https://myserver.com:8447/callback</a></code>. Note that the port number is not
mandatory for the default values, 80 for http, 443 for https.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2AuthHandler oauth2 = OAuth2AuthHandler
  .create(vertx, provider, <span class="hljs-string">"https://myserver.com:8447/callback"</span>);

<span class="hljs-comment">// now allow the handler to setup the callback url for you</span>
oauth2.setupCallback(router.route());</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example the route object is created inline by <code>Router.route()</code> however if you want to have full control of the
order the handler is called (for example you want it to be called as soon as possible in the chain) you can always
create the route object before and pass it as a reference to this method.</p>
</div>
<div class="sect2">
<h3 id="_a_real_world_example"><a class="anchor" href="#_a_real_world_example"></a>A real world example</h3>
<div class="paragraph">
<p>Up to now you have learned how to use the Oauth2 Handler however you will notice that for each request you will need
to authenticate. This is because the handler has no state and there was no state management applied in the examples.</p>
</div>
<div class="paragraph">
<p>Although having no state is recommended for API facing endpoints, for example, using JWT (we will cover those later)
for user facing endpoinst we can keep the authentication result stored in the session. For this to work we would
need an application like the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2Auth authProvider =
  GithubAuth
    .create(vertx, <span class="hljs-string">"CLIENTID"</span>, <span class="hljs-string">"CLIENT SECRET"</span>);
<span class="hljs-comment">// We need a user session handler too to make sure</span>
<span class="hljs-comment">// the user is stored in the session between requests</span>
router.route()
  .handler(SessionHandler.create(LocalSessionStore.create(vertx)));
<span class="hljs-comment">// we now protect the resource under the path "/protected"</span>
router.route(<span class="hljs-string">"/protected"</span>).handler(
  OAuth2AuthHandler.create(vertx, authProvider)
    <span class="hljs-comment">// we now configure the oauth2 handler, it will</span>
    <span class="hljs-comment">// setup the callback handler</span>
    <span class="hljs-comment">// as expected by your oauth2 provider.</span>
    .setupCallback(router.route(<span class="hljs-string">"/callback"</span>))
    <span class="hljs-comment">// for this resource we require that users have</span>
    <span class="hljs-comment">// the authority to retrieve the user emails</span>
    .withScope(<span class="hljs-string">"user:email"</span>)
);
<span class="hljs-comment">// Entry point to the application, this will render</span>
<span class="hljs-comment">// a custom template.</span>
router.get(<span class="hljs-string">"/"</span>).handler(ctx -&gt; ctx.response()
  .putHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"text/html"</span>)
  .end(
    <span class="hljs-string">"&lt;html&gt;\n"</span> +
      <span class="hljs-string">"  &lt;body&gt;\n"</span> +
      <span class="hljs-string">"    &lt;p&gt;\n"</span> +
      <span class="hljs-string">"      Well, hello there!\n"</span> +
      <span class="hljs-string">"    &lt;/p&gt;\n"</span> +
      <span class="hljs-string">"    &lt;p&gt;\n"</span> +
      <span class="hljs-string">"      We're going to the protected resource, if there is no\n"</span> +
      <span class="hljs-string">"      user in the session we will talk to the GitHub API. Ready?\n"</span> +
      <span class="hljs-string">"      &lt;a href=\"/protected\"&gt;Click here&lt;/a&gt; to begin!&lt;/a&gt;\n"</span> +
      <span class="hljs-string">"    &lt;/p&gt;\n"</span> +
      <span class="hljs-string">"    &lt;p&gt;\n"</span> +
      <span class="hljs-string">"      &lt;b&gt;If that link doesn't work&lt;/b&gt;, remember to provide your\n"</span> +
      <span class="hljs-string">"      own &lt;a href=\"https://github.com/settings/applications/new\"&gt;\n"</span> +
      <span class="hljs-string">"      Client ID&lt;/a&gt;!\n"</span> +
      <span class="hljs-string">"    &lt;/p&gt;\n"</span> +
      <span class="hljs-string">"  &lt;/body&gt;\n"</span> +
      <span class="hljs-string">"&lt;/html&gt;"</span>));
<span class="hljs-comment">// The protected resource</span>
router.get(<span class="hljs-string">"/protected"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// at this moment your user object should contain the info</span>
  <span class="hljs-comment">// from the Oauth2 response, since this is a protected resource</span>
  <span class="hljs-comment">// as specified above in the handler config the user object is never null</span>
  User user = ctx.user();
  <span class="hljs-comment">// just dump it to the client for demo purposes</span>
  ctx.response().end(user.toString());
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mixing_oauth2_and_jwt"><a class="anchor" href="#_mixing_oauth2_and_jwt"></a>Mixing OAuth2 and JWT</h3>
<div class="paragraph">
<p>Some providers use JWT tokens as access tokens, this is a feature of <a href="https://tools.ietf.org/html/rfc6750">RFC6750</a>
and can be quite useful when one wants to mix client based authentication and API authorization. For example say that
you have a application that provides some protected HTML documents but you also want it to be available for API&#8217;s to
consume. In this case an API cannot easily perform the redirect handshake required by OAuth2 but can use a Token
provided before hand.</p>
</div>
<div class="paragraph">
<p>This is handled automatically by the handler as long as the provider is configured to support JWTs.</p>
</div>
<div class="paragraph">
<p>In real life this means that your API&#8217;s can access your protected resources using the header <code>Authorization</code> with the
value <code>Bearer BASE64_ACCESS_TOKEN</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_webauthn"><a class="anchor" href="#_webauthn"></a>WebAuthn</h3>
<div class="paragraph">
<p>Our online existence relies on an outdated and fragile idea of passwords. The password is what lies between a malicious
user and your bank account or social media accounts. Passwords are hard to maintain; it&#8217;s hard to store them on the
server (passwords get stolen). They&#8217;re hard to memorize, or not tell to others (phishing attacks).</p>
</div>
<div class="paragraph">
<p>But there&#8217;s a better way! A passwordless world, and it is a standard by W3C and FIDO Alliance running on your browser.</p>
</div>
<div class="paragraph">
<p>WebAuthn is an API that allows servers to register and authenticate users using public-key cryptography instead of a
password, an API that uses cryptography in a user-accessible way with the help of an authentication device, for example
a yubikey token, or your mobile phone.</p>
</div>
<div class="paragraph">
<p>The protocol requires at least the first callback to be mounted on the router:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>/webauthn/response</code> the callback used to perform all the validations</p>
</li>
<li>
<p><code>/webauthn/login</code> the endpoint to allow users to start the login flow (optional, but without it it won&#8217;t be able to login)</p>
</li>
<li>
<p><code>/webauthn/register</code> the endpoint to allow users to register a new identificator (optional, if the data is already stored this endpoint is not needed)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>An example of a protected application is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">WebAuthn webAuthn = WebAuthn.create(
  vertx,
  <span class="hljs-keyword">new</span> WebAuthnOptions()
    .setRelyingParty(<span class="hljs-keyword">new</span> RelyingParty().setName(<span class="hljs-string">"Vert.x WebAuthN Demo"</span>))
    <span class="hljs-comment">// What kind of authentication do you want? do you care?</span>
    <span class="hljs-comment">// # security keys</span>
    .setAuthenticatorAttachment(AuthenticatorAttachment.CROSS_PLATFORM)
    <span class="hljs-comment">// # fingerprint</span>
    .setAuthenticatorAttachment(AuthenticatorAttachment.PLATFORM)
    .setUserVerification(UserVerification.REQUIRED))
  <span class="hljs-comment">// where to load the credentials from?</span>
  .authenticatorFetcher(fetcher)
  <span class="hljs-comment">// update the state of an authenticator</span>
  .authenticatorUpdater(updater);

<span class="hljs-comment">// parse the BODY</span>
router.post()
  .handler(BodyHandler.create());
<span class="hljs-comment">// add a session handler</span>
router.route()
  .handler(SessionHandler
    .create(LocalSessionStore.create(vertx)));

<span class="hljs-comment">// security handler</span>
WebAuthnHandler webAuthNHandler = WebAuthnHandler.create(webAuthn)
  .setOrigin(<span class="hljs-string">"https://192.168.178.74.xip.io:8443"</span>)
  <span class="hljs-comment">// required callback</span>
  .setupCallback(router.post(<span class="hljs-string">"/webauthn/response"</span>))
  <span class="hljs-comment">// optional register callback</span>
  .setupCredentialsCreateCallback(router.post(<span class="hljs-string">"/webauthn/register"</span>))
  <span class="hljs-comment">// optional login callback</span>
  .setupCredentialsGetCallback(router.post(<span class="hljs-string">"/webauthn/login"</span>));

<span class="hljs-comment">// secure the remaining routes</span>
router.route().handler(webAuthNHandler);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The application is not secure on the backend side but there is some code needed to be performed on the client side. A bit
of boilerplate is required, take these 2 functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript"><span class="hljs-comment">/**
* Converts PublicKeyCredential into serialised JSON
* <span class="hljs-doctag">@param  <span class="hljs-type">{Object}</span> <span class="hljs-variable">pubKeyCred</span></span>
* <span class="hljs-doctag">@return <span class="hljs-type">{Object}</span>            </span>- JSON encoded publicKeyCredential
*/</span>
<span class="hljs-keyword">var</span> publicKeyCredentialToJSON = <span class="hljs-function">(<span class="hljs-params">pubKeyCred</span>) =&gt;</span> {
 <span class="hljs-keyword">if</span> (pubKeyCred <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
   <span class="hljs-keyword">let</span> arr = [];
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> pubKeyCred) { arr.push(publicKeyCredentialToJSON(i)) }

   <span class="hljs-keyword">return</span> arr
 }

 <span class="hljs-keyword">if</span> (pubKeyCred <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ArrayBuffer</span>) {
   <span class="hljs-keyword">return</span> base64url.encode(pubKeyCred)
 }

 <span class="hljs-keyword">if</span> (pubKeyCred <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) {
   <span class="hljs-keyword">let</span> obj = {};

   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> pubKeyCred) {
     obj[key] = publicKeyCredentialToJSON(pubKeyCred[key])
   }

   <span class="hljs-keyword">return</span> obj
 }

 <span class="hljs-keyword">return</span> pubKeyCred
};

<span class="hljs-comment">/**
* Generate secure random buffer
* @param  {Number} len - Length of the buffer (default 32 bytes)
* @return {Uint8Array} - random string
*/</span>
<span class="hljs-keyword">var</span> generateRandomBuffer = <span class="hljs-function">(<span class="hljs-params">len</span>) =&gt;</span> {
 len = len || <span class="hljs-number">32</span>;

 <span class="hljs-keyword">let</span> randomBuffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(len);
 <span class="hljs-built_in">window</span>.crypto.getRandomValues(randomBuffer);

 <span class="hljs-keyword">return</span> randomBuffer
};

<span class="hljs-comment">/**
* Decodes arrayBuffer required fields.
*/</span>
<span class="hljs-keyword">var</span> preformatMakeCredReq = <span class="hljs-function">(<span class="hljs-params">makeCredReq</span>) =&gt;</span> {
 makeCredReq.challenge = base64url.decode(makeCredReq.challenge);
 makeCredReq.user.id = base64url.decode(makeCredReq.user.id);

 <span class="hljs-keyword">return</span> makeCredReq
};

<span class="hljs-comment">/**
* Decodes arrayBuffer required fields.
*/</span>
<span class="hljs-keyword">var</span> preformatGetAssertReq = <span class="hljs-function">(<span class="hljs-params">getAssert</span>) =&gt;</span> {
 getAssert.challenge = base64url.decode(getAssert.challenge);

 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> allowCred <span class="hljs-keyword">of</span> getAssert.allowCredentials) {
   allowCred.id = base64url.decode(allowCred.id)
 }

 <span class="hljs-keyword">return</span> getAssert
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions will help you with the interaction with the server. Nothing more. Let&#8217;s start by login in a user:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript"><span class="hljs-comment">// using the functions defined before...</span>
getGetAssertionChallenge({<span class="hljs-attr">name</span>: <span class="hljs-string">'your-user-name'</span>})
.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
 <span class="hljs-comment">// base64 must be decoded to a JavaScript Buffer</span>
 <span class="hljs-keyword">let</span> publicKey = preformatGetAssertReq(response);
 <span class="hljs-comment">// the response is then passed to the browser</span>
 <span class="hljs-comment">// to generate an assertion by interacting with your token/phone/etc...</span>
 <span class="hljs-keyword">return</span> navigator.credentials.get({publicKey})
})
.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
 <span class="hljs-comment">// convert response buffers to base64 and json</span>
 <span class="hljs-keyword">let</span> getAssertionResponse = publicKeyCredentialToJSON(response);
 <span class="hljs-comment">// send information to server</span>
 <span class="hljs-keyword">return</span> sendWebAuthnResponse(getAssertionResponse)
})
.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
 <span class="hljs-comment">// success!</span>
 alert(<span class="hljs-string">'Login success'</span>)
})
.catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> alert(error));

<span class="hljs-comment">// utility functions</span>

<span class="hljs-keyword">let</span> sendWebAuthnResponse = <span class="hljs-function">(<span class="hljs-params">body</span>) =&gt;</span> {
 <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'/webauthn/response'</span>, {
   <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
   <span class="hljs-attr">credentials</span>: <span class="hljs-string">'include'</span>,
   <span class="hljs-attr">headers</span>: {
     <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
   },
   <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(body)
 })
   .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
     <span class="hljs-keyword">if</span> (!response.ok) {
       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Server responded with error: <span class="hljs-subst">${response.statusText}</span>`</span>);
     }
     <span class="hljs-keyword">return</span> response;
   })
};

<span class="hljs-keyword">let</span> getGetAssertionChallenge = <span class="hljs-function">(<span class="hljs-params">formBody</span>) =&gt;</span> {
 <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'/webauthn/login'</span>, {
   <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
   <span class="hljs-attr">credentials</span>: <span class="hljs-string">'include'</span>,
   <span class="hljs-attr">headers</span>: {
     <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
   },
   <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(formBody)
 })
   .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
     <span class="hljs-keyword">if</span> (!response.ok) {
       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Server responded with error: <span class="hljs-subst">${response.statusText}</span>`</span>);
     }
     <span class="hljs-keyword">return</span> response;
   })
   .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.json())
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above already covered 66% of the API, 2 out fo 3 endpoints where covered. The final endpoint is the user
registration. User registration is the process of enrolling a new key into the server credential store and map to a user,
and of course on the client side a private key was created and associated with the server but this key never left the
hardware token or your phone security chip.</p>
</div>
<div class="paragraph">
<p>To register a user and reusing most of the functions already defined above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript"><span class="hljs-comment">/* Handle for register form submission */</span>
getMakeCredentialsChallenge({<span class="hljs-attr">name</span>: <span class="hljs-string">'myalias'</span>, <span class="hljs-attr">displayName</span>: <span class="hljs-string">'Paulo Lopes'</span>})
.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
 <span class="hljs-comment">// convert challenge &amp; id to buffer and perform register</span>
 <span class="hljs-keyword">let</span> publicKey = preformatMakeCredReq(response);
 <span class="hljs-comment">// create a new secure key pair</span>
 <span class="hljs-keyword">return</span> navigator.credentials.create({publicKey})
})
.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
 <span class="hljs-comment">// convert response from buffer to json</span>
 <span class="hljs-keyword">let</span> makeCredResponse = <span class="hljs-built_in">window</span>.publicKeyCredentialToJSON(response);
 <span class="hljs-comment">// send to server to confirm the user</span>
 <span class="hljs-keyword">return</span> sendWebAuthnResponse(makeCredResponse)
})
.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
 alert(<span class="hljs-string">'Registration completed'</span>)
})
.catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> alert(error));

<span class="hljs-comment">// utility functions</span>

<span class="hljs-keyword">let</span> getMakeCredentialsChallenge = <span class="hljs-function">(<span class="hljs-params">formBody</span>) =&gt;</span> {
 <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'/webauthn/register'</span>, {
   <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
   <span class="hljs-attr">credentials</span>: <span class="hljs-string">'include'</span>,
   <span class="hljs-attr">headers</span>: {
     <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
   },
   <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(formBody)
 })
   .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
     <span class="hljs-keyword">if</span> (!response.ok) {
       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Server responded with error: <span class="hljs-subst">${response.statusText}</span>`</span>);
     }
     <span class="hljs-keyword">return</span> response;
   })
   .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.json())
};</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
Due to the secure nature of the API browsers will not allow you to use this API on plain text HTTP. All requests
must go over HTTPS.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
WebAuthN requires HTTPS with a working TLS certificate, you can use self signed certiticates too during
development.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_handling_http_method_overriding"><a class="anchor" href="#_handling_http_method_overriding"></a>Handling HTTP Method overriding</h3>
<div class="paragraph">
<p>Many companies and other services impose limitations to the REST HTTP methods they allow to the outside world. Some are lax by allowing any method, most are restricted by allowing only a small-but-decent set and some only allow GET and POST. The reasons for such restritions varies: browser or client limitations or a really strict corporate firewalls. Web services with only GET and POST does not express well the REST ideology. PUT, DELETE, OPTIONS, among others are quite useful to specify what do to to a resource. To deal with it, it was created the X-HTTP-METHOD-OVERRIDE HTTP header as a workaround.</p>
</div>
<div class="paragraph">
<p>By sending a request with GET/POST and which method the request should truly process inside the X-HTTP-METHOD-OVERRIDE HTTP header, the server should recognize the header and redirect to the appropriate method.</p>
</div>
<div class="paragraph">
<p>Vert.x allows one to do so, simply by:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(MethodOverrideHandler.create());

router.route(HttpMethod.GET, <span class="hljs-string">"/"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do GET stuff...</span>
});

router.route(HttpMethod.POST, <span class="hljs-string">"/"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do POST stuff...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since it will redirect the request, it is wise to avoid firing request handlers unnecessarily, so it is better to add the MethodOverrideHandler as the first handler.</p>
</div>
<div class="paragraph">
<p>Also, a word of caution: THIS MIGHT BECOME AN ATTACK VECTOR FOR ILL-INTENTIONED PEOPLE!</p>
</div>
<div class="paragraph">
<p>To mitigate such a problem, the MethodOverrideHandler comes with a Safe-Downgrade Policy by default. This policy says that the method contained in X-HTTP-METHOD-OVERRIDE can override the original one if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the overriding method is idempotent; or</p>
</li>
<li>
<p>the overriding method is safe and the method to be overrided is NOT idempotent; or</p>
</li>
<li>
<p>the method to be overrided is not safe.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Although we do NOT recommend, Vert.x will not force you to anything. If it is your desire to allow any overriding, then:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">router.route().handler(MethodOverrideHandler.create(<span class="hljs-keyword">false</span>));

router.route(HttpMethod.GET, <span class="hljs-string">"/"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do GET stuff...</span>
});

router.route(HttpMethod.POST, <span class="hljs-string">"/"</span>).handler(ctx -&gt; {
  <span class="hljs-comment">// do POST stuff...</span>
});</code></pre>
</div>
</div>
</div>
</div>
</div></div></div></div></div></div><footer><div class="container"><div class="footer-nav-section"><div class="footer-nav-list footer-logo"><a href="/"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAxMTI1LjYgMzE1LjIiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZT4uc3Qwe2ZpbGw6Izc4MmE5MX08L3N0eWxlPjxwYXRoIGQ9Ik0xMjAuOSAyMTQuMkwxOTAuNSAwaDUyLjNsLTk4LjUgMjczLjhIOTguMkwwIDBoNTIuMWw2OC44IDIxNC4yem0yOTEuMi02Mi42SDI5OS42djg0LjJINDMxdjM4SDI1MlYwaDE3Ny43djM4LjRIMjk5LjZWMTE0aDExMi41djM3LjZ6bTgzLjctMTEzLjJINTQ2YzE2LjUuMyAyOSA0LjQgMzcuMyAxMi40IDguMyA4IDEyLjUgMTkuNCAxMi41IDM0IDAgMTQtNC41IDI1LjEtMTMuNSAzMy4yLTkgOC4xLTIxLjYgMTIuMS0zNy42IDEyLjFoLTI3LjF2MjQuMmw4Ni4xIDExOS41aDUxdi0yLjRsLTc3LjItMTA2LjdjMjQuOS01LjUgNDMuMy0yMS43IDUyLjYtMzUuOSA4LjItMTIuNiAxMy4zLTI3LjcgMTMuMy00NiAwLTI2LjgtOC42LTQ3LjQtMjUuOC02MS41QzYwMC41IDcuMSA1NzYuMSAwIDU0NC41IDBoLTk2LjN2MjczLjhoNDcuNiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDUyLjMgMTU3LjdsLTQxLjUgNjIuNyAyOS43IDUzLjRoODUuMXoiLz48Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSI4MjcuOSIgY3k9IjI3NC43IiByPSI0MC41Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTEwMzcgMGwtNDcuNiA3NC4yTDk0OSAwaC04NGw4NS4zIDEzNS44LTY3LjEgMTA1LjdjNS43IDkuNSA5LjEgMjAuNSA5LjIgMzIuNGg1MC4xTDExMjEuMyAwSDEwMzd6Ii8+PHBhdGggZD0iTTc2My41IDI3My44Yy4xLTkuOSAyLjUtMTkuMiA2LjYtMjcuNVYzOC40aDg1LjRWMEg2MzguMnYzOC40aDg0LjZ2MjM1LjRoNDAuN3oiLz48L3N2Zz4=" alt="Vert.x Logo"/></a></div><div class="footer-nav-list"><h5>Eclipse Vert.x</h5><ul class=""><li><a class="navbar-menu-item" href="/docs/">文档</a></li><li><a href="/download/">下载</a></li><li><a href="/blog/">博客</a></li><li><a href="/community/">社区</a></li><li><a href="/translation/">翻译团队</a></li><li><a href="https://github.com/eclipse-vertx/vert.x">GitHub</a></li><li><a href="https://github.com/vertx-china/vertx-web-site">翻译GitHub</a></li></ul></div><div class="footer-nav-list"><h5>资源</h5><ul class=""><li><a href="/faq/">答疑</a></li><li><a href="/channels/">Channels</a></li><li><a href="https://how-to.vertx.io/">How-To’s</a></li><li><a href="https://start.vertx.io/">App Generator</a></li></ul></div><div class="footer-nav-list"><h5>Eclipse</h5><ul class=""><li><a href="https://www.eclipse.org/">Eclipse Foundation</a></li><li><a href="https://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li><li><a href="https://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li><li><a href="https://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li><li><a href="https://www.eclipse.org/legal/">Legal Resources</a></li></ul></div></div><div class="footer-copyright"><div class="footer-copyright-remarks">© <!-- -->2021<!-- --> Eclipse Vert.x<br/>Eclipse Vert.x is open source and dual-licensed under the <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="noopener noreferrer">Eclipse Public License 2.0</a> and the <a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache License 2.0</a>. <br class="footer-copyright-break"/>Website design by <a href="https://michelkraemer.com" target="_blank" rel="noopener noreferrer">Michel Krämer</a>.</div><div class="footer-copyright-eclipse-logo"><a href="https://www.eclipse.org/" target="_blank" rel="noopener noreferrer"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAyODEuMyA5MS4xIiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGU+LnN0MHtmaWxsOiNmNzk0MjJ9LnN0MXtmaWxsOiMzZDNjM2J9PC9zdHlsZT48ZyBpZD0iTGF5ZXJfMV8xXyI+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI2NS43IDg0TDI1NyA3M2gtMi43djE3LjdoMy4zdi0xMmw5LjMgMTJoMi4xVjczaC0zLjN2MTF6bS0zMi40LTguM2M0LjIgMCA1LjggMy4zIDUuOCA2LjNzLTEuNiA2LTUuOCA2LTUuNy0zLjEtNS44LTYgMS43LTYuMyA1LjgtNi4zem0wLTNjLTYuMSAwLTkuMSA0LjctOS4xIDkuMyAwIDQuNyAyLjkgOS4xIDkuMSA5LjFzOS00LjYgOS4xLTkuMi0zLTkuMi05LjEtOS4yem0tMjEuMiAxOFY3M2gtMy4zdjE3LjdoMy4zem0tMjMuNiAwaDMuM1Y3Nmg1LjZ2LTNoLTE0LjZ2M2g1LjZsLjEgMTQuN3ptLTE4LjktNi41SDE2M2wzLjMtNy42IDMuMyA3LjZ6bTIuOCA2LjVoMy42TDE2OC4yIDczaC0zLjZsLTggMTcuN2gzLjZsMS41LTMuM2g5LjNsMS40IDMuM3ptLTM4LTE0LjZoMy42YzMuOSAwIDUuNSAyLjggNS41IDUuNS4xIDIuOC0xLjUgNS44LTUuNSA1LjhoLTMuNlY3Ni4xem0zLjctMy4xaC02Ljl2MTcuN2g2LjljNi4yIDAgOC45LTQuNSA4LjktOXMtMi44LTguNy04LjktOC43em0tMjIuNCAxMUwxMDcgNzNoLTIuN3YxNy43aDMuM3YtMTJsOS4zIDEyaDIuMVY3M2gtMy4zdjExek04OC4yIDczdjEwLjJjMCAzLTEuNiA0LjktNC4zIDQuOXMtNC42LTEuNy00LjYtNC45VjczSDc2djEwLjFjMCA1LjMgMy42IDcuOSA3LjkgNy45IDQuNCAwIDcuNy0yLjcgNy43LTcuOVY3M2gtMy40em0tMzMgMi43YzQuMiAwIDUuOCAzLjMgNS44IDYuM3MtMS42IDYtNS44IDYtNS43LTMuMS01LjgtNiAxLjctNi4zIDUuOC02LjN6bTAtM2MtNi4xIDAtOS4xIDQuNy05LjEgOS4zczIuOSA5LjEgOS4xIDkuMSA5LTQuNiA5LjEtOS4yLTMtOS4yLTkuMS05LjJ6bS0yOS43IDE4di02LjVoOC45di0zLjFoLTguOXYtNC44aDkuNFY3M0gyMi4ydjE3LjZoMy4zeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yNjkuNCA1NC40aC0yMi4ydi04LjloMjEuNHYtNi45aC0yMS40di05LjFoMjIuMnYtNy4yaC0yOS42djM5LjVoMjkuNnYtNy40em0tNDAtMjUuNmMtMy02LjEtOS40LTcuOC0xNS41LTcuOC03LjMgMC0xNS4zIDMuNC0xNS4zIDExLjUgMCA4LjkgNy40IDExIDE1LjUgMTIgNS4yLjYgOS4xIDIuMSA5LjEgNS44IDAgNC4zLTQuNCA1LjktOS4xIDUuOXMtOS40LTEuOS0xMS4xLTYuM2wtNi4yIDMuMmMyLjkgNy4yIDkuMSA5LjcgMTcuMiA5LjcgOC44IDAgMTYuNi0zLjggMTYuNi0xMi42IDAtOS40LTcuNy0xMS42LTE1LjktMTIuNi00LjctLjYtOC44LTEuNS04LjgtNSAwLTIuOSAyLjYtNS4yIDguMi01LjIgNC4zIDAgOCAyLjIgOS40IDQuNGw1LjktM3pNMTc2IDIyLjJjLTYuMi0uMS0xMi40IDAtMTguNiAwdjM5LjVoNy40VjUwLjFIMTc2YzE5LjQgMCAxOS40LTI3LjkgMC0yNy45em0tMTEuMSA3LjFIMTc2YzkuNSAwIDkuNSAxNCAwIDE0aC0xMS4ybC4xLTE0em0tMTggMzIuNVYyMi4yaC03LjR2MzkuNWw3LjQuMXptLTQ0LTM5LjZ2MzkuNWgyNy43di02LjloLTIwLjNWMjIuMmgtNy40ek05MC43IDUxLjdjLTIuNyAyLjUtNi4yIDQtOS45IDQtOS44IDAtMTMuNS02LjgtMTMuNi0xMy40czQuMS0xMy43IDEzLjYtMTMuN2MzLjUtLjEgNyAxLjMgOS41IDMuN2w1LTQuOGMtMy44LTMuOS05LjEtNi0xNC41LTYtMTQuMyAwLTIxIDEwLjUtMjAuOSAyMC44czYuMyAyMC4zIDIwLjkgMjAuM2M1LjYuMSAxMS0yIDE1LTUuOWwtNS4xLTV6bS0zOSAyLjdIMjkuNXYtOC45aDIxLjR2LTYuOUgyOS41di05LjFoMjIuMnYtNy4ySDIyLjJ2MzkuNWgyOS42bC0uMS03LjR6Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTkuOCAxOC4yQzE4LjggNC4xIDM2LjktLjggNTIuMSA2bC0xLS43QzM1LjctNC42IDE1LjItLjEgNS4zIDE1LjNzLTUuNCAzNS45IDEwIDQ1LjhsMS4xLjZDMy44IDUwLjguOCAzMi4zIDkuOCAxOC4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yNzIuMiAyNi4xYzAtMi41IDIuMS00LjYgNC42LTQuNiAyLjUgMCA0LjYgMi4xIDQuNiA0LjYgMCAyLjUtMi4xIDQuNi00LjYgNC42LTIuNiAwLTQuNi0yLjEtNC42LTQuNnptOC42IDBjMC0yLjItMS44LTQuMS00LTQuMXMtNC4xIDEuOC00LjEgNC4xYzAgMi4yIDEuNyA0IDMuOSA0LjFoLjFjMi4zIDAgNC4xLTEuOCA0LjEtNC4xem0tNi0yLjVoMi4zYzEuMSAwIDEuOS41IDEuOSAxLjYgMCAuNy0uNCAxLjMtMS4xIDEuNWwxLjIgMS43aC0xLjRsLTEtMS41aC0uN3YxLjVoLTEuMWwtLjEtNC44em0yLjIgMi4zYy41IDAgLjgtLjMuOC0uN3MtLjMtLjctLjgtLjdoLTF2MS4zbDEgLjF6Ii8+PC9nPjwvc3ZnPg==" alt="Eclipse foundation Logo"/></a></div></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"4.0.2/vertx-web/java","title":"Vert.x-Web","fallbackGitHubStars":null,"toc":"\u003cdiv id=\"toc\" class=\"toc\"\u003e\n\u003cdiv id=\"toctitle\"\u003eTable of Contents\u003c/div\u003e\n\u003cul class=\"sectlevel1\"\u003e\n\u003cli\u003e\u003ca href=\"#_using_vert_x_web\"\u003e使用 Vert.x Web\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_development_mode\"\u003e开发模式\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_re_cap_on_vert_x_core_http_servers\"\u003e回顾 Vert.x Core 的 HTTP 服务端\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_basic_vert_x_web_concepts\"\u003eVert.x Web 的基本概念\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_requests_and_calling_the_next_handler\"\u003e处理请求并调用下一个处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_simple_responses\"\u003e简单的响应\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_using_blocking_handlers\"\u003e使用阻塞式处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_routing_by_exact_path\"\u003e基于精确路径的路由\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_routing_by_paths_that_begin_with_something\"\u003e基于路径前缀的路由\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_capturing_path_parameters\"\u003e捕捉路径参数\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_routing_with_regular_expressions\"\u003e基于正则表达式的路由\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_capturing_path_parameters_with_regular_expressions\"\u003e通过正则表达式捕捉路径参数\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_using_named_capture_groups\"\u003e使用命名的捕捉组\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_routing_by_http_method\"\u003e基于 HTTP 方法的路由\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_route_order\"\u003eRoute order\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_routing_based_on_mime_type_of_request\"\u003eRouting based on MIME type of request\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_routing_based_on_mime_types_acceptable_by_the_client\"\u003eRouting based on MIME types acceptable by the client\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_routing_based_on_virtualhost\"\u003eRouting based on VirtualHost\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_combining_routing_criteria\"\u003eCombining routing criteria\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_enabling_and_disabling_routes\"\u003eEnabling and disabling routes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_forward_support\"\u003eForward Support\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_context_data\"\u003eContext data\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_helper_functions\"\u003eHelper functions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_reroute\"\u003eReroute\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_sub_routers\"\u003eSub-routers\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_localization\"\u003eLocalization\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_route_match_failures\"\u003eRoute match failures\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_error_handling\"\u003eError handling\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_request_body_handling\"\u003eRequest body handling\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_getting_the_request_body\"\u003eGetting the request body\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_limiting_body_size\"\u003eLimiting body size\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_merging_form_attributes\"\u003eMerging form attributes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_file_uploads\"\u003eHandling file uploads\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_cookies\"\u003eHandling cookies\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_manipulating_cookies\"\u003eManipulating cookies\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_sessions\"\u003eHandling sessions\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_session_stores\"\u003eSession stores\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_creating_the_session_handler\"\u003eCreating the session handler\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_using_the_session\"\u003eUsing the session\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_session_timeout\"\u003eSession timeout\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_authentication_authorization\"\u003eAuthentication / authorization\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_creating_an_authentication_handler\"\u003eCreating an Authentication handler\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_authentication_in_your_application\"\u003eHandling authentication in your application\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_http_basic_authentication\"\u003eHTTP Basic Authentication\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_redirect_authentication_handler\"\u003eRedirect authentication handler\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_jwt_authentication\"\u003eJWT authentication\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_configuring_authorization\"\u003eConfiguring authorization\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_chaining_multiple_authentication_handlers\"\u003eChaining multiple authentication handlers\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_serving_static_resources\"\u003eServing static resources\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_configuring_caching\"\u003eConfiguring caching\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_configuring_the_index_page\"\u003eConfiguring the index page\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_changing_the_web_root\"\u003eChanging the web root\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_serving_hidden_files\"\u003eServing hidden files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_directory_listing\"\u003eDirectory listing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_disabling_file_caching_on_disk\"\u003eDisabling file caching on disk\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_cors_handling\"\u003eCORS handling\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_multi_tenant\"\u003eMulti Tenant\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_templates\"\u003e模板\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_mvel_template_engine\"\u003eMVEL 模版引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_jade_template_engine\"\u003eJade 模版引擎（译者注：Jade 已更名为 Pug)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handlebars_template_engine\"\u003eHandlebars 模板引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_thymeleaf_template_engine\"\u003eThymeleaf 模板引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_apache_freemarker_template_engine\"\u003eApache FreeMarker 模版引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_pebble_template_engine\"\u003ePebble 模版引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_rocker_template_engine\"\u003eRocker 模版引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_httl_template_engine\"\u003eHTTL 模版引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_rythm_template_engine\"\u003eRythm 模版引擎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_caching\"\u003e缓存\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_error_handler\"\u003e错误处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_request_logger\"\u003e请求日志\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_serving_favicons\"\u003e提供网页图标\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_timeout_handler\"\u003e超时处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_response_time_handler\"\u003e响应时间处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_content_type_handler\"\u003e内容类型（Content type）处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_sockjs\"\u003eSockJS\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_sockjs_handler\"\u003eSockJS 处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_sockjs_sockets\"\u003e处理 SockJS 套接字\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_the_client_side\"\u003e客户端\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_configuring_the_sockjs_handler\"\u003e配置 SockJS 处理器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_writing_to_a_sockjs_socket_over_the_event_bus\"\u003e通过 event bus 写入 SockJS 套接字\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_sockjs_event_bus_bridge\"\u003eSockJS 桥接 Event Bus\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_securing_the_bridge\"\u003e守护连接桥\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_requiring_authorization_for_messages\"\u003e消息授权\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_event_bus_bridge_events\"\u003eHandling event bus bridge events\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_csrf_cross_site_request_forgery\"\u003eCSRF Cross Site Request Forgery\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_using_ajax\"\u003eUsing AJAX\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_hsts_handler\"\u003eHSTS Handler\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_csp_handler\"\u003eCSP Handler\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_xframe_handler\"\u003eXFrame Handler\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_oauth2authhandler_handler\"\u003eOAuth2AuthHandler Handler\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_a_real_world_example\"\u003eA real world example\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_mixing_oauth2_and_jwt\"\u003eMixing OAuth2 and JWT\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_webauthn\"\u003eWebAuthn\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_handling_http_method_overriding\"\u003eHandling HTTP Method overriding\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e","contents":"\u003ch1\u003eVert.x-Web\u003c/h1\u003e\n\n\u003cdiv id=\"preamble\"\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web是基于Vert.x的，用于构建Web应用程序的一系列构建模块。 可以将其视为一把构建现代的，可扩展的Web应用的瑞士军刀。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Core 提供了一系列相对底层的功能用于操作HTTP，对于一部分应用是足够的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 基于 Vert.x Core 提供了一系列更丰富的功能，以便更容易地开发实际的 Web 应用。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e它继承了 Vert.x 2.x 里的 \u003ca href=\"http://pmlopes.github.io/yoke/\"\u003eYoke\u003c/a\u003e 的特点，灵感来自于 Node.js 的框架 \u003ca href=\"http://expressjs.com/\"\u003eExpress\u003c/a\u003e 和 Ruby 的框架 \u003ca href=\"http://www.sinatrarb.com/\"\u003eSinatra\u003c/a\u003e 等等。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 的设计是强大的，非侵入式的, 并且是完全可插拔的。您可以只使用您需要的部分。 Vert.x Web 不是一个容器。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可以使用 Vert.x Web 来构建经典的服务端 Web 应用， RESTful 应用， 实时的（服务端推送)Web 应用, 或任何您所能想到的 Web 应用类型。应用类型的选择取决于您的喜好，而不是 Vert.x Web。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web is a great fit for writing RESTful HTTP micro-services, but we don’t force you to write apps like that。\nVert.x Web 非常适合编写 RESTful HTTP 微服务，\u003cstrong\u003e 但我们不强制 \u003c/strong\u003e 您必须把应用实现成这样。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 的一部分关键特性有：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e路由(基于方法,路径等)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e基于正则表达式的路径匹配\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从路径中提取参数\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内容协商\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e处理消息体\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e消息体的长度限制\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMultipart 表单\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMultipart 文件上传\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e子路由\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e支持本地会话和集群会话\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e支持 CORS(跨域资源共享)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e错误页面处理器\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHTTP基本/摘要认证\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e基于重定向的认证\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e授权处理器\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e基于 JWT 的授权\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e用户/角色/权限授权\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e网页图标处理器\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e支持服务端模板渲染，包括以下开箱即用的模板引擎:\u003c/p\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHandlebars\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eJade\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMVEL\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThymeleaf\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eApache FreeMarker\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePebble\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRocker\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e响应时间处理器\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e静态文件服务，包括缓存逻辑以及目录监听\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e支持请求超时\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e支持 SockJS\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e桥接 Event-bus\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCSRF 跨域请求伪造\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e虚拟主机\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 的大部分特性是使用Handler实现的， 而且您随时可以实现您自己的处理器。我们预计随着时间的推移会有更多的处理器被实现。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e我们会在本手册里讨论所有上述的特性。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_using_vert_x_web\"\u003e\u003ca class=\"anchor\" href=\"#_using_vert_x_web\"\u003e\u003c/a\u003e使用 Vert.x Web\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 Vert.x Web 之前，需要为您的构建工具在描述文件中添加  \u003cem\u003edependencies\u003c/em\u003e 依赖项：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMaven (在您的 \u003ccode\u003epom.xml\u003c/code\u003e 文件中):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eio.vertx\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003evertx-web\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e4.0.2\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGradle (在您的 \u003ccode\u003ebuild.gradle\u003c/code\u003e 文件中)：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003edependencies {\n compile \u003cspan class=\"hljs-string\"\u003e'io.vertx:vertx-web:4.0.2'\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_development_mode\"\u003e\u003ca class=\"anchor\" href=\"#_development_mode\"\u003e\u003c/a\u003e开发模式\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 默认使用生产模式。\n您可以通过设置 \u003ccode\u003edev\u003c/code\u003e 值到下面的其中一个来切换开发模式：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eVERTXWEB_ENVIRONMENT\u003c/code\u003e 环境变量，或\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003evertxweb.environment\u003c/code\u003e 系统属性\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在开发模式：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e模板引擎缓存被禁用\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eErrorHandler\u003c/code\u003e 不显示异常详细信息\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eStaticHandler\u003c/code\u003e 不处理缓存头\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGraphQL开发工具被禁用\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_re_cap_on_vert_x_core_http_servers\"\u003e\u003ca class=\"anchor\" href=\"#_re_cap_on_vert_x_core_http_servers\"\u003e\u003c/a\u003e回顾 Vert.x Core 的 HTTP 服务端\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 使用并暴露了 Vert.x Core 的 API，所以熟悉基于 Vert.x Core 编写 HTTP 服务端的基本概念是很有价值的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x core HTTP文档对此进行了详细介绍。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这是一个用 Vert.x core 编写的 Hello World Web服务。暂不涉及Vert.x-Web：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eHttpServer server = vertx.createHttpServer();\n\nserver.requestHandler(request -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 所有的请求都会调用这个处理器处理\u003c/span\u003e\n  HttpServerResponse response = request.response();\n  response.putHeader(\u003cspan class=\"hljs-string\"\u003e\"content-type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"text/plain\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 写入响应并结束处理\u003c/span\u003e\n  response.end(\u003cspan class=\"hljs-string\"\u003e\"Hello World!\"\u003c/span\u003e);\n});\n\nserver.listen(\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e我们创建了一个 HTTP 服务器实例，并设置了一个请求处理器。所有的请求都会调用这个处理器处理。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当请求到达时，我们设置响应的 Content Type 为 \u003ccode\u003etext/plain\u003c/code\u003e ， 并写入了 \u003ccode\u003eHello World!\u003c/code\u003e 然后结束了处理。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e之后，我们告诉服务器监听 \u003ccode\u003e8080\u003c/code\u003e 端口(默认的主机名是 \u003ccode\u003elocalhost\u003c/code\u003e )。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可以执行这段代码，并打开浏览器访问 \u003ccode\u003e\u003ca href=\"http://localhost:8080\" class=\"bare\"\u003ehttp://localhost:8080\u003c/a\u003e\u003c/code\u003e 来验证它是否如预期一样工作。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_basic_vert_x_web_concepts\"\u003e\u003ca class=\"anchor\" href=\"#_basic_vert_x_web_concepts\"\u003e\u003c/a\u003eVert.x Web 的基本概念\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e高屋建瓴 (Here\u0026#8217;s the 10000 foot view)：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Router.html\"\u003e路由器 Router\u003c/a\u003e\u003c/code\u003e 是 Vert.x Web 的核心概念之一。 它是一个维护了零或多个\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html\"\u003e路由 Routes\u003c/a\u003e\u003c/code\u003e 的对象。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个 router 接收 HTTP 请求，并查找首个匹配该请求的route, 然后将请求传递给这个route\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003eRoute\u003c/code\u003e 可以持有一个与之关联的 \u003cem\u003ehandler\u003c/em\u003e 用于接收请求。 您可以通过这个处理器对请求 \u003cem\u003e做一些事情\u003c/em\u003e, 然后结束响应或者把请求传递给下一个匹配的处理器。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是一个简单的路由示例：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eHttpServer server = vertx.createHttpServer();\n\nRouter router = Router.router(vertx);\n\nrouter.route().handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 所有的请求都会调用这个处理器处理\u003c/span\u003e\n  HttpServerResponse response = ctx.response();\n  response.putHeader(\u003cspan class=\"hljs-string\"\u003e\"content-type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"text/plain\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 写入响应并结束处理\u003c/span\u003e\n  response.end(\u003cspan class=\"hljs-string\"\u003e\"Hello World from Vert.x-Web!\"\u003c/span\u003e);\n});\n\nserver.requestHandler(router).listen(\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e它做了和上文使用 Vert.x Core 实现的 hello world HTTP 服务基本相同的事情，只是这一次换成了 Vert.x Web。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e我们像以前一样创建一个HTTP服务器，然后我们创建一个 router。当我们完成这些之后,我们创建一个简单的没有匹配条件的 rout，它能够匹配 \u003cem\u003e全部\u003c/em\u003e 到来的请求。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e然后，我们为该路由指定一个处理器。该处理器将处理所有到来的请求。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e传递给处理器的对象是 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e - 它包含标准的 Vert.x \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\"\u003eHttpServerRequest\u003c/a\u003e\u003c/code\u003e 和 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html\"\u003eHttpServerResponse\u003c/a\u003e\u003c/code\u003e\n还有其他各种有用的东西，让使用Vert.x-Web变得更加简单。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e处理器调用的参数是一个 \u003ca href=\"http://vertx.io/docs/apidocs/io/vertx/ext/web/RoutingContext.html\"\u003e \u003ccode\u003eRoutingContext\u003c/code\u003e \u003c/a\u003e 对象。 它不仅包含了 Vert.x 中标准的 \u003ca href=\"http://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerRequest.html\"\u003e \u003ccode\u003eHttpServerRequest\u003c/code\u003e \u003c/a\u003e 和\n\u003ca href=\"http://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerResponse.html\"\u003e \u003ccode\u003eHttpServerResponse\u003c/code\u003e \u003c/a\u003e，还包含了各种用于简化 Vert.x Web 使用的东西。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e每个被路由的请求， 都有一个唯一的路由上下文实例， 并将这个实例传递给该请求的所有处理器。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当我们建立了处理器之后，我们设置 HTTP 服务器的请求处理器，使所有的请求都通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/Handler。html#handle-java.lang.Object-\"\u003ehandle\u003c/a\u003e\u003c/code\u003e 处理。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这些是最基本的，下面我们来看一下更多的细节：\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_handling_requests_and_calling_the_next_handler\"\u003e\u003ca class=\"anchor\" href=\"#_handling_requests_and_calling_the_next_handler\"\u003e\u003c/a\u003e处理请求并调用下一个处理器\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当 Vert.x Web 决定路由一个请求到匹配的route，它会调用对应处理器并将一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e 实例传递给它. route可以具有不同的处理器， 您可以叠加使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route。html#handler-io.vertx.core.Handler-\"\u003ehandler\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果您不在处理器里结束这个响应，您需要调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\"\u003enext\u003c/a\u003e\u003c/code\u003e 方法让其他匹配的 route 来处理请求(如果有)。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您不需要在处理器执行完毕时调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\"\u003enext\u003c/a\u003e\u003c/code\u003e 。 您可以在之后需要的时间点调用它：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e);\nroute.handler(ctx -\u0026gt; {\n\n  HttpServerResponse response = ctx.response();\n  \u003cspan class=\"hljs-comment\"\u003e// 开启分块响应，因为我们将在执行其他处理器时添加数据\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 仅当有多个处理器输出时\u003c/span\u003e\n  response.setChunked(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n\n  response.write(\u003cspan class=\"hljs-string\"\u003e\"route1\\n\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 延迟5秒后调用下一匹配route\u003c/span\u003e\n  ctx.vertx().setTimer(\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e, tid -\u0026gt; ctx.next());\n});\n\nroute.handler(ctx -\u0026gt; {\n\n  HttpServerResponse response = ctx.response();\n  response.write(\u003cspan class=\"hljs-string\"\u003e\"route2\\n\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 延迟5秒后调用下一匹配route\u003c/span\u003e\n  ctx.vertx().setTimer(\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e, tid -\u0026gt; ctx.next());\n});\n\nroute.handler(ctx -\u0026gt; {\n\n  HttpServerResponse response = ctx.response();\n  response.write(\u003cspan class=\"hljs-string\"\u003e\"route3\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 现在结束响应\u003c/span\u003e\n  ctx.response().end();\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在上述的例子中， \u003ccode\u003eroute1\u003c/code\u003e 向响应里写入了数据， 5秒之后 \u003ccode\u003eroute2\u003c/code\u003e 向响应里写入了数据，再5秒之后 \u003ccode\u003eroute3\u003c/code\u003e 向响应里写入了数据并结束了响应。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n所有发生的这些没有线程阻塞。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_simple_responses\"\u003e\u003ca class=\"anchor\" href=\"#_simple_responses\"\u003e\u003c/a\u003e简单的响应\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e处理器非常强大， 因为它们允许您构建非常复杂的应用程序。 为了保证简单的响应，例如直接从vert.x API返回异步响应，router 包含一个快捷的处理器：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e响应返回JSON。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果处理过程中发生错误，一个适当的错误会返回。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果序列化JSON中发生错误，一个适当的错误会返回。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-comment\"\u003e// 这个处理器将保证这个响应会被序列化成json\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// content type被设置成 \"application/json\"\u003c/span\u003e\n  .respond(\n    ctx -\u0026gt; Future.succeededFuture(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"world\"\u003c/span\u003e)));\n\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-comment\"\u003e// 这个处理器将保证这个Pojo会被序列化成json\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// content type被设置成 \"application/json\"\u003c/span\u003e\n  .respond(\n    ctx -\u0026gt; Future.succeededFuture(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Pojo()));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e不过， 如果提供的函数支持调用 \u003ccode\u003ewrite\u003c/code\u003e 或 \u003ccode\u003eend\u003c/code\u003e ， 您还可以将其用于非JSON响应。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e)\n  .respond(\n    ctx -\u0026gt; ctx\n      .response()\n        .putHeader(\u003cspan class=\"hljs-string\"\u003e\"Content-Type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"text/plain\"\u003c/span\u003e)\n        .end(\u003cspan class=\"hljs-string\"\u003e\"hello world!\"\u003c/span\u003e));\n\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-comment\"\u003e// 在这种情况下，处理器确保连接被终止\u003c/span\u003e\n  .respond(\n    ctx -\u0026gt; ctx\n      .response()\n        .setChunked(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e)\n        .write(\u003cspan class=\"hljs-string\"\u003e\"Write some text...\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_using_blocking_handlers\"\u003e\u003ca class=\"anchor\" href=\"#_using_blocking_handlers\"\u003e\u003c/a\u003e使用阻塞式处理器\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e某些时候您可能需要在处理器里执行一些需要阻塞 Event Loop 的操作，比如调用某个传统的阻塞式 API 或者执行密集计算。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您不能在普通的处理器里执行这些操作， 因此我们提供了将route设置成阻塞式处理器的功能。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e阻塞式处理器和普通处理器很像， 区别是 Vert.x 会使用 Worker Pool 中的线程而不是 Event Loop 线程来处理请求。\n您可以使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-\"\u003eblockingHandler\u003c/a\u003e\u003c/code\u003e\n方法来建立阻塞式处理器。 以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().blockingHandler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 执行某些同步的耗时操作\u003c/span\u003e\n  service.doSomethingThatBlocks();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 调用下一个处理器\u003c/span\u003e\n  ctx.next();\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e默认情况下，在同一个 Context (例如同一个 Verticle 实例) 上执行的所有阻塞式处理器是顺序的， 也就意味着只有一个处理器执行完了才会继续执行下一个。 如果您不关心执行的顺序，并且不介意阻塞式处理器以并行的方式执行， 您可以在使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-boolean-\"\u003eblockingHandler\u003c/a\u003e\u003c/code\u003e 时，设置阻塞式处理器的 \u003ccode\u003eordered\u003c/code\u003e 为 false。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n如果您需要在一个阻塞处理器中处理一个 multipart 类型的表单数据，您需要首先使用一个非阻塞的处理器来调用 \u003ccode\u003esetExpectMultipart(true)\u003c/code\u003e 。以下是例子：\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.post(\u003cspan class=\"hljs-string\"\u003e\"/some/endpoint\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  ctx.request().setExpectMultipart(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n  ctx.next();\n}).blockingHandler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ... 执行某些阻塞操作\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_routing_by_exact_path\"\u003e\u003ca class=\"anchor\" href=\"#_routing_by_exact_path\"\u003e\u003c/a\u003e基于精确路径的路由\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e可以将 \u003ccode\u003eRoute\u003c/code\u003e 设置为根据需要所匹配的 URI。在这种情况下它只会匹配路径一致的请求。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在下面这个例子中，处理器会被路径为 \u003ccode\u003e/some/path/\u003c/code\u003e 的请求调用。我们会忽略结尾的 \u003ccode\u003e/\u003c/code\u003e ， 所以路径 \u003ccode\u003e/some/path\u003c/code\u003e 或者 \u003ccode\u003e/some/path//\u003c/code\u003e 的请求也是匹配的\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route().path(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e);\n\nroute.handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 这个处理器会被以下路径的请求调用：\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path/`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path//`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 但不包括:\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path` 路径末尾的斜线会被严格限制\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path/subdir`\u003c/span\u003e\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 路径结尾没有斜线的不会被严格限制\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 这意味着结尾的斜线是可选的\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 无论怎样都会匹配\u003c/span\u003e\nRoute route2 = router.route().path(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e);\n\nroute2.handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 这个处理器会被以下路径的请求调用：\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path/`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path//`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 但不包括:\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path/subdir`\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_routing_by_paths_that_begin_with_something\"\u003e\u003ca class=\"anchor\" href=\"#_routing_by_paths_that_begin_with_something\"\u003e\u003c/a\u003e基于路径前缀的路由\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您经常需要为所有以某些路径开始的请求设置 \u003ccode\u003eRoute\u003c/code\u003e 。 您可以使用正则表达式来实现， 但更简单的方式是在声明 \u003ccode\u003eRoute\u003c/code\u003e 的路径时使用一个 \u003ccode\u003e*\u003c/code\u003e 作为结尾。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在下面的例子中处理器会匹配所有 URI 以 \u003ccode\u003e/some/path\u003c/code\u003e 开头的请求。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e例如 \u003ccode\u003e/some/path/foo.html\u003c/code\u003e 和 \u003ccode\u003e/some/path/otherdir/blah.css\u003c/code\u003e 都会匹配。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route().path(\u003cspan class=\"hljs-string\"\u003e\"/some/path/*\"\u003c/span\u003e);\n\nroute.handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 这个处理器处理会被所有以 `/some/path/` 开头的请求调用， 例如：\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path/`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path/subdir`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path/subdir/blah.html`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 但不包括:\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/path` 这个路径被限制因为以斜线结尾\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// `/some/bath`\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e也可以在创建 \u003ccode\u003eRoute\u003c/code\u003e 的时候指定任意的路径：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/*\"\u003c/span\u003e);\n\nroute.handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 这个处理器的调用规则和上面的例子一样\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_capturing_path_parameters\"\u003e\u003ca class=\"anchor\" href=\"#_capturing_path_parameters\"\u003e\u003c/a\u003e捕捉路径参数\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e可以通过占位符声明路径参数并在处理请求时通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#pathParam-java.lang.String-\"\u003epathParam\u003c/a\u003e\u003c/code\u003e 。 方法获取\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是一个例子\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter\n  .route(HttpMethod.POST, \u003cspan class=\"hljs-string\"\u003e\"/catalogue/products/:productType/:productID/\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    String productType = ctx.pathParam(\u003cspan class=\"hljs-string\"\u003e\"productType\"\u003c/span\u003e);\n    String productID = ctx.pathParam(\u003cspan class=\"hljs-string\"\u003e\"productID\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 执行某些操作...\u003c/span\u003e\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e占位符由 \u003ccode\u003e:\u003c/code\u003e 和参数名构成. 参数名由字母， 数字和下划线构成。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在上面的例子中， 如果一个 POST 请求的路径为  \u003ccode\u003e/catalogue/products/tools/drill123/\u003c/code\u003e ， 那么会匹配这个 \u003ccode\u003eRoute\u003c/code\u003e ， 并且会接收参数 \u003ccode\u003eproductType\u003c/code\u003e 的值为 \u003ccode\u003etools\u003c/code\u003e ，参数 \u003ccode\u003eproductID\u003c/code\u003e 的值为 \u003ccode\u003edrill123\u003c/code\u003e 。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n您也可以将 * 捕获为路径参数 * 。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_routing_with_regular_expressions\"\u003e\u003ca class=\"anchor\" href=\"#_routing_with_regular_expressions\"\u003e\u003c/a\u003e基于正则表达式的路由\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e同样也可用正则表达式匹配路由的 URI 路径。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route().pathRegex(\u003cspan class=\"hljs-string\"\u003e\".*foo\"\u003c/span\u003e);\n\nroute.handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 以下路径的请求都会调用这个处理器：\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// /some/path/foo\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// /foo\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// /foo/bar/wibble/foo\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// /bar/foo\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 但不包括：\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// /bar/wibble\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e或者在创建 route 时指定正则表达式：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.routeWithRegex(\u003cspan class=\"hljs-string\"\u003e\".*foo\"\u003c/span\u003e);\n\nroute.handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 这个路由器的调用规则和上面的例子一样\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_capturing_path_parameters_with_regular_expressions\"\u003e\u003ca class=\"anchor\" href=\"#_capturing_path_parameters_with_regular_expressions\"\u003e\u003c/a\u003e通过正则表达式捕捉路径参数\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您也可以通过正则表达式声明捕捉路径参数，以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.routeWithRegex(\u003cspan class=\"hljs-string\"\u003e\".*foo\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 这个正则表达式可以匹配路径类似于：\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `/foo/bar` 的请求\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `foo` 可以通过参数 param0 获取，`bar` 可以通过参数 param1 获取\u003c/span\u003e\nroute.pathRegex(\u003cspan class=\"hljs-string\"\u003e\"\\\\/([^\\\\/]+)\\\\/([^\\\\/]+)\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  String productType = ctx.pathParam(\u003cspan class=\"hljs-string\"\u003e\"param0\"\u003c/span\u003e);\n  String productID = ctx.pathParam(\u003cspan class=\"hljs-string\"\u003e\"param1\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 执行某些操作……\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在上述的例子中，如果一个请求的路径为 \u003ccode\u003e/tools/drill123/\u003c/code\u003e，那么会匹配这个 \u003ccode\u003eroute\u003c/code\u003e，\n并且会接收到参数 \u003ccode\u003eproductType\u003c/code\u003e 的值为 \u003ccode\u003etools\u003c/code\u003e，参数 \u003ccode\u003eproductID\u003c/code\u003e 的值为 \u003ccode\u003edrill123\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e捕捉（译者注：这里指的是捕捉参数这一行为）在正则表达式中用捕捉组表示（即用圆括号括住捕捉）\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_using_named_capture_groups\"\u003e\u003ca class=\"anchor\" href=\"#_using_named_capture_groups\"\u003e\u003c/a\u003e使用命名的捕捉组\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e使用序号参数名在某些场景下可能会比较麻烦。\n亦可在正则表达式路径中使用命名的捕捉组。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter\n  .routeWithRegex(\u003cspan class=\"hljs-string\"\u003e\"\\\\/(?\u0026lt;productType\u0026gt;[^\\\\/]+)\\\\/(?\u0026lt;productID\u0026gt;[^\\\\/]+)\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    String productType = ctx.pathParam(\u003cspan class=\"hljs-string\"\u003e\"productType\"\u003c/span\u003e);\n    String productID = ctx.pathParam(\u003cspan class=\"hljs-string\"\u003e\"productID\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 执行某些操作……\u003c/span\u003e\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在上述的例子中，命名捕捉组将路径参数映射到同名的捕捉组中。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e此外，您仍可以使用普通捕捉组访问组参数（例如：\u003ccode\u003eparams0, params1\u0026#8230;\u0026#8203;\u003c/code\u003e）\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_routing_by_http_method\"\u003e\u003ca class=\"anchor\" href=\"#_routing_by_http_method\"\u003e\u003c/a\u003e基于 HTTP 方法的路由\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRoute 默认会匹配所有的 HTTP 方法。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果您只想让 route 匹配特定的 HTTP 方法，那么您可以使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-\"\u003emethod\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route().method(HttpMethod.POST);\n\nroute.handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 所有的 POST 请求都会调用这个处理器\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e或者您可以在创建 Route 时和路径一起指定：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route(HttpMethod.POST, \u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e);\n\nroute.handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 所有路径为 `/some/path/`\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 的 POST 请求都会调用这个处理器\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果您想让 Route 指定 HTTP 方法，您也可以使用对应的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Router.html#get--\"\u003eget\u003c/a\u003e\u003c/code\u003e，\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Router.html#post--\"\u003epost\u003c/a\u003e\u003c/code\u003e 以及 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Router.html#put--\"\u003eput\u003c/a\u003e\u003c/code\u003e 等方法。\n例如：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.get().handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 所有 GET 请求都会调用这个处理器\u003c/span\u003e\n\n});\n\nrouter.get(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 所有路径以 `/some/path/` 开始的\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// GET 请求都会调用这个处理器\u003c/span\u003e\n\n});\n\nrouter.getWithRegex(\u003cspan class=\"hljs-string\"\u003e\".*foo\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 所有路径以 `foo` 结尾的\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// GET 请求都会调用这个处理器\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果您想要让 route 匹配不止一个 HTTP 方法，\n您可多次调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-\"\u003emethod\u003c/a\u003e\u003c/code\u003e 方法：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route().method(HttpMethod.POST).method(HttpMethod.PUT);\n\nroute.handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 所有 GET 或 POST 请求都会调用这个处理器\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果您的应用程序需要自定义 HTTP 动词，例如，在一个 \u003ccode\u003e基于Web的分布式编写和版本控制（WebDAV）\u003c/code\u003e 服务器中，\n您可这样自定义动词：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.route()\n  .method(HttpMethod.valueOf(\u003cspan class=\"hljs-string\"\u003e\"MKCOL\"\u003c/span\u003e))\n  .handler(ctx -\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// 所有 MKCOL 请求都会调用这个处理器\u003c/span\u003e\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n请务必留意，像 rerouting 等特性不接受自定义 http 方法，\n这些操作在检测到自定义动词时将会使用 \u003ccode\u003eOTHER\u003c/code\u003e 值以替代自定义名。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_route_order\"\u003e\u003ca class=\"anchor\" href=\"#_route_order\"\u003e\u003c/a\u003eRoute order\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy default routes are matched in the order they are added to the router.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen a request arrives the router will step through each route and check if it matches, if it matches then\nthe handler for that route will be called.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf the handler subsequently calls \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\"\u003enext\u003c/a\u003e\u003c/code\u003e the handler for the next\nmatching route (if any) will be called. And so on.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example to illustrate this:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n    \u003cspan class=\"hljs-comment\"\u003e// enable chunked responses because we will be adding data as\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// we execute over other handlers. This is only required once and\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// only if several handlers do output.\u003c/span\u003e\n    response.setChunked(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n\n    response.write(\u003cspan class=\"hljs-string\"\u003e\"route1\\n\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// Now call the next matching route\u003c/span\u003e\n    ctx.next();\n  });\n\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(\u003cspan class=\"hljs-string\"\u003e\"route2\\n\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// Now call the next matching route\u003c/span\u003e\n    ctx.next();\n  });\n\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(\u003cspan class=\"hljs-string\"\u003e\"route3\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// Now end the response\u003c/span\u003e\n    ctx.response().end();\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn the above example the response will contain:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003eroute1\nroute2\nroute3\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAs the routes have been called in that order for any request that starts with \u003ccode\u003e/some/path\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you want to override the default ordering for routes, you can do so using \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#order-int-\"\u003eorder\u003c/a\u003e\u003c/code\u003e,\nspecifying an integer value.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRoutes are assigned an order at creation time corresponding to the order in which they were added to the router, with\nthe first route numbered \u003ccode\u003e0\u003c/code\u003e, the second route numbered \u003ccode\u003e1\u003c/code\u003e, and so on.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy specifying an order for the route you can override the default ordering. Order can also be negative, e.g. if you\nwant to ensure a route is evaluated before route number \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eLet\u0026#8217;s change the ordering of route2 so it runs before route1:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e)\n  .order(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(\u003cspan class=\"hljs-string\"\u003e\"route1\\n\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// Now call the next matching route\u003c/span\u003e\n    ctx.next();\n  });\n\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e)\n  .order(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n    \u003cspan class=\"hljs-comment\"\u003e// enable chunked responses because we will be adding data as\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// we execute over other handlers. This is only required once and\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// only if several handlers do output.\u003c/span\u003e\n    response.setChunked(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n\n    response.write(\u003cspan class=\"hljs-string\"\u003e\"route2\\n\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// Now call the next matching route\u003c/span\u003e\n    ctx.next();\n  });\n\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/some/path/\"\u003c/span\u003e)\n  .order(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(\u003cspan class=\"hljs-string\"\u003e\"route3\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// Now end the response\u003c/span\u003e\n    ctx.response().end();\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003ethen the response will now contain:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003eroute2\nroute1\nroute3\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf two matching routes have the same value of order, then they will be called in the order they were added.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can also specify that a route is handled last, with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#last--\"\u003elast\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\nRoute order can be specified only before you configure an handler!\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_routing_based_on_mime_type_of_request\"\u003e\u003ca class=\"anchor\" href=\"#_routing_based_on_mime_type_of_request\"\u003e\u003c/a\u003eRouting based on MIME type of request\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can specify that a route will match against matching request MIME types using \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-\"\u003econsumes\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn this case, the request will contain a \u003ccode\u003econtent-type\u003c/code\u003e header specifying the MIME type of the request body.\nThis will be matched against the value specified in \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-\"\u003econsumes\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBasically, \u003ccode\u003econsumes\u003c/code\u003e is describing which MIME types the handler can \u003cem\u003econsume\u003c/em\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMatching can be done on exact MIME type matches:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .consumes(\u003cspan class=\"hljs-string\"\u003e\"text/html\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    \u003cspan class=\"hljs-comment\"\u003e// This handler will be called for any request with\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// content-type header set to `text/html`\u003c/span\u003e\n\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMultiple exact matches can also be specified:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .consumes(\u003cspan class=\"hljs-string\"\u003e\"text/html\"\u003c/span\u003e)\n  .consumes(\u003cspan class=\"hljs-string\"\u003e\"text/plain\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    \u003cspan class=\"hljs-comment\"\u003e// This handler will be called for any request with\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// content-type header set to `text/html` or `text/plain`.\u003c/span\u003e\n\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMatching on wildcards for the sub-type is supported:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .consumes(\u003cspan class=\"hljs-string\"\u003e\"text/*\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    \u003cspan class=\"hljs-comment\"\u003e// This handler will be called for any request\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// with top level type `text` e.g. content-type\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// header set to `text/html` or `text/plain`\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// will both match\u003c/span\u003e\n\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAnd you can also match on the top level type\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .consumes(\u003cspan class=\"hljs-string\"\u003e\"*/json\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    \u003cspan class=\"hljs-comment\"\u003e// This handler will be called for any request with sub-type json\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// e.g. content-type header set to `text/json` or\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// `application/json` will both match\u003c/span\u003e\n\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you don\u0026#8217;t specify a \u003ccode\u003e/\u003c/code\u003e in the consumers, it will assume you meant the sub-type.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_routing_based_on_mime_types_acceptable_by_the_client\"\u003e\u003ca class=\"anchor\" href=\"#_routing_based_on_mime_types_acceptable_by_the_client\"\u003e\u003c/a\u003eRouting based on MIME types acceptable by the client\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe HTTP \u003ccode\u003eaccept\u003c/code\u003e header is used to signify which MIME types of the response are acceptable to the client.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAn \u003ccode\u003eaccept\u003c/code\u003e header can have multiple MIME types separated by \u0026#8216;,\u0026#8217;.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMIME types can also have a \u003ccode\u003eq\u003c/code\u003e value appended to them* which signifies a weighting to apply if more than one\nresponse MIME type is available matching the accept header. The q value is a number between 0 and 1.0.\nIf omitted it defaults to 1.0.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eFor example, the following \u003ccode\u003eaccept\u003c/code\u003e header signifies the client will accept a MIME type of only \u003ccode\u003etext/plain\u003c/code\u003e:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAccept: text/plain\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith the following the client will accept \u003ccode\u003etext/plain\u003c/code\u003e or \u003ccode\u003etext/html\u003c/code\u003e with no preference.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAccept: text/plain, text/html\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith the following the client will accept \u003ccode\u003etext/plain\u003c/code\u003e or \u003ccode\u003etext/html\u003c/code\u003e but prefers \u003ccode\u003etext/html\u003c/code\u003e as it has a higher\n\u003ccode\u003eq\u003c/code\u003e value (the default value is q=1.0)\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAccept: text/plain; q=0.9, text/html\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf the server can provide both text/plain and text/html it should provide the text/html in this case.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy using \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#produces-java.lang.String-\"\u003eproduces\u003c/a\u003e\u003c/code\u003e you define which MIME type(s) the route produces, e.g. the\nfollowing handler produces a response with MIME type \u003ccode\u003eapplication/json\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.putHeader(\u003cspan class=\"hljs-string\"\u003e\"content-type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e);\n    response.end(someJSON);\n\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn this case the route will match with any request with an \u003ccode\u003eaccept\u003c/code\u003e header that matches \u003ccode\u003eapplication/json\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere are some examples of \u003ccode\u003eaccept\u003c/code\u003e headers that will match:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAccept: application/json\nAccept: application/*\nAccept: application/json, text/html\nAccept: application/json;q=0.7, text/html;q=0.8, text/plain\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can also mark your route as producing more than one MIME type. If this is the case, then you use\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--\"\u003egetAcceptableContentType\u003c/a\u003e\u003c/code\u003e to find out the actual MIME type that\nwas accepted.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"text/html\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    HttpServerResponse response = ctx.response();\n\n    \u003cspan class=\"hljs-comment\"\u003e// Get the actual MIME type acceptable\u003c/span\u003e\n    String acceptableContentType = ctx.getAcceptableContentType();\n\n    response.putHeader(\u003cspan class=\"hljs-string\"\u003e\"content-type\"\u003c/span\u003e, acceptableContentType);\n    response.end(whatever);\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn the above example, if you sent a request with the following \u003ccode\u003eaccept\u003c/code\u003e header:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAccept: application/json; q=0.7, text/html\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThen the route would match and \u003ccode\u003eacceptableContentType\u003c/code\u003e would contain \u003ccode\u003etext/html\u003c/code\u003e as both are\nacceptable but that has a higher \u003ccode\u003eq\u003c/code\u003e value.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_routing_based_on_virtualhost\"\u003e\u003ca class=\"anchor\" href=\"#_routing_based_on_virtualhost\"\u003e\u003c/a\u003eRouting based on VirtualHost\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can configure that a \u003ccode\u003eRoute\u003c/code\u003e will match against the request hostname.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRequest are checked against the \u003ccode\u003eHost\u003c/code\u003e header to a match and patterns allow the usage of \u003ccode\u003e\u003cstrong\u003e\u003c/code\u003e wildcards, as for\nexample \u003ccode\u003e\u003c/strong\u003e.vertx.io\u003c/code\u003e or fully domain names as \u003ccode\u003ewww.vertx.io\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().virtualHost(\u003cspan class=\"hljs-string\"\u003e\"*.vertx.io\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do something if the request is for *.vertx.io\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_combining_routing_criteria\"\u003e\u003ca class=\"anchor\" href=\"#_combining_routing_criteria\"\u003e\u003c/a\u003eCombining routing criteria\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can combine all the above routing criteria in many different ways, for example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route(HttpMethod.PUT, \u003cspan class=\"hljs-string\"\u003e\"myapi/orders\"\u003c/span\u003e)\n  .consumes(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    \u003cspan class=\"hljs-comment\"\u003e// This would be match for any PUT method to paths starting\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// with \"myapi/orders\" with a content-type of \"application/json\"\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// and an accept header matching \"application/json\"\u003c/span\u003e\n\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_enabling_and_disabling_routes\"\u003e\u003ca class=\"anchor\" href=\"#_enabling_and_disabling_routes\"\u003e\u003c/a\u003eEnabling and disabling routes\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can disable a route with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#disable--\"\u003edisable\u003c/a\u003e\u003c/code\u003e. A disabled route will be ignored when matching.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can re-enable a disabled route with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Route.html#enable--\"\u003eenable\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_forward_support\"\u003e\u003ca class=\"anchor\" href=\"#_forward_support\"\u003e\u003c/a\u003eForward Support\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYour application may be behind a proxy server, \u003ccode\u003eHAProxy\u003c/code\u003e for example. When working under this setup accessing the\nclient connection details will not properly return the expected results. For example the client host ip address will\nbe the proxy server ip address, not the client\u0026#8217;s one.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn order to get the right connection information, a special header \u003ccode\u003eForward\u003c/code\u003e has been standardized to include the right\ninformation. However this standard is not very old, so many proxies out there have been using other headers that usually\nstart with the prefix: \u003ccode\u003eX-Forward\u003c/code\u003e. Vert.x web allows the usage and parsing of these headers but not by default.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe reason why these headers are disabled by default is to prevent malicious applications to forge their origin and hide\nwhere they are really coming from.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAs previously mentioned forward is disabled by default, to enable you should use:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.allowForward(AllowForwardHeaders.FORWARD);\n\n\u003cspan class=\"hljs-comment\"\u003e// we can now allow forward header parsing\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// and in this case only the \"X-Forward\" headers will be considered\u003c/span\u003e\nrouter.allowForward(AllowForwardHeaders.X_FORWARD);\n\n\u003cspan class=\"hljs-comment\"\u003e// we can now allow forward header parsing\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// and in this case both the \"Forward\" header and \"X-Forward\" headers\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// will be considered, yet the values from \"Forward\" take precedence\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// this means if case of a conflict (2 headers for the same value)\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// the \"Forward\" value will be taken and the \"X-Forward\" ignored.\u003c/span\u003e\nrouter.allowForward(AllowForwardHeaders.ALL);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSame rule applies to explicitly disable the parsing of the headers:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.allowForward(AllowForwardHeaders.NONE);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo read more about the format of the header format, please consult:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://tools.ietf.org/html/rfc7239#section-4\" class=\"bare\"\u003ehttps://tools.ietf.org/html/rfc7239#section-4\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded\" class=\"bare\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBehind the scenes, what this feature does is changing the following values of your connection (either HTTP or WebSocket):\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eprotocol\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehost name\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehost port\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_context_data\"\u003e\u003ca class=\"anchor\" href=\"#_context_data\"\u003e\u003c/a\u003eContext data\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can use the context data in the \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e to maintain any data that you\nwant to share between handlers for the lifetime of the request.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example where one handler sets some data in the context data and a subsequent handler retrieves it:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can use the \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#put-java.lang.String-java.lang.Object-\"\u003eput\u003c/a\u003e\u003c/code\u003e to put any object, and\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#get-java.lang.String-\"\u003eget\u003c/a\u003e\u003c/code\u003e to retrieve any object from the context data.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eA request sent to path \u003ccode\u003e/some/path/other\u003c/code\u003e will match both routes.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.get(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  ctx.put(\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"bar\"\u003c/span\u003e);\n  ctx.next();\n\n});\n\nrouter.get(\u003cspan class=\"hljs-string\"\u003e\"/some/path/other\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  String bar = ctx.get(\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// Do something with bar\u003c/span\u003e\n  ctx.response().end();\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAlternatively you can access the entire context data map with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#data--\"\u003edata\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_helper_functions\"\u003e\u003ca class=\"anchor\" href=\"#_helper_functions\"\u003e\u003c/a\u003eHelper functions\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhile the routing context will allow you to access the underlying request and response objects, sometimes it will be\nmore productive if a few shortcuts would be present to help with common tasks. A few helpers are present in the context\nto facilitate with this task.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eServe an \"attachment\", an attachment is a response that will trigger the browser to open the response on the OS\napplication configured to handle a specific mime type. Imagine you\u0026#8217;re generating a PDF:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ectx\n  .attachment(\u003cspan class=\"hljs-string\"\u003e\"weekly-report.pdf\"\u003c/span\u003e)\n  .end(pdfBuffer);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003ePerform a redirect to a different page or host. One example is to redirect to an HTTPS variant of the application:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ectx.redirect(\u003cspan class=\"hljs-string\"\u003e\"https://securesite.com/\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// there is a special handling for the target \"back\".\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// In this case the redirect would send the user to the\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// referrer url or \"/\" if there's no referrer.\u003c/span\u003e\n\nctx.redirect(\u003cspan class=\"hljs-string\"\u003e\"back\"\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSend a JSON response to the client:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ectx.json(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"vert.x\"\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// also applies to arrays\u003c/span\u003e\nctx.json(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonArray().add(\u003cspan class=\"hljs-string\"\u003e\"vertx\"\u003c/span\u003e).add(\u003cspan class=\"hljs-string\"\u003e\"web\"\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// or any object that will be converted according\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// to the json encoder available at runtime.\u003c/span\u003e\nctx.json(someObject);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSimple content type check:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ectx.is(\u003cspan class=\"hljs-string\"\u003e\"html\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// =\u0026gt; true\u003c/span\u003e\nctx.is(\u003cspan class=\"hljs-string\"\u003e\"text/html\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// =\u0026gt; true\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// When Content-Type is application/json\u003c/span\u003e\nctx.is(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// =\u0026gt; true\u003c/span\u003e\nctx.is(\u003cspan class=\"hljs-string\"\u003e\"html\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// =\u0026gt; false\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVerify if a request is \"fresh\" with respect to the cache headers and the current values of last modified/ etag.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ectx.lastModified(\u003cspan class=\"hljs-string\"\u003e\"Wed, 13 Jul 2011 18:30:00 GMT\"\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// this will now be used to verify the freshness of the request\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.isFresh()) {\n  \u003cspan class=\"hljs-comment\"\u003e// client cache value is fresh perhaps we\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// can stop and return 304?\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAnd a few other simple self explanatory shortcuts:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ectx.etag(\u003cspan class=\"hljs-string\"\u003e\"W/123456789\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// set the last modified value\u003c/span\u003e\nctx.lastModified(\u003cspan class=\"hljs-string\"\u003e\"Wed, 13 Jul 2011 18:30:00 GMT\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// quickly end\u003c/span\u003e\nctx.end();\nctx.end(\u003cspan class=\"hljs-string\"\u003e\"body\"\u003c/span\u003e);\nctx.end(buffer);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_reroute\"\u003e\u003ca class=\"anchor\" href=\"#_reroute\"\u003e\u003c/a\u003eReroute\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eUntil now all routing mechanism allow you to handle your requests in a sequential way, however there might be times\nwhere you will want to go back. Since the context does not expose any information about the previous or next handler,\nmostly because this information is dynamic there is a way to restart the whole routing from the start of the current\nRouter.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.get(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  ctx.put(\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"bar\"\u003c/span\u003e);\n  ctx.next();\n\n});\n\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/some/path/B\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; ctx.response().end());\n\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/some/path\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; ctx.reroute(\u003cspan class=\"hljs-string\"\u003e\"/some/path/B\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSo from the code you can see that if a request arrives at \u003ccode\u003e/some/path\u003c/code\u003e if first add a value to the context, then\nmoves to the next handler that re routes the request to \u003ccode\u003e/some/path/B\u003c/code\u003e which terminates the request.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can reroute based on a new path or based on a new path and method. Note however that rerouting based on method\nmight introduce security issues since for example a usually safe GET request can become a DELETE.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eReroute is also allowed on the failure handler, however due to the nature of re router when called the current status\ncode and failure reason are reset. In order the rerouted handler should generate the correct status code if needed,\nfor example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.get(\u003cspan class=\"hljs-string\"\u003e\"/my-pretty-notfound-handler\"\u003c/span\u003e).handler(ctx -\u0026gt; ctx.response()\n  .setStatusCode(\u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e)\n  .end(\u003cspan class=\"hljs-string\"\u003e\"NOT FOUND fancy html here!!!\"\u003c/span\u003e));\n\nrouter.get().failureHandler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.statusCode() == \u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e) {\n    ctx.reroute(\u003cspan class=\"hljs-string\"\u003e\"/my-pretty-notfound-handler\"\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    ctx.next();\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIt should be clear that reroute works on \u003ccode\u003epaths\u003c/code\u003e, so if you need to preserve and or add state across reroutes, one\nshould use the \u003ccode\u003eRoutingContext\u003c/code\u003e object. For example you want to reroute to a new path with a extra parameter:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.get(\u003cspan class=\"hljs-string\"\u003e\"/final-target\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// continue from here...\u003c/span\u003e\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// (Will reroute to /final-target including the query string)\u003c/span\u003e\nrouter.get().handler(ctx -\u0026gt; ctx.reroute(\u003cspan class=\"hljs-string\"\u003e\"/final-target?variable=value\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// A safer way would be to add the variable to the context\u003c/span\u003e\nrouter.get().handler(ctx -\u0026gt; ctx\n  .put(\u003cspan class=\"hljs-string\"\u003e\"variable\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e)\n  .reroute(\u003cspan class=\"hljs-string\"\u003e\"/final-target\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eReroute will re-parse the query params too. Be aware that previously query params will be discarded. The method\nwill also silently discard and ignore any html fragment from the path. This is to keep the semantics of reroute\nconsistent between a regular request and a re route.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf more information is required to be passed to the new request, it should use the context that is preserved all the\nlifetime of the HTTP transaction.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_sub_routers\"\u003e\u003ca class=\"anchor\" href=\"#_sub_routers\"\u003e\u003c/a\u003eSub-routers\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSometimes if you have a lot of handlers it can make sense to split them up into multiple routers. This is also useful\nif you want to reuse a set of handlers in a different application, rooted at a different path root.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo do this you can mount a router at a \u003cem\u003emount point\u003c/em\u003e in another router. The router that is mounted is called a\n\u003cem\u003esub-router\u003c/em\u003e. Sub routers can mount other sub routers so you can have several levels of sub-routers if you like.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eLet\u0026#8217;s look at a simple example of a sub-router mounted with another router.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis sub-router will maintain the set of handlers that corresponds to a simple fictional REST API. We will mount that on another\nrouter. The full implementation of the REST API is not shown.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s the sub-router:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter restAPI = Router.router(vertx);\n\nrestAPI.get(\u003cspan class=\"hljs-string\"\u003e\"/products/:productID\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// TODO Handle the lookup of the product....\u003c/span\u003e\n  ctx.response().write(productJSON);\n\n});\n\nrestAPI.put(\u003cspan class=\"hljs-string\"\u003e\"/products/:productID\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// TODO Add a new product...\u003c/span\u003e\n  ctx.response().end();\n\n});\n\nrestAPI.delete(\u003cspan class=\"hljs-string\"\u003e\"/products/:productID\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// TODO delete the product...\u003c/span\u003e\n  ctx.response().end();\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf this router was used as a top level router, then GET/PUT/DELETE requests to urls like \u003ccode\u003e/products/product1234\u003c/code\u003e\nwould invoke the  API.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHowever, let\u0026#8217;s say we already have a web-site as described by another router:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter mainRouter = Router.router(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// Handle static resources\u003c/span\u003e\nmainRouter.route(\u003cspan class=\"hljs-string\"\u003e\"/static/*\"\u003c/span\u003e).handler(myStaticHandler);\n\nmainRouter.route(\u003cspan class=\"hljs-string\"\u003e\".*\\\\.templ\"\u003c/span\u003e).handler(myTemplateHandler);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWe can now mount the sub router on the main router, against a mount point, in this case \u003ccode\u003e/productsAPI\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003emainRouter.mountSubRouter(\u003cspan class=\"hljs-string\"\u003e\"/productsAPI\"\u003c/span\u003e, restAPI);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis means the REST API is now accessible via paths like: \u003ccode\u003e/productsAPI/products/product1234\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThere are a couple of rules that must be fulfilled before sub routers can be used:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe route path must end with a wild card\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eParameters are allowed but full regex patterns not\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOnly 1 handler can be registered before or after this call (but they can on a new route object for the same path)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOnly 1 router per path object\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eValidation happens at the time the router is added to the http server. This means that you cannot get any validation\nerror during the build time because of the dynamic nature of sub routers. They depend on the context to be validated.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_localization\"\u003e\u003ca class=\"anchor\" href=\"#_localization\"\u003e\u003c/a\u003eLocalization\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web parses the \u003ccode\u003eAccept-Language\u003c/code\u003e header and provides some helper methods to identify which is the preferred\nlocale for a client or the sorted list of preferred locales by quality.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.get(\u003cspan class=\"hljs-string\"\u003e\"/localized\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// although it might seem strange by running a loop with a switch we\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// make sure that the locale order of preference is preserved when\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// replying in the users language.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (LanguageHeader language : ctx.acceptableLanguages()) {\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (language.tag()) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"en\"\u003c/span\u003e:\n        ctx.response().end(\u003cspan class=\"hljs-string\"\u003e\"Hello!\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"fr\"\u003c/span\u003e:\n        ctx.response().end(\u003cspan class=\"hljs-string\"\u003e\"Bonjour!\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"pt\"\u003c/span\u003e:\n        ctx.response().end(\u003cspan class=\"hljs-string\"\u003e\"Olá!\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"es\"\u003c/span\u003e:\n        ctx.response().end(\u003cspan class=\"hljs-string\"\u003e\"Hola!\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// we do not know the user language so lets just inform that back:\u003c/span\u003e\n  ctx.response().end(\u003cspan class=\"hljs-string\"\u003e\"Sorry we don't speak: \"\u003c/span\u003e + ctx.preferredLanguage());\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe main method \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#acceptableLanguages--\"\u003eacceptableLanguages\u003c/a\u003e\u003c/code\u003e will return the ordered list of locales the\nuser understands, if you\u0026#8217;re only interested in the user prefered locale then the helper:\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#preferredLanguage--\"\u003epreferredLanguage\u003c/a\u003e\u003c/code\u003e will return the 1st element of the list or \u003ccode\u003enull\u003c/code\u003e if no\nlocale was provided by the user.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_route_match_failures\"\u003e\u003ca class=\"anchor\" href=\"#_route_match_failures\"\u003e\u003c/a\u003eRoute match failures\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf no routes match for any particular request, Vert.x-Web will signal an error depending on match failure:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e404 If no route matches the path\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e405 If a route matches the path but don\u0026#8217;t match the HTTP Method\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e406 If a route matches the path and the method but It can\u0026#8217;t provide a response with a content type matching \u003ccode\u003eAccept\u003c/code\u003e header\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e415 If a route matches the path and the method but It can\u0026#8217;t accept the \u003ccode\u003eContent-type\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e400 If a route matches the path and the method but It can\u0026#8217;t accept an empty body\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can manually manage those failures using \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\"\u003eerrorHandler\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_error_handling\"\u003e\u003ca class=\"anchor\" href=\"#_error_handling\"\u003e\u003c/a\u003eError handling\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAs well as setting handlers to handle requests you can also set handlers to handle failures in routing.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eFailure handlers are used with the exact same route matching criteria that you use with normal handlers.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eFor example you can provide a failure handler that will only handle failures on certain paths, or for certain HTTP methods.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis allows you to set different failure handlers for different parts of your application.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example failure handler that will only be called for failure that occur when routing to GET requests\nto paths that start with \u003ccode\u003e/somepath/\u003c/code\u003e:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route = router.get(\u003cspan class=\"hljs-string\"\u003e\"/somepath/*\"\u003c/span\u003e);\n\nroute.failureHandler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// This will be called for failures that occur\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// when routing requests to paths starting with\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// '/somepath/'\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eFailure routing will occur if a handler throws an exception, or if a handler calls\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#fail-int-\"\u003efail\u003c/a\u003e\u003c/code\u003e specifying an HTTP status code to deliberately signal a failure.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf an exception is caught from a handler this will result in a failure with status code \u003ccode\u003e500\u003c/code\u003e being signalled.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen handling the failure, the failure handler is passed the routing context which also allows the failure or failure code\nto be retrieved so the failure handler can use that to generate a failure response.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRoute route1 = router.get(\u003cspan class=\"hljs-string\"\u003e\"/somepath/path1/\"\u003c/span\u003e);\n\nroute1.handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// Let's say this throws a RuntimeException\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RuntimeException(\u003cspan class=\"hljs-string\"\u003e\"something happened!\"\u003c/span\u003e);\n\n});\n\nRoute route2 = router.get(\u003cspan class=\"hljs-string\"\u003e\"/somepath/path2\"\u003c/span\u003e);\n\nroute2.handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// This one deliberately fails the request passing in the status code\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// E.g. 403 - Forbidden\u003c/span\u003e\n  ctx.fail(\u003cspan class=\"hljs-number\"\u003e403\u003c/span\u003e);\n\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// Define a failure handler\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// This will get called for any failures in the above handlers\u003c/span\u003e\nRoute route3 = router.get(\u003cspan class=\"hljs-string\"\u003e\"/somepath/*\"\u003c/span\u003e);\n\nroute3.failureHandler(failureRoutingContext -\u0026gt; {\n\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e statusCode = failureRoutingContext.statusCode();\n\n  \u003cspan class=\"hljs-comment\"\u003e// Status code will be 500 for the RuntimeException\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// or 403 for the other failure\u003c/span\u003e\n  HttpServerResponse response = failureRoutingContext.response();\n  response.setStatusCode(statusCode).end(\u003cspan class=\"hljs-string\"\u003e\"Sorry! Not today\"\u003c/span\u003e);\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eFor the eventuality that an error occurs when running the error handler related usage of not allowed characters in\nstatus message header, then the original status message will be changed to the default message from the error code.\nThis is a tradeoff to keep the semantics of the HTTP protocol working instead of abruptly creash and close the socket\nwithout properly completing the protocol.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_request_body_handling\"\u003e\u003ca class=\"anchor\" href=\"#_request_body_handling\"\u003e\u003c/a\u003eRequest body handling\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\"\u003eBodyHandler\u003c/a\u003e\u003c/code\u003e allows you to retrieve request bodies, limit body sizes and handle\nfile uploads.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou should make sure a body handler is on a matching route for any requests that require this functionality.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe usage of this handler requires that it is installed as soon as possible in the router since it needs\nto install handlers to consume the HTTP request body and this must be done before executing any async call.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(BodyHandler.create());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf an async call is required before, the \u003ccode\u003eHttpServerRequest\u003c/code\u003e should be paused and then resumed so that the request\nevents are not delivered until the body handler is ready to process them.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(ctx -\u0026gt; {\n\n  HttpServerRequest request = ctx.request();\n\n  \u003cspan class=\"hljs-comment\"\u003e// Pause the request\u003c/span\u003e\n  request.pause();\n\n  someAsyncCall(result -\u0026gt; {\n\n    \u003cspan class=\"hljs-comment\"\u003e// Resume the request\u003c/span\u003e\n    request.resume();\n\n    \u003cspan class=\"hljs-comment\"\u003e// And continue processing\u003c/span\u003e\n    ctx.next();\n  });\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// This body handler will be called for all routes\u003c/span\u003e\nrouter.route().handler(BodyHandler.create());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\nUploads can be a source of DDoS attacks, in order to reduce the attack surface, it is recommended to\nset sensible limits on \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-\"\u003esetBodyLimit\u003c/a\u003e\u003c/code\u003e (e.g.: 10mb for general uploads or\n100kb for JSON).\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_getting_the_request_body\"\u003e\u003ca class=\"anchor\" href=\"#_getting_the_request_body\"\u003e\u003c/a\u003eGetting the request body\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you know the request body is JSON, then you can use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsJson-int-\"\u003egetBodyAsJson\u003c/a\u003e\u003c/code\u003e,\nif you know it\u0026#8217;s a string you can use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsString--\"\u003egetBodyAsString\u003c/a\u003e\u003c/code\u003e, or to\nretrieve it as a buffer use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBody--\"\u003egetBody\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_limiting_body_size\"\u003e\u003ca class=\"anchor\" href=\"#_limiting_body_size\"\u003e\u003c/a\u003eLimiting body size\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo limit the size of a request body, create the body handler then use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-\"\u003esetBodyLimit\u003c/a\u003e\u003c/code\u003e\nto specifying the maximum body size, in bytes. This is useful to avoid running out of memory with very large bodies.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf an attempt to send a body greater than the maximum size is made, an HTTP status code of 413 - \u003ccode\u003eRequest Entity Too Large\u003c/code\u003e,\nwill be sent.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThere is no body limit by default.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_merging_form_attributes\"\u003e\u003ca class=\"anchor\" href=\"#_merging_form_attributes\"\u003e\u003c/a\u003eMerging form attributes\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy default, the body handler will merge any form attributes into the request parameters. If you don\u0026#8217;t want this behaviour\nyou can use disable it with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setMergeFormAttributes-boolean-\"\u003esetMergeFormAttributes\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_handling_file_uploads\"\u003e\u003ca class=\"anchor\" href=\"#_handling_file_uploads\"\u003e\u003c/a\u003eHandling file uploads\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBody handler is also used to handle multi-part file uploads.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf a body handler is on a matching route for the request, any file uploads will be automatically streamed to the\nuploads directory, which is \u003ccode\u003efile-uploads\u003c/code\u003e by default.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eEach file will be given an automatically generated file name, and the file uploads will be available on the routing\ncontext with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#fileUploads--\"\u003efileUploads\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(BodyHandler.create());\n\nrouter.post(\u003cspan class=\"hljs-string\"\u003e\"/some/path/uploads\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  Set\u0026lt;FileUpload\u0026gt; uploads = ctx.fileUploads();\n  \u003cspan class=\"hljs-comment\"\u003e// Do something with uploads....\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eEach file upload is described by a \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/FileUpload.html\"\u003eFileUpload\u003c/a\u003e\u003c/code\u003e instance, which allows various properties\nsuch as the name, file-name and size to be accessed.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_handling_cookies\"\u003e\u003ca class=\"anchor\" href=\"#_handling_cookies\"\u003e\u003c/a\u003eHandling cookies\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web has out of the box cookies support.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_manipulating_cookies\"\u003e\u003ca class=\"anchor\" href=\"#_manipulating_cookies\"\u003e\u003c/a\u003eManipulating cookies\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getCookie-java.lang.String-\"\u003egetCookie\u003c/a\u003e\u003c/code\u003e to retrieve\na cookie by name, or use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#cookieMap--\"\u003ecookieMap\u003c/a\u003e\u003c/code\u003e to retrieve the entire set.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo remove a cookie, use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#removeCookie-java.lang.String-\"\u003eremoveCookie\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo add a cookie use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#addCookie-io.vertx.core.http.Cookie-\"\u003eaddCookie\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe set of cookies will be written back in the response automatically when the response headers are written so the\nbrowser can store them.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eCookies are described by instances of \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/http/Cookie.html\"\u003eCookie\u003c/a\u003e\u003c/code\u003e. This allows you to retrieve the name,\nvalue, domain, path and other normal cookie properties.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example of querying and adding cookies:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eCookie someCookie = ctx.getCookie(\u003cspan class=\"hljs-string\"\u003e\"mycookie\"\u003c/span\u003e);\nString cookieValue = someCookie.getValue();\n\n\u003cspan class=\"hljs-comment\"\u003e// Do something with cookie...\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// Add a cookie - this will get written back in the response automatically\u003c/span\u003e\nctx.addCookie(Cookie.cookie(\u003cspan class=\"hljs-string\"\u003e\"othercookie\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"somevalue\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_handling_sessions\"\u003e\u003ca class=\"anchor\" href=\"#_handling_sessions\"\u003e\u003c/a\u003eHandling sessions\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web provides out of the box support for sessions.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSessions last between HTTP requests for the length of a browser session and give you a place where you can add\nsession-scope information, such as a shopping basket.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web uses session cookies to identify a session. The session cookie is temporary and will be deleted by your browser\nwhen it\u0026#8217;s closed.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWe don\u0026#8217;t put the actual data of your session in the session cookie - the cookie simply uses an identifier to look-up\nthe actual session on the server. The identifier is a random UUID generated using a secure random, so it should\nbe effectively unguessable.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eCookies are passed across the wire in HTTP requests and responses so it\u0026#8217;s always wise to make sure you are using\nHTTPS when sessions are being used. Vert.x will warn you if you attempt to use sessions over straight HTTP.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo enable sessions in your application you must have a \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/SessionHandler.html\"\u003eSessionHandler\u003c/a\u003e\u003c/code\u003e\non a matching route before your application logic.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe session handler handles the creation of session cookies and the lookup of the session so you don\u0026#8217;t have to do\nthat yourself.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSessions data is saved to a session store automatically after the response headers have been sent to the client.\nBut note that, with this mechanism, there is no guarantee the data is fully persisted before the client receives the response.\nThere are occasions though when this guarantee is needed.\nIn this case you can force a flush.\nThis will disable the automatic saving process, unless the flushing operation failed.\nThis allows to control the state before completing the response like:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eChainAuthHandler chain =\n  ChainAuthHandler.any()\n    .add(authNHandlerA)\n    .add(ChainAuthHandler.all()\n      .add(authNHandlerB)\n      .add(authNHandlerC));\n\n\u003cspan class=\"hljs-comment\"\u003e// secure your route\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/secure/resource\"\u003c/span\u003e).handler(chain);\n\u003cspan class=\"hljs-comment\"\u003e// your app\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/secure/resource\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do something...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Session Handler state by default uses a cookie to store session ID. Session ID is a unique string, used to\nrecognize individual visitor between visits. But, if client\u0026#8217;s web browser doesn\u0026#8217;t support cookies or visitor has\ndisabled cookies in web browser\u0026#8217;s settings, we can\u0026#8217;t store session id on client\u0026#8217;s machine. In this case, new session\nwill be created for every request. This behavior is useless because we can\u0026#8217;t remember information for certain visitor\nbetween two requests. We can say that, by default, sessions can\u0026#8217;t work if browser doesn\u0026#8217;t support cookies.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web supports sessions without cookies, known as \"cookieless\" sessions. As an alternative, Vert.x Web can embed\nsession id inside of page URL. On this way, all page links will contain session id string. When visitor clicks on some\nof these links, it will read session id from page URL, so we don\u0026#8217;t need cookies support to have functional sessions.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo enable cookieless sessions:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .handler(SessionHandler.create(store).setCookieless(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIt is important to know that in this mode the session ID should be passed by the application to the end user, usually by\nrendering it on the HTML page or script. There are some important rules. The session id is identified by the following\npattern on the path \u003ccode\u003e/optional/path/prefix/'('sessionId')'/path/suffix\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAs an example, given the path: \u003ccode\u003e\u003ca href=\"http://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/\" class=\"bare\"\u003ehttp://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/\u003c/a\u003e\u003c/code\u003e the session Id will\nbe: \u003ccode\u003e3abhbgwjg33aqrt3uat2kh4d\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMain security problem when working with sessions is a possibility that malicious user will find out others' session id.\nIf two users share same session id, they share same session variables too and website is considering them as one\nvisitor. This could be a security risk if session is used for any private or sensitive data, or to allow access to\nrestricted areas of web site. When cookies are used, session id can be protected using SSL and by marking a cookie as\nsecure. But, in case of cookieless session, session id is part of URL and is much more vulnerable.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_session_stores\"\u003e\u003ca class=\"anchor\" href=\"#_session_stores\"\u003e\u003c/a\u003eSession stores\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo create a session handler you need to have a session store instance. The session store is the object that\nholds the actual sessions for your application.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe session store is responsible for holding a secure pseudo random number generator in order to guarantee secure session\nids. This PRNG is independent of the store which means that given a session id from store A one cannot derive the\nsession id of store B since they have different seeds and states.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy default this PRNG uses a mixed mode, blocking for seeding, non blocking for generating. The PRNG will also reseed\nevery 5 minutes with 64bits of new entropy. However this can all be configured using the system properties:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eio.vertx.ext.auth.prng.algorithm e.g.: SHA1PRNG\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eio.vertx.ext.auth.prng.seed.interval e.g.: 1000 (every second)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eio.vertx.ext.auth.prng.seed.bits e.g.: 128\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMost users should not need to configure these values unless if you notice that the performance of your application is\nbeing affected by the PRNG algorithm.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web comes with two session store implementations out of the box, and you can also write your own if you prefer.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe implementations are expected to follow the \u003ccode\u003eServiceLoader\u003c/code\u003e conventions and all stores that are available at runtime\nfrom the classpath will be exposed. When more than 1 implementations are available the first one that can be\ninstantiated and configured with success becomes the default. If none is available, then the default depends on the mode\nVert.x was created. If cluster mode is available the the clustered session store is the default otherwise the local\nstorage is the default.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_local_session_store\"\u003e\u003ca class=\"anchor\" href=\"#_local_session_store\"\u003e\u003c/a\u003eLocal session store\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith this store, sessions are stored locally in memory and only available in this instance.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis store is appropriate if you have just a single Vert.x instance of you are using sticky sessions in your application\nand have configured your load balancer to always route HTTP requests to the same Vert.x instance.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you can\u0026#8217;t ensure your requests will all terminate on the same server then don\u0026#8217;t use this store as your\nrequests might end up on a server which doesn\u0026#8217;t know about your session.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eLocal session stores are implemented by using a shared local map, and have a reaper which clears out expired sessions.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe reaper interval can be configured with a json message with the key: \u003ccode\u003ereaperInterval\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere are some examples of creating a local \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/sstore/SessionStore.html\"\u003eSessionStore\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eSessionStore store1 = LocalSessionStore.create(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// Create a local session store specifying the local shared map name to use\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// This might be useful if you have more than one application in the same\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Vert.x instance and want to use different maps for different applications\u003c/span\u003e\nSessionStore store2 = LocalSessionStore.create(\n  vertx,\n  \u003cspan class=\"hljs-string\"\u003e\"myapp3.sessionmap\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// Create a local session store specifying the local shared map name to use and\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// setting the reaper interval for expired sessions to 10 seconds\u003c/span\u003e\nSessionStore store3 = LocalSessionStore.create(\n  vertx,\n  \u003cspan class=\"hljs-string\"\u003e\"myapp3.sessionmap\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-number\"\u003e10000\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_clustered_session_store\"\u003e\u003ca class=\"anchor\" href=\"#_clustered_session_store\"\u003e\u003c/a\u003eClustered session store\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith this store, sessions are stored in a distributed map which is accessible across the Vert.x cluster.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis store is appropriate if you\u0026#8217;re \u003cem\u003enot\u003c/em\u003e using sticky sessions, i.e. your load balancer is distributing different\nrequests from the same browser to different servers.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYour session is accessible from any node in the cluster using this store.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo you use a clustered session store you should make sure your Vert.x instance is clustered.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere are some examples of creating a clustered \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/sstore/SessionStore.html\"\u003eSessionStore\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eVertx.clusteredVertx(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VertxOptions(), res -\u0026gt; {\n\n  Vertx vertx = res.result();\n\n  \u003cspan class=\"hljs-comment\"\u003e// Create a clustered session store using defaults\u003c/span\u003e\n  SessionStore store1 = ClusteredSessionStore.create(vertx);\n\n  \u003cspan class=\"hljs-comment\"\u003e// Create a clustered session store specifying the distributed map name to use\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// This might be useful if you have more than one application in the cluster\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// and want to use different maps for different applications\u003c/span\u003e\n  SessionStore store2 = ClusteredSessionStore.create(\n    vertx,\n    \u003cspan class=\"hljs-string\"\u003e\"myclusteredapp3.sessionmap\"\u003c/span\u003e);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_other_stores\"\u003e\u003ca class=\"anchor\" href=\"#_other_stores\"\u003e\u003c/a\u003eOther stores\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eOther stores are also available, these stores can be used by importing the correct jar\nto the project. One example of such stores is the cookie store. This store has the advantage\nthat it requires no backend or server side state, which can be useful it some situations\n\u003cstrong\u003eBUT\u003c/strong\u003e all session data will be sent back to the client in the Cookie, so if you need to store\nprivate information this should not be used.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis store is appropriate if you\u0026#8217;re using sticky sessions, i.e. your load balancer is\ndistributing different requests from the same browser to different servers.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAs the session is stored in the Cookie, this means sessions survive server crashes too.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eA second known implementation is the Redis session store. This store works just like the normal cluster store, however\njust like it\u0026#8217;s name suggests, it uses a redis backend to keep the session data centralized.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThese stores are available with the coordinates:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003egroupId: \u003ccode\u003eio.vertx\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eartifactId: \u003ccode\u003evertx-web-sstore-{cookie|redis}\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_creating_the_session_handler\"\u003e\u003ca class=\"anchor\" href=\"#_creating_the_session_handler\"\u003e\u003c/a\u003eCreating the session handler\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eOnce you\u0026#8217;ve created a session store you can create a session handler, and add it to a route. You should make sure\nyour session handler is routed to before your application handlers.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// Create a clustered session store using defaults\u003c/span\u003e\nSessionStore store = ClusteredSessionStore.create(vertx);\n\nSessionHandler sessionHandler = SessionHandler.create(store);\n\n\u003cspan class=\"hljs-comment\"\u003e// the session handler controls the cookie used for the session\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// this includes configuring, for example, the same site policy\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// like this, for strict same site policy.\u003c/span\u003e\nsessionHandler.setCookieSameSite(CookieSameSite.STRICT);\n\n\u003cspan class=\"hljs-comment\"\u003e// Make sure all requests are routed through the session handler too\u003c/span\u003e\nrouter.route().handler(sessionHandler);\n\n\u003cspan class=\"hljs-comment\"\u003e// Now your application handlers\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/somepath/blah/\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  Session session = ctx.session();\n  session.put(\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"bar\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// etc\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe session handler will ensure that your session is automatically looked up (or created if no session exists)\nfrom the session store and set on the routing context before it gets to your application handlers.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_using_the_session\"\u003e\u003ca class=\"anchor\" href=\"#_using_the_session\"\u003e\u003c/a\u003eUsing the session\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn your handlers you can access the session instance with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#session--\"\u003esession\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou put data into the session with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Session.html#put-java.lang.String-java.lang.Object-\"\u003eput\u003c/a\u003e\u003c/code\u003e,\nyou get data from the session with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Session.html#get-java.lang.String-\"\u003eget\u003c/a\u003e\u003c/code\u003e, and you remove\ndata from the session with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Session.html#remove-java.lang.String-\"\u003eremove\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe keys for items in the session are always strings. The values can be any type for a local session store, and for\na clustered session store they can be any basic type, or \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\"\u003eBuffer\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/json/JsonObject.html\"\u003eJsonObject\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/json/JsonArray.html\"\u003eJsonArray\u003c/a\u003e\u003c/code\u003e or a serializable object, as the values have to serialized across the cluster.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example of manipulating session data:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(sessionHandler);\n\n\u003cspan class=\"hljs-comment\"\u003e// Now your application handlers\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/somepath/blah\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  Session session = ctx.session();\n\n  \u003cspan class=\"hljs-comment\"\u003e// Put some data from the session\u003c/span\u003e\n  session.put(\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"bar\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// Retrieve some data from a session\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e age = session.get(\u003cspan class=\"hljs-string\"\u003e\"age\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// Remove some data from a session\u003c/span\u003e\n  JsonObject obj = session.remove(\u003cspan class=\"hljs-string\"\u003e\"myobj\"\u003c/span\u003e);\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSessions are automatically written back to the store after after responses are complete.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can manually destroy a session using \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Session.html#destroy--\"\u003edestroy\u003c/a\u003e\u003c/code\u003e. This will remove the session\nfrom the context and the session store. Note that if there is no session a new one will be automatically created\nfor the next request from the browser that\u0026#8217;s routed through the session handler.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_session_timeout\"\u003e\u003ca class=\"anchor\" href=\"#_session_timeout\"\u003e\u003c/a\u003eSession timeout\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSessions will be automatically timed out if they are not accessed for a time greater than the timeout period. When\na session is timed out, it is removed from the store.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSessions are automatically marked as accessed when a request arrives and the session is looked up and and when the\nresponse is complete and the session is stored back in the store.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can also use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/Session.html#setAccessed--\"\u003esetAccessed\u003c/a\u003e\u003c/code\u003e to manually mark a session as accessed.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe session timeout can be configured when creating the session handler. Default timeout is 30 minutes.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_authentication_authorization\"\u003e\u003ca class=\"anchor\" href=\"#_authentication_authorization\"\u003e\u003c/a\u003eAuthentication / authorization\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x comes with some out-of-the-box handlers for handling both authentication and authorization. In vert.x web\nthe meanings for the 2 words are:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eAuthentication\u003c/strong\u003e - Tells who the user is\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eAuthorization\u003c/strong\u003e - Tells what the user is allowed to do\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhile \u003cstrong\u003eAuthentication\u003c/strong\u003e is tightened to a well known protocol, e.g.:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHTTP Basic Authentication\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHTTP Digest Authentication\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOAuth2 Authentication\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u0026#8230;\u0026#8203;\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003cstrong\u003eAuthorization\u003c/strong\u003e in vert.x is quite generic and can be used regardless of the prior. Yet it is also possible and a valid\nuse case to use the same provider module for both cases.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_creating_an_authentication_handler\"\u003e\u003ca class=\"anchor\" href=\"#_creating_an_authentication_handler\"\u003e\u003c/a\u003eCreating an Authentication handler\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo create an auth handler you need an instance of \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\"\u003eAuthenticationProvider\u003c/a\u003e\u003c/code\u003e.\nAuthentication provider is used for authentication of users. Vert.x provides several authentication provider instances\nout of the box in the vertx-auth project. For full information on auth providers and how to use and configure them\nplease consult the auth documentation.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s a simple example of creating a basic auth handler given an auth provider.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\nAuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_handling_authentication_in_your_application\"\u003e\u003ca class=\"anchor\" href=\"#_handling_authentication_in_your_application\"\u003e\u003c/a\u003eHandling authentication in your application\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eLet\u0026#8217;s say you want all requests to paths that start with \u003ccode\u003e/private/\u003c/code\u003e to be subject to authentication. To do that you\nmake sure your authentication handler is before your application handlers on those paths:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\nAuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);\n\n\u003cspan class=\"hljs-comment\"\u003e// All requests to paths starting with '/private/' will be protected\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/private/*\"\u003c/span\u003e).handler(basicAuthHandler);\n\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/someotherpath\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// This will be public access - no login required\u003c/span\u003e\n\n});\n\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/private/somepath\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// This will require a login\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// This will have the value true\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eboolean\u003c/span\u003e isAuthenticated = ctx.user() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e;\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf the authentication handler has successfully authenticated the user it will inject a \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/User.html\"\u003eUser\u003c/a\u003e\u003c/code\u003e\nobject into the \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e so it\u0026#8217;s available in your handlers with:\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#user--\"\u003euser\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you want your User object to be stored in the session so it\u0026#8217;s available between requests so you don\u0026#8217;t have to\nauthenticate on each request, then you should make sure you have a session handler before the authentication handler.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eOnce you have your user object you can also programmatically use the methods on it to authorize the user.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you want to cause the user to be logged out you can call \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#clearUser--\"\u003eclearUser\u003c/a\u003e\u003c/code\u003e\non the routing context.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_http_basic_authentication\"\u003e\u003ca class=\"anchor\" href=\"#_http_basic_authentication\"\u003e\u003c/a\u003eHTTP Basic Authentication\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ca href=\"http://en.wikipedia.org/wiki/Basic_access_authentication\"\u003eHTTP Basic Authentication\u003c/a\u003e is a simple means of authentication\nthat can be appropriate for simple applications.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith basic authentication, credentials are sent unencrypted across the wire in HTTP headers so it\u0026#8217;s essential that you\nserve your application using HTTPS not HTTP.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith basic authentication, if a user requests a resource that requires authentication, the basic auth handler will send\nback a \u003ccode\u003e401\u003c/code\u003e response with the header \u003ccode\u003eWWW-Authenticate\u003c/code\u003e set. This prompts the browser to show a log-in dialogue and\nprompt the user to enter their username and password.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe request is made to the resource again, this time with the \u003ccode\u003eAuthorization\u003c/code\u003e header set, containing the username\nand password encoded in Base64.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen the basic auth handler receives this information, it calls the configured \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\"\u003eAuthenticationProvider\u003c/a\u003e\u003c/code\u003e\nwith the username and password to authenticate the user. If the authentication is successful then the routing of the\nrequest is allowed to continue to the application handlers, otherwise a \u003ccode\u003e403\u003c/code\u003e response is returned to signify that\naccess is denied.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_redirect_authentication_handler\"\u003e\u003ca class=\"anchor\" href=\"#_redirect_authentication_handler\"\u003e\u003c/a\u003eRedirect authentication handler\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith redirect authentication handling the user is redirected to towards a login page in the case they are trying to\naccess a protected resource and they are not logged in.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe user then fills in the login form and submits it. This is handled by the server which authenticates\nthe user and, if authenticated redirects the user back to the original resource.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo use redirect auth you configure an instance of \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html\"\u003eRedirectAuthHandler\u003c/a\u003e\u003c/code\u003e instead of a\nbasic authentication handler.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou will also need to setup handlers to serve your actual login page, and a handler to handle the actual login itself.\nTo handle the login we provide a prebuilt handler \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/FormLoginHandler.html\"\u003eFormLoginHandler\u003c/a\u003e\u003c/code\u003e for the purpose.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example of a simple app, using a redirect auth handler on the default redirect url \u003ccode\u003e/loginpage\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\n\u003cspan class=\"hljs-comment\"\u003e// All requests to paths starting with '/private/' will be protected\u003c/span\u003e\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/private/*\"\u003c/span\u003e)\n  .handler(RedirectAuthHandler.create(authProvider));\n\n\u003cspan class=\"hljs-comment\"\u003e// Handle the actual login\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// One of your pages must POST form login data\u003c/span\u003e\nrouter.post(\u003cspan class=\"hljs-string\"\u003e\"/login\"\u003c/span\u003e).handler(FormLoginHandler.create(authProvider));\n\n\u003cspan class=\"hljs-comment\"\u003e// Set a static server to serve static resources, e.g. the login page\u003c/span\u003e\nrouter.route().handler(StaticHandler.create());\n\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/someotherpath\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// This will be public access - no login required\u003c/span\u003e\n  });\n\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/private/somepath\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; {\n\n    \u003cspan class=\"hljs-comment\"\u003e// This will require a login\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// This will have the value true\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eboolean\u003c/span\u003e isAuthenticated = ctx.user() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e;\n\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_jwt_authentication\"\u003e\u003ca class=\"anchor\" href=\"#_jwt_authentication\"\u003e\u003c/a\u003eJWT authentication\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWith JWT authentication resources can be protected by means of permissions and users without enough rights are denied\naccess. You need to add the \u003ccode\u003eio.vertx:vertx-auth-jwt:4.0.2\u003c/code\u003e dependency to use \u003ccode\u003eJWTAuthProvider\u003c/code\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo use this handler there are 2 steps involved:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eSetup an handler to issue tokens (or rely on a 3rd party)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSetup the handler to filter the requests\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003ePlease note that these 2 handlers should be only available on HTTPS, not doing so allows sniffing the tokens in\ntransit which leads to session hijacking attacks.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example on how to issue tokens:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\nJWTAuthOptions authConfig = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JWTAuthOptions()\n  .setKeyStore(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e KeyStoreOptions()\n    .setType(\u003cspan class=\"hljs-string\"\u003e\"jceks\"\u003c/span\u003e)\n    .setPath(\u003cspan class=\"hljs-string\"\u003e\"keystore.jceks\"\u003c/span\u003e)\n    .setPassword(\u003cspan class=\"hljs-string\"\u003e\"secret\"\u003c/span\u003e));\n\nJWTAuth jwt = JWTAuth.create(vertx, authConfig);\n\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/login\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// this is an example, authentication should be done with another provider...\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    \u003cspan class=\"hljs-string\"\u003e\"paulo\"\u003c/span\u003e.equals(ctx.request().getParam(\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e)) \u0026amp;\u0026amp;\n      \u003cspan class=\"hljs-string\"\u003e\"secret\"\u003c/span\u003e.equals(ctx.request().getParam(\u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e))) {\n    ctx.response()\n      .end(jwt.generateToken(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"sub\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"paulo\"\u003c/span\u003e)));\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    ctx.fail(\u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e);\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eNow that your client has a token all it is required is that \u003cstrong\u003efor all\u003c/strong\u003e consequent request the HTTP header\n\u003ccode\u003eAuthorization\u003c/code\u003e is filled with: \u003ccode\u003eBearer \u0026lt;token\u0026gt;\u003c/code\u003e e.g.:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\nJWTAuthOptions authConfig = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JWTAuthOptions()\n  .setKeyStore(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e KeyStoreOptions()\n    .setType(\u003cspan class=\"hljs-string\"\u003e\"jceks\"\u003c/span\u003e)\n    .setPath(\u003cspan class=\"hljs-string\"\u003e\"keystore.jceks\"\u003c/span\u003e)\n    .setPassword(\u003cspan class=\"hljs-string\"\u003e\"secret\"\u003c/span\u003e));\n\nJWTAuth authProvider = JWTAuth.create(vertx, authConfig);\n\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/protected/*\"\u003c/span\u003e).handler(JWTAuthHandler.create(authProvider));\n\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/protected/somepage\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// some handle code...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eJWT allows you to add any information you like to the token itself. By doing this there is no state in the server\nwhich allows you to scale your applications without need for clustered session data. In order to add data to the\ntoken, during the creation of the token just add data to the JsonObject parameter:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eJWTAuthOptions authConfig = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JWTAuthOptions()\n  .setKeyStore(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e KeyStoreOptions()\n    .setType(\u003cspan class=\"hljs-string\"\u003e\"jceks\"\u003c/span\u003e)\n    .setPath(\u003cspan class=\"hljs-string\"\u003e\"keystore.jceks\"\u003c/span\u003e)\n    .setPassword(\u003cspan class=\"hljs-string\"\u003e\"secret\"\u003c/span\u003e));\n\nJWTAuth authProvider = JWTAuth.create(vertx, authConfig);\n\nauthProvider\n  .generateToken(\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject()\n      .put(\u003cspan class=\"hljs-string\"\u003e\"sub\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"paulo\"\u003c/span\u003e)\n      .put(\u003cspan class=\"hljs-string\"\u003e\"someKey\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some value\"\u003c/span\u003e),\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JWTOptions());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAnd the same when consuming:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eHandler\u0026lt;RoutingContext\u0026gt; handler = ctx -\u0026gt; {\n  String theSubject = ctx.user().principal().getString(\u003cspan class=\"hljs-string\"\u003e\"sub\"\u003c/span\u003e);\n  String someKey = ctx.user().principal().getString(\u003cspan class=\"hljs-string\"\u003e\"someKey\"\u003c/span\u003e);\n};\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_configuring_authorization\"\u003e\u003ca class=\"anchor\" href=\"#_configuring_authorization\"\u003e\u003c/a\u003eConfiguring authorization\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eUntil now all examples were covering authentication. Authorization is the next logical step when dealing with user.\nWhile authentication was really specific to the protocol, \u003cstrong\u003eauthorization\u003c/strong\u003e is independent, all information is extracted\nfrom the \u003ccode\u003eUser\u003c/code\u003e object.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBefore this is possible there is a need to load the authorizations to this same object. In order to do this the\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/AuthorizationHandler.html\"\u003eAuthorizationHandler\u003c/a\u003e\u003c/code\u003e should be used. An authorization handler will load all known\nauthorizations from a given \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\"\u003eAuthorizationProvider\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(\n  \u003cspan class=\"hljs-comment\"\u003e// create the handler that will perform the attestation\u003c/span\u003e\n  AuthorizationHandler.create(\n    \u003cspan class=\"hljs-comment\"\u003e// what to attest\u003c/span\u003e\n    PermissionBasedAuthorization.create(\u003cspan class=\"hljs-string\"\u003e\"can-do-work\"\u003c/span\u003e))\n    \u003cspan class=\"hljs-comment\"\u003e// where to lookup the authorizations for the user\u003c/span\u003e\n    .addAuthorizationProvider(authProvider));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe lookup can be performed on more than 1 source, just keep adding \u003ccode\u003eaddAuthorizationProvider(provider)\u003c/code\u003e to the handler.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example of configuring an app so that different authorities are required for different parts of the\napp. Note that the meaning of the authorities is determined by the underlying auth provider that you use. E.g. some\nmay support a role/permission based model but others might use another model.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route(\u003cspan class=\"hljs-string\"\u003e\"/listproducts/*\"\u003c/span\u003e).handler(\n  \u003cspan class=\"hljs-comment\"\u003e// create the handler that will perform the attestation\u003c/span\u003e\n  AuthorizationHandler.create(\n    \u003cspan class=\"hljs-comment\"\u003e// what to attest\u003c/span\u003e\n    PermissionBasedAuthorization.create(\u003cspan class=\"hljs-string\"\u003e\"list_products\"\u003c/span\u003e))\n    \u003cspan class=\"hljs-comment\"\u003e// where to lookup the authorizations for the user\u003c/span\u003e\n    .addAuthorizationProvider(authProvider));\n\n\u003cspan class=\"hljs-comment\"\u003e// Only \"admin\" has access to /private/settings\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/private/settings/*\"\u003c/span\u003e).handler(\n  \u003cspan class=\"hljs-comment\"\u003e// create the handler that will perform the attestation\u003c/span\u003e\n  AuthorizationHandler.create(\n    \u003cspan class=\"hljs-comment\"\u003e// what to attest\u003c/span\u003e\n    RoleBasedAuthorization.create(\u003cspan class=\"hljs-string\"\u003e\"admin\"\u003c/span\u003e))\n    .addAuthorizationProvider(authProvider));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_chaining_multiple_authentication_handlers\"\u003e\u003ca class=\"anchor\" href=\"#_chaining_multiple_authentication_handlers\"\u003e\u003c/a\u003eChaining multiple authentication handlers\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThere are times when you want to support multiple authentication mechanisms in a single application. For this you can\nuse the \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/ChainAuthHandler.html\"\u003eChainAuthHandler\u003c/a\u003e\u003c/code\u003e. The chain auth handler will attempt to perform\nauthentication on a chain of handlers.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIt is important to know that some handlers require specific providers, for example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/JWTAuthHandler.html\"\u003eJWTAuthHandler\u003c/a\u003e\u003c/code\u003e requires \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/jwt/JWTAuth.html\"\u003eJWTAuth\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/DigestAuthHandler.html\"\u003eDigestAuthHandler\u003c/a\u003e\u003c/code\u003e requires \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/htdigest/HtdigestAuth.html\"\u003eHtdigestAuth\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/OAuth2AuthHandler.html\"\u003eOAuth2AuthHandler\u003c/a\u003e\u003c/code\u003e requires \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/OAuth2Auth.html\"\u003eOAuth2Auth\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/WebAuthnHandler.html\"\u003eWebAuthnHandler\u003c/a\u003e\u003c/code\u003e requires \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/webauthn/WebAuthn.html\"\u003eWebAuthn\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSo it is not expected that the providers will be shared across all handlers. There are cases where one can share the\nprovider across handlers, for example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/BasicAuthHandler.html\"\u003eBasicAuthHandler\u003c/a\u003e\u003c/code\u003e can take any provider.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html\"\u003eRedirectAuthHandler\u003c/a\u003e\u003c/code\u003e can take any provider.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSo say that you want to create an application that accepts both \u003ccode\u003eHTTP Basic Authentication\u003c/code\u003e and \u003ccode\u003eForm Redirect\u003c/code\u003e. You\nwould start configuring your chain as:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eChainAuthHandler chain = ChainAuthHandler.any();\n\n\u003cspan class=\"hljs-comment\"\u003e// add http basic auth handler to the chain\u003c/span\u003e\nchain.add(BasicAuthHandler.create(provider));\n\u003cspan class=\"hljs-comment\"\u003e// add form redirect auth handler to the chain\u003c/span\u003e\nchain.add(RedirectAuthHandler.create(provider));\n\n\u003cspan class=\"hljs-comment\"\u003e// secure your route\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/secure/resource\"\u003c/span\u003e).handler(chain);\n\u003cspan class=\"hljs-comment\"\u003e// your app\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/secure/resource\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do something...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSo when a user makes a request without a \u003ccode\u003eAuthorization\u003c/code\u003e header, this means that the chain will fail to authenticate\nwith the basic auth handler and will attempt to authenticate with the redirect handler. Since the redirect handler\nalways redirects you will be sent to the login form that you configured in that handler.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eLike the normal routing in vertx-web, auth chaning is a sequence, so if you would prefer to fallback to your browser\nasking for the user credentials using HTTP Basic authentication instead of the redirect all you need to to is reverse\nthe order of appending to the chain.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eNow assume that you make a request where you provide the header \u003ccode\u003eAuthorization\u003c/code\u003e with the value \u003ccode\u003eBasic [token]\u003c/code\u003e. In\nthis case the basic auth handler will attempt to authenticate and if it is sucessful the chain will stop and\nvertx-web will continue to process your handlers. If the token is not valid, for example bad username/password, then\nthe chain will continue to the following entry. In this specific case the redirect auth handler.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eComplex chaining is also possible, for example, building logic sequences such as: \u003ccode\u003eHandlerA\u003c/code\u003e OR (\u003ccode\u003eHandlerB\u003c/code\u003e AND \u003ccode\u003eHandlerC\u003c/code\u003e).\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eChainAuthHandler chain =\n  ChainAuthHandler.any()\n    .add(authNHandlerA)\n    .add(ChainAuthHandler.all()\n      .add(authNHandlerB)\n      .add(authNHandlerC));\n\n\u003cspan class=\"hljs-comment\"\u003e// secure your route\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/secure/resource\"\u003c/span\u003e).handler(chain);\n\u003cspan class=\"hljs-comment\"\u003e// your app\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/secure/resource\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do something...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_serving_static_resources\"\u003e\u003ca class=\"anchor\" href=\"#_serving_static_resources\"\u003e\u003c/a\u003eServing static resources\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web comes with an out of the box handler for serving static web resources so you can write static web servers\nvery easily.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo serve static resources such as \u003ccode\u003e.html\u003c/code\u003e, \u003ccode\u003e.css\u003c/code\u003e, \u003ccode\u003e.js\u003c/code\u003e or any other static resource, you use an instance of\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html\"\u003eStaticHandler\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAny requests to paths handled by the static handler will result in files being served from a directory on the file system\nor from the classpath. The default static file directory is \u003ccode\u003ewebroot\u003c/code\u003e but this can be configured.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn the following example all requests to paths starting with \u003ccode\u003e/static/\u003c/code\u003e will get served from the directory \u003ccode\u003ewebroot\u003c/code\u003e:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route(\u003cspan class=\"hljs-string\"\u003e\"/static/*\"\u003c/span\u003e).handler(StaticHandler.create());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eFor example, if there was a request with path \u003ccode\u003e/static/css/mystyles.css\u003c/code\u003e the static serve will look for a file in the\ndirectory \u003ccode\u003ewebroot/css/mystyle.css\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIt will also look for a file on the classpath called \u003ccode\u003ewebroot/css/mystyle.css\u003c/code\u003e. This means you can package up all your\nstatic resources into a jar file (or fatjar) and distribute them like that.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen Vert.x finds a resource on the classpath for the first time it extracts it and caches it in a temporary directory\non disk so it doesn\u0026#8217;t have to do this each time.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe handler will handle range aware requests. When a client makes a request to a static resource, the handler will\nnotify that it can handle range aware request by stating the unit on the \u003ccode\u003eAccept-Ranges\u003c/code\u003e header. Further requests\nthat contain the \u003ccode\u003eRange\u003c/code\u003e header with the correct unit and start and end indexes will then receive partial responses\nwith the correct \u003ccode\u003eContent-Range\u003c/code\u003e header.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_configuring_caching\"\u003e\u003ca class=\"anchor\" href=\"#_configuring_caching\"\u003e\u003c/a\u003eConfiguring caching\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy default the static handler will set cache headers to enable browsers to effectively cache files.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web sets the headers \u003ccode\u003ecache-control\u003c/code\u003e,\u003ccode\u003elast-modified\u003c/code\u003e, and \u003ccode\u003edate\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003ecache-control\u003c/code\u003e is set to \u003ccode\u003emax-age=86400\u003c/code\u003e by default. This corresponds to one day. This can be configured with\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxAgeSeconds-long-\"\u003esetMaxAgeSeconds\u003c/a\u003e\u003c/code\u003e if required.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf a browser sends a GET or a HEAD request with an \u003ccode\u003eif-modified-since\u003c/code\u003e header and the resource has not been modified\nsince that date, a \u003ccode\u003e304\u003c/code\u003e status is returned which tells the browser to use its locally cached resource.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf handling of cache headers is not required, it can be disabled with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCachingEnabled-boolean-\"\u003esetCachingEnabled\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen cache handling is enabled Vert.x-Web will cache the last modified date of resources in memory, this avoids a disk hit\nto check the actual last modified date every time.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eEntries in the cache have an expiry time, and after that time, the file on disk will be checked again and the cache\nentry updated.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you know that your files never change on disk, then the cache entry will effectively never expire. This is the\ndefault.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you know that your files might change on disk when the server is running then you can set files read only to false with\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setFilesReadOnly-boolean-\"\u003esetFilesReadOnly\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo enable the maximum number of entries that can be cached in memory at any one time you can use\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxCacheSize-int-\"\u003esetMaxCacheSize\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo configure the expiry time of cache entries you can use \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCacheEntryTimeout-long-\"\u003esetCacheEntryTimeout\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_configuring_the_index_page\"\u003e\u003ca class=\"anchor\" href=\"#_configuring_the_index_page\"\u003e\u003c/a\u003eConfiguring the index page\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAny requests to the root path \u003ccode\u003e/\u003c/code\u003e will cause the index page to be served. By default the index page is \u003ccode\u003eindex.html\u003c/code\u003e.\nThis can be configured with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIndexPage-java.lang.String-\"\u003esetIndexPage\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_changing_the_web_root\"\u003e\u003ca class=\"anchor\" href=\"#_changing_the_web_root\"\u003e\u003c/a\u003eChanging the web root\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy default static resources will be served from the directory \u003ccode\u003ewebroot\u003c/code\u003e. To configure this use\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setWebRoot-java.lang.String-\"\u003esetWebRoot\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_serving_hidden_files\"\u003e\u003ca class=\"anchor\" href=\"#_serving_hidden_files\"\u003e\u003c/a\u003eServing hidden files\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy default the serve will serve hidden files (files starting with \u003ccode\u003e.\u003c/code\u003e).\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you do not want hidden files to be served you can configure it with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIncludeHidden-boolean-\"\u003esetIncludeHidden\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_directory_listing\"\u003e\u003ca class=\"anchor\" href=\"#_directory_listing\"\u003e\u003c/a\u003eDirectory listing\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe server can also perform directory listing. By default directory listing is disabled. To enabled it use\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryListing-boolean-\"\u003esetDirectoryListing\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen directory listing is enabled the content returned depends on the content type in the \u003ccode\u003eaccept\u003c/code\u003e header.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eFor \u003ccode\u003etext/html\u003c/code\u003e directory listing, the template used to render the directory listing page can be configured with\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryTemplate-java.lang.String-\"\u003esetDirectoryTemplate\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_disabling_file_caching_on_disk\"\u003e\u003ca class=\"anchor\" href=\"#_disabling_file_caching_on_disk\"\u003e\u003c/a\u003eDisabling file caching on disk\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy default, Vert.x will cache files that are served from the classpath into a file on disk in a sub-directory of a\ndirectory called \u003ccode\u003e.vertx\u003c/code\u003e in the current working directory. This is mainly useful when deploying services as\nfatjars in production where serving a file from the classpath every time can be slow.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn development this can cause a problem, as if you update your static content while the server is running, the\ncached file will be served not the updated file.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo disable file caching you can provide your vert.x options the property \u003ccode\u003efileResolverCachingEnabled\u003c/code\u003e to \u003ccode\u003efalse\u003c/code\u003e. For\nbackwards compatibility it will also default that value to the system property \u003ccode\u003evertx.disableFileCaching\u003c/code\u003e. E.g. you\ncould set up a run configuration in your IDE to set this when running your main class.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_cors_handling\"\u003e\u003ca class=\"anchor\" href=\"#_cors_handling\"\u003e\u003c/a\u003eCORS handling\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ca href=\"http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\"\u003eCross Origin Resource Sharing\u003c/a\u003e is a safe mechanism for\nallowing resources to be requested from one domain and served from another.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web includes a handler \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/CorsHandler.html\"\u003eCorsHandler\u003c/a\u003e\u003c/code\u003e that handles the CORS protocol for you.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route()\n  .handler(\n    CorsHandler.create(\u003cspan class=\"hljs-string\"\u003e\"vertx\\\\.io\"\u003c/span\u003e)\n      .allowedMethod(HttpMethod.GET));\n\nrouter.route().handler(ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// Your app handlers\u003c/span\u003e\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_multi_tenant\"\u003e\u003ca class=\"anchor\" href=\"#_multi_tenant\"\u003e\u003c/a\u003eMulti Tenant\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThere are cases where your application needs to handle more than just 1 tenant. In this case a helper handler is\nprovided that simplifies setting up the application.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn the case the tenant is identified by a HTTP header, say for example \u003ccode\u003eX-Tenant\u003c/code\u003e, then creating the handler is as\nsimple as:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(MultiTenantHandler.create(\u003cspan class=\"hljs-string\"\u003e\"X-Tenant\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou now should register what handler should be executed for the given tenant:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eMultiTenantHandler.create(\u003cspan class=\"hljs-string\"\u003e\"X-Tenant\"\u003c/span\u003e)\n  .addTenantHandler(\u003cspan class=\"hljs-string\"\u003e\"tenant-A\"\u003c/span\u003e, ctx -\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// do something for tenant A...\u003c/span\u003e\n  })\n  .addTenantHandler(\u003cspan class=\"hljs-string\"\u003e\"tenant-B\"\u003c/span\u003e, ctx -\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// do something for tenant B...\u003c/span\u003e\n  })\n  \u003cspan class=\"hljs-comment\"\u003e// optionally\u003c/span\u003e\n  .addDefaultHandler(ctx -\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// do something when no tenant matches...\u003c/span\u003e\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis is useful for security situations:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eOAuth2Auth gitHubAuthProvider = GithubAuth\n  .create(vertx, \u003cspan class=\"hljs-string\"\u003e\"CLIENT_ID\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"CLIENT_SECRET\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// create a oauth2 handler on our running server\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// the second argument is the full url to the callback\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// as you entered in your provider management console.\u003c/span\u003e\nOAuth2AuthHandler githubOAuth2 = OAuth2AuthHandler.create(\n  vertx,\n  gitHubAuthProvider,\n  \u003cspan class=\"hljs-string\"\u003e\"https://myserver.com/github-callback\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// setup the callback handler for receiving the GitHub callback\u003c/span\u003e\ngithubOAuth2.setupCallback(router.route());\n\n\u003cspan class=\"hljs-comment\"\u003e// create an OAuth2 provider, clientID and clientSecret\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// should be requested to Google\u003c/span\u003e\nOAuth2Auth googleAuthProvider = OAuth2Auth.create(vertx, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e OAuth2Options()\n  .setClientID(\u003cspan class=\"hljs-string\"\u003e\"CLIENT_ID\"\u003c/span\u003e)\n  .setClientSecret(\u003cspan class=\"hljs-string\"\u003e\"CLIENT_SECRET\"\u003c/span\u003e)\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setSite(\u003cspan class=\"hljs-string\"\u003e\"https://accounts.google.com\"\u003c/span\u003e)\n  .setTokenPath(\u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/oauth2/v3/token\"\u003c/span\u003e)\n  .setAuthorizationPath(\u003cspan class=\"hljs-string\"\u003e\"/o/oauth2/auth\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// create a oauth2 handler on our domain: \"http://localhost:8080\"\u003c/span\u003e\nOAuth2AuthHandler googleOAuth2 = OAuth2AuthHandler.create(\n  vertx,\n  googleAuthProvider,\n  \u003cspan class=\"hljs-string\"\u003e\"https://myserver.com/google-callback\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// setup the callback handler for receiving the Google callback\u003c/span\u003e\ngoogleOAuth2.setupCallback(router.route());\n\n\u003cspan class=\"hljs-comment\"\u003e// At this point the 2 callbacks endpoints are registered:\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// /github-callback -\u0026gt; handle github Oauth2 callbacks\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// /google-callback -\u0026gt; handle google Oauth2 callbacks\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// As the callbacks are made by the IdPs there's no header\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// to identify the source, hence the need of custom URLs\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// However for out Application we can control it so later\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// we can add the right handler for the right tenant\u003c/span\u003e\n\nrouter.route().handler(\n  MultiTenantHandler.create(\u003cspan class=\"hljs-string\"\u003e\"X-Tenant\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-comment\"\u003e// tenants using github should go this way:\u003c/span\u003e\n    .addTenantHandler(\u003cspan class=\"hljs-string\"\u003e\"github\"\u003c/span\u003e, githubOAuth2)\n    \u003cspan class=\"hljs-comment\"\u003e// tenants using google should go this way:\u003c/span\u003e\n    .addTenantHandler(\u003cspan class=\"hljs-string\"\u003e\"google\"\u003c/span\u003e, googleOAuth2)\n    \u003cspan class=\"hljs-comment\"\u003e// all other should be forbidden\u003c/span\u003e\n    .addDefaultHandler(ctx -\u0026gt; ctx.fail(\u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e)));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe tenant id can be read at any moment from the context, for example to decide which resource to load, or which\ndatabase to connect to:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// the default key is \"tenant\" as defined in\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// MultiTenantHandler.TENANT but this value can be\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// modified at creation time in the factory method\u003c/span\u003e\n  String tenant = ctx.get(MultiTenantHandler.TENANT);\n\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e(tenant) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"google\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-comment\"\u003e// do something for google users\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"github\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-comment\"\u003e// so something for github users\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMulti tenant is a powerful handler that will allow applications to live side by side, however it provides no sandboxing\nfor execution. It should not be used as isolation as wrongly written applications may leak state across tenants.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_templates\"\u003e\u003ca class=\"anchor\" href=\"#_templates\"\u003e\u003c/a\u003e模板\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 为若干流行的模板引擎提供了开箱即用的支持，通过这种方式来提供生成动态页面的能力。\n您也可以很容易地添加您自己的实现。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html\"\u003eTemplateEngine\u003c/a\u003e\u003c/code\u003e 定义了使用模板引擎的接口。\n当渲染模板时会调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html#render-io.vertx.core.json.JsonObject-java.lang.String-io.vertx.core.Handler-\"\u003erender\u003c/a\u003e\u003c/code\u003e 方法。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e最简单的使用模板的方式不是直接调用模板引擎，而是使用模板处理器\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/TemplateHandler.html\"\u003eTemplateHandler\u003c/a\u003e\u003c/code\u003e 。\n这个处理器会根据 HTTP 请求的路径来调用模板引擎。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e缺省情况下，模板处理器会在 \u003ccode\u003etemplates\u003c/code\u003e 目录中查找模板文件。这是可以配置的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e该处理器会返回渲染的结果，并默认设置 Content-Type 消息头为 \u003ccode\u003etext/html\u003c/code\u003e 。这也是可以配置的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在创建模板处理器时提供您想要使用的模板引擎实例。\nVert.x Web 并未嵌入模板引擎的实现，您需要配置项目来访问它们。\nVert.x Web 提供了每一种模板引擎的配置。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTemplateEngine engine = HandlebarsTemplateEngine.create();\nTemplateHandler handler = TemplateHandler.create(engine);\n\n\u003cspan class=\"hljs-comment\"\u003e// 这会将所有以 `/dynamic` 开头的 GET 请求路由到模板处理器上\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 例如 /dynamic/graph.hbs 会查找模板 /templates/graph.hbs\u003c/span\u003e\nrouter.get(\u003cspan class=\"hljs-string\"\u003e\"/dynamic/*\"\u003c/span\u003e).handler(handler);\n\n\u003cspan class=\"hljs-comment\"\u003e// 将所有以 `.hbs` 结尾的 GET 请求路由到模板处理器上\u003c/span\u003e\nrouter.getWithRegex(\u003cspan class=\"hljs-string\"\u003e\".+\\\\.hbs\"\u003c/span\u003e).handler(handler);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_mvel_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_mvel_template_engine\"\u003e\u003c/a\u003eMVEL 模版引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 MVEL 模板引擎：\n\u003ccode\u003eio.vertx:vertx-web-templ-mvel:4.0.2\u003c/code\u003e。 并通过此方法以创建 MVEL 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.mvel.MVELTemplateEngine#create(io.vertx.core.Vertx)\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 MVEL 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.templ\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在 MVEL 模板中可以通过 \u003ccode\u003econtext\u003c/code\u003e 上下文变量来访问路由上下文 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003eThe request path is @{context.request().path()}\n\nThe variable 'foo' from the session is @{context.session().get('foo')}\n\nThe value 'bar' from the context data is @{context.get('bar')}\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 MVEL 模板，\n请参考 \u003ca href=\"http://mvel.codehaus.org/MVEL+2.0+Templating+Guide\"\u003eMVEL 模板文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_jade_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_jade_template_engine\"\u003e\u003c/a\u003eJade 模版引擎（译者注：Jade 已更名为 Pug)\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 Jade 模板引擎：\n\u003ccode\u003eio.vertx:vertx-web-templ-jade:4.0.2\u003c/code\u003e。 并通过此方法以创建 Jade 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.jade.JadeTemplateEngine#create(io.vertx.core.Vertx)\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 Jade 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.jade\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在 Jade 模板中可以通过 \u003ccode\u003econtext\u003c/code\u003e 上下文变量来访问路由上下文 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e!!! 5\nhtml\n head\n   title= context.get('foo') + context.request().path()\n body\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 Jade 模板，\n请参考 \u003ca href=\"https://github.com/neuland/jade4j\"\u003eJade4j 文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_handlebars_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_handlebars_template_engine\"\u003e\u003c/a\u003eHandlebars 模板引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 Handlebars 模板引擎：\n\u003ccode\u003eio.vertx:vertx-web-templ-handlebars:4.0.2\u003c/code\u003e。 并通过此方法以创建 Handlebars 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.handlebars.HandlebarsTemplateEngine#create(io.vertx.core.Vertx)\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 Handlebars 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.hbs\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHandlebars 不允许在模板中随意地调用对象的方法，\n因此我们不能像对待其他模板引擎一样将RoutingContext传递到引擎里并让模板来识别它。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e替代方案是，可以使用模版中的上下文 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#data--\"\u003edata\u003c/a\u003e\u003c/code\u003e 对象。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果您要访问某些RoutingContext里不存在的信息，\n比如请求的路径、请求参数或者会话等，您需要在模板处理器执行之前将他们添加到上下文data里，例如：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTemplateHandler handler = TemplateHandler.create(engine);\n\nrouter.get(\u003cspan class=\"hljs-string\"\u003e\"/dynamic\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n\n  ctx.put(\u003cspan class=\"hljs-string\"\u003e\"request_path\"\u003c/span\u003e, ctx.request().path());\n  ctx.put(\u003cspan class=\"hljs-string\"\u003e\"session_data\"\u003c/span\u003e, ctx.session().data());\n\n  ctx.next();\n});\n\nrouter.get(\u003cspan class=\"hljs-string\"\u003e\"/dynamic/\"\u003c/span\u003e).handler(handler);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 Handlebars 模板，\n请参考 \u003ca href=\"https://github.com/jknack/handlebars.java\"\u003eHandlebars Java 文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_thymeleaf_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_thymeleaf_template_engine\"\u003e\u003c/a\u003eThymeleaf 模板引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 Thymeleaf 模板引擎：\n\u003ccode\u003eio.vertx:vertx-web-templ-thymeleaf:4.0.2\u003c/code\u003e。 并通过此方法以创建 Thymeleaf 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.thymeleaf.ThymeleafTemplateEngine#create(io.vertx.core.Vertx)\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 Thymeleaf 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.html\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在 Thymeleaf 模板中可以通过 \u003ccode\u003econtext\u003c/code\u003e 上下文变量来访问路由上下文 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e[snip]\n\u0026lt;p th:text=\"${context.get('foo')}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.get('bar')}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.normalizedPath()}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.request().params().get('param1')}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.request().params().get('param2')}\"\u0026gt;\u0026lt;/p\u0026gt;\n[snip]\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 Thymeleaf 模板，\n请参考 \u003ca href=\"http://www.thymeleaf.org/\"\u003eThymeleaf 文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_apache_freemarker_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_apache_freemarker_template_engine\"\u003e\u003c/a\u003eApache FreeMarker 模版引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 Apache FreeMarker ：\n\u003ccode\u003eio.vertx:vertx-web-templ-freemarker:4.0.2\u003c/code\u003e。 并通过此方法以创建 Apache FreeMarker 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.Engine#create()\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 Apache FreeMarker 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.ftl\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在 Apache FreeMarker 模板中可以通过 \u003ccode\u003econtext\u003c/code\u003e 上下文变量来访问路由上下文 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e[snip]\n\u0026lt;p th:text=\"${context.foo}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.bar}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.normalizedPath()}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.request().params().param1}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"${context.request().params().param2}\"\u0026gt;\u0026lt;/p\u0026gt;\n[snip]\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 Apache FreeMarker 模板，\n请参考 \u003ca href=\"http://www.freemarker.org/\"\u003eApache FreeMarker 文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_pebble_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_pebble_template_engine\"\u003e\u003c/a\u003ePebble 模版引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 Pebble ：\n\u003ccode\u003eio.vertx:vertx-web-templ-pebble:4.0.2\u003c/code\u003e。 并通过此方法以创建 Pebble 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.pebble.PebbleTemplateEngine#create(vertx)\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 Pebble 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.ped\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在 Pebble 模板中可以通过 \u003ccode\u003econtext\u003c/code\u003e 上下文变量来访问路由上下文 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e[snip]\n\u0026lt;p th:text=\"{{context.foo}}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"{{context.bar}}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"{{context.normalizedPath()}}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"{{context.request().params().param1}}\"\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p th:text=\"{{context.request().params().param2}}\"\u0026gt;\u0026lt;/p\u0026gt;\n[snip]\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 Pebble 模板，\n请参考 \u003ca href=\"http://www.mitchellbosecke.com/pebble/home/\"\u003ePebble 文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_rocker_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_rocker_template_engine\"\u003e\u003c/a\u003eRocker 模版引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 Rocker：\u003ccode\u003eio.vertx:vertx-web-templ-rocker:4.0.2\u003c/code\u003e。\n并通过此方法以创建 Rocker 模板引擎实例：\u003ccode\u003eio.vertx.ext.web.templ.rocker#create()\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRocker会将JSON上下文对象的值传递给 \u003ccode\u003erender\u003c/code\u003e 方法作为模版的参数。\n假定已知：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e[snip]\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\")\n .put(\"context\", new JsonObject().put(\"path\", \"/foo/bar\"));\n\nengine.render(context, \"somedir/TestRockerTemplate2\", render -\u0026gt; {\n // (...)\n});\n[snip]\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e那么相对应的模版文件 \u003ccode\u003esomedir/TestRockerTemplate2.rocker.html\u003c/code\u003e 可写作：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e@import io.vertx.core.json.JsonObject\n@args (JsonObject context, String foo, String bar)\nHello @foo and @bar\nRequest path is @context.getString(\"path\")\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_httl_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_httl_template_engine\"\u003e\u003c/a\u003eHTTL 模版引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 HTTL ：\n\u003ccode\u003eio.vertx:vertx-web-templ-httl:4.0.2\u003c/code\u003e。 并通过此方法以创建 HTTL 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.httl.HTTLTemplateEngine#create(io.vertx.core.Vertx)\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 HTTL 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.httl\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHTTL会将JSON上下文对象的值传递给 \u003ccode\u003erender\u003c/code\u003e 方法作为模版的参数。\n假定已知：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e[snip]\nTemplateEngine engine = HTTLTemplateEngine.create(vertx);\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\");\n\nengine.render(context, \"somedir/test-httl-template1.httl\", render -\u0026gt; {\n // (...)\n});\n[snip]\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e那么相对应的模版文件 \u003ccode\u003esomedir/test-httl-template1.httl\u003c/code\u003e 可写作：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e\u0026lt;!-- #set(String foo, String bar) --\u0026gt;\nHello ${foo} and ${bar}\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 HTTL 模板，\n请参考 \u003ca href=\"https://httl.github.io/en/\"\u003eHTTL 文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_rythm_template_engine\"\u003e\u003ca class=\"anchor\" href=\"#_rythm_template_engine\"\u003e\u003c/a\u003eRythm 模版引擎\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要在项目中添加以下 \u003cem\u003e依赖\u003c/em\u003e 以使用 Rythm ：\n\u003ccode\u003eio.vertx:vertx-web-templ-rythm:4.0.2\u003c/code\u003e。 并通过此方法以创建 Rythm 模板引擎实例：\n\u003ccode\u003eio.vertx.ext.web.templ.rythm.RythmTemplateEngine#create(io.vertx.core.Vertx)\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在使用 Rythm 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 \u003ccode\u003e.html\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRythm会将JSON上下文对象的值传递给 \u003ccode\u003erender\u003c/code\u003e 方法作为模版的参数。\n假定已知：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e[snip]\nTemplateEngine engine = RythmTemplateEngine.create(vertx);\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\");\n\nengine.render(context, \"somedir/test-rythm-template1.html\", render -\u0026gt; {\n // (...)\n});\n[snip]\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e那么相对应的模版文件 \u003ccode\u003esomedir/test-rythm-template1.httl\u003c/code\u003e 可写作：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e\u0026lt;!-- #set(String foo, String bar) --\u0026gt;\nHello @foo and @bar\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于如何编写 HTTL 模板，请参考 \u003ca href=\"http://www.rythmengine.org/\"\u003eRythmEngine 文档\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_caching\"\u003e\u003ca class=\"anchor\" href=\"#_caching\"\u003e\u003c/a\u003e缓存\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e许多引擎支持将编译好的模版存入缓存。该缓存存放在Vert.x的可分享的数据local map里。\n这样引擎便可在多个verticle中安全高效地使用该缓存。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_disabling_caching\"\u003e\u003ca class=\"anchor\" href=\"#_disabling_caching\"\u003e\u003c/a\u003e禁用缓存\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在开发时，为了让每一次请求可以读取最新的模板，您可能希望禁用模板的缓存。\n您可通过设置系统变量：\u003ccode\u003evertxweb.environment\u003c/code\u003e 或环境变量\n\u003ccode\u003eVERTXWEB_ENVIRONMENT\u003c/code\u003e 为 \u003ccode\u003edev\u003c/code\u003e 或 \u003ccode\u003edevelopment\u003c/code\u003e 将其禁用。缓存默认是启用的。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_error_handler\"\u003e\u003ca class=\"anchor\" href=\"#_error_handler\"\u003e\u003c/a\u003e错误处理器\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可使用模版处理器自行渲染错误页面，\n但是Vert.x-Web同样为您提供了开箱即用且“好看的”错误处理器，可为您渲染错误页面。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e该处理器是 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/ErrorHandler.html\"\u003eErrorHandler\u003c/a\u003e\u003c/code\u003e。\n要使用该错误处理器，仅需要将其设置为您希望覆盖的错误路径的失败处理器即可（译者注：例如router.route(\"/*\").failureHandler(ErrorHandler.create(vertx))）。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_request_logger\"\u003e\u003ca class=\"anchor\" href=\"#_request_logger\"\u003e\u003c/a\u003e请求日志\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web通过内置处理器 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/LoggerHandler.html\"\u003eLoggerHandler\u003c/a\u003e\u003c/code\u003e 来记录请求日志。\n您需在挂载任何可能导致 \u003ccode\u003eRoutingContext\u003c/code\u003e 失败的处理器之前挂载该处理器。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e默认情况下，请求日志将会被记录到Vert.x logger中，亦可通过更改配置使用JUL logging, log4j 或 SLF4J记录。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e详见 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/LoggerFormat.html\"\u003eLoggerFormat\u003c/a\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_serving_favicons\"\u003e\u003ca class=\"anchor\" href=\"#_serving_favicons\"\u003e\u003c/a\u003e提供网页图标\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web通过内置处理器 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/FaviconHandler.html\"\u003eFaviconHandler\u003c/a\u003e\u003c/code\u003e 以提供网页图标。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e图标可以指定为文件系统上的某个路径，否则 Vert.x Web 默认会在 classpath 上寻找名为 \u003ccode\u003efavicon.ico\u003c/code\u003e 的文件。\n这意味着您可以将图标打包到包含您应用的 jar 包里。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_timeout_handler\"\u003e\u003ca class=\"anchor\" href=\"#_timeout_handler\"\u003e\u003c/a\u003e超时处理器\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x-Web内置一个超时处理器以处理超时请求。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e可通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/TimeoutHandler.html\"\u003eTimeoutHandler\u003c/a\u003e\u003c/code\u003e 配置。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果一个请求超时，则会给客户端返回一个 503 的响应。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e下面的例子设置了一个超时处理器。对于所有以 \u003ccode\u003e/foo\u003c/code\u003e 路径开头的请求，\n都会在执行时间超过 5 秒之后自动超时。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route(\u003cspan class=\"hljs-string\"\u003e\"/foo/\"\u003c/span\u003e).handler(TimeoutHandler.create(\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_response_time_handler\"\u003e\u003ca class=\"anchor\" href=\"#_response_time_handler\"\u003e\u003c/a\u003e响应时间处理器\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e该处理器会将从接收到请求到写入响应的消息头之间的毫秒数写入到响应的 \u003ccode\u003ex-response-time\u003c/code\u003e 里，\n例如：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003ex-response-time: 1456ms\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_content_type_handler\"\u003e\u003ca class=\"anchor\" href=\"#_content_type_handler\"\u003e\u003c/a\u003e内容类型（Content type）处理器\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003eResponseContentTypeHandler\u003c/code\u003e 会自动设置响应的 \u003ccode\u003eContent-Type\u003c/code\u003e 消息头。\n假设我们要构建一个 RESTful 的 Web 应用，我们需要在所有处理器里设置消息类型：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/api/books\"\u003c/span\u003e)\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; findBooks()\n    .onSuccess(books -\u0026gt; ctx.response()\n      .putHeader(\u003cspan class=\"hljs-string\"\u003e\"Content-Type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n      .end(toJson(books))).onFailure(ctx::fail));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e随着 API 接口数量的增长，设置内容类型会变得很麻烦。\n可以通过在相应的 Route 上添加 \u003ccode\u003eResponseContentTypeHandler\u003c/code\u003e 来避免这个问题：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route(\u003cspan class=\"hljs-string\"\u003e\"/api/*\"\u003c/span\u003e).handler(ResponseContentTypeHandler.create());\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/api/books\"\u003c/span\u003e)\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; findBooks()\n    .onSuccess(books -\u0026gt; ctx.response()\n      .end(toJson(books))).onFailure(ctx::fail));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e处理器会通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--\"\u003egetAcceptableContentType\u003c/a\u003e\u003c/code\u003e 方法来选择适当的内容类型。\n因此，您可以很容易地使用同一个处理器以提供不同类型的数据：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route(\u003cspan class=\"hljs-string\"\u003e\"/api/*\"\u003c/span\u003e).handler(ResponseContentTypeHandler.create());\n\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/api/books\"\u003c/span\u003e)\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"text/xml\"\u003c/span\u003e)\n  .produces(\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; findBooks()\n    .onSuccess(books -\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.getAcceptableContentType().equals(\u003cspan class=\"hljs-string\"\u003e\"text/xml\"\u003c/span\u003e)) {\n        ctx.response().end(toXML(books));\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        ctx.response().end(toJson(books));\n      }\n    })\n    .onFailure(ctx::fail));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_sockjs\"\u003e\u003ca class=\"anchor\" href=\"#_sockjs\"\u003e\u003c/a\u003eSockJS\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSockJS 是一个客户端的 JavaScript 库以及协议，它提供了类似 WebSocket 的接口以方便您与 SockJS 服务器创建连接，\n而无需您关心浏览器或网络是否允许真正的 WebSocket。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e它提供了若干不同的传输方式，\n并在运行时根据浏览器和网络的兼容性来选择使用哪种传输方式处理。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e然而这一切对您而言是透明的，您只需要简单地使用类似 WebSocket 的接口 \u003cem\u003e即可\u003c/em\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e请参阅 \u003ca href=\"https://github.com/sockjs/sockjs-client\"\u003e SockJS 网站\u003c/a\u003e以获取更多关于SockJS的信息。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_sockjs_handler\"\u003e\u003ca class=\"anchor\" href=\"#_sockjs_handler\"\u003e\u003c/a\u003eSockJS 处理器\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x 提供了一个开箱即用的处理器 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\"\u003eSockJSHandler\u003c/a\u003e\u003c/code\u003e\n以便您在 Vert.x-Web 应用中使用 SockJS。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您需要通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#create-io.vertx.core.Vertx-\"\u003eSockJSHandler.create\u003c/a\u003e\u003c/code\u003e 方法为每一个 SockJS 的应用创建处理器。\n您也可以在创建处理器时通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\"\u003eSockJSHandlerOptions\u003c/a\u003e\u003c/code\u003e\n对象来指定配置选项。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\nSockJSHandlerOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSHandlerOptions()\n  .setHeartbeatInterval(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_handling_sockjs_sockets\"\u003e\u003ca class=\"anchor\" href=\"#_handling_sockjs_sockets\"\u003e\u003c/a\u003e处理 SockJS 套接字\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可以在服务器端设置一个 SockJS 处理器，\n这个处理器会在客户端创建连接时被调用：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e传递给处理器的是 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html\"\u003eSockJSSocket\u003c/a\u003e\u003c/code\u003e 对象。\n这是一个类似套接字的接口，您可以像使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/net/NetSocket.html\"\u003eNetSocket\u003c/a\u003e\u003c/code\u003e 或\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/http/WebSocket.html\"\u003eWebSocket\u003c/a\u003e\u003c/code\u003e 那样通过它来读写数据。它实现了 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\"\u003eReadStream\u003c/a\u003e\u003c/code\u003e 和\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\"\u003eWriteStream\u003c/a\u003e\u003c/code\u003e 接口，因此您可以将它套用（pump）到其他读写流上。\n若 SockJS 连接使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#routingContext--\"\u003eroutingContext\u003c/a\u003e\u003c/code\u003e 加载，\n那么便可在手动管理会话（session）时访问 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\"\u003eRoutingContext\u003c/a\u003e\u003c/code\u003e。\n由此您可以通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webSession--\"\u003ewebSession\u003c/a\u003e\u003c/code\u003e 和\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webUser--\"\u003ewebUser\u003c/a\u003e\u003c/code\u003e 管理用户和会话。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e下面的例子中的 SockJS 处理器直接使用了它读取到的数据进行回写：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\nSockJSHandlerOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSHandlerOptions()\n  .setHeartbeatInterval(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);\n\nrouter.mountSubRouter(\u003cspan class=\"hljs-string\"\u003e\"/myapp\"\u003c/span\u003e, sockJSHandler.socketHandler(sockJSSocket -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 将数据回写\u003c/span\u003e\n  sockJSSocket.handler(sockJSSocket::write);\n\n}));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_the_client_side\"\u003e\u003ca class=\"anchor\" href=\"#_the_client_side\"\u003e\u003c/a\u003e客户端\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在客户端 JavaScript 环境里您需要通过 SockJS 的客户端库来建立连接。\n这是SockJS 客户端的地址 \u003ca href=\"https://www.npmjs.com/package/sockjs-client\"\u003ehttps://www.npmjs.com/package/sockjs-client\u003c/a\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可直接在捆绑软件或构建工具中直接引用它。\n或者您想在 \u003ccode\u003eHTML\u003c/code\u003e 文档中直接使用 \u003ccode\u003eCDN\u003c/code\u003e 版本，那么首先需要引入 sockjs 的依赖：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n ...\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e完整的使用细节可参阅 \u003ca href=\"https://github.com/sockjs/sockjs-client\"\u003eSockJS 网站\u003c/a\u003e，\n但简而言之可像这样使用：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e sock = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJS(\u003cspan class=\"hljs-string\"\u003e'http://mydomain.com/myapp'\u003c/span\u003e);\n\nsock.onopen = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'open'\u003c/span\u003e);\n};\n\nsock.onmessage = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) \u003c/span\u003e{\n \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, e.data);\n};\n\nsock.onevent = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent, message\u003c/span\u003e) \u003c/span\u003e{\n \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'event: %o, message:%o'\u003c/span\u003e, event, message);\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 为了标记消息已被处理了\u003c/span\u003e\n};\n\nsock.onunhandled = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ejson\u003c/span\u003e) \u003c/span\u003e{\n \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'this message has no address:'\u003c/span\u003e, json);\n};\n\nsock.onclose = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e);\n};\n\nsock.send(\u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e);\n\nsock.close();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_configuring_the_sockjs_handler\"\u003e\u003ca class=\"anchor\" href=\"#_configuring_the_sockjs_handler\"\u003e\u003c/a\u003e配置 SockJS 处理器\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e可使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\"\u003eSockJSHandlerOptions\u003c/a\u003e\u003c/code\u003e 为处理器配置各种选项。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_writing_to_a_sockjs_socket_over_the_event_bus\"\u003e\u003ca class=\"anchor\" href=\"#_writing_to_a_sockjs_socket_over_the_event_bus\"\u003e\u003c/a\u003e通过 event bus 写入 SockJS 套接字\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在创建 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html\"\u003eSockJSSocket\u003c/a\u003e\u003c/code\u003e 的时候，可为其注册一个 event bus 上的事件处理器。\n该处理器的地址就是 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#writeHandlerID--\"\u003ewriteHandlerID\u003c/a\u003e\u003c/code\u003e 。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e默认情况下，不允许注册事件处理器。\n需要通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\"\u003eSockJSHandlerOptions\u003c/a\u003e\u003c/code\u003e 以启用该设置。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\nSockJSHandlerOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSHandlerOptions().setRegisterWriteHandler(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);\n\nrouter.mountSubRouter(\u003cspan class=\"hljs-string\"\u003e\"/myapp\"\u003c/span\u003e, sockJSHandler.socketHandler(sockJSSocket -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 获取 writeHandlerID 并将其存放 (例如放在本地 map 里)\u003c/span\u003e\n  String writeHandlerID = sockJSSocket.writeHandlerID();\n\n}));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n默认情况下，处理器仅在本地注册。\n集群可通过配置 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html#setLocalWriteHandler-boolean-\"\u003esetLocalWriteHandler\u003c/a\u003e\u003c/code\u003e 为false启用。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e随后将数据写入 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\"\u003eBuffer\u003c/a\u003e\u003c/code\u003e 便可发送给 SockJS 套接字。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eeventBus.send(writeHandlerID, Buffer.buffer(\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_sockjs_event_bus_bridge\"\u003e\u003ca class=\"anchor\" href=\"#_sockjs_event_bus_bridge\"\u003e\u003c/a\u003eSockJS 桥接 Event Bus\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Web 提供了一个内置的被称为事件总线桥（event bus bridge）的 SockJS 套接字处理器。\n该处理器有效地将服务器端的 Vert.x 的事件总线延伸到客户端的 JavaScript 运行环境里。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这将创建一个分布式的事件总线。\n该 event bus 不仅可以在服务器端多个 Vert.x 实例中使用，还可以通过运行在浏览器里的 JavaScript 访问。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e由此，我们可以建立起一个连接多个浏览器和服务器群的庞大的分布式 event bus。\n浏览器只需与服务器集群建立连接，无需每次都与固定的某个服务器建立连接。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这些是通过 Vert.x 提供的一个简单的客户端 JavaScript 库 \u003ccode\u003evertx-eventbus.js\u003c/code\u003e 来实现的。\n它提供了一系列与服务器端的 Vert.x event-bus 极为类似的 API。\n通过这些 API 您可以发送或发布消息，或注册处理器来接收消息。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e该 JavaScript 库使用了 JavaScript 的 SockJS 客户端，与另外一端的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\"\u003eSockJS 处理器\u003c/a\u003e\u003c/code\u003e 建立起 SockJS 连接，\n并将事件总线上的流量通过管道（tunnel）传送至该客户端。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个特殊的 SockJS 套接字处理器因此被安装到 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\"\u003eSockJS 处理器\u003c/a\u003e\u003c/code\u003e 上，\n而该处理器将会处理 SockJS 的数据，并将建立起与服务器端的事件总线的连接桥。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e启用该连接桥您只需要在\nSockJS 处理器中调用\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-\"\u003ebridge\u003c/a\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSBridgeOptions();\n\u003cspan class=\"hljs-comment\"\u003e// 将连接桥挂载到路由器上\u003c/span\u003e\nrouter.mountSubRouter(\u003cspan class=\"hljs-string\"\u003e\"/eventbus\"\u003c/span\u003e, sockJSHandler.bridge(options));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在客户端的 JavaScript 中，您可以使用 \u003ca href=\"http://npmjs.com/package/@vertx/eventbus-bridge-client.js\"\u003e@vertx/eventbus-bridge-client.js\u003c/a\u003e\n库以创建跟事件总线的连接，并以此发送和接收消息。 该库可在 \u003ca href=\"http://npmjs.com/package/@vertx/eventbus-bridge-client.js\"\u003eNPM\u003c/a\u003e 上找到。\n您可直接在捆绑软件或构建工具中直接引用它，但同时它亦可以在 CDN 中使用\n（就像之前的 sockJS 例子）：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js'\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eb = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e EventBus(\u003cspan class=\"hljs-string\"\u003e'http://localhost:8080/eventbus'\u003c/span\u003e);\n\neb.onopen = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n\n \u003cspan class=\"hljs-comment\"\u003e// 设置一个处理器以接收消息\u003c/span\u003e\n eb.registerHandler(\u003cspan class=\"hljs-string\"\u003e'some-address'\u003c/span\u003e, (error, message) =\u0026gt; {\n   \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'received a message: '\u003c/span\u003e + \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(message));\n });\n\n \u003cspan class=\"hljs-comment\"\u003e// 发送消息\u003c/span\u003e\n eb.send(\u003cspan class=\"hljs-string\"\u003e'some-address'\u003c/span\u003e, {\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'tim'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e587\u003c/span\u003e});\n\n}\n\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e该例子中首先创建了一个 event bus 实例\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eb = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e EventBus(\u003cspan class=\"hljs-string\"\u003e'http://localhost:8080/eventbus'\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e构造器中的参数是连接 event bus 的URI。\n因为我们建立的连接桥是以 \u003ccode\u003eeventbus\u003c/code\u003e 为前缀，所以我们将会成功建立连接。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您在连接开启之前无法做任何事。当连接开启时 \u003ccode\u003eonopen\u003c/code\u003e 处理器将会被调用。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e连接桥支持自动重连，可设置延迟和退避选项。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eb = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e EventBus(\u003cspan class=\"hljs-string\"\u003e'http://localhost:8080/eventbus'\u003c/span\u003e);\neb.enableReconnect(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\neb.onopen = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{}; \u003cspan class=\"hljs-comment\"\u003e// 在此处设立处理器，每次建立连接或重连时候调用\u003c/span\u003e\neb.onreconnect = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{}; \u003cspan class=\"hljs-comment\"\u003e// 可选，仅在重连时被调用\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 或者，传入一个 options 对象\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e options = {\n   \u003cspan class=\"hljs-attr\"\u003evertxbus_reconnect_attempts_max\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eInfinity\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 重连尝试最多次数\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003evertxbus_reconnect_delay_min\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 在第一次尝试重连之前的初始延迟（单位为毫秒）\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003evertxbus_reconnect_delay_max\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 尝试重连之间的最大延迟（单位为毫秒）\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003evertxbus_reconnect_exponent\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 指数退避因子\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003evertxbus_randomization_factor\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 介于0和1之间的随机因子\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eb2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e EventBus(\u003cspan class=\"hljs-string\"\u003e'http://localhost:8080/eventbus'\u003c/span\u003e, options);\neb2.enableReconnect(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 创建处理器……\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_securing_the_bridge\"\u003e\u003ca class=\"anchor\" href=\"#_securing_the_bridge\"\u003e\u003c/a\u003e守护连接桥\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果您像上面的例子一样建立连接桥但未开启守护机制，此时您试图通过该桥发送消息，\n您会发现消息神秘地失踪了。发生了什么？\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e对于大多数的应用，您恐怕不希望客户端的 JavaScript\n代码可以发送任何消息到任意服务端处理器或其他所有浏览器上。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e例如，您可能在事件总线上注册了一个服务，用于访问或删除数据。\n我们并不希望出现恶意的行为或有害的客户端能够利用该服务删除数据库中所有的数据！\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e此外，我们恐怕也不希望任意一个客户端都能监听任意一个事件总线地址。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e为了解决这个问题，SockJs连接桥默认会拒绝所有的消息。\n您需要告诉连接桥哪些消息是可以通过的。（例外情况是，所有的回复消息都是可以通过的）。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e换句话说，连接桥的行为就像是配置了缺省策略为 \u003cem\u003e全部拒绝\u003c/em\u003e 策略的防火墙。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e为连接桥配置哪些消息可以通过是很简单的一件事。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可以通过调用连接桥时传入的\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSBridgeOptions.html\"\u003eSockJSBridgeOptions\u003c/a\u003e\u003c/code\u003e 来配置 \u003cem\u003e匹配\u003c/em\u003e 规则以指定哪些输入和输出的流量是允许通过的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e每一个匹配规则对应一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html\"\u003ePermittedOptions\u003c/a\u003e\u003c/code\u003e 对象：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"dlist\"\u003e\n\u003cdl\u003e\n\u003cdt class=\"hdlist1\"\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddress-java.lang.String-\"\u003esetAddress\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e该配置规则精确地定义了消息可以被发送到哪些地址。\n如您需要通过精确地址来控制消息的话，使用该选项。\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddressRegex-java.lang.String-\"\u003esetAddressRegex\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e该配置规则通过正则表达式来定义消息可以被发送到哪些地址。如您需要通过正则表达式来控制消息的话，请使用这个选项。\n如果指定了 \u003ccode\u003eaddress\u003c/code\u003e ，则该选项会被忽略。\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setMatch-io.vertx.core.json.JsonObject-\"\u003esetMatch\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e该配置规则通过消息的结构来控制消息是否可被发送。该配置中定义的每一个字段必须在消息中存在，且值一致。\n目前仅适用于 JSON 格式的消息。\u003c/p\u003e\n\u003c/dd\u003e\n\u003c/dl\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e对于一个 \u003cem\u003e输入\u003c/em\u003e 的消息（例如通过客户端 JavaScript 发送到服务器）\n当消息抵达时，Vert.x Web 会检查每一条输入许可。如果存在匹配规则，则消息可以通过。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e对于一个 \u003cem\u003e输出\u003c/em\u003e 的消息（例如通过服务器端发送给客户端 JavaScript）\n当消息发送时，Vert.x Web 会检查每一条输出许可。如果存在匹配，则消息可以通过。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e实际的匹配过程如下：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果指定了 \u003ccode\u003eaddress\u003c/code\u003e 字段，并且消息的目标地址与 \u003ccode\u003eaddress\u003c/code\u003e \u003cem\u003e精确\u003c/em\u003e 匹配，\n则匹配成功。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果没有指定 \u003ccode\u003eaddress\u003c/code\u003e 但指定了 \u003ccode\u003eaddressRegex\u003c/code\u003e 字段，并且消息的目标地址匹配了 \u003ccode\u003eaddress_re\u003c/code\u003e 里的正则表达式，\n则匹配成功。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果指定了 \u003ccode\u003ematch\u003c/code\u003e 字段，则消息的结构也必须匹配。\n消息需包含有 match 对象中的所有键值对，方能匹配成功。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\n\n\n\u003cspan class=\"hljs-comment\"\u003e// 允许客户端向地址 `demo.orderMgr` 发送消息\u003c/span\u003e\nPermittedOptions inboundPermitted1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddress(\u003cspan class=\"hljs-string\"\u003e\"demo.orderMgr\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 允许客户端向地址 `demo.persistor` 发送\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 包含有 `action` 的值为 `find`、\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `collecton` 的值为 `albums` 的消息。\u003c/span\u003e\nPermittedOptions inboundPermitted2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddress(\u003cspan class=\"hljs-string\"\u003e\"demo.persistor\"\u003c/span\u003e)\n  .setMatch(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"action\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"find\"\u003c/span\u003e)\n    .put(\u003cspan class=\"hljs-string\"\u003e\"collection\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"albums\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// 允许 `wibble` 值为 `foo` 的消息。\u003c/span\u003e\nPermittedOptions inboundPermitted3 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setMatch(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"wibble\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// 让我们定义 服务端 -\u0026gt; 客户端 发送消息匹配规则\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 允许向客户端发送地址为 `ticker.mystock` 的消息\u003c/span\u003e\nPermittedOptions outboundPermitted1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddress(\u003cspan class=\"hljs-string\"\u003e\"ticker.mystock\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 允许向客户端发送地址以 `news.` 开头的消息\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//（例如 news.europe, news.usa, 等）\u003c/span\u003e\nPermittedOptions outboundPermitted2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddressRegex(\u003cspan class=\"hljs-string\"\u003e\"news\\\\..+\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 让我们定义 客户端 -\u0026gt; 客户端 发送消息匹配规则\u003c/span\u003e\nSockJSBridgeOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSBridgeOptions().\n  addInboundPermitted(inboundPermitted1).\n  addInboundPermitted(inboundPermitted1).\n  addInboundPermitted(inboundPermitted3).\n  addOutboundPermitted(outboundPermitted1).\n  addOutboundPermitted(outboundPermitted2);\n\n\u003cspan class=\"hljs-comment\"\u003e// 将连接桥挂载到路由器上\u003c/span\u003e\nrouter.mountSubRouter(\u003cspan class=\"hljs-string\"\u003e\"/eventbus\"\u003c/span\u003e, sockJSHandler.bridge(options));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_requiring_authorization_for_messages\"\u003e\u003ca class=\"anchor\" href=\"#_requiring_authorization_for_messages\"\u003e\u003c/a\u003e消息授权\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e连接桥可使用 Vert.x Web 的授权功能以配置消息的访问权限，\n同时支持输入和输出的消息。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e为此，您可通过向上文所述的匹配规则中加入额外的字段\n以指定匹配需要哪些权限。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setRequiredAuthority-java.lang.String-\"\u003esetRequiredAuthority\u003c/a\u003e\u003c/code\u003e\n方法来指定对于登录用户，需要具有哪些权限才允许访问这个消息。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以下是例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ePermittedOptions inboundPermitted = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddress(\u003cspan class=\"hljs-string\"\u003e\"demo.orderService\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 仅限用户已登录并且拥有权限 `place_orders`\u003c/span\u003e\ninboundPermitted.setRequiredAuthority(\u003cspan class=\"hljs-string\"\u003e\"place_orders\"\u003c/span\u003e);\n\nSockJSBridgeOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e用户需要登录，并被授权才能够访问消息。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e因此，您需要配置一个 Vert.x 认证处理器来处理登录和授权。例如：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// 允许客户端向 `demo.orderService` 发送消息\u003c/span\u003e\nPermittedOptions inboundPermitted = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddress(\u003cspan class=\"hljs-string\"\u003e\"demo.orderService\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 仅限用户已登录并且拥有权限 `place_orders`\u003c/span\u003e\ninboundPermitted.setRequiredAuthority(\u003cspan class=\"hljs-string\"\u003e\"place_orders\"\u003c/span\u003e);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// 设置基础认证处理器：\u003c/span\u003e\n\nrouter.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\nAuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);\n\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/eventbus/*\"\u003c/span\u003e).handler(basicAuthHandler);\n\n\u003cspan class=\"hljs-comment\"\u003e// 将连接桥挂载到路由器上\u003c/span\u003e\nrouter.mountSubRouter(\n  \u003cspan class=\"hljs-string\"\u003e\"/eventbus\"\u003c/span\u003e,\n  sockJSHandler.bridge(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSBridgeOptions()\n    .addInboundPermitted(inboundPermitted)));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_handling_event_bus_bridge_events\"\u003e\u003ca class=\"anchor\" href=\"#_handling_event_bus_bridge_events\"\u003e\u003c/a\u003eHandling event bus bridge events\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you want to be notified when an event occurs on the bridge you can provide a handler when calling\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-io.vertx.core.Handler-\"\u003ebridge\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhenever an event occurs on the bridge it will be passed to the handler. The event is described by an instance of\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/BridgeEvent.html\"\u003eBridgeEvent\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe event can be one of the following types:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"dlist\"\u003e\n\u003cdl\u003e\n\u003cdt class=\"hdlist1\"\u003eSOCKET_CREATED\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when a new SockJS socket is created.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003eSOCKET_IDLE\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when SockJS socket is on idle for longer period of time than initially configured.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003eSOCKET_PING\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when the last ping timestamp is updated for the SockJS socket.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003eSOCKET_CLOSED\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when a SockJS socket is closed.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003eSEND\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when a message is attempted to be sent from the client to the server.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003ePUBLISH\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when a message is attempted to be published from the client to the server.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003eRECEIVE\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when a message is attempted to be delivered from the server to the client.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003eREGISTER\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when a client attempts to register a handler.\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003eUNREGISTER\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003eThis event will occur when a client attempts to unregister a handler.\u003c/p\u003e\n\u003c/dd\u003e\n\u003c/dl\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe event enables you to retrieve the type using \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#type--\"\u003etype\u003c/a\u003e\u003c/code\u003e and\ninspect the raw message of the event using \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#getRawMessage--\"\u003egetRawMessage\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe raw message is a JSON object with the following structure:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e{\n \"type\": \"send\"|\"publish\"|\"receive\"|\"register\"|\"unregister\",\n \"address\": the event bus address being sent/published/registered/unregistered\n \"body\": the body of the message\n}\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe event is also an instance of \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/Promise.html\"\u003ePromise\u003c/a\u003e\u003c/code\u003e. When you are finished handling the event you can\ncomplete the promise with \u003ccode\u003etrue\u003c/code\u003e to enable further processing.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you don\u0026#8217;t want the event to be processed you can complete the promise with \u003ccode\u003efalse\u003c/code\u003e. This is a useful feature that\nenables you to do your own filtering on messages passing through the bridge, or perhaps apply some fine grained\nauthorization or metrics.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example where we reject all messages flowing through the bridge if they contain the word \"Armadillos\".\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// Let through any messages sent to 'demo.orderMgr' from the client\u003c/span\u003e\nPermittedOptions inboundPermitted = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddress(\u003cspan class=\"hljs-string\"\u003e\"demo.someService\"\u003c/span\u003e);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted);\n\n\u003cspan class=\"hljs-comment\"\u003e// mount the bridge on the router\u003c/span\u003e\nrouter\n  .mountSubRouter(\u003cspan class=\"hljs-string\"\u003e\"/eventbus\"\u003c/span\u003e, sockJSHandler\n    .bridge(options, be -\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (be.type() == BridgeEventType.PUBLISH ||\n        be.type() == BridgeEventType.RECEIVE) {\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (be.getRawMessage().getString(\u003cspan class=\"hljs-string\"\u003e\"body\"\u003c/span\u003e).equals(\u003cspan class=\"hljs-string\"\u003e\"armadillos\"\u003c/span\u003e)) {\n          \u003cspan class=\"hljs-comment\"\u003e// Reject it\u003c/span\u003e\n          be.complete(\u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e);\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n        }\n      }\n      be.complete(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n    }));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHere\u0026#8217;s an example how to configure and handle SOCKET_IDLE bridge event type.\nNotice \u003ccode\u003esetPingTimeout(5000)\u003c/code\u003e which says that if ping message doesn\u0026#8217;t arrive from client within 5 seconds\nthen the SOCKET_IDLE bridge event would be triggered.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// Initialize SockJS handler\u003c/span\u003e\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted)\n  .setPingTimeout(\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// mount the bridge on the router\u003c/span\u003e\nrouter\n  .mountSubRouter(\u003cspan class=\"hljs-string\"\u003e\"/eventbus\"\u003c/span\u003e, sockJSHandler.bridge(options, be -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (be.type() == BridgeEventType.SOCKET_IDLE) {\n      \u003cspan class=\"hljs-comment\"\u003e// Do some custom handling...\u003c/span\u003e\n    }\n\n    be.complete(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n  }));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn client side JavaScript you use the 'vertx-eventbus.js` library to create connections to the event bus and to send and receive messages:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js'\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eb = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e EventBus(\u003cspan class=\"hljs-string\"\u003e'http://localhost:8080/eventbus'\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"vertxbus_ping_interval\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300000\u003c/span\u003e}); \u003cspan class=\"hljs-comment\"\u003e// sends ping every 5 minutes.\u003c/span\u003e\n\neb.onopen = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n\n\u003cspan class=\"hljs-comment\"\u003e// set a handler to receive a message\u003c/span\u003e\neb.registerHandler(\u003cspan class=\"hljs-string\"\u003e'some-address'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerror, message\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'received a message: '\u003c/span\u003e + \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(message));\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// send a message\u003c/span\u003e\neb.send(\u003cspan class=\"hljs-string\"\u003e'some-address'\u003c/span\u003e, {\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'tim'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e587\u003c/span\u003e});\n}\n\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe first thing the example does is to create a instance of the event bus\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eb = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e EventBus(\u003cspan class=\"hljs-string\"\u003e'http://localhost:8080/eventbus'\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"vertxbus_ping_interval\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300000\u003c/span\u003e});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe 2nd parameter to the constructor tells the sockjs library to send ping message every 5 minutes. since the server\nwas configured to expect ping every 5 seconds \u0026#8594; \u003ccode\u003eSOCKET_IDLE\u003c/code\u003e would be triggered on the server.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou can also amend the raw message, e.g. change the body. For messages that are flowing in from the client you can\nalso add headers to the message, here\u0026#8217;s an example:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRouter router = Router.router(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// Let through any messages sent to 'demo.orderService' from the client\u003c/span\u003e\nPermittedOptions inboundPermitted = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e PermittedOptions()\n  .setAddress(\u003cspan class=\"hljs-string\"\u003e\"demo.orderService\"\u003c/span\u003e);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted);\n\n\u003cspan class=\"hljs-comment\"\u003e// mount the bridge on the router\u003c/span\u003e\nrouter.mountSubRouter(\n  \u003cspan class=\"hljs-string\"\u003e\"/eventbus\"\u003c/span\u003e,\n  sockJSHandler.bridge(options, be -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n      be.type() == BridgeEventType.PUBLISH ||\n        be.type() == BridgeEventType.SEND) {\n\n      \u003cspan class=\"hljs-comment\"\u003e// Add some headers\u003c/span\u003e\n      JsonObject headers = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject()\n        .put(\u003cspan class=\"hljs-string\"\u003e\"header1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"val\"\u003c/span\u003e)\n        .put(\u003cspan class=\"hljs-string\"\u003e\"header2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"val2\"\u003c/span\u003e);\n\n      JsonObject rawMessage = be.getRawMessage();\n      rawMessage.put(\u003cspan class=\"hljs-string\"\u003e\"headers\"\u003c/span\u003e, headers);\n      be.setRawMessage(rawMessage);\n    }\n    be.complete(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n  }));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_csrf_cross_site_request_forgery\"\u003e\u003ca class=\"anchor\" href=\"#_csrf_cross_site_request_forgery\"\u003e\u003c/a\u003eCSRF Cross Site Request Forgery\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eCSRF or sometimes also known as XSRF is a technique by which an unauthorized site can gain your user\u0026#8217;s private data.\nVert.x-Web includes a handler \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/handler/CSRFHandler.html\"\u003eCSRFHandler\u003c/a\u003e\u003c/code\u003e that you can use to prevent cross site\nrequest forgery requests.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eOn each get request under this handler a cookie is added to the response with a unique token. Clients are then\nexpected to return this token back in a header. Since cookies are sent it is required that the cookie handler is also\npresent on the router.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen developing non single page applications that rely on the User-Agent to perform the \u003ccode\u003ePOST\u003c/code\u003e action, Headers cannot\nbe specified on HTML Forms. In order to solve this problem the header value will also be checked if and only if no\nheader was present in the Form attributes under the same name as the header, e.g.:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/submit\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"hidden\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"X-XSRF-TOKEN\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"abracadabra\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIt is the responsibility of the user to fill in the right value for the form field. Users who prefer to use an HTML\nonly solution can fill this value by fetching the the token value from the routing context under the key \u003ccode\u003eX-XSRF-TOKEN\u003c/code\u003e\nor the header name they have chosen during the instantiation of the \u003ccode\u003eCSRFHandler\u003c/code\u003e object.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(CSRFHandler.create(vertx, \u003cspan class=\"hljs-string\"\u003e\"abracadabra\"\u003c/span\u003e));\nrouter.route().handler(ctx -\u0026gt; {\n\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eNote that this handler is session aware. If there is a session available the form parameter or header might be omited\nduring the \u003ccode\u003ePOST\u003c/code\u003e action as it will be read from the session. This also implies that tokens will only be regenerated\non session upgrades.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eNote, for extra security users are advised to rotate the key that signs the tokens. This can be done online by replacing\nthe handler, or by restarting the application with a new configuration. Clickjacking could still affect applications. If\nthis is a critical application consider setting the header: \u003ccode\u003eX-Frame-Options\u003c/code\u003e as described in:\n\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\" class=\"bare\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_using_ajax\"\u003e\u003ca class=\"anchor\" href=\"#_using_ajax\"\u003e\u003c/a\u003eUsing AJAX\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWhen accessing protected routes via ajax both the csrf token will need to be passed in the request. Typically this is\ndone using a request header, as adding a request header can typically be done at a central location easily without\npayload modification.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe CSRF token is obtained from the server side context under the key \u003ccode\u003eX-XSRF-TOKEN\u003c/code\u003e (unless you specified a different\nname). This token needs to be exposed to the client-side, typically by including it in the initial page content. One\npossibility is to store it in an HTML \u0026lt;meta\u0026gt; tag, where value can then be retrieved at the time of the request by\nJavaScript.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe following can be included in your view (handlebar example below):\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"csrf-token\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"${X-XSRF-TOKEN}\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe following is an example of using the Fetch API to post to the /process route with the CSRF token from the \u0026lt;meta\u0026gt;\ntag on the page:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Read the CSRF token from the \u0026lt;meta\u0026gt; tag\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e token = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.querySelector(\u003cspan class=\"hljs-string\"\u003e'meta[name=\"csrf-token\"]'\u003c/span\u003e).getAttribute(\u003cspan class=\"hljs-string\"\u003e'content'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// Make a request using the Fetch API\u003c/span\u003e\nfetch(\u003cspan class=\"hljs-string\"\u003e'/process'\u003c/span\u003e, {\n \u003cspan class=\"hljs-attr\"\u003ecredentials\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'same-origin'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// \u0026lt;-- includes cookies in the request\u003c/span\u003e\n \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n   \u003cspan class=\"hljs-string\"\u003e'X-XSRF-TOKEN'\u003c/span\u003e: token \u003cspan class=\"hljs-comment\"\u003e// \u0026lt;-- is the csrf token as a header\u003c/span\u003e\n },\n \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: {\n   \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e\n }\n})\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_hsts_handler\"\u003e\u003ca class=\"anchor\" href=\"#_hsts_handler\"\u003e\u003c/a\u003eHSTS Handler\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHTTP Strict Transport Security (HSTS) is a web security policy mechanism that helps to protect websites against\nman-in-the-middle attacks such as protocol downgrade attacks and cookie hijacking. It allows web servers to declare that\nweb browsers (or other complying user agents) should automatically interact with it using only HTTPS connections, which\nprovide Transport Layer Security (TLS/SSL), unlike the insecure HTTP used alone. HSTS is an IETF standards track\nprotocol and is specified in RFC 6797.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis handler will configure the correct header for your application in a single step:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(HSTSHandler.create());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_csp_handler\"\u003e\u003ca class=\"anchor\" href=\"#_csp_handler\"\u003e\u003c/a\u003eCSP Handler\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eContent Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of\nattacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from\ndata theft to site defacement to distribution of malware.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eCSP is designed to be fully backward compatible. Browsers that don\u0026#8217;t support it still work with servers that\nimplement it, and vice-versa: browsers that don\u0026#8217;t support CSP simply ignore it, functioning as usual, defaulting to\nthe standard same-origin policy for web content. If the site doesn\u0026#8217;t offer the CSP header, browsers likewise use the\nstandard same-origin policy.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(\n  CSPHandler.create()\n    .addDirective(\u003cspan class=\"hljs-string\"\u003e\"default-src\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"*.trusted.com\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_xframe_handler\"\u003e\u003ca class=\"anchor\" href=\"#_xframe_handler\"\u003e\u003c/a\u003eXFrame Handler\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe \u003ccode\u003eX-Frame-Options\u003c/code\u003e HTTP response header can be used to indicate whether or not a browser should be allowed to render\na page in a \u003ccode\u003eframe\u003c/code\u003e, \u003ccode\u003eiframe\u003c/code\u003e, \u003ccode\u003eembed\u003c/code\u003e or \u003ccode\u003eobject\u003c/code\u003e. Sites can use this to avoid click-jacking attacks, by ensuring that\ntheir content is not embedded into other sites.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe added security is provided only if the user accessing the document is using a browser that supports\n\u003ccode\u003eX-Frame-Options\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIf you specify \u003ccode\u003eDENY\u003c/code\u003e, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to\ndo so will fail when loaded from the same site. On the other hand, if you specify \u003ccode\u003eSAMEORIGIN\u003c/code\u003e, you can still use the\npage in a frame as long as the site including it in a frame is the same as the one serving the page.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis handler will configure the correct header for your application in a single step:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(XFrameHandler.create(XFrameHandler.DENY));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_oauth2authhandler_handler\"\u003e\u003ca class=\"anchor\" href=\"#_oauth2authhandler_handler\"\u003e\u003c/a\u003eOAuth2AuthHandler Handler\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe \u003ccode\u003eOAuth2AuthHandler\u003c/code\u003e allows quick setup of secure routes using the OAuth2 protocol. This handler simplifies the\nauthCode flow. An example of using it to protect some resource and authenticate with GitHub can be implemented as:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eOAuth2Auth authProvider = GithubAuth\n  .create(vertx, \u003cspan class=\"hljs-string\"\u003e\"CLIENT_ID\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"CLIENT_SECRET\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// create a oauth2 handler on our running server\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// the second argument is the full url to the\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// callback as you entered in your provider management console.\u003c/span\u003e\nOAuth2AuthHandler oauth2 = OAuth2AuthHandler\n  .create(vertx, authProvider, \u003cspan class=\"hljs-string\"\u003e\"https://myserver.com/callback\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// setup the callback handler for receiving the GitHub callback\u003c/span\u003e\noauth2.setupCallback(router.route());\n\n\u003cspan class=\"hljs-comment\"\u003e// protect everything under /protected\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/protected/*\"\u003c/span\u003e).handler(oauth2);\n\u003cspan class=\"hljs-comment\"\u003e// mount some handler under the protected zone\u003c/span\u003e\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/protected/somepage\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; ctx.response().end(\u003cspan class=\"hljs-string\"\u003e\"Welcome to the protected resource!\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// welcome page\u003c/span\u003e\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; ctx.response()\n    .putHeader(\u003cspan class=\"hljs-string\"\u003e\"content-type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"text/html\"\u003c/span\u003e)\n    .end(\u003cspan class=\"hljs-string\"\u003e\"Hello\u0026lt;br\u0026gt;\u0026lt;a href=\\\"/protected/somepage\\\"\u0026gt;Protected by Github\u0026lt;/a\u0026gt;\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe OAuth2AuthHandler will setup a proper callback OAuth2 handler so the user does not need to deal with validation\nof the authority server response. It is quite important to know that authority server responses are only valid once,\nthis means that if a client issues a reload of the callback URL it will be asserted as a invalid request since the\nvalidation will fail.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eA rule of thumb is once a valid callback is executed issue a client side redirect to a protected resource. This\nredirect should also create a session cookie (or other session mechanism) so the user is not required to authenticate\nfor every request.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eDue to the nature of OAuth2 spec there are slight changes required in order to use other OAuth2 providers but\nvertx-auth provides you with many out of the box implementations:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAzure Active Directory \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/AzureADAuth.html\"\u003eAzureADAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBox.com \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/BoxAuth.html\"\u003eBoxAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDropbox \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/DropboxAuth.html\"\u003eDropboxAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFacebook \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FacebookAuth.html\"\u003eFacebookAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFoursquare \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FoursquareAuth.html\"\u003eFoursquareAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGithub \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GithubAuth.html\"\u003eGithubAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGoogle \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GoogleAuth.html\"\u003eGoogleAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eInstagram \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/InstagramAuth.html\"\u003eInstagramAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eKeycloak \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/KeycloakAuth.html\"\u003eKeycloakAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eLinkedIn \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/LinkedInAuth.html\"\u003eLinkedInAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMailchimp \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/MailchimpAuth.html\"\u003eMailchimpAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSalesforce \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SalesforceAuth.html\"\u003eSalesforceAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eShopify \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/ShopifyAuth.html\"\u003eShopifyAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSoundcloud \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SoundcloudAuth.html\"\u003eSoundcloudAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eStripe \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/StripeAuth.html\"\u003eStripeAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTwitter \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/TwitterAuth.html\"\u003eTwitterAuth\u003c/a\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eHowever if you\u0026#8217;re using an unlisted provider you can still do it using the base API like this:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eOAuth2Auth authProvider = OAuth2Auth.create(vertx, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e OAuth2Options()\n  .setClientID(\u003cspan class=\"hljs-string\"\u003e\"CLIENT_ID\"\u003c/span\u003e)\n  .setClientSecret(\u003cspan class=\"hljs-string\"\u003e\"CLIENT_SECRET\"\u003c/span\u003e)\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setSite(\u003cspan class=\"hljs-string\"\u003e\"https://accounts.google.com\"\u003c/span\u003e)\n  .setTokenPath(\u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/oauth2/v3/token\"\u003c/span\u003e)\n  .setAuthorizationPath(\u003cspan class=\"hljs-string\"\u003e\"/o/oauth2/auth\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// create a oauth2 handler on our domain: \"http://localhost:8080\"\u003c/span\u003e\nOAuth2AuthHandler oauth2 = OAuth2AuthHandler\n  .create(vertx, authProvider, \u003cspan class=\"hljs-string\"\u003e\"http://localhost:8080\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// these are the scopes\u003c/span\u003e\noauth2.withScope(\u003cspan class=\"hljs-string\"\u003e\"profile\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// setup the callback handler for receiving the Google callback\u003c/span\u003e\noauth2.setupCallback(router.get(\u003cspan class=\"hljs-string\"\u003e\"/callback\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// protect everything under /protected\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/protected/*\"\u003c/span\u003e).handler(oauth2);\n\u003cspan class=\"hljs-comment\"\u003e// mount some handler under the protected zone\u003c/span\u003e\nrouter\n  .route(\u003cspan class=\"hljs-string\"\u003e\"/protected/somepage\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; ctx.response().end(\u003cspan class=\"hljs-string\"\u003e\"Welcome to the protected resource!\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// welcome page\u003c/span\u003e\nrouter\n  .get(\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e)\n  .handler(ctx -\u0026gt; ctx.response()\n    .putHeader(\u003cspan class=\"hljs-string\"\u003e\"content-type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"text/html\"\u003c/span\u003e)\n    .end(\u003cspan class=\"hljs-string\"\u003e\"Hello\u0026lt;br\u0026gt;\u0026lt;a href=\\\"/protected/somepage\\\"\u0026gt;Protected by Google\u0026lt;/a\u0026gt;\"\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou will need to provide all the details of your provider manually but the end result is the same.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe handler will pin your application the the configured callback url. The usage is simple as providing the handler\na route instance and all setup will be done for you. In a typical use case your provider will ask you what is the\ncallback url to your application, your then enter a url like: \u003ccode\u003e\u003ca href=\"https://myserver.com/callback\" class=\"bare\"\u003ehttps://myserver.com/callback\u003c/a\u003e\u003c/code\u003e. This is the second\nargument to the handler now you just need to set it up. To make it easier to the end user all you need to do is call\nthe setupCallback method.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis is how you pin your handler to the server \u003ccode\u003e\u003ca href=\"https://myserver.com:8447/callback\" class=\"bare\"\u003ehttps://myserver.com:8447/callback\u003c/a\u003e\u003c/code\u003e. Note that the port number is not\nmandatory for the default values, 80 for http, 443 for https.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eOAuth2AuthHandler oauth2 = OAuth2AuthHandler\n  .create(vertx, provider, \u003cspan class=\"hljs-string\"\u003e\"https://myserver.com:8447/callback\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// now allow the handler to setup the callback url for you\u003c/span\u003e\noauth2.setupCallback(router.route());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn the example the route object is created inline by \u003ccode\u003eRouter.route()\u003c/code\u003e however if you want to have full control of the\norder the handler is called (for example you want it to be called as soon as possible in the chain) you can always\ncreate the route object before and pass it as a reference to this method.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_a_real_world_example\"\u003e\u003ca class=\"anchor\" href=\"#_a_real_world_example\"\u003e\u003c/a\u003eA real world example\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eUp to now you have learned how to use the Oauth2 Handler however you will notice that for each request you will need\nto authenticate. This is because the handler has no state and there was no state management applied in the examples.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAlthough having no state is recommended for API facing endpoints, for example, using JWT (we will cover those later)\nfor user facing endpoinst we can keep the authentication result stored in the session. For this to work we would\nneed an application like the following snippet:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eOAuth2Auth authProvider =\n  GithubAuth\n    .create(vertx, \u003cspan class=\"hljs-string\"\u003e\"CLIENTID\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"CLIENT SECRET\"\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// We need a user session handler too to make sure\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// the user is stored in the session between requests\u003c/span\u003e\nrouter.route()\n  .handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\u003cspan class=\"hljs-comment\"\u003e// we now protect the resource under the path \"/protected\"\u003c/span\u003e\nrouter.route(\u003cspan class=\"hljs-string\"\u003e\"/protected\"\u003c/span\u003e).handler(\n  OAuth2AuthHandler.create(vertx, authProvider)\n    \u003cspan class=\"hljs-comment\"\u003e// we now configure the oauth2 handler, it will\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// setup the callback handler\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// as expected by your oauth2 provider.\u003c/span\u003e\n    .setupCallback(router.route(\u003cspan class=\"hljs-string\"\u003e\"/callback\"\u003c/span\u003e))\n    \u003cspan class=\"hljs-comment\"\u003e// for this resource we require that users have\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// the authority to retrieve the user emails\u003c/span\u003e\n    .withScope(\u003cspan class=\"hljs-string\"\u003e\"user:email\"\u003c/span\u003e)\n);\n\u003cspan class=\"hljs-comment\"\u003e// Entry point to the application, this will render\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// a custom template.\u003c/span\u003e\nrouter.get(\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e).handler(ctx -\u0026gt; ctx.response()\n  .putHeader(\u003cspan class=\"hljs-string\"\u003e\"Content-Type\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"text/html\"\u003c/span\u003e)\n  .end(\n    \u003cspan class=\"hljs-string\"\u003e\"\u0026lt;html\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"  \u0026lt;body\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"    \u0026lt;p\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"      Well, hello there!\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"    \u0026lt;/p\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"    \u0026lt;p\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"      We're going to the protected resource, if there is no\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"      user in the session we will talk to the GitHub API. Ready?\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"      \u0026lt;a href=\\\"/protected\\\"\u0026gt;Click here\u0026lt;/a\u0026gt; to begin!\u0026lt;/a\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"    \u0026lt;/p\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"    \u0026lt;p\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"      \u0026lt;b\u0026gt;If that link doesn't work\u0026lt;/b\u0026gt;, remember to provide your\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"      own \u0026lt;a href=\\\"https://github.com/settings/applications/new\\\"\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"      Client ID\u0026lt;/a\u0026gt;!\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"    \u0026lt;/p\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"  \u0026lt;/body\u0026gt;\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"\u0026lt;/html\u0026gt;\"\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// The protected resource\u003c/span\u003e\nrouter.get(\u003cspan class=\"hljs-string\"\u003e\"/protected\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// at this moment your user object should contain the info\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// from the Oauth2 response, since this is a protected resource\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// as specified above in the handler config the user object is never null\u003c/span\u003e\n  User user = ctx.user();\n  \u003cspan class=\"hljs-comment\"\u003e// just dump it to the client for demo purposes\u003c/span\u003e\n  ctx.response().end(user.toString());\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_mixing_oauth2_and_jwt\"\u003e\u003ca class=\"anchor\" href=\"#_mixing_oauth2_and_jwt\"\u003e\u003c/a\u003eMixing OAuth2 and JWT\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSome providers use JWT tokens as access tokens, this is a feature of \u003ca href=\"https://tools.ietf.org/html/rfc6750\"\u003eRFC6750\u003c/a\u003e\nand can be quite useful when one wants to mix client based authentication and API authorization. For example say that\nyou have a application that provides some protected HTML documents but you also want it to be available for API\u0026#8217;s to\nconsume. In this case an API cannot easily perform the redirect handshake required by OAuth2 but can use a Token\nprovided before hand.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThis is handled automatically by the handler as long as the provider is configured to support JWTs.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eIn real life this means that your API\u0026#8217;s can access your protected resources using the header \u003ccode\u003eAuthorization\u003c/code\u003e with the\nvalue \u003ccode\u003eBearer BASE64_ACCESS_TOKEN\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_webauthn\"\u003e\u003ca class=\"anchor\" href=\"#_webauthn\"\u003e\u003c/a\u003eWebAuthn\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eOur online existence relies on an outdated and fragile idea of passwords. The password is what lies between a malicious\nuser and your bank account or social media accounts. Passwords are hard to maintain; it\u0026#8217;s hard to store them on the\nserver (passwords get stolen). They\u0026#8217;re hard to memorize, or not tell to others (phishing attacks).\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBut there\u0026#8217;s a better way! A passwordless world, and it is a standard by W3C and FIDO Alliance running on your browser.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eWebAuthn is an API that allows servers to register and authenticate users using public-key cryptography instead of a\npassword, an API that uses cryptography in a user-accessible way with the help of an authentication device, for example\na yubikey token, or your mobile phone.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe protocol requires at least the first callback to be mounted on the router:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/webauthn/response\u003c/code\u003e the callback used to perform all the validations\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/webauthn/login\u003c/code\u003e the endpoint to allow users to start the login flow (optional, but without it it won\u0026#8217;t be able to login)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/webauthn/register\u003c/code\u003e the endpoint to allow users to register a new identificator (optional, if the data is already stored this endpoint is not needed)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAn example of a protected application is:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eWebAuthn webAuthn = WebAuthn.create(\n  vertx,\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e WebAuthnOptions()\n    .setRelyingParty(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RelyingParty().setName(\u003cspan class=\"hljs-string\"\u003e\"Vert.x WebAuthN Demo\"\u003c/span\u003e))\n    \u003cspan class=\"hljs-comment\"\u003e// What kind of authentication do you want? do you care?\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// # security keys\u003c/span\u003e\n    .setAuthenticatorAttachment(AuthenticatorAttachment.CROSS_PLATFORM)\n    \u003cspan class=\"hljs-comment\"\u003e// # fingerprint\u003c/span\u003e\n    .setAuthenticatorAttachment(AuthenticatorAttachment.PLATFORM)\n    .setUserVerification(UserVerification.REQUIRED))\n  \u003cspan class=\"hljs-comment\"\u003e// where to load the credentials from?\u003c/span\u003e\n  .authenticatorFetcher(fetcher)\n  \u003cspan class=\"hljs-comment\"\u003e// update the state of an authenticator\u003c/span\u003e\n  .authenticatorUpdater(updater);\n\n\u003cspan class=\"hljs-comment\"\u003e// parse the BODY\u003c/span\u003e\nrouter.post()\n  .handler(BodyHandler.create());\n\u003cspan class=\"hljs-comment\"\u003e// add a session handler\u003c/span\u003e\nrouter.route()\n  .handler(SessionHandler\n    .create(LocalSessionStore.create(vertx)));\n\n\u003cspan class=\"hljs-comment\"\u003e// security handler\u003c/span\u003e\nWebAuthnHandler webAuthNHandler = WebAuthnHandler.create(webAuthn)\n  .setOrigin(\u003cspan class=\"hljs-string\"\u003e\"https://192.168.178.74.xip.io:8443\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-comment\"\u003e// required callback\u003c/span\u003e\n  .setupCallback(router.post(\u003cspan class=\"hljs-string\"\u003e\"/webauthn/response\"\u003c/span\u003e))\n  \u003cspan class=\"hljs-comment\"\u003e// optional register callback\u003c/span\u003e\n  .setupCredentialsCreateCallback(router.post(\u003cspan class=\"hljs-string\"\u003e\"/webauthn/register\"\u003c/span\u003e))\n  \u003cspan class=\"hljs-comment\"\u003e// optional login callback\u003c/span\u003e\n  .setupCredentialsGetCallback(router.post(\u003cspan class=\"hljs-string\"\u003e\"/webauthn/login\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// secure the remaining routes\u003c/span\u003e\nrouter.route().handler(webAuthNHandler);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe application is not secure on the backend side but there is some code needed to be performed on the client side. A bit\nof boilerplate is required, take these 2 functions:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n* Converts PublicKeyCredential into serialised JSON\n* \u003cspan class=\"hljs-doctag\"\u003e@param  \u003cspan class=\"hljs-type\"\u003e{Object}\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epubKeyCred\u003c/span\u003e\u003c/span\u003e\n* \u003cspan class=\"hljs-doctag\"\u003e@return \u003cspan class=\"hljs-type\"\u003e{Object}\u003c/span\u003e            \u003c/span\u003e- JSON encoded publicKeyCredential\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e publicKeyCredentialToJSON = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epubKeyCred\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pubKeyCred \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e) {\n   \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e arr = [];\n   \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e pubKeyCred) { arr.push(publicKeyCredentialToJSON(i)) }\n\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr\n }\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pubKeyCred \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eArrayBuffer\u003c/span\u003e) {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e base64url.encode(pubKeyCred)\n }\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pubKeyCred \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e) {\n   \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e obj = {};\n\n   \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e pubKeyCred) {\n     obj[key] = publicKeyCredentialToJSON(pubKeyCred[key])\n   }\n\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e obj\n }\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e pubKeyCred\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n* Generate secure random buffer\n* @param  {Number} len - Length of the buffer (default 32 bytes)\n* @return {Uint8Array} - random string\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e generateRandomBuffer = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003elen\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n len = len || \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e;\n\n \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e randomBuffer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eUint8Array\u003c/span\u003e(len);\n \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.crypto.getRandomValues(randomBuffer);\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e randomBuffer\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n* Decodes arrayBuffer required fields.\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e preformatMakeCredReq = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emakeCredReq\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n makeCredReq.challenge = base64url.decode(makeCredReq.challenge);\n makeCredReq.user.id = base64url.decode(makeCredReq.user.id);\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e makeCredReq\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n* Decodes arrayBuffer required fields.\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e preformatGetAssertReq = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003egetAssert\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n getAssert.challenge = base64url.decode(getAssert.challenge);\n\n \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e allowCred \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e getAssert.allowCredentials) {\n   allowCred.id = base64url.decode(allowCred.id)\n }\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e getAssert\n};\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThese functions will help you with the interaction with the server. Nothing more. Let\u0026#8217;s start by login in a user:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// using the functions defined before...\u003c/span\u003e\ngetGetAssertionChallenge({\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'your-user-name'\u003c/span\u003e})\n.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-comment\"\u003e// base64 must be decoded to a JavaScript Buffer\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e publicKey = preformatGetAssertReq(response);\n \u003cspan class=\"hljs-comment\"\u003e// the response is then passed to the browser\u003c/span\u003e\n \u003cspan class=\"hljs-comment\"\u003e// to generate an assertion by interacting with your token/phone/etc...\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e navigator.credentials.get({publicKey})\n})\n.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-comment\"\u003e// convert response buffers to base64 and json\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e getAssertionResponse = publicKeyCredentialToJSON(response);\n \u003cspan class=\"hljs-comment\"\u003e// send information to server\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sendWebAuthnResponse(getAssertionResponse)\n})\n.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-comment\"\u003e// success!\u003c/span\u003e\n alert(\u003cspan class=\"hljs-string\"\u003e'Login success'\u003c/span\u003e)\n})\n.catch(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u0026gt;\u003c/span\u003e alert(error));\n\n\u003cspan class=\"hljs-comment\"\u003e// utility functions\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sendWebAuthnResponse = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ebody\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/webauthn/response'\u003c/span\u003e, {\n   \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003ecredentials\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'include'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n     \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e\n   },\n   \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(body)\n })\n   .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n     \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!response.ok) {\n       \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Server responded with error: \u003cspan class=\"hljs-subst\"\u003e${response.statusText}\u003c/span\u003e`\u003c/span\u003e);\n     }\n     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response;\n   })\n};\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e getGetAssertionChallenge = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eformBody\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/webauthn/login'\u003c/span\u003e, {\n   \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003ecredentials\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'include'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n     \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e\n   },\n   \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(formBody)\n })\n   .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n     \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!response.ok) {\n       \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Server responded with error: \u003cspan class=\"hljs-subst\"\u003e${response.statusText}\u003c/span\u003e`\u003c/span\u003e);\n     }\n     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response;\n   })\n   .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e response.json())\n};\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eThe example above already covered 66% of the API, 2 out fo 3 endpoints where covered. The final endpoint is the user\nregistration. User registration is the process of enrolling a new key into the server credential store and map to a user,\nand of course on the client side a private key was created and associated with the server but this key never left the\nhardware token or your phone security chip.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo register a user and reusing most of the functions already defined above:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* Handle for register form submission */\u003c/span\u003e\ngetMakeCredentialsChallenge({\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'myalias'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edisplayName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Paulo Lopes'\u003c/span\u003e})\n.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-comment\"\u003e// convert challenge \u0026amp; id to buffer and perform register\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e publicKey = preformatMakeCredReq(response);\n \u003cspan class=\"hljs-comment\"\u003e// create a new secure key pair\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e navigator.credentials.create({publicKey})\n})\n.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-comment\"\u003e// convert response from buffer to json\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e makeCredResponse = \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.publicKeyCredentialToJSON(response);\n \u003cspan class=\"hljs-comment\"\u003e// send to server to confirm the user\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sendWebAuthnResponse(makeCredResponse)\n})\n.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n alert(\u003cspan class=\"hljs-string\"\u003e'Registration completed'\u003c/span\u003e)\n})\n.catch(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u0026gt;\u003c/span\u003e alert(error));\n\n\u003cspan class=\"hljs-comment\"\u003e// utility functions\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e getMakeCredentialsChallenge = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eformBody\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/webauthn/register'\u003c/span\u003e, {\n   \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003ecredentials\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'include'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n     \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e\n   },\n   \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(formBody)\n })\n   .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n     \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!response.ok) {\n       \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Server responded with error: \u003cspan class=\"hljs-subst\"\u003e${response.statusText}\u003c/span\u003e`\u003c/span\u003e);\n     }\n     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response;\n   })\n   .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e response.json())\n};\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock warning\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e警告\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\nDue to the secure nature of the API browsers will not allow you to use this API on plain text HTTP. All requests\nmust go over HTTPS.\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock warning\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e警告\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\nWebAuthN requires HTTPS with a working TLS certificate, you can use self signed certiticates too during\ndevelopment.\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_handling_http_method_overriding\"\u003e\u003ca class=\"anchor\" href=\"#_handling_http_method_overriding\"\u003e\u003c/a\u003eHandling HTTP Method overriding\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMany companies and other services impose limitations to the REST HTTP methods they allow to the outside world. Some are lax by allowing any method, most are restricted by allowing only a small-but-decent set and some only allow GET and POST. The reasons for such restritions varies: browser or client limitations or a really strict corporate firewalls. Web services with only GET and POST does not express well the REST ideology. PUT, DELETE, OPTIONS, among others are quite useful to specify what do to to a resource. To deal with it, it was created the X-HTTP-METHOD-OVERRIDE HTTP header as a workaround.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eBy sending a request with GET/POST and which method the request should truly process inside the X-HTTP-METHOD-OVERRIDE HTTP header, the server should recognize the header and redirect to the appropriate method.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x allows one to do so, simply by:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(MethodOverrideHandler.create());\n\nrouter.route(HttpMethod.GET, \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do GET stuff...\u003c/span\u003e\n});\n\nrouter.route(HttpMethod.POST, \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do POST stuff...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eSince it will redirect the request, it is wise to avoid firing request handlers unnecessarily, so it is better to add the MethodOverrideHandler as the first handler.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAlso, a word of caution: THIS MIGHT BECOME AN ATTACK VECTOR FOR ILL-INTENTIONED PEOPLE!\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eTo mitigate such a problem, the MethodOverrideHandler comes with a Safe-Downgrade Policy by default. This policy says that the method contained in X-HTTP-METHOD-OVERRIDE can override the original one if:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ethe overriding method is idempotent; or\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ethe overriding method is safe and the method to be overrided is NOT idempotent; or\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ethe method to be overrided is not safe.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAlthough we do NOT recommend, Vert.x will not force you to anything. If it is your desire to allow any overriding, then:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003erouter.route().handler(MethodOverrideHandler.create(\u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e));\n\nrouter.route(HttpMethod.GET, \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do GET stuff...\u003c/span\u003e\n});\n\nrouter.route(HttpMethod.POST, \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e).handler(ctx -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// do POST stuff...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e","version":"4.0.2"},"__N_SSG":true},"page":"/docs/[[...slug]]","query":{"slug":["4.0.2","vertx-web","java"]},"buildId":"zHMoO9ldBFegbgOjRGRgi","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-9a5c89434732593ca2fd.js"></script><script src="/_next/static/chunks/main-b6e20584df76f29b6f35.js" async=""></script><script src="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" async=""></script><script src="/_next/static/chunks/framework.fcef98db13e2318579fb.js" async=""></script><script src="/_next/static/chunks/commons.5b8771ac6e8a338f82f1.js" async=""></script><script src="/_next/static/chunks/styles.7064a0f84b2a7c13404a.js" async=""></script><script src="/_next/static/chunks/pages/_app-3dbbc9c041333077c167.js" async=""></script><script src="/_next/static/chunks/5df0631eea625b022d3730b3f1bf573e1b8deb37.3b9874ba65db13e7d868.js" async=""></script><script src="/_next/static/chunks/31acfd8439b7c9eee4abe9f59c7500d6c943ee0d.0c2b12aac197391070e2.js" async=""></script><script src="/_next/static/chunks/pages/docs/%5B%5B...slug%5D%5D-f144718c033f8d0b431b.js" async=""></script><script src="/_next/static/zHMoO9ldBFegbgOjRGRgi/_buildManifest.js" async=""></script><script src="/_next/static/zHMoO9ldBFegbgOjRGRgi/_ssgManifest.js" async=""></script></body></html>