<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="description" content="Vert.x | Reactive applications on the JVM"/><meta name="robots" content="index,follow"/><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,400" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&amp;display=swap" rel="stylesheet"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48x48.png"/><link rel="alternate" type="application/rss+xml" href="/feed/rss.xml"/><link rel="alternate" type="application/atom+xml" href="/feed/atom.xml"/><link rel="alternate" type="application/json" href="/feed/feed.json"/><title>服务发现 | Eclipse Vert.x</title><link rel="preload" href="https://api.github.com/repos/vert-x3/vertx-service-discovery" as="fetch" crossorigin="anonymous"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/styles.bee17d6f.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.bee17d6f.chunk.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-b6e20584df76f29b6f35.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.fcef98db13e2318579fb.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.5b8771ac6e8a338f82f1.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.7064a0f84b2a7c13404a.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3dbbc9c041333077c167.js" as="script"/><link rel="preload" href="/_next/static/chunks/5df0631eea625b022d3730b3f1bf573e1b8deb37.2c5d42edba8dda0b0ba3.js" as="script"/><link rel="preload" href="/_next/static/chunks/31acfd8439b7c9eee4abe9f59c7500d6c943ee0d.c89fc1fca127558204bd.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/docs/%5B%5B...slug%5D%5D-3a425d1828d3af7aa498.js" as="script"/></head><body data-build-time="2021-06-07T22:53:48.181Z" data-build-commit-id="d75e5ce1c643e30f0fbcf97477fb29664a47aaae" data-build-run-id="916520509"><div id="__next"><main class="page docs"><header><div class="navbar"><div class="navbar-content container"><div class="navbar-logo"><a href="/"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAxMjMyLjYgMzE1LjIiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZT4uc3Qwe2ZpbGw6Izc4MmE5MX08L3N0eWxlPjxwYXRoIGQ9Ik0xMjAuOSAyMTQuMkwxOTAuNSAwaDUyLjNsLTk4LjUgMjczLjhIOTguMkwwIDBoNTIuMWw2OC44IDIxNC4yem0yOTEuMi02Mi42SDI5OS42djg0LjJINDMxdjM4SDI1MlYwaDE3Ny43djM4LjRIMjk5LjZWMTE0aDExMi41djM3LjZ6bTgzLjctMTEzLjJINTQ2YzE2LjUuMyAyOSA0LjQgMzcuMyAxMi40IDguMyA4IDEyLjUgMTkuNCAxMi41IDM0IDAgMTQtNC41IDI1LjEtMTMuNSAzMy4yLTkgOC4xLTIxLjYgMTIuMS0zNy42IDEyLjFoLTI3LjF2MjQuMmw4Ni4xIDExOS41aDUxdi0yLjRsLTc3LjItMTA2LjdjMjQuOS01LjUgNDMuMy0yMS43IDUyLjYtMzUuOSA4LjItMTIuNiAxMy4zLTI3LjcgMTMuMy00NiAwLTI2LjgtOC42LTQ3LjQtMjUuOC02MS41QzYwMC41IDcuMSA1NzYuMSAwIDU0NC41IDBoLTk2LjN2MjczLjhoNDcuNiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDUyLjMgMTU3LjdsLTQxLjUgNjIuNyAyOS43IDUzLjRoODUuMXoiLz48Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSI4MjcuOSIgY3k9IjI3NC43IiByPSI0MC41Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTEwMzcgMGwtNDcuNiA3NC4yTDk0OSAwaC04NGw4NS4zIDEzNS44LTY3LjEgMTA1LjdjNS43IDkuNSA5LjEgMjAuNSA5LjIgMzIuNGg1MC4xTDExMjEuMyAwSDEwMzd6Ii8+PHBhdGggZD0iTTc2My41IDI3My44Yy4xLTkuOSAyLjUtMTkuMiA2LjYtMjcuNVYzOC40aDg1LjRWMEg2MzguMnYzOC40aDg0LjZ2MjM1LjRoNDAuN3ptNDE0LTI2Ni45aC0xNS4zdjQyLjJoLTguNVY2LjloLTE1LjJWMGgzOXY2Ljl6TTExOTMgMGwxNC4yIDM3LjdMMTIyMS4zIDBoMTF2NDkuMWgtOC41VjMyLjlsLjgtMjEuNy0xNC41IDM3LjloLTYuMWwtMTQuNS0zNy44LjggMjEuNnYxNi4yaC04LjVWMGgxMS4yeiIvPjwvc3ZnPg==" alt="Vert.x Logo"/></a></div><div class="navbar-collapse-button"><span></span><span></span><span></span></div><div class="navbar-right"><div class="navbar-menu"><span class="navbar-menu-item with-drop-down"><div class="dropdown"><a class="dropdown-title">开始<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu"><a href="/introduction-to-vertx-and-reactive/"><li class="dropdown-item">简介</li></a><a href="/get-started/"><li class="dropdown-item">开始</li></a><a href="https://start.vertx.io/" target="_blank" rel="noreferrer"><li class="dropdown-item">应用生成器 <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a></ul></div></span><a class="navbar-menu-item" href="/docs/">文档</a><span class="navbar-menu-item with-drop-down"><div class="dropdown"><a class="dropdown-title">资源<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu"><a href="/faq/"><li class="dropdown-item">答疑</li></a><a href="/channels/"><li class="dropdown-item">联系渠道</li></a><a href="https://how-to.vertx.io/" target="_blank" rel="noreferrer"><li class="dropdown-item">操作指南 <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a><a href="https://github.com/vert-x3/vertx-eventbus-bridge-clients" target="_blank" rel="noreferrer"><li class="dropdown-item">EventBus Bridge Clients <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a></ul></div></span><a class="navbar-menu-item" href="/blog/">博客</a><a class="navbar-menu-item" href="/community/">社区</a><a class="navbar-menu-item" href="/translation/">翻译团队</a></div><div class="navbar-social"><a href="https://github.com/vert-x3/vertx-awesome" class="navbar-social-link" title="Awesome Vert.x" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="List of awesome Vert.x projects"><title>Awesome Vert.x</title><path d="M24 11.438l-6.154-5.645-.865.944 5.128 4.7H1.895l5.128-4.705-.865-.943-6.154 5.649H0v3.72c0 1.683 1.62 3.053 3.61 3.053h3.795c1.99 0 3.61-1.37 3.61-3.051v-2.446h1.97v2.446c0 1.68 1.62 3.051 3.61 3.051h3.794c1.99 0 3.61-1.37 3.61-3.051v-3.721z"></path></svg></a><a href="https://stackoverflow.com/questions/tagged/vert.x" class="navbar-social-link" title="Stack Overflow" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Stack Overflow questions related to Vert.x"><title>Stack Overflow</title><path d="M18.986 21.865v-6.404h2.134V24H1.844v-8.539h2.13v6.404h15.012zM6.111 19.731H16.85v-2.137H6.111v2.137zm.259-4.852l10.48 2.189.451-2.07-10.478-2.187-.453 2.068zm1.359-5.056l9.705 4.53.903-1.95-9.706-4.53-.902 1.936v.014zm2.715-4.785l8.217 6.855 1.359-1.62-8.216-6.853-1.35 1.617-.01.001zM15.751 0l-1.746 1.294 6.405 8.604 1.746-1.294L15.749 0h.002z"></path></svg></a><a href="https://www.youtube.com/channel/UCGN6L3tRhs92Uer3c6VxOSA" class="navbar-social-link" title="YouTube" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="YouTube channel of Vert.x"><title>YouTube</title><path d="M23.499 6.203a3.008 3.008 0 00-2.089-2.089c-1.87-.501-9.4-.501-9.4-.501s-7.509-.01-9.399.501a3.008 3.008 0 00-2.088 2.09A31.258 31.26 0 000 12.01a31.258 31.26 0 00.523 5.785 3.008 3.008 0 002.088 2.089c1.869.502 9.4.502 9.4.502s7.508 0 9.399-.502a3.008 3.008 0 002.089-2.09 31.258 31.26 0 00.5-5.784 31.258 31.26 0 00-.5-5.808zm-13.891 9.4V8.407l6.266 3.604z"></path></svg></a><a href="https://discord.gg/KzEMwP2" class="navbar-social-link" title="Discord" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Eclipse Vert.x channel on Discord"><title>Discord</title><path d="M20.222 0c1.406 0 2.54 1.137 2.607 2.475V24l-2.677-2.273-1.47-1.338-1.604-1.398.67 2.205H3.71c-1.402 0-2.54-1.065-2.54-2.476V2.48C1.17 1.142 2.31.003 3.715.003h16.5L20.222 0zm-6.118 5.683h-.03l-.202.2c2.073.6 3.076 1.537 3.076 1.537-1.336-.668-2.54-1.002-3.744-1.137-.87-.135-1.74-.064-2.475 0h-.2c-.47 0-1.47.2-2.81.735-.467.203-.735.336-.735.336s1.002-1.002 3.21-1.537l-.135-.135s-1.672-.064-3.477 1.27c0 0-1.805 3.144-1.805 7.02 0 0 1 1.74 3.743 1.806 0 0 .4-.533.805-1.002-1.54-.468-2.14-1.404-2.14-1.404s.134.066.335.2h.06c.03 0 .044.015.06.03v.006c.016.016.03.03.06.03.33.136.66.27.93.4.466.202 1.065.403 1.8.536.93.135 1.996.2 3.21 0 .6-.135 1.2-.267 1.8-.535.39-.2.87-.4 1.397-.737 0 0-.6.936-2.205 1.404.33.466.795 1 .795 1 2.744-.06 3.81-1.8 3.87-1.726 0-3.87-1.815-7.02-1.815-7.02-1.635-1.214-3.165-1.26-3.435-1.26l.056-.02zm.168 4.413c.703 0 1.27.6 1.27 1.335 0 .74-.57 1.34-1.27 1.34-.7 0-1.27-.6-1.27-1.334.002-.74.573-1.338 1.27-1.338zm-4.543 0c.7 0 1.266.6 1.266 1.335 0 .74-.57 1.34-1.27 1.34-.7 0-1.27-.6-1.27-1.334 0-.74.57-1.338 1.27-1.338z"></path></svg></a><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx" class="navbar-social-link" title="Vert.x 用户组" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="A Google group for Vert.x users"><title>Vert.x 用户组</title><path d="M.92 3.332c-.776 0-1.216.67-.692 1.383l2.537 4.403v7.86c0 2.013 1.467 3.69 3.459 3.69H20.31a3.75 3.75 0 003.69-3.69V7.043a3.723 3.723 0 00-3.668-3.71zm5.786 3.71H20.1c.587 0 1.153.357 1.153.923 0 .566-.566.922-1.153.922H6.706c-.587 0-1.153-.356-1.153-.922 0-.566.566-.923 1.153-.923zm0 3.69H20.1c.587 0 1.153.356 1.153.922 0 .566-.566.922-1.153.922H6.706c-.587 0-1.153-.356-1.153-.922 0-.566.566-.922 1.153-.922zm-.021 3.71h9.705c.587 0 1.153.356 1.153.922 0 .566-.566.923-1.153.923H6.685c-.587 0-1.153-.357-1.153-.923 0-.566.566-.922 1.153-.922Z"></path></svg></a><a href="https://shang.qq.com/wpa/qunwpa?idkey=587f58cacb9557e3291b46098e0fe09427b98a1c0f866da23c04c2762bc7e2ad" class="navbar-social-link" title="Vert.x中国用户组QQ群" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Vert.x中国用户组QQ群"><title>Vert.x中国用户组QQ群</title><path d="M21.395 15.035a39.548 39.548 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a38.97 38.97 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673zM12.662 4.846c.039-1.052.659-1.878 1.385-1.846s1.281.912 1.242 1.964c-.039 1.051-.659 1.878-1.385 1.846s-1.282-.912-1.242-1.964zM9.954 3c.725-.033 1.345.794 1.384 1.846.04 1.052-.517 1.931-1.242 1.963-.726.033-1.346-.794-1.385-1.845C8.672 3.912 9.228 3.033 9.954 3zM7.421 8.294c.194-.43 2.147-.908 4.566-.908h.026c2.418 0 4.372.479 4.566.908a.14.14 0 0 1 .014.061c0 .031-.01.059-.026.083-.163.238-2.333 1.416-4.553 1.416h-.026c-2.221 0-4.39-1.178-4.553-1.416a.136.136 0 0 1-.014-.144zm10.422 8.622c-.22 3.676-2.403 5.987-5.774 6.021h-.137c-3.37-.033-5.554-2.345-5.773-6.021-.081-1.35.001-2.496.147-3.43.318.063.638.122.958.176v3.506s1.658.334 3.318.103v-3.225c.488.027.96.04 1.406.034h.025c1.678.021 3.714-.204 5.683-.594.146.934.227 2.08.147 3.43zM10.48 5.804c.313-.041.542-.409.508-.825-.033-.415-.314-.72-.629-.679-.313.04-.541.409-.508.824.034.417.315.72.629.68zM14.479 5.156c.078.037.221.042.289-.146.035-.095.025-.165-.009-.214-.023-.033-.133-.118-.371-.176-.904-.22-1.341.384-1.405.499-.04.072-.012.176.056.227.067.051.139.037.179-.006.58-.628 1.21-.208 1.261-.184z"></path></svg></a></div></div></div></div></header><div class="page-content docs-content"><div class="container"><div class="docs-content-wrapper"><aside class=""><div class="docs-content-wrapper-sidebar"><div class="search-panel"><div class="search"><input type="text" placeholder="Search..." value=""/><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon-delete"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg></div><ul class="search-results"></ul><div class="search-results-none">No results.</div></div><div class="docs-content-toc"><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_using_the_service_discovery">使用服务发现</a></li>
<li><a href="#_overall_concepts">概念总览</a>
<ul class="sectlevel2">
<li><a href="#_service_records">服务记录</a></li>
<li><a href="#_service_provider_and_publisher">提供者和发布者</a></li>
<li><a href="#_service_consumer">服务消费者</a></li>
<li><a href="#_service_object">服务对象</a></li>
<li><a href="#_service_types">服务类型</a></li>
<li><a href="#_service_events">服务事件</a></li>
<li><a href="#_backend">后台</a></li>
</ul>
</li>
<li><a href="#_creating_a_service_discovery_instance">创建服务发现实例</a></li>
<li><a href="#_publishing_services">发布服务</a></li>
<li><a href="#_withdrawing_services">回收服务</a></li>
<li><a href="#_looking_for_services">寻找服务</a></li>
<li><a href="#_retrieving_a_service_reference">获取服务引用</a></li>
<li><a href="#_types_of_services">服务类型</a>
<ul class="sectlevel2">
<li><a href="#_services_with_no_type">无类型的服务</a></li>
<li><a href="#_implementing_your_own_service_type">实现您自己的服务类型</a></li>
<li><a href="#_http_endpoints">HTTP 节点</a></li>
<li><a href="#_event_bus_services">Event bus 服务</a></li>
<li><a href="#_message_source">消息源服务</a></li>
<li><a href="#_jdbc_data_source">JDBC数据源</a></li>
<li><a href="#_redis_data_source">Redis 数据源</a></li>
<li><a href="#_mongo_data_source">Mongo数据源</a></li>
</ul>
</li>
<li><a href="#_listening_for_service_arrivals_and_departures">监听服务的注册和注销</a></li>
<li><a href="#_listening_for_service_usage">监听服务使用状况</a></li>
<li><a href="#_service_discovery_bridges">服务发现桥接器</a>
<ul class="sectlevel2">
<li><a href="#_rxjava_2_api">RxJava 2 API</a></li>
</ul>
</li>
<li><a href="#_additional_bridges">其他的桥接器支持</a>
<ul class="sectlevel2">
<li><a href="#_consul_bridge">Consul 网桥</a></li>
<li><a href="#_kubernetes_bridge">Kubernetes 桥接器</a></li>
<li><a href="#_docker_links_bridge">Docker Links 桥接器</a></li>
</ul>
</li>
<li><a href="#_additional_backends">其他的后台支持</a>
<ul class="sectlevel2">
<li><a href="#_redis_backend">Redis backend</a></li>
</ul>
</li>
</ul>
</div></div></div></aside><div class="docs-content-sidebar-toggle"><div style="position:relative"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></div></div><div class="docs-content-inner"><div class="docs-content-metadata"><div class="docs-content-metadata-left"><div class="docs-content-metadata-repo"><div class="github-stars"><a href="https://github.com/vert-x3/vertx-service-discovery"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>null stars</a></div></div><div><a href="https://vertx.io/docs/apidocs"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg> API</a></div><div class="docs-content-metadata-edit"><a href="https://github.com/vertx-china/vertx-web-site/tree/master/docs/translation/vertx-service-discovery/java"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg> 改进翻译</a></div><span class="docs-content-metadata-version"><div class="dropdown"><a class="dropdown-title">v4.1.0<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu align-right"><a href="/docs/vertx-service-discovery/java/"><li class="dropdown-item active has-active-siblings"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="dropdown-check-icon"><polyline points="20 6 9 17 4 12"></polyline></svg>Latest (v<!-- -->4.1.0<!-- -->)</li></a><a href="/docs/4.0.3/vertx-service-discovery/java/"><li class="dropdown-item has-active-siblings">v<!-- -->4.0.3</li></a><a href="/docs/3.9.7/vertx-service-discovery/java/"><li class="dropdown-item has-active-siblings">v<!-- -->3.9.7</li></a></ul></div></span></div></div><div><h1>Vert.x 服务发现</h1>

<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 服务发现组件提供了一套用于对各种资源服务的发布、发现的基础组件，例如 服务代理、HTTP服务节点（HTTP endpoint）、数据源（data source）&#8230;&#8203; 这些资源统称为 <code>服务</code> 。一个 <code>服务</code> 即是一个可被发现的功能性模块。它可以用类型、元数据、位置来区分，所以一个 <code>服务</code> 可以是一个数据库、服务代理、HTTP节点或者其他任何您能够描述、发现、交互的服务资源。它不一定是一个vert.x对象，它可以是任何组件。每个 <code>服务</code> 都被描述成一个 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> （即：下述 <code>服务记录</code> ）。</p>
</div>
<div class="paragraph">
<p><code>服务发现</code> 组件实现了面向服务计算中定义的服务交互。此外，在某种程度上，还提供了动态的面向服务计算交互，这样应用程序可以对各种服务的上线、下线作出处理。</p>
</div>
<div class="paragraph">
<p>一个服务提供者可以做如下事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>发布一个服务的 <code>服务记录</code></p>
</li>
<li>
<p>下线一个已发布的 <code>服务记录</code></p>
</li>
<li>
<p>更新线上服务的状态 (下线、暂停服务&#8230;&#8203;)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个服务消费者可以做如下事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>寻找服务</p>
</li>
<li>
<p>选择绑定到某个服务（获取一个 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code>) 并使用）</p>
</li>
<li>
<p>当服务消费者停止后立即释放服务提供者资源</p>
</li>
<li>
<p>监听服务的注册、注销、更新</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>服务消费者将：1)寻找符合自己需求的 <code>服务记录</code>； 2) 接收提供访问入口的 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> ；3) 获得一个提供访问入口的 <code>服务</code> 对象；4) 停止后立即释放服务对象</p>
</div>
<div class="paragraph">
<p>这个过程可以用 <em>服务类型</em> （service type） 来简化，如果你知道服务的类型(JDBC client, Http client&#8230;&#8203;)，那么你可以直接获取到这个服务对象。</p>
</div>
<div class="paragraph">
<p>综上所述，服务提供者和消费者之间共享的核心信息都存放在 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">records</a></code> 当中。</p>
</div>
<div class="paragraph">
<p>提供者和消费者必须创建自己的 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html">ServiceDiscovery</a></code> 实例。这些实例在后台（分布式架构）进行协作，以使服务之间信息保持同步。</p>
</div>
<div class="paragraph">
<p>vert.x的服务发现通过桥接方式 支持对其他服务发现技术的导入和导出。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_service_discovery"><a class="anchor" href="#_using_the_service_discovery"></a>使用服务发现</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要使用Vert.x 服务发现组件，需要将下列依赖加入到依赖配置中文件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (<code>pom.xml</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vertx-service-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (<code>build.gradle</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile <span class="hljs-string">'io.vertx:vertx-service-discovery:4.0.3'</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overall_concepts"><a class="anchor" href="#_overall_concepts"></a>概念总览</h2>
<div class="sectionbody">
<div class="paragraph">
<p>服务发现机制基于以下章节的几个概念。</p>
</div>
<div class="sect2">
<h3 id="_service_records"><a class="anchor" href="#_service_records"></a>服务记录</h3>
<div class="paragraph">
<p>一个服务 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 是服务提供者发布的一个服务描述对象。它包含了名称、元数据、位置对象（描述服务发布在哪里）。这个 <code>服务记录</code> 是提供者（发布 <code>服务记录</code> ）和消费者（寻找服务时获取 <code>服务记录</code> ）之间仅有的共享对象。</p>
</div>
<div class="paragraph">
<p>元数据和位置格式由 <code>服务类型（service type）</code> 决定（见下述）。</p>
</div>
<div class="paragraph">
<p>服务提供方准备好之后，一个 <code>服务记录</code> 就被发布了，服务停止时 <code>服务记录</code> 被回收</p>
</div>
</div>
<div class="sect2">
<h3 id="_service_provider_and_publisher"><a class="anchor" href="#_service_provider_and_publisher"></a>提供者和发布者</h3>
<div class="paragraph">
<p>服务提供者是一个提供 <em>服务</em> 的对象。发布者负责发布描述提供者的 <code>服务记录</code> 。它可能是同一个对象（提供者仅仅发布自己）也可能是个不同的对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="_service_consumer"><a class="anchor" href="#_service_consumer"></a>服务消费者</h3>
<div class="paragraph">
<p>服务消费者在服务发现模块中检索服务。每次检索都会得到 <code>0..n</code> 个
<code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ，从这些 <code>服务记录</code> 当中，服务消费者可以获取到 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> ，这个 <code>服务引用</code> 绑定了提供方和消费方，它允许消费方获取到 <em>服务对象（service object）</em> （用来使用服务）或释放服务。</p>
</div>
<div class="paragraph">
<p>释放 <code>服务引用</code> 是一件很重要的事情，这清除了 <code>服务引用</code> 对象并更新了服务的使用状态</p>
</div>
</div>
<div class="sect2">
<h3 id="_service_object"><a class="anchor" href="#_service_object"></a>服务对象</h3>
<div class="paragraph">
<p><code>服务对象</code> 是一个提供了服务入口的对象。它可以是各种形式，例如 代理、客户端、甚至是一些不存在的服务类型。服务对象的性质取决于服务类型。</p>
</div>
<div class="paragraph">
<p>注意：因为Vert.x多语言的性质，所以如果你在java、groovy或其他语言获取的 <code>服务对象</code> 会不一样。</p>
</div>
</div>
<div class="sect2">
<h3 id="_service_types"><a class="anchor" href="#_service_types"></a>服务类型</h3>
<div class="paragraph">
<p>服务仅仅是一些 <code>资源（resource）</code> 或不同类型的 <code>服务</code>。他们可以是功能服务组件、数据库、REST-Api等等。Vert.x服务发现模块定义 <code>服务类型</code> 来处理各类型的差异。每个类型定义了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务是如何定位的（URI, event bus address, IP / DNS&#8230;&#8203;）- <em>location</em></p>
</li>
<li>
<p>服务对象的性质（service proxy, HTTP client, message consumer&#8230;&#8203;）<em>client</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>服务发现组件提供了一些现成的服务类型，但是你可以添加你自己的类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_service_events"><a class="anchor" href="#_service_events"></a>服务事件</h3>
<div class="paragraph">
<p>每当发布或注销一个服务，event-bus上就会触发一个事件(event),这个事件包含了被更新的服务记录。</p>
</div>
<div class="paragraph">
<p>另外，为了追踪谁调用谁，每当调用 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getReference-io.vertx.servicediscovery.Record-">getReference</a></code> 则获取reference或者 调用 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html#release--">release</a></code> 释放reference的时候，事件都在event-bus上被发出 用以跟踪服务的使用情况。</p>
</div>
<div class="paragraph">
<p>关于事件的更多详细信息如下。</p>
</div>
</div>
<div class="sect2">
<h3 id="_backend"><a class="anchor" href="#_backend"></a>后台</h3>
<div class="paragraph">
<p>服务发现模块使用了Vert.x的分布式数据结构来存储 <code>服务记录</code> 。所以所有的集群成员都能获取到所有的 <code>服务记录</code> 。这是后台默认的实现。你可以实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html">ServiceDiscoveryBackend</a></code> SPI 来实现自己的Backend。例如，Vert.x提供了一个基于Redis的基础实现。</p>
</div>
<div class="paragraph">
<p>注意：服务发现不要求必须是Vert.x集群。在单节点模式下，这个数据结构存储于本地。它可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html">ServiceImporter</a></code> 实现。从3.5.0版本开始，你可以在集群模式下用本地结构的event，这可以设置系统参数 <code>vertx-service-discovery-backend-local</code> 为 <code>true</code> (或者设置环境变量 <code>VERTX-SERVICE-DISCOVERY-BACKEND-LOCAL</code> 为 <code>true</code>) 来实现。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_a_service_discovery_instance"><a class="anchor" href="#_creating_a_service_discovery_instance"></a>创建服务发现实例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>提供者和消费者必须创建他们自己的 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html">ServiceDiscovery</a></code> 实例来使用服务发现组件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery discovery = ServiceDiscovery.create(vertx);

<span class="hljs-comment">// 自定义配置</span>
discovery = ServiceDiscovery.create(vertx,
    <span class="hljs-keyword">new</span> ServiceDiscoveryOptions()
        .setAnnounceAddress(<span class="hljs-string">"service-announce"</span>)
        .setName(<span class="hljs-string">"my-name"</span>));

<span class="hljs-comment">// Do something...</span>

discovery.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，公告地址(发送事件的event-bus地址)是 <code>vertx.discovery.announce</code>。你也可以为service usage（见service usage章节）配置一个名称。</p>
</div>
<div class="paragraph">
<p>当你再也不需要服务发现对象时，不要忘记去关闭它。它关闭了您已配置的发现导入器和导出器，并释放服务引用。</p>
</div>
<div class="paragraph">
<p>您应该避免共享服务发现实例，因此service usage 将代表正确的“usage”</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_publishing_services"><a class="anchor" href="#_publishing_services"></a>发布服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一旦你拥有了服务发现实例，你可以发布服务。步骤如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>为这个服务提供者创建一个服务记录</p>
</li>
<li>
<p>发布这个服务记录</p>
</li>
<li>
<p>持有这个服务记录，以便于后续的注销和更改操作</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了创建服务记录，你可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 类，或者用不同服务类型提供的便捷方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = <span class="hljs-keyword">new</span> Record()
    .setType(<span class="hljs-string">"eventbus-service-proxy"</span>)
    .setLocation(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"endpoint"</span>, <span class="hljs-string">"the-service-address"</span>))
    .setName(<span class="hljs-string">"my-service"</span>)
    .setMetadata(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"some-label"</span>, <span class="hljs-string">"some-value"</span>));

discovery.publish(record, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    <span class="hljs-comment">// 发布成功</span>
    Record publishedRecord = ar.result();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 发布失败</span>
  }
});

<span class="hljs-comment">// 由一个类型创建的record</span>
record = HttpEndpoint.createRecord(<span class="hljs-string">"some-rest-api"</span>, <span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">"/api"</span>);
discovery.publish(record, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    <span class="hljs-comment">// 发布成功</span>
    Record publishedRecord = ar.result();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 发布失败</span>
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>持有服务记录的引用是很重要的事情，因为服务记录中拥有一个 <code>注册 id</code>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_withdrawing_services"><a class="anchor" href="#_withdrawing_services"></a>回收服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要回收(下线)一个record，使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.unpublish(record.getRegistration(), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    <span class="hljs-comment">// Ok</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 无法下线服务，可能是因为已经被移除或者 record根本没有被发布</span>
  }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_looking_for_services"><a class="anchor" href="#_looking_for_services"></a>寻找服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>本章解释了获取服务的底层原理，每个服务类型都提供了便捷的方式来整合各个的步骤</em></p>
</div>
<div class="paragraph">
<p>在消费方，第一件事就是要寻找服务记录。您可以检索单个服务记录或者所有符合条件的服务记录。第一种情况，第一个符合条件的服务记录被返回。</p>
</div>
<div class="paragraph">
<p>消费方可以提供一个过滤器(filter)来选择服务。有两种方式来描述过滤器：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一个以 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 为参数并以布尔类型（这是一个断言）作为返回值的函数</p>
</li>
<li>
<p>这个过滤器是一个JSON-obejct。每一个给出的filter过滤条件都会检查record，所有的过滤条件都必须满足record。过滤条件可以用 <code>*</code> 通配符来表示对key的要求，而不是精准匹配。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们来看看JSON过滤器的一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{ "name" = "a" } =&gt; 筛选出名称是"a"的record
{ "color" = "*" } =&gt; 筛选出存在"color"字段的record
{ "color" = "red" } =&gt; 筛选出"color"字段是"red"的record
{ "color" = "red", "name" = "a"} =&gt; 筛选出"color"字段是"red" 且 "name"字段是"a"的record</pre>
</div>
</div>
<div class="paragraph">
<p>如果没有设置JSON过滤器(<code>null</code> 或 empty) ，则筛选出所有的服务记录。当用函数来过滤时，如果你想获取到所有的服务记录，那无论是什么样的服务记录，你必须要返回 <em>true</em></p>
</div>
<div class="paragraph">
<p>示例如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(r -&gt; <span class="hljs-keyword">true</span>, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    <span class="hljs-keyword">if</span> (ar.result() != <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// 获取到一个record</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 寻找成功但是没有符合条件的服务</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 查找失败</span>
  }
});

discovery.getRecord((JsonObject) <span class="hljs-keyword">null</span>, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    <span class="hljs-keyword">if</span> (ar.result() != <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// 获取到一个record</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 寻找成功但是没有符合条件的服务</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 查找失败</span>
  }
});


<span class="hljs-comment">// 通过名称获取record</span>
discovery.getRecord(r -&gt; r.getName().equals(<span class="hljs-string">"some-name"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    <span class="hljs-keyword">if</span> (ar.result() != <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// 获取到一个record</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 寻找成功但是没有符合条件的服务</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 查找失败</span>
  }
});

discovery.getRecord(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-service"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    <span class="hljs-keyword">if</span> (ar.result() != <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// 获取到一个record</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 寻找成功但是没有符合条件的服务</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 查找失败</span>
  }
});

<span class="hljs-comment">// 获取所有符合过滤器条件的record</span>
discovery.getRecords(r -&gt; <span class="hljs-string">"some-value"</span>.equals(r.getMetadata().getString(<span class="hljs-string">"some-label"</span>)), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    List&lt;Record&gt; results = ar.result();
    <span class="hljs-comment">// 如果获取到非空list，那么我们获取到了record</span>
    <span class="hljs-comment">// 否则说明寻找成功但是没有符合条件的服务</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 查找失败</span>
  }
});


discovery.getRecords(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"some-label"</span>, <span class="hljs-string">"some-value"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    List&lt;Record&gt; results = ar.result();
    <span class="hljs-comment">// 如果获取到非空list，那么我们获取到了record</span>
    <span class="hljs-comment">// 否则说明寻找成功但是没有符合条件的服务</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 查找失败</span>
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-io.vertx.core.json.JsonObject-io.vertx.core.Handler-">getRecords</a></code> 来获取单条服务记录或者所有符合条件的服务记录。默认情况下，对于服务记录的查找仅仅包含 <code>status</code> 是 <code>UP</code> 的情况。这可以被重写：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当使用JSON过滤器时，设置 <code>status</code> 为你的期望值（或者 <code>*</code> 来接收所有的状态）</p>
</li>
<li>
<p>当使用函数时，在 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-java.util.function.Function-boolean-io.vertx.core.Handler-">getRecords</a></code> 函数 设置 <code>includeOutOfService</code> 参数为 <code>true</code>。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_retrieving_a_service_reference"><a class="anchor" href="#_retrieving_a_service_reference"></a>获取服务引用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一旦你选择了 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ，你可以获取一个 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> 和 <code>服务对象</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceReference reference1 = discovery.getReference(record1);
ServiceReference reference2 = discovery.getReference(record2);

<span class="hljs-comment">// 获取到service object，返回服务引用的类型取决于 service type</span>
<span class="hljs-comment">// Http 节点</span>
HttpClient client = reference1.getAs(HttpClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
<span class="hljs-comment">// 消息源</span>
MessageConsumer consumer = reference2.getAs(MessageConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">// 当服务使用完毕</span>
reference1.release();
reference2.release();</code></pre>
</div>
</div>
<div class="paragraph">
<p>切记处理完毕之后释放服务引用资源</p>
</div>
<div class="paragraph">
<p>一个服务引用代表了一个对服务提供者的绑定关系。</p>
</div>
<div class="paragraph">
<p>获取服务引用时，你可以传一个包含了各种数据的 <code><a href="../../apidocs/io/vertx/core/json/JsonObject.html">JsonObject</a></code> 用来配置 <code>服务对象</code> 。某些服务类型不需要额外的配置，如下是一些必要的配置（数据源为例）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceReference reference = discovery.getReferenceWithConfiguration(record, conf);

<span class="hljs-comment">// 获取到service object，返回服务引用的类型取决于 service type</span>
<span class="hljs-comment">// JDBC 节点</span>
JDBCClient client = reference.getAs(JDBCClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">// Do something with the client...</span>

<span class="hljs-comment">// 当服务使用完毕</span>
reference.release();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前述例子当中，代码用了 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html#getAs-java.lang.Class-">getAs</a></code> 函数，其参数是你期望得到的服务类型。如果你用java语言，你可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html#get--">get</a></code> 函数。然而其他语言 你必须传一个你期望的类型值。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_types_of_services"><a class="anchor" href="#_types_of_services"></a>服务类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如上所述，服务发现有 <code>服务类型</code> 的概念来管理不同类型的服务。</p>
</div>
<div class="paragraph">
<p>这些类型默认通过如下方式提供：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html">HttpEndpoint</a></code> - 对于 REST API&#8217;来讲, 服务对象是一个由 <code>host</code>、<code>port</code>（位置是 <code>url</code> 参数）配置的
<code><a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a></code> .</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> - 对于服务代理，服务对象是一个proxy。它的类型是`proxies interface`（服务所在位置是地址）</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> - 对于消息源（发送者），服务对象是一个 <code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html">MessageConsumer</a></code> （服务所在位置是地址）。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html">JDBCDataSource</a></code> - 对于 JDBC 数据源, 服务对象是一个 <code><a href="../../apidocs/io/vertx/ext/jdbc/JDBCClient.html">JDBCClient</a></code> （客户端配置从 location，metadata和消费方配置来解析）。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html">RedisDataSource</a></code> - 对于 Redis 数据源, 服务对象是一个 <code><a href="../../apidocs/io/vertx/redis/client/Redis.html">Redis</a></code> (客户端配置从 location，metadata和消费方配置来解析).</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html">MongoDataSource</a></code> - 对于 Mongo 数据源, 服务对象是一个 <code><a href="../../apidocs/io/vertx/ext/mongo/MongoClient.html">MongoClient</a></code> (客户端配置从 location，metadata和消费方配置来解析).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节总体上给出有关服务类型的详细信息，并介绍如何使用默认服务类型。</p>
</div>
<div class="sect2">
<h3 id="_services_with_no_type"><a class="anchor" href="#_services_with_no_type"></a>无类型的服务</h3>
<div class="paragraph">
<p>一些record也许没有类型(<code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html#UNKNOWN">ServiceType.UNKNOWN</a></code>)。所以不可能从这些record里面获取到服务对象，但是你可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 对象的 <code>location</code> 和 <code>metadata</code> 来构建连接的具体信息。</p>
</div>
<div class="paragraph">
<p>使用这些服务不会触发 <code>service usage</code> 事件</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_your_own_service_type"><a class="anchor" href="#_implementing_your_own_service_type"></a>实现您自己的服务类型</h3>
<div class="paragraph">
<p>你可以通过实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html">ServiceType</a></code> SPI 的方式来创建你自己的服务类型:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(可选) 创建一个public interface 继承 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html">ServiceType</a></code> 。这个interface仅仅用来提供辅助函数来简化你自定义类型的用法，例如 <code>createRecord</code> 函数, <code>getX</code> ， <code>X</code> 是你获取到的服务对象的类型。可以查看 <code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html">HttpEndpoint</a></code> 或者 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 等接口例子来了解这种设计</p>
</li>
<li>
<p>创建一个类来实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html">ServiceType</a></code> ，或者实现你在第一步创建的类型。 这个类型有 <code>name</code> 和一个为这个类型创建 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> 的函数。这个name必须匹配 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 类的 <code>type</code> 字段，这个record的type就是您自己定义的服务类型。</p>
</li>
<li>
<p>创建一个类继承 <code>io.vertx.ext.discovery.types.AbstractServiceReference</code> ，您可以参数化您将要返回的带有服务对象类型的类，你必须实现 <code>AbstractServiceReference#retrieve()</code> 函数来创建服务对象。这个函数只能被调用一次。如果需要清除服务对象，也要重写 <code>AbstractServiceReference#onClose()</code> 函数</p>
</li>
<li>
<p>在打包jar时在jar内创建一个 <code>META-INF/services/io.vertx.servicediscovery.spi.ServiceType</code> 文件。这个文件仅仅包含您在第二步创建的类的全名。</p>
</li>
<li>
<p>创建一个包含service type interface（步骤1）的jar，实现类（步骤2，步骤3）和服务描述文件（步骤4）。把这个jar放在你应用的classpath下，然后您的服务类型现在就已经可用了。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_http_endpoints"><a class="anchor" href="#_http_endpoints"></a>HTTP 节点</h3>
<div class="paragraph">
<p>一个HTTP节点代表一个REST API或者可用HTTP请求访问的服务。HTTP节点服务对象是一个由host、port、ssl所配置的 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a></code> 对象</p>
</div>
<div class="sect3">
<h4 id="_publishing_a_http_endpoint"><a class="anchor" href="#_publishing_a_http_endpoint"></a>发布一个HTTP节点</h4>
<div class="paragraph">
<p>要发布一个HTTP节点，你需要一个 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ，你可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#createRecord-java.lang.String-java.lang.String-int-java.lang.String-io.vertx.core.json.JsonObject-">HttpEndpoint.createRecord</a></code> 来创建服务记录。</p>
</div>
<div class="paragraph">
<p>下面一段阐述如何用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html">HttpEndpoint</a></code> 创建 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record1 = HttpEndpoint.createRecord(
  <span class="hljs-string">"some-http-service"</span>, <span class="hljs-comment">// 服务名称</span>
  <span class="hljs-string">"localhost"</span>, <span class="hljs-comment">//  host</span>
  <span class="hljs-number">8433</span>, <span class="hljs-comment">// port</span>
  <span class="hljs-string">"/api"</span> <span class="hljs-comment">// 服务的根路由</span>
);

discovery.publish(record1, ar -&gt; {
  <span class="hljs-comment">// ...</span>
});

Record record2 = HttpEndpoint.createRecord(
  <span class="hljs-string">"some-other-name"</span>, <span class="hljs-comment">// 服务名称</span>
  <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 是否要求 HTTPs</span>
  <span class="hljs-string">"localhost"</span>, <span class="hljs-comment">// host</span>
  <span class="hljs-number">8433</span>, <span class="hljs-comment">// port</span>
  <span class="hljs-string">"/api"</span>, <span class="hljs-comment">// 服务的根路由</span>
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"some-metadata"</span>, <span class="hljs-string">"some value"</span>)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你在容器或者云启动你的服务时，也许并不知道服务的公网IP和端口，所以发布操作必须要通过另一个对象来获取这个信息，通常它是一个 <em>桥接对象</em> （ <code>bridge</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_a_http_endpoint"><a class="anchor" href="#_consuming_a_http_endpoint"></a>消费一个HTTP服务节点</h4>
<div class="paragraph">
<p>一旦HTTP节点发布，一个消费者可以获取到它。这个服务对象是一个配置了host和port的 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-http-service"</span>), ar1 -&gt; {
  <span class="hljs-keyword">if</span> (ar1.succeeded() &amp;&amp; ar1.result() != <span class="hljs-keyword">null</span>) {
    <span class="hljs-comment">// 获取服务引用</span>
    ServiceReference reference = discovery.getReference(ar1.result());
    <span class="hljs-comment">// 获取服务对象</span>
    HttpClient client = reference.getAs(HttpClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-comment">// 定义完整的path</span>
    client.request(HttpMethod.GET, <span class="hljs-string">"/api/persons"</span>).compose(request -&gt;
      request
        .send()
        .compose(HttpClientResponse::body))
      .onComplete(ar2 -&gt; {
      <span class="hljs-comment">// 不要忘记释放服务资源</span>
      reference.release();
    });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#getClient-io.vertx.servicediscovery.ServiceDiscovery-io.vertx.core.json.JsonObject-io.vertx.core.Handler-">HttpEndpoint.getClient</a></code> 函数，通过一次函数调用来同时完成服务查找和服务对象获取的操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpEndpoint.getClient(discovery, <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-http-service"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    HttpClient client = ar.result();

    <span class="hljs-comment">// 你需要提供完整的path</span>
    client.request(HttpMethod.GET, <span class="hljs-string">"/api/persons"</span>).compose(request -&gt;
      request
        .send()
        .compose(HttpClientResponse::body))
      .onComplete(ar2 -&gt; {
        <span class="hljs-comment">// 不要忘记释放服务资源</span>
        ServiceDiscovery.releaseServiceObject(discovery, client);
      });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这第二个写法里，用 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#releaseServiceObject-io.vertx.servicediscovery.ServiceDiscovery-java.lang.Object-">ServiceDiscovery.releaseServiceObject</a></code> 来释放服务对象，所以你不需要持有服务引用。</p>
</div>
<div class="paragraph">
<p>从Vert.x 3.4.0开始，提供了另一个客户端。这个更高层次封装的客户端名字叫 <code><a href="../../apidocs/io/vertx/ext/web/client/WebClient.html">WebClient</a></code>，这个客户端用起来更容易。你可以通过如下方式获取 <code><a href="../../apidocs/io/vertx/ext/web/client/WebClient.html">WebClient</a></code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-http-service"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class="hljs-keyword">null</span>) {
    <span class="hljs-comment">// 获取服务引用</span>
    ServiceReference reference = discovery.getReference(ar.result());
    <span class="hljs-comment">// 获取服务对象</span>
    WebClient client = reference.getAs(WebClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-comment">// 你需要提供完整的path</span>
    client.get(<span class="hljs-string">"/api/persons"</span>).send(
      response -&gt; {

        <span class="hljs-comment">// ...</span>

        <span class="hljs-comment">// 不要忘记释放服务资源</span>
        reference.release();

      });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，如果你更倾向于用服务类型的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpEndpoint.getWebClient(discovery, <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-http-service"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    WebClient client = ar.result();

    <span class="hljs-comment">// 你需要提供完整的path</span>
    client.get(<span class="hljs-string">"/api/persons"</span>)
      .send(response -&gt; {

        <span class="hljs-comment">// ...</span>

        <span class="hljs-comment">// 不要忘记释放服务资源</span>
        ServiceDiscovery.releaseServiceObject(discovery, client);

      });
  }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_services"><a class="anchor" href="#_event_bus_services"></a>Event bus 服务</h3>
<div class="paragraph">
<p>Event bus服务是服务代理，它基于event bus实现了异步RPC服务。当从event bus服务获取一个服务对象，你获取到对应类型的服务代理。你可以从 <code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> 获取辅助函数。</p>
</div>
<div class="paragraph">
<p>注意：服务代理（服务的实现和服务接口）是由java实现的</p>
</div>
<div class="sect3">
<h4 id="_publishing_an_event_bus_service"><a class="anchor" href="#_publishing_an_event_bus_service"></a>发布一个event bus服务</h4>
<div class="paragraph">
<p>发布event bus服务，你需要创建一个 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = EventBusService.createRecord(
    <span class="hljs-string">"some-eventbus-service"</span>, <span class="hljs-comment">// 服务名称</span>
    <span class="hljs-string">"address"</span>, <span class="hljs-comment">// 服务地址,</span>
    <span class="hljs-string">"examples.MyService"</span>, <span class="hljs-comment">// 字符串格式的服务接口类名</span>
    <span class="hljs-keyword">new</span> JsonObject()
        .put(<span class="hljs-string">"some-metadata"</span>, <span class="hljs-string">"some value"</span>)
);

discovery.publish(record, ar -&gt; {
  <span class="hljs-comment">// ...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以传服务接口类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = EventBusService.createRecord(
<span class="hljs-string">"some-eventbus-service"</span>, <span class="hljs-comment">// 服务名称</span>
<span class="hljs-string">"address"</span>, <span class="hljs-comment">// 服务地址,</span>
MyService<span class="hljs-class">.<span class="hljs-keyword">class</span> // 接口类
)</span>;

discovery.publish(record, ar -&gt; {
<span class="hljs-comment">// ...</span>
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_an_event_bus_service"><a class="anchor" href="#_consuming_an_event_bus_service"></a>消费event bus服务</h4>
<div class="paragraph">
<p>要消费一个event bus服务，你可以先获取服务记录，再通过服务记录获取服务引用；或者用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> 接口通过一次调用来完成这两个操作。</p>
</div>
<div class="paragraph">
<p>当使用服务引用是，你应该这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-eventbus-service"</span>), ar -&gt; {
<span class="hljs-keyword">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class="hljs-keyword">null</span>) {
<span class="hljs-comment">// 获取服务引用</span>
ServiceReference reference = discovery.getReference(ar.result());
<span class="hljs-comment">// 获取服务对象</span>
MyService service = reference.getAs(MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">// 不要忘记释放服务资源</span>
reference.release();
}
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> 类，你可以像下述获取代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EventBusService.getProxy(discovery, MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">ar</span> -&gt; </span>{
<span class="hljs-keyword">if</span> (ar.succeeded()) {
MyService service = ar.result();

<span class="hljs-comment">// 不要忘记释放服务资源</span>
ServiceDiscovery.releaseServiceObject(discovery, service);
}
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_message_source"><a class="anchor" href="#_message_source"></a>消息源服务</h3>
<div class="paragraph">
<p>消息源是一个往event bus地址发送消息的组件，消息源客户端是 `<a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html">MessageConsumer</a>`类。</p>
</div>
<div class="paragraph">
<p>消息被发送给到eventBus的 <em>location</em> 或 消息源服务上。</p>
</div>
<div class="sect3">
<h4 id="_publishing_a_message_source"><a class="anchor" href="#_publishing_a_message_source"></a>推送消息</h4>
<div class="paragraph">
<p>就像其他类型的服务，推送一个消息分2步走：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 创建一个服务对象。</p>
</li>
<li>
<p>推送消息</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = MessageSource.createRecord(
    <span class="hljs-string">"some-message-source-service"</span>, <span class="hljs-comment">// 服务名</span>
    <span class="hljs-string">"some-address"</span> <span class="hljs-comment">// event bus 地址</span>
);

discovery.publish(record, ar -&gt; {
  <span class="hljs-comment">// ...</span>
});

record = MessageSource.createRecord(
    <span class="hljs-string">"some-other-message-source-service"</span>, <span class="hljs-comment">// 服务名</span>
    <span class="hljs-string">"some-address"</span>, <span class="hljs-comment">// event bus 地址</span>
    <span class="hljs-string">"examples.MyData"</span> <span class="hljs-comment">// 消息体类型</span>
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述第二个record当中，我们同时指明了消息体（payload）的类型，这个参数是可选的。</p>
</div>
<div class="paragraph">
<p>在Java当中，你可以用 <code><a href="../../apidocs/java/lang/Class.html">Class</a></code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record1 = MessageSource.createRecord(
<span class="hljs-string">"some-message-source-service"</span>, <span class="hljs-comment">// 服务名</span>
<span class="hljs-string">"some-address"</span>, <span class="hljs-comment">// 服务地址</span>
JsonObject<span class="hljs-class">.<span class="hljs-keyword">class</span> // 消息体类型
)</span>;

Record record2 = MessageSource.createRecord(
<span class="hljs-string">"some-other-message-source-service"</span>, <span class="hljs-comment">// 服务名</span>
<span class="hljs-string">"some-address"</span>, <span class="hljs-comment">// 服务地址</span>
JsonObject<span class="hljs-class">.<span class="hljs-keyword">class</span>, // 消息体类型
<span class="hljs-title">new</span> <span class="hljs-title">JsonObject</span>().<span class="hljs-title">put</span>("<span class="hljs-title">some</span>-<span class="hljs-title">metadata</span>", "<span class="hljs-title">some</span> <span class="hljs-title">value</span>")
)</span>;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_a_message_source"><a class="anchor" href="#_consuming_a_message_source"></a>消费消息服务</h4>
<div class="paragraph">
<p>在消费者端，你可以获取服务记录从而获取服务引用，或者用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 通过一次调用合两步为一。</p>
</div>
<div class="paragraph">
<p>通过第一种方式，代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-message-source-service"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class="hljs-keyword">null</span>) {
    <span class="hljs-comment">// 获取服务引用</span>
    ServiceReference reference = discovery.getReference(ar.result());
    <span class="hljs-comment">// 获取服务对象</span>
    MessageConsumer&lt;JsonObject&gt; consumer = reference.getAs(MessageConsumer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-comment">// 指定消息处理器</span>
    consumer.handler(message -&gt; {
      <span class="hljs-comment">// 消息处理器逻辑</span>
      JsonObject payload = message.body();
    });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 时，代码就变成了如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MessageSource.&lt;JsonObject&gt;getConsumer(discovery, <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-message-source-service"</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    MessageConsumer&lt;JsonObject&gt; consumer = ar.result();

    <span class="hljs-comment">// 指定消息处理器</span>
    consumer.handler(message -&gt; {
      <span class="hljs-comment">// 消息处理器逻辑</span>
      JsonObject payload = message.body();
    });
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jdbc_data_source"><a class="anchor" href="#_jdbc_data_source"></a>JDBC数据源</h3>
<div class="paragraph">
<p>数据源代表数据库或数据仓储。而JDBC数据源特指用JDBC驱动访问数据库。JDBC数据源客户端是 <code><a href="../../apidocs/io/vertx/ext/jdbc/JDBCClient.html">JDBCClient</a></code> 类。</p>
</div>
<div class="sect3">
<h4 id="_publishing_a_jdbc_service"><a class="anchor" href="#_publishing_a_jdbc_service"></a>发布JDBC服务</h4>
<div class="paragraph">
<p>类似其他类型的服务，发布JDBC服务需要2步：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html">JDBCDataSource</a></code> 创建record</p>
</li>
<li>
<p>推送record</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = JDBCDataSource.createRecord(
    <span class="hljs-string">"some-data-source-service"</span>, <span class="hljs-comment">// 服务名</span>
    <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"url"</span>, <span class="hljs-string">"some jdbc url"</span>), <span class="hljs-comment">// 服务地址</span>
    <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"some-metadata"</span>, <span class="hljs-string">"some-value"</span>) <span class="hljs-comment">// 元数据</span>
);

discovery.publish(record, ar -&gt; {
  <span class="hljs-comment">// ...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为JDBC数据源可以使用很多数据库，并且访问方式经常不一样，所以服务记录是没有标准结构定义的，<code>location</code> 是访问数据库配置而提供的一个通用JSONObject属性，用于访问数据源(JDBC url，username&#8230;&#8203;)。其他字段的定义依赖于数据库以及所用连接池决定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_a_jdbc_service"><a class="anchor" href="#_consuming_a_jdbc_service"></a>消费一个JDBC服务</h4>
<div class="paragraph">
<p>由前所述，如何获取数据源取决于数据源本身。要创建 <code><a href="../../apidocs/io/vertx/ext/jdbc/JDBCClient.html">JDBCClient</a></code> ，你可以同时提供：<code>record location</code>，元数据和一个有消费方提供的一个Json object：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(
    <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-data-source-service"</span>),
    ar -&gt; {
      <span class="hljs-keyword">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 获取服务引用</span>
        ServiceReference reference = discovery.getReferenceWithConfiguration(
            ar.result(), <span class="hljs-comment">// record</span>
            <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"username"</span>, <span class="hljs-string">"clement"</span>).put(<span class="hljs-string">"password"</span>, <span class="hljs-string">"*****"</span>)); <span class="hljs-comment">// 一些额外的元数据</span>

        <span class="hljs-comment">// 获取service object</span>
        JDBCClient client = reference.getAs(JDBCClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

        <span class="hljs-comment">// ...</span>

        <span class="hljs-comment">// 完毕</span>
        reference.release();
      }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以用 <code><a href="../../apidocs/io/vertx/ext/jdbc/JDBCClient.html">JDBCClient</a></code> 通过一次调用来发现和获取服务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JDBCDataSource.&lt;JsonObject&gt;getJDBCClient(discovery,
    <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-data-source-service"</span>),
    <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"username"</span>, <span class="hljs-string">"clement"</span>).put(<span class="hljs-string">"password"</span>, <span class="hljs-string">"*****"</span>), <span class="hljs-comment">// 一些额外的元数据</span>
    ar -&gt; {
      <span class="hljs-keyword">if</span> (ar.succeeded()) {
        JDBCClient client = ar.result();

        <span class="hljs-comment">// ...</span>

        <span class="hljs-comment">// 不要忘记释放服务资源</span>
        ServiceDiscovery.releaseServiceObject(discovery, client);

      }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_redis_data_source"><a class="anchor" href="#_redis_data_source"></a>Redis 数据源</h3>
<div class="paragraph">
<p>Redis数据源是Redis持久性数据库的一种特殊实现。</p>
</div>
<div class="paragraph">
<p>Redis数据源客户端是 <code><a href="../../apidocs/io/vertx/redis/client/Redis.html">Redis</a></code> 类</p>
</div>
<div class="sect3">
<h4 id="_publishing_a_redis_service"><a class="anchor" href="#_publishing_a_redis_service"></a>发布Redis服务</h4>
<div class="paragraph">
<p>发布Redis服务需要2步：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html">RedisDataSource</a></code> 创建服务记录</p>
</li>
<li>
<p>推送record</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = RedisDataSource.createRecord(
  <span class="hljs-string">"some-redis-data-source-service"</span>, <span class="hljs-comment">// 服务名</span>
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"url"</span>, <span class="hljs-string">"localhost"</span>), <span class="hljs-comment">// 服务地址</span>
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"some-metadata"</span>, <span class="hljs-string">"some-value"</span>) <span class="hljs-comment">// 一些元数据</span>
);

discovery.publish(record, ar -&gt; {
  <span class="hljs-comment">// ...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>location</code> 是一个简单的JSON对象，应提供用于访问Redis数据源的字段(url,port&#8230;&#8203;.)</p>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_a_redis_service"><a class="anchor" href="#_consuming_a_redis_service"></a>消费Redis服务</h4>
<div class="paragraph">
<p>由前所述，如何访问数据源决定于数据源本身。创建一个 <code><a href="../../apidocs/io/vertx/redis/client/Redis.html">Redis</a></code> 对象，你可以同时提供：record地址，元数据和由消费方提供的Json object。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-redis-data-source-service"</span>), ar -&gt; {
    <span class="hljs-keyword">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// 获取服务引用</span>
      ServiceReference reference = discovery.getReference(ar.result());

      <span class="hljs-comment">// 获取服务实例</span>
      Redis client = reference.getAs(Redis<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

      <span class="hljs-comment">// ...</span>

      <span class="hljs-comment">// 完毕 释放资源</span>
      reference.release();
    }
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html">RedisDataSource</a></code> 通过一次调用完成服务发现和获取。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisDataSource.getRedisClient(discovery,
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-redis-data-source-service"</span>),
  ar -&gt; {
    <span class="hljs-keyword">if</span> (ar.succeeded()) {
      Redis client = ar.result();

      <span class="hljs-comment">// ...</span>

      <span class="hljs-comment">// 不要忘记释放服务资源</span>
      ServiceDiscovery.releaseServiceObject(discovery, client);

    }
  });</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mongo_data_source"><a class="anchor" href="#_mongo_data_source"></a>Mongo数据源</h3>
<div class="paragraph">
<p>Mongo数据源是MongoDB数据库的专用化实现。
Mongo数据源服务的客户端是 <code><a href="../../apidocs/io/vertx/ext/mongo/MongoClient.html">MongoClient</a></code> 类</p>
</div>
<div class="sect3">
<h4 id="_publishing_a_mongo_service"><a class="anchor" href="#_publishing_a_mongo_service"></a>发布Mongo服务</h4>
<div class="paragraph">
<p>发布Mongo服务需要2步：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html">MongoDataSource</a></code> 创建服务记录</p>
</li>
<li>
<p>推送record</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = MongoDataSource.createRecord(
  <span class="hljs-string">"some-data-source-service"</span>, <span class="hljs-comment">// 服务名</span>
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"connection_string"</span>, <span class="hljs-string">"some mongo connection"</span>), <span class="hljs-comment">// 服务地址</span>
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"some-metadata"</span>, <span class="hljs-string">"some-value"</span>) <span class="hljs-comment">// 元数据</span>
);

discovery.publish(record, ar -&gt; {
  <span class="hljs-comment">// ...</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>location</code> 是一个简单的JSON对象，应提供用于访问Mongo数据源的字段(url, port&#8230;&#8203;)</p>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_a_mongo_service"><a class="anchor" href="#_consuming_a_mongo_service"></a>消费Mongo服务</h4>
<div class="paragraph">
<p>由前所述，如何访问数据源取决于数据源本身。创建 <code><a href="../../apidocs/io/vertx/ext/mongo/MongoClient.html">MongoClient</a></code> ，你可以同时提供：<code>record location</code> ,元数据和consumer提供的json object：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-data-source-service"</span>),
  ar -&gt; {
    <span class="hljs-keyword">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// 获取服务引用</span>
      ServiceReference reference = discovery.getReferenceWithConfiguration(
        ar.result(), <span class="hljs-comment">// record</span>
        <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"username"</span>, <span class="hljs-string">"clement"</span>).put(<span class="hljs-string">"password"</span>, <span class="hljs-string">"*****"</span>)); <span class="hljs-comment">// 额外的元数据</span>

      <span class="hljs-comment">// 获取服务对象</span>
      MongoClient client = reference.get();

      <span class="hljs-comment">// ...</span>

      <span class="hljs-comment">// 完毕 释放资源</span>
      reference.release();
    }
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html">MongoDataSource</a></code> 类通过一次调用来完成服务查找和获取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MongoDataSource.&lt;JsonObject&gt;getMongoClient(discovery,
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"some-data-source-service"</span>),
  <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"username"</span>, <span class="hljs-string">"clement"</span>).put(<span class="hljs-string">"password"</span>, <span class="hljs-string">"*****"</span>), <span class="hljs-comment">// 一些额外的元数据</span>
  ar -&gt; {
    <span class="hljs-keyword">if</span> (ar.succeeded()) {
      MongoClient client = ar.result();

      <span class="hljs-comment">// ...</span>

      <span class="hljs-comment">// 不要忘记释放服务资源</span>
      ServiceDiscovery.releaseServiceObject(discovery, client);

    }
  });</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_listening_for_service_arrivals_and_departures"><a class="anchor" href="#_listening_for_service_arrivals_and_departures"></a>监听服务的注册和注销</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每当服务提供方被发布或移除， <em>vertx.discovery.announce</em> 地址上会推送一个事件。
这个地址可以在 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html">ServiceDiscoveryOptions</a></code> 配置</p>
</div>
<div class="paragraph">
<p>收到的record会有一个 <code>status</code> 字段，它描述了record的新状态：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UP</code> : 服务可获取，您可以开启并使用它</p>
</li>
<li>
<p><code>DOWN</code> : 服务不可获取，你不应该再使用它</p>
</li>
<li>
<p><code>OUT_OF_SERVICE</code> : 服务不在运行状态，你不该再用它，但是可能过一会可能会恢复</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_listening_for_service_usage"><a class="anchor" href="#_listening_for_service_usage"></a>监听服务使用状况</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每当获取或释放服务引用时 <em>vertx.discovery.usage</em> 地址上会推送一个event。这个地址可以由 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html">ServiceDiscoveryOptions</a></code> 配置。</p>
</div>
<div class="paragraph">
<p>这会让您监听服务的使用情况并映射服务的绑定情况。</p>
</div>
<div class="paragraph">
<p>收到的消息是一个包含如下信息的 <code><a href="../../apidocs/io/vertx/core/json/JsonObject.html">JsonObject</a></code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>record</code> 属性指服务记录对象</p>
</li>
<li>
<p><code>type</code> 属性是事件的类型，它有两个值：<code>bind</code> ，<code>release</code></p>
</li>
<li>
<p><code>id</code> 属性是服务发现的id（名称或者node id）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个 <code>id</code> 可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html">ServiceDiscoveryOptions</a></code> 配置。默认情况下 单节点是"localhost"，集群模式下是node id。</p>
</div>
<div class="paragraph">
<p>你可以禁用服务使用情况的功能，这可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html#setUsageAddress-java.lang.String-">setUsageAddress</a></code> 设置 <code>usage address</code> 为 <code>null</code> 来实现。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_service_discovery_bridges"><a class="anchor" href="#_service_discovery_bridges"></a>服务发现桥接器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>桥接器 可以让你从其他服务发现机制(Docker，Kubernetes，Consul&#8230;&#8203;)里导入导出服务
每个桥接器决定了服务如何导入导出。这不一定是双向操作。</p>
</div>
<div class="paragraph">
<p>您可以实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html">ServiceImporter</a></code> 接口，并用 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#registerServiceImporter-io.vertx.servicediscovery.spi.ServiceImporter-io.vertx.core.json.JsonObject-">registerServiceImporter</a></code> 来注册的方式，为自己提供桥接器。</p>
</div>
<div class="paragraph">
<p>第二个参数是可选的，它可以配置桥接器。</p>
</div>
<div class="paragraph">
<p>当桥接器被注册时，<code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html#start-io.vertx.core.Vertx-io.vertx.servicediscovery.spi.ServicePublisher-io.vertx.core.json.JsonObject-io.vertx.core.Promise-">start</a></code> 函数被调用。
它让您可以配置桥接器。当桥接器被配置时，准备就绪并导入/导出初始服务后，它让给定的 <code><a href="../../apidocs/io/vertx/core/Future.html">Future</a></code> 处于 <code>completed</code> 状态；如果bridge starts函数正在阻塞，则它必须使用 <code><a href="../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-">executeBlocking</a></code> 构造，并设置给定的future对象为 <code>completed</code> 状态。</p>
</div>
<div class="paragraph">
<p>当服务发现组件停止，桥接器也随即停止。</p>
</div>
<div class="paragraph">
<p>调用 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html#close-io.vertx.core.Handler-">close</a></code> 函数会清除资源，移除已经导入/导出的服务。这个函数必须设置返回的 <code><a href="../../apidocs/io/vertx/core/Future.html">Future</a></code> 对象为 <code>completed</code> 状态,目的在于提醒调用者处理完成事件。</p>
</div>
<div class="paragraph">
<p>注意：在集群当中，只需要注册服务记录当中一个成员的桥接器即可，因为所有的服务记录都是互通的。</p>
</div>
<div class="sect2">
<h3 id="_rxjava_2_api"><a class="anchor" href="#_rxjava_2_api"></a>RxJava 2 API</h3>
<div class="paragraph">
<p>Service importers do not have a generated RxJava 2 implementation.</p>
</div>
<div class="paragraph">
<p>You must create an instance and wrap it with <code><a href="../../apidocs/io/vertx/reactivex/servicediscovery/spi/ServiceImporter.html">ServiceImporter</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JsonObject defaultConf = <span class="hljs-keyword">new</span> JsonObject();
ServiceImporter rxServiceImporter = <span class="hljs-keyword">new</span> ServiceImporter(<span class="hljs-keyword">new</span> KubernetesServiceImporter());
serviceDiscovery.registerServiceImporter(rxServiceImporter, defaultConf);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_additional_bridges"><a class="anchor" href="#_additional_bridges"></a>其他的桥接器支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 服务发现组件除了支持桥接器机制以外，还提供了一些现成的桥接器。</p>
</div>
<div class="sect2">
<h3 id="_consul_bridge"><a class="anchor" href="#_consul_bridge"></a>Consul 网桥</h3>
<div class="paragraph">
<p>Consul服务发现网桥从 <a href="http://consul.io">Consul</a> 导入服务到Vert.x服务发现。这个网桥链接了 Consul agent 服务 并周期性扫描以下服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新导入的服务</p>
</li>
<li>
<p>移除 处于 <code>maintenance</code> 模式的服务或已经从consul中被移除的服务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个桥接器使用的是 Consul 的HTTP API接口。它不能将服务导出到Consul，并且也不支持服务的修改。</p>
</div>
<div class="paragraph">
<p>服务的类型是通过 <code>tags</code> 推断出来的，如果有一个 <code>tag</code> 和已知的服务类型一样，那么就使用这种服务类型，如果没有匹配的，那么服务导入后将标记为unknown类型。目前暂时只支持http-endpoint类型。</p>
</div>
<div class="sect3">
<h4 id="_using_the_bridge"><a class="anchor" href="#_using_the_bridge"></a>桥接器的使用</h4>
<div class="paragraph">
<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (<code>pom.xml</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vertx-service-discovery-bridge-consul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (<code>build.gradle</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile <span class="hljs-string">'io.vertx:vertx-service-discovery-bridge-consul:4.0.3'</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在创建服务发现对象的时候，像下面这样注册桥接器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx)
    .registerServiceImporter(<span class="hljs-keyword">new</span> ConsulServiceImporter(),
        <span class="hljs-keyword">new</span> JsonObject()
            .put(<span class="hljs-string">"host"</span>, <span class="hljs-string">"localhost"</span>)
            .put(<span class="hljs-string">"port"</span>, <span class="hljs-number">8500</span>)
            .put(<span class="hljs-string">"scan-period"</span>, <span class="hljs-number">2000</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以做一些配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>host</code> 属性，配置 agent 的地址，默认是 <code>localhost</code></p>
</li>
<li>
<p><code>port</code> 属性，配置 agent 的端口，默认的端口是 8500</p>
</li>
<li>
<p><code>acl_token</code> 属性，配置 agent 的访问控制令牌，默认值是 null</p>
</li>
<li>
<p><code>scan-period</code> 属性，配置扫描的频率，扫描的单位是毫秒（ms），默认是 2000 ms</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_kubernetes_bridge"><a class="anchor" href="#_kubernetes_bridge"></a>Kubernetes 桥接器</h3>
<div class="paragraph">
<p>Kubernetes 桥接器可以从Kubernetes（或者 Openshift v3）中导入服务到Vert.x的服务发现组件中。
Kubernetes的所有服务，都将映射为一条 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ，目前桥接器只支持将服务从Kubernetes中导入到Vert.x中（反过来不行）。</p>
</div>
<div class="paragraph">
<p>Kubernetes中的服务，在导入到Vert.x后都会创建对应的 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ，服务类型是通过 <code>service-type</code> 标签推断出来，或者通过服务暴露的端口推断出来。</p>
</div>
<div class="sect3">
<h4 id="_using_the_bridge_2"><a class="anchor" href="#_using_the_bridge_2"></a>桥接器的使用</h4>
<div class="paragraph">
<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (<code>pom.xml</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vertx-service-discovery-bridge-kubernetes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle ( <code>build.gradle</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile <span class="hljs-string">'io.vertx:vertx-service-discovery-bridge-kubernetes:4.0.3'</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，当创建服务发现时，按如下注册桥接器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JsonObject defaultConf = <span class="hljs-keyword">new</span> JsonObject();
serviceDiscovery.registerServiceImporter(<span class="hljs-keyword">new</span> KubernetesServiceImporter(), defaultConf);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_the_bridge"><a class="anchor" href="#_configuring_the_bridge"></a>桥接器的配置</h4>
<div class="paragraph">
<p>桥接器的配置项有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OAuth token（默认是使用 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 中的内容）</p>
</li>
<li>
<p>服务搜索的命名空间（默认是`default`）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，应用程序必须能够访问 Kubernetes 并且能够读取所选择的命名空间。</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_service_to_record_mapping"><a class="anchor" href="#_the_service_to_record_mapping"></a>服务记录的映射</h4>
<div class="paragraph">
<p>服务记录按照如下的步骤进行创建：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从 <code>service.type</code> 中推断出服务类型；如果没有设置，那么服务类型被设置为 <code>unknown</code></p>
</li>
<li>
<p>服务记录的名称就是服务的名称</p>
</li>
<li>
<p>服务的标签（label）都被映射为服务记录的元数据</p>
</li>
<li>
<p>此外还会加上：<code>kubernetes.uuid</code> , <code>kubernetes.namespace</code> , <code>kubernetes.name</code></p>
</li>
<li>
<p><code>location</code> 信息将从服务的第一个端口推断出来</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于 HTTP 端点，如果服务带有值为 <code>true</code> 的 <code>ssl</code> (<code>https</code>) 标签的话，那么服务记录的 <code>ssl</code> (<code>https</code>)属性将被设置为 <code>true</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_dynamics"><a class="anchor" href="#_dynamics"></a>动态性</h4>
<div class="paragraph">
<p>Kubernetes 桥接器将会在启动(<code>start</code>)的时候导入所有的服务，在停止(<code>stop</code>)的时候移除所有的服务。在运行期间，它将监听 Kubernetes 的服务，并且动态地导入新加入的服务，移除被删除的服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_supported_types"><a class="anchor" href="#_supported_types"></a>支持的类型</h4>
<div class="paragraph">
<p>桥接器使用 <code>service-type</code> 标签来指定类型。另外，它还检查服务的端口，支持如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>80，443，8080-9000： HTTP端点</p>
</li>
<li>
<p>5432，5433：JDBC数据源（PostGreSQL）</p>
</li>
<li>
<p>3306，13306：JDBC数据源（MySql）</p>
</li>
<li>
<p>6379: Redis 数据源</p>
</li>
<li>
<p>ports 27017, 27018 和 27019: MongoDB 数据源</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果 <code>service-type</code> 存在，那么将覆盖端口的默认配置</p>
</div>
<div class="paragraph">
<p>Unresolved directive in index.adoc - include::zookeeper-bridge.adoc[]</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_docker_links_bridge"><a class="anchor" href="#_docker_links_bridge"></a>Docker Links 桥接器</h3>
<div class="paragraph">
<p>Docker Links 桥接器可以从 Docker Links 中导入服务到 Vert.x 的服务发现组件中。当你将一个Docker容器与另外一个Docker容器链接在一起(link)的时候，Docker将会注入一组环境变量。该桥接器将分析这些环境变量，并且针对每个链接(link)，生成一个服务记录。服务记录的类型从 <code>service.type</code> 属性中推断；如果没有设置，那么服务类型将被设置为 <code>unknown</code> 。目前暂时只支持 <code>http-endpoint</code> 服务类型。</p>
</div>
<div class="paragraph">
<p>由于Docker容器只在启动的时候创建链接，所以这个桥接器只会在启动的时候导入服务记录，然后此后就都不改变了。</p>
</div>
<div class="sect3">
<h4 id="_using_the_bridge_3"><a class="anchor" href="#_using_the_bridge_3"></a>桥接器的使用</h4>
<div class="paragraph">
<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (<code>pom.xml</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vertx-service-discovery-bridge-docker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle ( <code>build.gradle</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile <span class="hljs-string">'io.vertx:vertx-service-discovery-bridge-docker:4.0.3'</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建服务发现对象时，注册桥接器的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx)
    .registerServiceImporter(<span class="hljs-keyword">new</span> DockerLinksServiceImporter(), <span class="hljs-keyword">new</span> JsonObject());</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种桥接器不需要进一步的配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_additional_backends"><a class="anchor" href="#_additional_backends"></a>其他的后台支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了此库支持的后台之外，Vert.x服务发现还提供了其他后台以供您在自己的应用程序中使用。</p>
</div>
<div class="sect2">
<h3 id="_redis_backend"><a class="anchor" href="#_redis_backend"></a>Redis backend</h3>
<div class="paragraph">
<p>服务发现组件通过实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html">ServiceDiscoveryBackend</a></code> SPI提供了一种可插拔的存储后端扩展机制，这是以Redis为基础的SPI的实现。</p>
</div>
<div class="sect3">
<h4 id="_using_the_redis_backend"><a class="anchor" href="#_using_the_redis_backend"></a>使用 Redis 存储后端</h4>
<div class="paragraph">
<p>要使用 Redis 存储后端，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven ( <code>pom.xml</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vertx-service-discovery-backend-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle ( <code>build.gradle</code> 文件):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile <span class="hljs-string">'io.vertx:vertx-service-discovery-backend-redis:4.0.3'</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>需要注意的是，你只能在 <code>classpath</code> 中指定一个SPI的实现；如果没有指定，那么将使用默认的存储后端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuration"><a class="anchor" href="#_configuration"></a>配置</h4>
<div class="paragraph">
<p>Redis存储后端是基于 <a href="http://vertx.io/docs/vertx-redis-client/java">vertx-redis-client</a> 实现的，这个配置是客户端配置以及在Redis上 <code>key</code> 的存储记录</p>
</div>
<div class="paragraph">
<p>下面是一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx, <span class="hljs-keyword">new</span> ServiceDiscoveryOptions()
    .setBackendConfiguration(
        <span class="hljs-keyword">new</span> JsonObject()
            .put(<span class="hljs-string">"connectionString"</span>, <span class="hljs-string">"redis://localhost:6379"</span>)
            .put(<span class="hljs-string">"key"</span>, <span class="hljs-string">"records"</span>)
    ));</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的一点是，配置是在 <code>setBackendConfiguration</code> 方法中传入的（如果使用JSON，则传递给 <code>backendConfiguration</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx,
  <span class="hljs-keyword">new</span> ServiceDiscoveryOptions(<span class="hljs-keyword">new</span> JsonObject()
    .put(<span class="hljs-string">"backendConfiguration"</span>,
      <span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">"connectionString"</span>, <span class="hljs-string">"redis://localhost:6379"</span>).put(<span class="hljs-string">"key"</span>, <span class="hljs-string">"my-records"</span>)
)));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div></div></div></div></div></div><footer><div class="container"><div class="footer-nav-section"><div class="footer-nav-list footer-logo"><a href="/"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAxMjMyLjYgMzE1LjIiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZT4uc3Qwe2ZpbGw6Izc4MmE5MX08L3N0eWxlPjxwYXRoIGQ9Ik0xMjAuOSAyMTQuMkwxOTAuNSAwaDUyLjNsLTk4LjUgMjczLjhIOTguMkwwIDBoNTIuMWw2OC44IDIxNC4yem0yOTEuMi02Mi42SDI5OS42djg0LjJINDMxdjM4SDI1MlYwaDE3Ny43djM4LjRIMjk5LjZWMTE0aDExMi41djM3LjZ6bTgzLjctMTEzLjJINTQ2YzE2LjUuMyAyOSA0LjQgMzcuMyAxMi40IDguMyA4IDEyLjUgMTkuNCAxMi41IDM0IDAgMTQtNC41IDI1LjEtMTMuNSAzMy4yLTkgOC4xLTIxLjYgMTIuMS0zNy42IDEyLjFoLTI3LjF2MjQuMmw4Ni4xIDExOS41aDUxdi0yLjRsLTc3LjItMTA2LjdjMjQuOS01LjUgNDMuMy0yMS43IDUyLjYtMzUuOSA4LjItMTIuNiAxMy4zLTI3LjcgMTMuMy00NiAwLTI2LjgtOC42LTQ3LjQtMjUuOC02MS41QzYwMC41IDcuMSA1NzYuMSAwIDU0NC41IDBoLTk2LjN2MjczLjhoNDcuNiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDUyLjMgMTU3LjdsLTQxLjUgNjIuNyAyOS43IDUzLjRoODUuMXoiLz48Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSI4MjcuOSIgY3k9IjI3NC43IiByPSI0MC41Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTEwMzcgMGwtNDcuNiA3NC4yTDk0OSAwaC04NGw4NS4zIDEzNS44LTY3LjEgMTA1LjdjNS43IDkuNSA5LjEgMjAuNSA5LjIgMzIuNGg1MC4xTDExMjEuMyAwSDEwMzd6Ii8+PHBhdGggZD0iTTc2My41IDI3My44Yy4xLTkuOSAyLjUtMTkuMiA2LjYtMjcuNVYzOC40aDg1LjRWMEg2MzguMnYzOC40aDg0LjZ2MjM1LjRoNDAuN3ptNDE0LTI2Ni45aC0xNS4zdjQyLjJoLTguNVY2LjloLTE1LjJWMGgzOXY2Ljl6TTExOTMgMGwxNC4yIDM3LjdMMTIyMS4zIDBoMTF2NDkuMWgtOC41VjMyLjlsLjgtMjEuNy0xNC41IDM3LjloLTYuMWwtMTQuNS0zNy44LjggMjEuNnYxNi4yaC04LjVWMGgxMS4yeiIvPjwvc3ZnPg==" alt="Vert.x Logo"/></a></div><div class="footer-nav-list"><h5>Eclipse Vert.x</h5><ul class=""><li><a class="navbar-menu-item" href="/docs/">文档</a></li><li><a href="/download/">下载</a></li><li><a href="/blog/">博客</a></li><li><a href="/community/">社区</a></li><li><a href="/translation/">翻译团队</a></li><li><a href="https://github.com/eclipse-vertx/vert.x">GitHub</a></li><li><a href="https://github.com/vertx-china/vertx-web-site">翻译GitHub</a></li></ul></div><div class="footer-nav-list"><h5>资源</h5><ul class=""><li><a href="/faq/">答疑</a></li><li><a href="/channels/">联系渠道</a></li><li><a href="https://how-to.vertx.io/">操作指南</a></li><li><a href="https://start.vertx.io/">应用生成器</a></li></ul></div><div class="footer-nav-list"><h5>Eclipse</h5><ul class=""><li><a href="https://www.eclipse.org/">Eclipse 基金会</a></li><li><a href="https://www.eclipse.org/legal/privacy.php">隐私政策</a></li><li><a href="https://www.eclipse.org/legal/termsofuse.php">使用条款</a></li><li><a href="https://www.eclipse.org/legal/copyright.php">版权代理</a></li><li><a href="https://www.eclipse.org/legal/">法律资源</a></li></ul></div></div><div class="footer-copyright"><div class="footer-copyright-remarks">© <!-- -->2021<!-- --> Eclipse Vert.x™<br/>Eclipse Vert.x™ 是开源的，并在<a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="noopener noreferrer">Eclipse Public License 2.0</a>和<a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache License 2.0</a>协议下获得了双重许可。<br class="footer-copyright-break"/>网站由 <a href="https://michelkraemer.com" target="_blank" rel="noopener noreferrer">Michel Krämer</a> 设计。</div><div class="footer-copyright-eclipse-logo"><a href="https://www.eclipse.org/" target="_blank" rel="noopener noreferrer"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAyODEuMyA5MS4xIiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGU+LnN0MHtmaWxsOiNmNzk0MjJ9LnN0MXtmaWxsOiMzZDNjM2J9PC9zdHlsZT48ZyBpZD0iTGF5ZXJfMV8xXyI+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI2NS43IDg0TDI1NyA3M2gtMi43djE3LjdoMy4zdi0xMmw5LjMgMTJoMi4xVjczaC0zLjN2MTF6bS0zMi40LTguM2M0LjIgMCA1LjggMy4zIDUuOCA2LjNzLTEuNiA2LTUuOCA2LTUuNy0zLjEtNS44LTYgMS43LTYuMyA1LjgtNi4zem0wLTNjLTYuMSAwLTkuMSA0LjctOS4xIDkuMyAwIDQuNyAyLjkgOS4xIDkuMSA5LjFzOS00LjYgOS4xLTkuMi0zLTkuMi05LjEtOS4yem0tMjEuMiAxOFY3M2gtMy4zdjE3LjdoMy4zem0tMjMuNiAwaDMuM1Y3Nmg1LjZ2LTNoLTE0LjZ2M2g1LjZsLjEgMTQuN3ptLTE4LjktNi41SDE2M2wzLjMtNy42IDMuMyA3LjZ6bTIuOCA2LjVoMy42TDE2OC4yIDczaC0zLjZsLTggMTcuN2gzLjZsMS41LTMuM2g5LjNsMS40IDMuM3ptLTM4LTE0LjZoMy42YzMuOSAwIDUuNSAyLjggNS41IDUuNS4xIDIuOC0xLjUgNS44LTUuNSA1LjhoLTMuNlY3Ni4xem0zLjctMy4xaC02Ljl2MTcuN2g2LjljNi4yIDAgOC45LTQuNSA4LjktOXMtMi44LTguNy04LjktOC43em0tMjIuNCAxMUwxMDcgNzNoLTIuN3YxNy43aDMuM3YtMTJsOS4zIDEyaDIuMVY3M2gtMy4zdjExek04OC4yIDczdjEwLjJjMCAzLTEuNiA0LjktNC4zIDQuOXMtNC42LTEuNy00LjYtNC45VjczSDc2djEwLjFjMCA1LjMgMy42IDcuOSA3LjkgNy45IDQuNCAwIDcuNy0yLjcgNy43LTcuOVY3M2gtMy40em0tMzMgMi43YzQuMiAwIDUuOCAzLjMgNS44IDYuM3MtMS42IDYtNS44IDYtNS43LTMuMS01LjgtNiAxLjctNi4zIDUuOC02LjN6bTAtM2MtNi4xIDAtOS4xIDQuNy05LjEgOS4zczIuOSA5LjEgOS4xIDkuMSA5LTQuNiA5LjEtOS4yLTMtOS4yLTkuMS05LjJ6bS0yOS43IDE4di02LjVoOC45di0zLjFoLTguOXYtNC44aDkuNFY3M0gyMi4ydjE3LjZoMy4zeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yNjkuNCA1NC40aC0yMi4ydi04LjloMjEuNHYtNi45aC0yMS40di05LjFoMjIuMnYtNy4yaC0yOS42djM5LjVoMjkuNnYtNy40em0tNDAtMjUuNmMtMy02LjEtOS40LTcuOC0xNS41LTcuOC03LjMgMC0xNS4zIDMuNC0xNS4zIDExLjUgMCA4LjkgNy40IDExIDE1LjUgMTIgNS4yLjYgOS4xIDIuMSA5LjEgNS44IDAgNC4zLTQuNCA1LjktOS4xIDUuOXMtOS40LTEuOS0xMS4xLTYuM2wtNi4yIDMuMmMyLjkgNy4yIDkuMSA5LjcgMTcuMiA5LjcgOC44IDAgMTYuNi0zLjggMTYuNi0xMi42IDAtOS40LTcuNy0xMS42LTE1LjktMTIuNi00LjctLjYtOC44LTEuNS04LjgtNSAwLTIuOSAyLjYtNS4yIDguMi01LjIgNC4zIDAgOCAyLjIgOS40IDQuNGw1LjktM3pNMTc2IDIyLjJjLTYuMi0uMS0xMi40IDAtMTguNiAwdjM5LjVoNy40VjUwLjFIMTc2YzE5LjQgMCAxOS40LTI3LjkgMC0yNy45em0tMTEuMSA3LjFIMTc2YzkuNSAwIDkuNSAxNCAwIDE0aC0xMS4ybC4xLTE0em0tMTggMzIuNVYyMi4yaC03LjR2MzkuNWw3LjQuMXptLTQ0LTM5LjZ2MzkuNWgyNy43di02LjloLTIwLjNWMjIuMmgtNy40ek05MC43IDUxLjdjLTIuNyAyLjUtNi4yIDQtOS45IDQtOS44IDAtMTMuNS02LjgtMTMuNi0xMy40czQuMS0xMy43IDEzLjYtMTMuN2MzLjUtLjEgNyAxLjMgOS41IDMuN2w1LTQuOGMtMy44LTMuOS05LjEtNi0xNC41LTYtMTQuMyAwLTIxIDEwLjUtMjAuOSAyMC44czYuMyAyMC4zIDIwLjkgMjAuM2M1LjYuMSAxMS0yIDE1LTUuOWwtNS4xLTV6bS0zOSAyLjdIMjkuNXYtOC45aDIxLjR2LTYuOUgyOS41di05LjFoMjIuMnYtNy4ySDIyLjJ2MzkuNWgyOS42bC0uMS03LjR6Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTkuOCAxOC4yQzE4LjggNC4xIDM2LjktLjggNTIuMSA2bC0xLS43QzM1LjctNC42IDE1LjItLjEgNS4zIDE1LjNzLTUuNCAzNS45IDEwIDQ1LjhsMS4xLjZDMy44IDUwLjguOCAzMi4zIDkuOCAxOC4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yNzIuMiAyNi4xYzAtMi41IDIuMS00LjYgNC42LTQuNiAyLjUgMCA0LjYgMi4xIDQuNiA0LjYgMCAyLjUtMi4xIDQuNi00LjYgNC42LTIuNiAwLTQuNi0yLjEtNC42LTQuNnptOC42IDBjMC0yLjItMS44LTQuMS00LTQuMXMtNC4xIDEuOC00LjEgNC4xYzAgMi4yIDEuNyA0IDMuOSA0LjFoLjFjMi4zIDAgNC4xLTEuOCA0LjEtNC4xem0tNi0yLjVoMi4zYzEuMSAwIDEuOS41IDEuOSAxLjYgMCAuNy0uNCAxLjMtMS4xIDEuNWwxLjIgMS43aC0xLjRsLTEtMS41aC0uN3YxLjVoLTEuMWwtLjEtNC44em0yLjIgMi4zYy41IDAgLjgtLjMuOC0uN3MtLjMtLjctLjgtLjdoLTF2MS4zbDEgLjF6Ii8+PC9nPjwvc3ZnPg==" alt="Eclipse foundation Logo"/></a></div></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"4.0.3/vertx-service-discovery/java","title":"Vert.x 服务发现","fallbackGitHubStars":null,"toc":"\u003cdiv id=\"toc\" class=\"toc\"\u003e\n\u003cdiv id=\"toctitle\"\u003eTable of Contents\u003c/div\u003e\n\u003cul class=\"sectlevel1\"\u003e\n\u003cli\u003e\u003ca href=\"#_using_the_service_discovery\"\u003e使用服务发现\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_overall_concepts\"\u003e概念总览\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_service_records\"\u003e服务记录\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_service_provider_and_publisher\"\u003e提供者和发布者\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_service_consumer\"\u003e服务消费者\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_service_object\"\u003e服务对象\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_service_types\"\u003e服务类型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_service_events\"\u003e服务事件\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_backend\"\u003e后台\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_creating_a_service_discovery_instance\"\u003e创建服务发现实例\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_publishing_services\"\u003e发布服务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_withdrawing_services\"\u003e回收服务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_looking_for_services\"\u003e寻找服务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_retrieving_a_service_reference\"\u003e获取服务引用\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_types_of_services\"\u003e服务类型\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_services_with_no_type\"\u003e无类型的服务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_implementing_your_own_service_type\"\u003e实现您自己的服务类型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_http_endpoints\"\u003eHTTP 节点\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_event_bus_services\"\u003eEvent bus 服务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_message_source\"\u003e消息源服务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_jdbc_data_source\"\u003eJDBC数据源\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_redis_data_source\"\u003eRedis 数据源\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_mongo_data_source\"\u003eMongo数据源\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_listening_for_service_arrivals_and_departures\"\u003e监听服务的注册和注销\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_listening_for_service_usage\"\u003e监听服务使用状况\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_service_discovery_bridges\"\u003e服务发现桥接器\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_rxjava_2_api\"\u003eRxJava 2 API\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_additional_bridges\"\u003e其他的桥接器支持\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_consul_bridge\"\u003eConsul 网桥\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_kubernetes_bridge\"\u003eKubernetes 桥接器\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_docker_links_bridge\"\u003eDocker Links 桥接器\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_additional_backends\"\u003e其他的后台支持\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_redis_backend\"\u003eRedis backend\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e","contents":"\u003ch1\u003eVert.x 服务发现\u003c/h1\u003e\n\n\u003cdiv id=\"preamble\"\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x 服务发现组件提供了一套用于对各种资源服务的发布、发现的基础组件，例如 服务代理、HTTP服务节点（HTTP endpoint）、数据源（data source）\u0026#8230;\u0026#8203; 这些资源统称为 \u003ccode\u003e服务\u003c/code\u003e 。一个 \u003ccode\u003e服务\u003c/code\u003e 即是一个可被发现的功能性模块。它可以用类型、元数据、位置来区分，所以一个 \u003ccode\u003e服务\u003c/code\u003e 可以是一个数据库、服务代理、HTTP节点或者其他任何您能够描述、发现、交互的服务资源。它不一定是一个vert.x对象，它可以是任何组件。每个 \u003ccode\u003e服务\u003c/code\u003e 都被描述成一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e （即：下述 \u003ccode\u003e服务记录\u003c/code\u003e ）。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e服务发现\u003c/code\u003e 组件实现了面向服务计算中定义的服务交互。此外，在某种程度上，还提供了动态的面向服务计算交互，这样应用程序可以对各种服务的上线、下线作出处理。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个服务提供者可以做如下事情：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e发布一个服务的 \u003ccode\u003e服务记录\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e下线一个已发布的 \u003ccode\u003e服务记录\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e更新线上服务的状态 (下线、暂停服务\u0026#8230;\u0026#8203;)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个服务消费者可以做如下事情：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e寻找服务\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e选择绑定到某个服务（获取一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\"\u003eServiceReference\u003c/a\u003e\u003c/code\u003e) 并使用）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e当服务消费者停止后立即释放服务提供者资源\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e监听服务的注册、注销、更新\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务消费者将：1)寻找符合自己需求的 \u003ccode\u003e服务记录\u003c/code\u003e； 2) 接收提供访问入口的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\"\u003eServiceReference\u003c/a\u003e\u003c/code\u003e ；3) 获得一个提供访问入口的 \u003ccode\u003e服务\u003c/code\u003e 对象；4) 停止后立即释放服务对象\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这个过程可以用 \u003cem\u003e服务类型\u003c/em\u003e （service type） 来简化，如果你知道服务的类型(JDBC client, Http client\u0026#8230;\u0026#8203;)，那么你可以直接获取到这个服务对象。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e综上所述，服务提供者和消费者之间共享的核心信息都存放在 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003erecords\u003c/a\u003e\u003c/code\u003e 当中。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e提供者和消费者必须创建自己的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html\"\u003eServiceDiscovery\u003c/a\u003e\u003c/code\u003e 实例。这些实例在后台（分布式架构）进行协作，以使服务之间信息保持同步。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003evert.x的服务发现通过桥接方式 支持对其他服务发现技术的导入和导出。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_using_the_service_discovery\"\u003e\u003ca class=\"anchor\" href=\"#_using_the_service_discovery\"\u003e\u003c/a\u003e使用服务发现\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要使用Vert.x 服务发现组件，需要将下列依赖加入到依赖配置中文件：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMaven (\u003ccode\u003epom.xml\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eio.vertx\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003evertx-service-discovery\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e4.0.3\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGradle (\u003ccode\u003ebuild.gradle\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003ecompile \u003cspan class=\"hljs-string\"\u003e'io.vertx:vertx-service-discovery:4.0.3'\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_overall_concepts\"\u003e\u003ca class=\"anchor\" href=\"#_overall_concepts\"\u003e\u003c/a\u003e概念总览\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务发现机制基于以下章节的几个概念。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_service_records\"\u003e\u003ca class=\"anchor\" href=\"#_service_records\"\u003e\u003c/a\u003e服务记录\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个服务 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e 是服务提供者发布的一个服务描述对象。它包含了名称、元数据、位置对象（描述服务发布在哪里）。这个 \u003ccode\u003e服务记录\u003c/code\u003e 是提供者（发布 \u003ccode\u003e服务记录\u003c/code\u003e ）和消费者（寻找服务时获取 \u003ccode\u003e服务记录\u003c/code\u003e ）之间仅有的共享对象。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e元数据和位置格式由 \u003ccode\u003e服务类型（service type）\u003c/code\u003e 决定（见下述）。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务提供方准备好之后，一个 \u003ccode\u003e服务记录\u003c/code\u003e 就被发布了，服务停止时 \u003ccode\u003e服务记录\u003c/code\u003e 被回收\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_service_provider_and_publisher\"\u003e\u003ca class=\"anchor\" href=\"#_service_provider_and_publisher\"\u003e\u003c/a\u003e提供者和发布者\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务提供者是一个提供 \u003cem\u003e服务\u003c/em\u003e 的对象。发布者负责发布描述提供者的 \u003ccode\u003e服务记录\u003c/code\u003e 。它可能是同一个对象（提供者仅仅发布自己）也可能是个不同的对象。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_service_consumer\"\u003e\u003ca class=\"anchor\" href=\"#_service_consumer\"\u003e\u003c/a\u003e服务消费者\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务消费者在服务发现模块中检索服务。每次检索都会得到 \u003ccode\u003e0..n\u003c/code\u003e 个\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e ，从这些 \u003ccode\u003e服务记录\u003c/code\u003e 当中，服务消费者可以获取到 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\"\u003eServiceReference\u003c/a\u003e\u003c/code\u003e ，这个 \u003ccode\u003e服务引用\u003c/code\u003e 绑定了提供方和消费方，它允许消费方获取到 \u003cem\u003e服务对象（service object）\u003c/em\u003e （用来使用服务）或释放服务。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e释放 \u003ccode\u003e服务引用\u003c/code\u003e 是一件很重要的事情，这清除了 \u003ccode\u003e服务引用\u003c/code\u003e 对象并更新了服务的使用状态\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_service_object\"\u003e\u003ca class=\"anchor\" href=\"#_service_object\"\u003e\u003c/a\u003e服务对象\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e服务对象\u003c/code\u003e 是一个提供了服务入口的对象。它可以是各种形式，例如 代理、客户端、甚至是一些不存在的服务类型。服务对象的性质取决于服务类型。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e注意：因为Vert.x多语言的性质，所以如果你在java、groovy或其他语言获取的 \u003ccode\u003e服务对象\u003c/code\u003e 会不一样。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_service_types\"\u003e\u003ca class=\"anchor\" href=\"#_service_types\"\u003e\u003c/a\u003e服务类型\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务仅仅是一些 \u003ccode\u003e资源（resource）\u003c/code\u003e 或不同类型的 \u003ccode\u003e服务\u003c/code\u003e。他们可以是功能服务组件、数据库、REST-Api等等。Vert.x服务发现模块定义 \u003ccode\u003e服务类型\u003c/code\u003e 来处理各类型的差异。每个类型定义了：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e服务是如何定位的（URI, event bus address, IP / DNS\u0026#8230;\u0026#8203;）- \u003cem\u003elocation\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务对象的性质（service proxy, HTTP client, message consumer\u0026#8230;\u0026#8203;）\u003cem\u003eclient\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务发现组件提供了一些现成的服务类型，但是你可以添加你自己的类型。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_service_events\"\u003e\u003ca class=\"anchor\" href=\"#_service_events\"\u003e\u003c/a\u003e服务事件\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e每当发布或注销一个服务，event-bus上就会触发一个事件(event),这个事件包含了被更新的服务记录。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e另外，为了追踪谁调用谁，每当调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getReference-io.vertx.servicediscovery.Record-\"\u003egetReference\u003c/a\u003e\u003c/code\u003e 则获取reference或者 调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html#release--\"\u003erelease\u003c/a\u003e\u003c/code\u003e 释放reference的时候，事件都在event-bus上被发出 用以跟踪服务的使用情况。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e关于事件的更多详细信息如下。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_backend\"\u003e\u003ca class=\"anchor\" href=\"#_backend\"\u003e\u003c/a\u003e后台\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务发现模块使用了Vert.x的分布式数据结构来存储 \u003ccode\u003e服务记录\u003c/code\u003e 。所以所有的集群成员都能获取到所有的 \u003ccode\u003e服务记录\u003c/code\u003e 。这是后台默认的实现。你可以实现 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html\"\u003eServiceDiscoveryBackend\u003c/a\u003e\u003c/code\u003e SPI 来实现自己的Backend。例如，Vert.x提供了一个基于Redis的基础实现。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e注意：服务发现不要求必须是Vert.x集群。在单节点模式下，这个数据结构存储于本地。它可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html\"\u003eServiceImporter\u003c/a\u003e\u003c/code\u003e 实现。从3.5.0版本开始，你可以在集群模式下用本地结构的event，这可以设置系统参数 \u003ccode\u003evertx-service-discovery-backend-local\u003c/code\u003e 为 \u003ccode\u003etrue\u003c/code\u003e (或者设置环境变量 \u003ccode\u003eVERTX-SERVICE-DISCOVERY-BACKEND-LOCAL\u003c/code\u003e 为 \u003ccode\u003etrue\u003c/code\u003e) 来实现。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_creating_a_service_discovery_instance\"\u003e\u003ca class=\"anchor\" href=\"#_creating_a_service_discovery_instance\"\u003e\u003c/a\u003e创建服务发现实例\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e提供者和消费者必须创建他们自己的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html\"\u003eServiceDiscovery\u003c/a\u003e\u003c/code\u003e 实例来使用服务发现组件：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eServiceDiscovery discovery = ServiceDiscovery.create(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// 自定义配置\u003c/span\u003e\ndiscovery = ServiceDiscovery.create(vertx,\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ServiceDiscoveryOptions()\n        .setAnnounceAddress(\u003cspan class=\"hljs-string\"\u003e\"service-announce\"\u003c/span\u003e)\n        .setName(\u003cspan class=\"hljs-string\"\u003e\"my-name\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// Do something...\u003c/span\u003e\n\ndiscovery.close();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e默认情况下，公告地址(发送事件的event-bus地址)是 \u003ccode\u003evertx.discovery.announce\u003c/code\u003e。你也可以为service usage（见service usage章节）配置一个名称。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当你再也不需要服务发现对象时，不要忘记去关闭它。它关闭了您已配置的发现导入器和导出器，并释放服务引用。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您应该避免共享服务发现实例，因此service usage 将代表正确的“usage”\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_publishing_services\"\u003e\u003ca class=\"anchor\" href=\"#_publishing_services\"\u003e\u003c/a\u003e发布服务\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一旦你拥有了服务发现实例，你可以发布服务。步骤如下：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e为这个服务提供者创建一个服务记录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e发布这个服务记录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e持有这个服务记录，以便于后续的注销和更改操作\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e为了创建服务记录，你可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e 类，或者用不同服务类型提供的便捷方式。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Record()\n    .setType(\u003cspan class=\"hljs-string\"\u003e\"eventbus-service-proxy\"\u003c/span\u003e)\n    .setLocation(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"endpoint\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"the-service-address\"\u003c/span\u003e))\n    .setName(\u003cspan class=\"hljs-string\"\u003e\"my-service\"\u003c/span\u003e)\n    .setMetadata(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"some-label\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-value\"\u003c/span\u003e));\n\ndiscovery.publish(record, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    \u003cspan class=\"hljs-comment\"\u003e// 发布成功\u003c/span\u003e\n    Record publishedRecord = ar.result();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 发布失败\u003c/span\u003e\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 由一个类型创建的record\u003c/span\u003e\nrecord = HttpEndpoint.createRecord(\u003cspan class=\"hljs-string\"\u003e\"some-rest-api\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/api\"\u003c/span\u003e);\ndiscovery.publish(record, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    \u003cspan class=\"hljs-comment\"\u003e// 发布成功\u003c/span\u003e\n    Record publishedRecord = ar.result();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 发布失败\u003c/span\u003e\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e持有服务记录的引用是很重要的事情，因为服务记录中拥有一个 \u003ccode\u003e注册 id\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_withdrawing_services\"\u003e\u003ca class=\"anchor\" href=\"#_withdrawing_services\"\u003e\u003c/a\u003e回收服务\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要回收(下线)一个record，使用：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.unpublish(record.getRegistration(), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    \u003cspan class=\"hljs-comment\"\u003e// Ok\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 无法下线服务，可能是因为已经被移除或者 record根本没有被发布\u003c/span\u003e\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_looking_for_services\"\u003e\u003ca class=\"anchor\" href=\"#_looking_for_services\"\u003e\u003c/a\u003e寻找服务\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003cem\u003e本章解释了获取服务的底层原理，每个服务类型都提供了便捷的方式来整合各个的步骤\u003c/em\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在消费方，第一件事就是要寻找服务记录。您可以检索单个服务记录或者所有符合条件的服务记录。第一种情况，第一个符合条件的服务记录被返回。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e消费方可以提供一个过滤器(filter)来选择服务。有两种方式来描述过滤器：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e一个以 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e 为参数并以布尔类型（这是一个断言）作为返回值的函数\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e这个过滤器是一个JSON-obejct。每一个给出的filter过滤条件都会检查record，所有的过滤条件都必须满足record。过滤条件可以用 \u003ccode\u003e*\u003c/code\u003e 通配符来表示对key的要求，而不是精准匹配。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e我们来看看JSON过滤器的一个例子：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003e{ \"name\" = \"a\" } =\u0026gt; 筛选出名称是\"a\"的record\n{ \"color\" = \"*\" } =\u0026gt; 筛选出存在\"color\"字段的record\n{ \"color\" = \"red\" } =\u0026gt; 筛选出\"color\"字段是\"red\"的record\n{ \"color\" = \"red\", \"name\" = \"a\"} =\u0026gt; 筛选出\"color\"字段是\"red\" 且 \"name\"字段是\"a\"的record\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果没有设置JSON过滤器(\u003ccode\u003enull\u003c/code\u003e 或 empty) ，则筛选出所有的服务记录。当用函数来过滤时，如果你想获取到所有的服务记录，那无论是什么样的服务记录，你必须要返回 \u003cem\u003etrue\u003c/em\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e示例如下：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(r -\u0026gt; \u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 获取到一个record\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 寻找成功但是没有符合条件的服务\u003c/span\u003e\n    }\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 查找失败\u003c/span\u003e\n  }\n});\n\ndiscovery.getRecord((JsonObject) \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 获取到一个record\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 寻找成功但是没有符合条件的服务\u003c/span\u003e\n    }\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 查找失败\u003c/span\u003e\n  }\n});\n\n\n\u003cspan class=\"hljs-comment\"\u003e// 通过名称获取record\u003c/span\u003e\ndiscovery.getRecord(r -\u0026gt; r.getName().equals(\u003cspan class=\"hljs-string\"\u003e\"some-name\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 获取到一个record\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 寻找成功但是没有符合条件的服务\u003c/span\u003e\n    }\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 查找失败\u003c/span\u003e\n  }\n});\n\ndiscovery.getRecord(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-service\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 获取到一个record\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 寻找成功但是没有符合条件的服务\u003c/span\u003e\n    }\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 查找失败\u003c/span\u003e\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 获取所有符合过滤器条件的record\u003c/span\u003e\ndiscovery.getRecords(r -\u0026gt; \u003cspan class=\"hljs-string\"\u003e\"some-value\"\u003c/span\u003e.equals(r.getMetadata().getString(\u003cspan class=\"hljs-string\"\u003e\"some-label\"\u003c/span\u003e)), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    List\u0026lt;Record\u0026gt; results = ar.result();\n    \u003cspan class=\"hljs-comment\"\u003e// 如果获取到非空list，那么我们获取到了record\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 否则说明寻找成功但是没有符合条件的服务\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 查找失败\u003c/span\u003e\n  }\n});\n\n\ndiscovery.getRecords(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"some-label\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-value\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    List\u0026lt;Record\u0026gt; results = ar.result();\n    \u003cspan class=\"hljs-comment\"\u003e// 如果获取到非空list，那么我们获取到了record\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 否则说明寻找成功但是没有符合条件的服务\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 查找失败\u003c/span\u003e\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e我们可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\"\u003egetRecords\u003c/a\u003e\u003c/code\u003e 来获取单条服务记录或者所有符合条件的服务记录。默认情况下，对于服务记录的查找仅仅包含 \u003ccode\u003estatus\u003c/code\u003e 是 \u003ccode\u003eUP\u003c/code\u003e 的情况。这可以被重写：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e当使用JSON过滤器时，设置 \u003ccode\u003estatus\u003c/code\u003e 为你的期望值（或者 \u003ccode\u003e*\u003c/code\u003e 来接收所有的状态）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e当使用函数时，在 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-java.util.function.Function-boolean-io.vertx.core.Handler-\"\u003egetRecords\u003c/a\u003e\u003c/code\u003e 函数 设置 \u003ccode\u003eincludeOutOfService\u003c/code\u003e 参数为 \u003ccode\u003etrue\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_retrieving_a_service_reference\"\u003e\u003ca class=\"anchor\" href=\"#_retrieving_a_service_reference\"\u003e\u003c/a\u003e获取服务引用\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一旦你选择了 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e ，你可以获取一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\"\u003eServiceReference\u003c/a\u003e\u003c/code\u003e 和 \u003ccode\u003e服务对象\u003c/code\u003e :\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eServiceReference reference1 = discovery.getReference(record1);\nServiceReference reference2 = discovery.getReference(record2);\n\n\u003cspan class=\"hljs-comment\"\u003e// 获取到service object，返回服务引用的类型取决于 service type\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Http 节点\u003c/span\u003e\nHttpClient client = reference1.getAs(HttpClient\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 消息源\u003c/span\u003e\nMessageConsumer consumer = reference2.getAs(MessageConsumer\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 当服务使用完毕\u003c/span\u003e\nreference1.release();\nreference2.release();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e切记处理完毕之后释放服务引用资源\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个服务引用代表了一个对服务提供者的绑定关系。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e获取服务引用时，你可以传一个包含了各种数据的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/json/JsonObject.html\"\u003eJsonObject\u003c/a\u003e\u003c/code\u003e 用来配置 \u003ccode\u003e服务对象\u003c/code\u003e 。某些服务类型不需要额外的配置，如下是一些必要的配置（数据源为例）：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eServiceReference reference = discovery.getReferenceWithConfiguration(record, conf);\n\n\u003cspan class=\"hljs-comment\"\u003e// 获取到service object，返回服务引用的类型取决于 service type\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// JDBC 节点\u003c/span\u003e\nJDBCClient client = reference.getAs(JDBCClient\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// Do something with the client...\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 当服务使用完毕\u003c/span\u003e\nreference.release();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在前述例子当中，代码用了 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html#getAs-java.lang.Class-\"\u003egetAs\u003c/a\u003e\u003c/code\u003e 函数，其参数是你期望得到的服务类型。如果你用java语言，你可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html#get--\"\u003eget\u003c/a\u003e\u003c/code\u003e 函数。然而其他语言 你必须传一个你期望的类型值。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_types_of_services\"\u003e\u003ca class=\"anchor\" href=\"#_types_of_services\"\u003e\u003c/a\u003e服务类型\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如上所述，服务发现有 \u003ccode\u003e服务类型\u003c/code\u003e 的概念来管理不同类型的服务。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这些类型默认通过如下方式提供：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html\"\u003eHttpEndpoint\u003c/a\u003e\u003c/code\u003e - 对于 REST API\u0026#8217;来讲, 服务对象是一个由 \u003ccode\u003ehost\u003c/code\u003e、\u003ccode\u003eport\u003c/code\u003e（位置是 \u003ccode\u003eurl\u003c/code\u003e 参数）配置的\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/http/HttpClient.html\"\u003eHttpClient\u003c/a\u003e\u003c/code\u003e .\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\"\u003eEventBusService\u003c/a\u003e\u003c/code\u003e - 对于服务代理，服务对象是一个proxy。它的类型是`proxies interface`（服务所在位置是地址）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\"\u003eMessageSource\u003c/a\u003e\u003c/code\u003e - 对于消息源（发送者），服务对象是一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html\"\u003eMessageConsumer\u003c/a\u003e\u003c/code\u003e （服务所在位置是地址）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html\"\u003eJDBCDataSource\u003c/a\u003e\u003c/code\u003e - 对于 JDBC 数据源, 服务对象是一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\"\u003eJDBCClient\u003c/a\u003e\u003c/code\u003e （客户端配置从 location，metadata和消费方配置来解析）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html\"\u003eRedisDataSource\u003c/a\u003e\u003c/code\u003e - 对于 Redis 数据源, 服务对象是一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/redis/client/Redis.html\"\u003eRedis\u003c/a\u003e\u003c/code\u003e (客户端配置从 location，metadata和消费方配置来解析).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html\"\u003eMongoDataSource\u003c/a\u003e\u003c/code\u003e - 对于 Mongo 数据源, 服务对象是一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\"\u003eMongoClient\u003c/a\u003e\u003c/code\u003e (客户端配置从 location，metadata和消费方配置来解析).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e本节总体上给出有关服务类型的详细信息，并介绍如何使用默认服务类型。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_services_with_no_type\"\u003e\u003ca class=\"anchor\" href=\"#_services_with_no_type\"\u003e\u003c/a\u003e无类型的服务\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一些record也许没有类型(\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html#UNKNOWN\"\u003eServiceType.UNKNOWN\u003c/a\u003e\u003c/code\u003e)。所以不可能从这些record里面获取到服务对象，但是你可以通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e 对象的 \u003ccode\u003elocation\u003c/code\u003e 和 \u003ccode\u003emetadata\u003c/code\u003e 来构建连接的具体信息。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e使用这些服务不会触发 \u003ccode\u003eservice usage\u003c/code\u003e 事件\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_implementing_your_own_service_type\"\u003e\u003ca class=\"anchor\" href=\"#_implementing_your_own_service_type\"\u003e\u003c/a\u003e实现您自己的服务类型\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你可以通过实现 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html\"\u003eServiceType\u003c/a\u003e\u003c/code\u003e SPI 的方式来创建你自己的服务类型:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e(可选) 创建一个public interface 继承 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html\"\u003eServiceType\u003c/a\u003e\u003c/code\u003e 。这个interface仅仅用来提供辅助函数来简化你自定义类型的用法，例如 \u003ccode\u003ecreateRecord\u003c/code\u003e 函数, \u003ccode\u003egetX\u003c/code\u003e ， \u003ccode\u003eX\u003c/code\u003e 是你获取到的服务对象的类型。可以查看 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html\"\u003eHttpEndpoint\u003c/a\u003e\u003c/code\u003e 或者 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\"\u003eMessageSource\u003c/a\u003e\u003c/code\u003e 等接口例子来了解这种设计\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建一个类来实现 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html\"\u003eServiceType\u003c/a\u003e\u003c/code\u003e ，或者实现你在第一步创建的类型。 这个类型有 \u003ccode\u003ename\u003c/code\u003e 和一个为这个类型创建 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\"\u003eServiceReference\u003c/a\u003e\u003c/code\u003e 的函数。这个name必须匹配 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e 类的 \u003ccode\u003etype\u003c/code\u003e 字段，这个record的type就是您自己定义的服务类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建一个类继承 \u003ccode\u003eio.vertx.ext.discovery.types.AbstractServiceReference\u003c/code\u003e ，您可以参数化您将要返回的带有服务对象类型的类，你必须实现 \u003ccode\u003eAbstractServiceReference#retrieve()\u003c/code\u003e 函数来创建服务对象。这个函数只能被调用一次。如果需要清除服务对象，也要重写 \u003ccode\u003eAbstractServiceReference#onClose()\u003c/code\u003e 函数\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在打包jar时在jar内创建一个 \u003ccode\u003eMETA-INF/services/io.vertx.servicediscovery.spi.ServiceType\u003c/code\u003e 文件。这个文件仅仅包含您在第二步创建的类的全名。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建一个包含service type interface（步骤1）的jar，实现类（步骤2，步骤3）和服务描述文件（步骤4）。把这个jar放在你应用的classpath下，然后您的服务类型现在就已经可用了。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_http_endpoints\"\u003e\u003ca class=\"anchor\" href=\"#_http_endpoints\"\u003e\u003c/a\u003eHTTP 节点\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个HTTP节点代表一个REST API或者可用HTTP请求访问的服务。HTTP节点服务对象是一个由host、port、ssl所配置的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/http/HttpClient.html\"\u003eHttpClient\u003c/a\u003e\u003c/code\u003e 对象\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_publishing_a_http_endpoint\"\u003e\u003ca class=\"anchor\" href=\"#_publishing_a_http_endpoint\"\u003e\u003c/a\u003e发布一个HTTP节点\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要发布一个HTTP节点，你需要一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e ，你可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#createRecord-java.lang.String-java.lang.String-int-java.lang.String-io.vertx.core.json.JsonObject-\"\u003eHttpEndpoint.createRecord\u003c/a\u003e\u003c/code\u003e 来创建服务记录。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e下面一段阐述如何用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html\"\u003eHttpEndpoint\u003c/a\u003e\u003c/code\u003e 创建 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record1 = HttpEndpoint.createRecord(\n  \u003cspan class=\"hljs-string\"\u003e\"some-http-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名称\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e//  host\u003c/span\u003e\n  \u003cspan class=\"hljs-number\"\u003e8433\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// port\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"/api\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 服务的根路由\u003c/span\u003e\n);\n\ndiscovery.publish(record1, ar -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n});\n\nRecord record2 = HttpEndpoint.createRecord(\n  \u003cspan class=\"hljs-string\"\u003e\"some-other-name\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名称\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 是否要求 HTTPs\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// host\u003c/span\u003e\n  \u003cspan class=\"hljs-number\"\u003e8433\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// port\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"/api\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务的根路由\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"some-metadata\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some value\"\u003c/span\u003e)\n);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当你在容器或者云启动你的服务时，也许并不知道服务的公网IP和端口，所以发布操作必须要通过另一个对象来获取这个信息，通常它是一个 \u003cem\u003e桥接对象\u003c/em\u003e （ \u003ccode\u003ebridge\u003c/code\u003e ）。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_consuming_a_http_endpoint\"\u003e\u003ca class=\"anchor\" href=\"#_consuming_a_http_endpoint\"\u003e\u003c/a\u003e消费一个HTTP服务节点\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一旦HTTP节点发布，一个消费者可以获取到它。这个服务对象是一个配置了host和port的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/http/HttpClient.html\"\u003eHttpClient\u003c/a\u003e\u003c/code\u003e ：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-http-service\"\u003c/span\u003e), ar1 -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar1.succeeded() \u0026amp;\u0026amp; ar1.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 获取服务引用\u003c/span\u003e\n    ServiceReference reference = discovery.getReference(ar1.result());\n    \u003cspan class=\"hljs-comment\"\u003e// 获取服务对象\u003c/span\u003e\n    HttpClient client = reference.getAs(HttpClient\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 定义完整的path\u003c/span\u003e\n    client.request(HttpMethod.GET, \u003cspan class=\"hljs-string\"\u003e\"/api/persons\"\u003c/span\u003e).compose(request -\u0026gt;\n      request\n        .send()\n        .compose(HttpClientResponse::body))\n      .onComplete(ar2 -\u0026gt; {\n      \u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\n      reference.release();\n    });\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你也可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#getClient-io.vertx.servicediscovery.ServiceDiscovery-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\"\u003eHttpEndpoint.getClient\u003c/a\u003e\u003c/code\u003e 函数，通过一次函数调用来同时完成服务查找和服务对象获取的操作。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eHttpEndpoint.getClient(discovery, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-http-service\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    HttpClient client = ar.result();\n\n    \u003cspan class=\"hljs-comment\"\u003e// 你需要提供完整的path\u003c/span\u003e\n    client.request(HttpMethod.GET, \u003cspan class=\"hljs-string\"\u003e\"/api/persons\"\u003c/span\u003e).compose(request -\u0026gt;\n      request\n        .send()\n        .compose(HttpClientResponse::body))\n      .onComplete(ar2 -\u0026gt; {\n        \u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\n        ServiceDiscovery.releaseServiceObject(discovery, client);\n      });\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在这第二个写法里，用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#releaseServiceObject-io.vertx.servicediscovery.ServiceDiscovery-java.lang.Object-\"\u003eServiceDiscovery.releaseServiceObject\u003c/a\u003e\u003c/code\u003e 来释放服务对象，所以你不需要持有服务引用。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e从Vert.x 3.4.0开始，提供了另一个客户端。这个更高层次封装的客户端名字叫 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\"\u003eWebClient\u003c/a\u003e\u003c/code\u003e，这个客户端用起来更容易。你可以通过如下方式获取 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\"\u003eWebClient\u003c/a\u003e\u003c/code\u003e：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-http-service\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded() \u0026amp;\u0026amp; ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 获取服务引用\u003c/span\u003e\n    ServiceReference reference = discovery.getReference(ar.result());\n    \u003cspan class=\"hljs-comment\"\u003e// 获取服务对象\u003c/span\u003e\n    WebClient client = reference.getAs(WebClient\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 你需要提供完整的path\u003c/span\u003e\n    client.get(\u003cspan class=\"hljs-string\"\u003e\"/api/persons\"\u003c/span\u003e).send(\n      response -\u0026gt; {\n\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\n        reference.release();\n\n      });\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e另外，如果你更倾向于用服务类型的方式：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eHttpEndpoint.getWebClient(discovery, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-http-service\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    WebClient client = ar.result();\n\n    \u003cspan class=\"hljs-comment\"\u003e// 你需要提供完整的path\u003c/span\u003e\n    client.get(\u003cspan class=\"hljs-string\"\u003e\"/api/persons\"\u003c/span\u003e)\n      .send(response -\u0026gt; {\n\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\n        ServiceDiscovery.releaseServiceObject(discovery, client);\n\n      });\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_event_bus_services\"\u003e\u003ca class=\"anchor\" href=\"#_event_bus_services\"\u003e\u003c/a\u003eEvent bus 服务\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eEvent bus服务是服务代理，它基于event bus实现了异步RPC服务。当从event bus服务获取一个服务对象，你获取到对应类型的服务代理。你可以从 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\"\u003eEventBusService\u003c/a\u003e\u003c/code\u003e 获取辅助函数。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e注意：服务代理（服务的实现和服务接口）是由java实现的\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_publishing_an_event_bus_service\"\u003e\u003ca class=\"anchor\" href=\"#_publishing_an_event_bus_service\"\u003e\u003c/a\u003e发布一个event bus服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e发布event bus服务，你需要创建一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record = EventBusService.createRecord(\n    \u003cspan class=\"hljs-string\"\u003e\"some-eventbus-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名称\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"address\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务地址,\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"examples.MyService\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 字符串格式的服务接口类名\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject()\n        .put(\u003cspan class=\"hljs-string\"\u003e\"some-metadata\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some value\"\u003c/span\u003e)\n);\n\ndiscovery.publish(record, ar -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你也可以传服务接口类：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record = EventBusService.createRecord(\n\u003cspan class=\"hljs-string\"\u003e\"some-eventbus-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名称\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"address\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务地址,\u003c/span\u003e\nMyService\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e // 接口类\n)\u003c/span\u003e;\n\ndiscovery.publish(record, ar -\u0026gt; {\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_consuming_an_event_bus_service\"\u003e\u003ca class=\"anchor\" href=\"#_consuming_an_event_bus_service\"\u003e\u003c/a\u003e消费event bus服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要消费一个event bus服务，你可以先获取服务记录，再通过服务记录获取服务引用；或者用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\"\u003eEventBusService\u003c/a\u003e\u003c/code\u003e 接口通过一次调用来完成这两个操作。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当使用服务引用是，你应该这样做：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-eventbus-service\"\u003c/span\u003e), ar -\u0026gt; {\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded() \u0026amp;\u0026amp; ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n\u003cspan class=\"hljs-comment\"\u003e// 获取服务引用\u003c/span\u003e\nServiceReference reference = discovery.getReference(ar.result());\n\u003cspan class=\"hljs-comment\"\u003e// 获取服务对象\u003c/span\u003e\nMyService service = reference.getAs(MyService\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\nreference.release();\n}\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\"\u003eEventBusService\u003c/a\u003e\u003c/code\u003e 类，你可以像下述获取代理：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eEventBusService.getProxy(discovery, MyService\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e, \u003cspan class=\"hljs-title\"\u003ear\u003c/span\u003e -\u0026gt; \u003c/span\u003e{\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\nMyService service = ar.result();\n\n\u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\nServiceDiscovery.releaseServiceObject(discovery, service);\n}\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_message_source\"\u003e\u003ca class=\"anchor\" href=\"#_message_source\"\u003e\u003c/a\u003e消息源服务\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e消息源是一个往event bus地址发送消息的组件，消息源客户端是 `\u003ca href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html\"\u003eMessageConsumer\u003c/a\u003e`类。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e消息被发送给到eventBus的 \u003cem\u003elocation\u003c/em\u003e 或 消息源服务上。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_publishing_a_message_source\"\u003e\u003ca class=\"anchor\" href=\"#_publishing_a_message_source\"\u003e\u003c/a\u003e推送消息\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e就像其他类型的服务，推送一个消息分2步走：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\"\u003eMessageSource\u003c/a\u003e\u003c/code\u003e 创建一个服务对象。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e推送消息\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record = MessageSource.createRecord(\n    \u003cspan class=\"hljs-string\"\u003e\"some-message-source-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"some-address\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// event bus 地址\u003c/span\u003e\n);\n\ndiscovery.publish(record, ar -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n});\n\nrecord = MessageSource.createRecord(\n    \u003cspan class=\"hljs-string\"\u003e\"some-other-message-source-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"some-address\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// event bus 地址\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"examples.MyData\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 消息体类型\u003c/span\u003e\n);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在上述第二个record当中，我们同时指明了消息体（payload）的类型，这个参数是可选的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在Java当中，你可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/java/lang/Class.html\"\u003eClass\u003c/a\u003e\u003c/code\u003e 参数：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record1 = MessageSource.createRecord(\n\u003cspan class=\"hljs-string\"\u003e\"some-message-source-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"some-address\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务地址\u003c/span\u003e\nJsonObject\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e // 消息体类型\n)\u003c/span\u003e;\n\nRecord record2 = MessageSource.createRecord(\n\u003cspan class=\"hljs-string\"\u003e\"some-other-message-source-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"some-address\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务地址\u003c/span\u003e\nJsonObject\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e, // 消息体类型\n\u003cspan class=\"hljs-title\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eJsonObject\u003c/span\u003e().\u003cspan class=\"hljs-title\"\u003eput\u003c/span\u003e(\"\u003cspan class=\"hljs-title\"\u003esome\u003c/span\u003e-\u003cspan class=\"hljs-title\"\u003emetadata\u003c/span\u003e\", \"\u003cspan class=\"hljs-title\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003evalue\u003c/span\u003e\")\n)\u003c/span\u003e;\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_consuming_a_message_source\"\u003e\u003ca class=\"anchor\" href=\"#_consuming_a_message_source\"\u003e\u003c/a\u003e消费消息服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在消费者端，你可以获取服务记录从而获取服务引用，或者用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\"\u003eMessageSource\u003c/a\u003e\u003c/code\u003e 通过一次调用合两步为一。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e通过第一种方式，代码如下：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-message-source-service\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded() \u0026amp;\u0026amp; ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 获取服务引用\u003c/span\u003e\n    ServiceReference reference = discovery.getReference(ar.result());\n    \u003cspan class=\"hljs-comment\"\u003e// 获取服务对象\u003c/span\u003e\n    MessageConsumer\u0026lt;JsonObject\u0026gt; consumer = reference.getAs(MessageConsumer\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 指定消息处理器\u003c/span\u003e\n    consumer.handler(message -\u0026gt; {\n      \u003cspan class=\"hljs-comment\"\u003e// 消息处理器逻辑\u003c/span\u003e\n      JsonObject payload = message.body();\n    });\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\"\u003eMessageSource\u003c/a\u003e\u003c/code\u003e 时，代码就变成了如下：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eMessageSource.\u0026lt;JsonObject\u0026gt;getConsumer(discovery, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-message-source-service\"\u003c/span\u003e), ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    MessageConsumer\u0026lt;JsonObject\u0026gt; consumer = ar.result();\n\n    \u003cspan class=\"hljs-comment\"\u003e// 指定消息处理器\u003c/span\u003e\n    consumer.handler(message -\u0026gt; {\n      \u003cspan class=\"hljs-comment\"\u003e// 消息处理器逻辑\u003c/span\u003e\n      JsonObject payload = message.body();\n    });\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_jdbc_data_source\"\u003e\u003ca class=\"anchor\" href=\"#_jdbc_data_source\"\u003e\u003c/a\u003eJDBC数据源\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e数据源代表数据库或数据仓储。而JDBC数据源特指用JDBC驱动访问数据库。JDBC数据源客户端是 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\"\u003eJDBCClient\u003c/a\u003e\u003c/code\u003e 类。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_publishing_a_jdbc_service\"\u003e\u003ca class=\"anchor\" href=\"#_publishing_a_jdbc_service\"\u003e\u003c/a\u003e发布JDBC服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e类似其他类型的服务，发布JDBC服务需要2步：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html\"\u003eJDBCDataSource\u003c/a\u003e\u003c/code\u003e 创建record\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e推送record\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record = JDBCDataSource.createRecord(\n    \u003cspan class=\"hljs-string\"\u003e\"some-data-source-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"url\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some jdbc url\"\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 服务地址\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"some-metadata\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-value\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 元数据\u003c/span\u003e\n);\n\ndiscovery.publish(record, ar -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e因为JDBC数据源可以使用很多数据库，并且访问方式经常不一样，所以服务记录是没有标准结构定义的，\u003ccode\u003elocation\u003c/code\u003e 是访问数据库配置而提供的一个通用JSONObject属性，用于访问数据源(JDBC url，username\u0026#8230;\u0026#8203;)。其他字段的定义依赖于数据库以及所用连接池决定。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_consuming_a_jdbc_service\"\u003e\u003ca class=\"anchor\" href=\"#_consuming_a_jdbc_service\"\u003e\u003c/a\u003e消费一个JDBC服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e由前所述，如何获取数据源取决于数据源本身。要创建 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\"\u003eJDBCClient\u003c/a\u003e\u003c/code\u003e ，你可以同时提供：\u003ccode\u003erecord location\u003c/code\u003e，元数据和一个有消费方提供的一个Json object：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-data-source-service\"\u003c/span\u003e),\n    ar -\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded() \u0026amp;\u0026amp; ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 获取服务引用\u003c/span\u003e\n        ServiceReference reference = discovery.getReferenceWithConfiguration(\n            ar.result(), \u003cspan class=\"hljs-comment\"\u003e// record\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"clement\"\u003c/span\u003e).put(\u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"*****\"\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 一些额外的元数据\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// 获取service object\u003c/span\u003e\n        JDBCClient client = reference.getAs(JDBCClient\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// 完毕\u003c/span\u003e\n        reference.release();\n      }\n    });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\"\u003eJDBCClient\u003c/a\u003e\u003c/code\u003e 通过一次调用来发现和获取服务。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eJDBCDataSource.\u0026lt;JsonObject\u0026gt;getJDBCClient(discovery,\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-data-source-service\"\u003c/span\u003e),\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"clement\"\u003c/span\u003e).put(\u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"*****\"\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 一些额外的元数据\u003c/span\u003e\n    ar -\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n        JDBCClient client = ar.result();\n\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\n        ServiceDiscovery.releaseServiceObject(discovery, client);\n\n      }\n    });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_redis_data_source\"\u003e\u003ca class=\"anchor\" href=\"#_redis_data_source\"\u003e\u003c/a\u003eRedis 数据源\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRedis数据源是Redis持久性数据库的一种特殊实现。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRedis数据源客户端是 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/redis/client/Redis.html\"\u003eRedis\u003c/a\u003e\u003c/code\u003e 类\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_publishing_a_redis_service\"\u003e\u003ca class=\"anchor\" href=\"#_publishing_a_redis_service\"\u003e\u003c/a\u003e发布Redis服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e发布Redis服务需要2步：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html\"\u003eRedisDataSource\u003c/a\u003e\u003c/code\u003e 创建服务记录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e推送record\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record = RedisDataSource.createRecord(\n  \u003cspan class=\"hljs-string\"\u003e\"some-redis-data-source-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"url\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 服务地址\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"some-metadata\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-value\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 一些元数据\u003c/span\u003e\n);\n\ndiscovery.publish(record, ar -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003elocation\u003c/code\u003e 是一个简单的JSON对象，应提供用于访问Redis数据源的字段(url,port\u0026#8230;\u0026#8203;.)\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_consuming_a_redis_service\"\u003e\u003ca class=\"anchor\" href=\"#_consuming_a_redis_service\"\u003e\u003c/a\u003e消费Redis服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e由前所述，如何访问数据源决定于数据源本身。创建一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/redis/client/Redis.html\"\u003eRedis\u003c/a\u003e\u003c/code\u003e 对象，你可以同时提供：record地址，元数据和由消费方提供的Json object。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-redis-data-source-service\"\u003c/span\u003e), ar -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded() \u0026amp;\u0026amp; ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 获取服务引用\u003c/span\u003e\n      ServiceReference reference = discovery.getReference(ar.result());\n\n      \u003cspan class=\"hljs-comment\"\u003e// 获取服务实例\u003c/span\u003e\n      Redis client = reference.getAs(Redis\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\u003c/span\u003e;\n\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n      \u003cspan class=\"hljs-comment\"\u003e// 完毕 释放资源\u003c/span\u003e\n      reference.release();\n    }\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你也可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html\"\u003eRedisDataSource\u003c/a\u003e\u003c/code\u003e 通过一次调用完成服务发现和获取。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRedisDataSource.getRedisClient(discovery,\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-redis-data-source-service\"\u003c/span\u003e),\n  ar -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n      Redis client = ar.result();\n\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n      \u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\n      ServiceDiscovery.releaseServiceObject(discovery, client);\n\n    }\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_mongo_data_source\"\u003e\u003ca class=\"anchor\" href=\"#_mongo_data_source\"\u003e\u003c/a\u003eMongo数据源\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eMongo数据源是MongoDB数据库的专用化实现。\nMongo数据源服务的客户端是 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\"\u003eMongoClient\u003c/a\u003e\u003c/code\u003e 类\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_publishing_a_mongo_service\"\u003e\u003ca class=\"anchor\" href=\"#_publishing_a_mongo_service\"\u003e\u003c/a\u003e发布Mongo服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e发布Mongo服务需要2步：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"olist arabic\"\u003e\n\u003col class=\"arabic\"\u003e\n\u003cli\u003e\n\u003cp\u003e用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html\"\u003eMongoDataSource\u003c/a\u003e\u003c/code\u003e 创建服务记录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e推送record\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eRecord record = MongoDataSource.createRecord(\n  \u003cspan class=\"hljs-string\"\u003e\"some-data-source-service\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 服务名\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"connection_string\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some mongo connection\"\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 服务地址\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"some-metadata\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-value\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 元数据\u003c/span\u003e\n);\n\ndiscovery.publish(record, ar -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003elocation\u003c/code\u003e 是一个简单的JSON对象，应提供用于访问Mongo数据源的字段(url, port\u0026#8230;\u0026#8203;)\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_consuming_a_mongo_service\"\u003e\u003ca class=\"anchor\" href=\"#_consuming_a_mongo_service\"\u003e\u003c/a\u003e消费Mongo服务\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e由前所述，如何访问数据源取决于数据源本身。创建 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\"\u003eMongoClient\u003c/a\u003e\u003c/code\u003e ，你可以同时提供：\u003ccode\u003erecord location\u003c/code\u003e ,元数据和consumer提供的json object：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003ediscovery.getRecord(\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-data-source-service\"\u003c/span\u003e),\n  ar -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded() \u0026amp;\u0026amp; ar.result() != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 获取服务引用\u003c/span\u003e\n      ServiceReference reference = discovery.getReferenceWithConfiguration(\n        ar.result(), \u003cspan class=\"hljs-comment\"\u003e// record\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"clement\"\u003c/span\u003e).put(\u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"*****\"\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 额外的元数据\u003c/span\u003e\n\n      \u003cspan class=\"hljs-comment\"\u003e// 获取服务对象\u003c/span\u003e\n      MongoClient client = reference.get();\n\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n      \u003cspan class=\"hljs-comment\"\u003e// 完毕 释放资源\u003c/span\u003e\n      reference.release();\n    }\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你也可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html\"\u003eMongoDataSource\u003c/a\u003e\u003c/code\u003e 类通过一次调用来完成服务查找和获取：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eMongoDataSource.\u0026lt;JsonObject\u0026gt;getMongoClient(discovery,\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"some-data-source-service\"\u003c/span\u003e),\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"clement\"\u003c/span\u003e).put(\u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"*****\"\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 一些额外的元数据\u003c/span\u003e\n  ar -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n      MongoClient client = ar.result();\n\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n      \u003cspan class=\"hljs-comment\"\u003e// 不要忘记释放服务资源\u003c/span\u003e\n      ServiceDiscovery.releaseServiceObject(discovery, client);\n\n    }\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_listening_for_service_arrivals_and_departures\"\u003e\u003ca class=\"anchor\" href=\"#_listening_for_service_arrivals_and_departures\"\u003e\u003c/a\u003e监听服务的注册和注销\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e每当服务提供方被发布或移除， \u003cem\u003evertx.discovery.announce\u003c/em\u003e 地址上会推送一个事件。\n这个地址可以在 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html\"\u003eServiceDiscoveryOptions\u003c/a\u003e\u003c/code\u003e 配置\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e收到的record会有一个 \u003ccode\u003estatus\u003c/code\u003e 字段，它描述了record的新状态：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eUP\u003c/code\u003e : 服务可获取，您可以开启并使用它\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eDOWN\u003c/code\u003e : 服务不可获取，你不应该再使用它\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eOUT_OF_SERVICE\u003c/code\u003e : 服务不在运行状态，你不该再用它，但是可能过一会可能会恢复\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_listening_for_service_usage\"\u003e\u003ca class=\"anchor\" href=\"#_listening_for_service_usage\"\u003e\u003c/a\u003e监听服务使用状况\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e每当获取或释放服务引用时 \u003cem\u003evertx.discovery.usage\u003c/em\u003e 地址上会推送一个event。这个地址可以由 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html\"\u003eServiceDiscoveryOptions\u003c/a\u003e\u003c/code\u003e 配置。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这会让您监听服务的使用情况并映射服务的绑定情况。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e收到的消息是一个包含如下信息的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/json/JsonObject.html\"\u003eJsonObject\u003c/a\u003e\u003c/code\u003e ：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003erecord\u003c/code\u003e 属性指服务记录对象\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003etype\u003c/code\u003e 属性是事件的类型，它有两个值：\u003ccode\u003ebind\u003c/code\u003e ，\u003ccode\u003erelease\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eid\u003c/code\u003e 属性是服务发现的id（名称或者node id）\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这个 \u003ccode\u003eid\u003c/code\u003e 可以通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html\"\u003eServiceDiscoveryOptions\u003c/a\u003e\u003c/code\u003e 配置。默认情况下 单节点是\"localhost\"，集群模式下是node id。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你可以禁用服务使用情况的功能，这可以通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html#setUsageAddress-java.lang.String-\"\u003esetUsageAddress\u003c/a\u003e\u003c/code\u003e 设置 \u003ccode\u003eusage address\u003c/code\u003e 为 \u003ccode\u003enull\u003c/code\u003e 来实现。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_service_discovery_bridges\"\u003e\u003ca class=\"anchor\" href=\"#_service_discovery_bridges\"\u003e\u003c/a\u003e服务发现桥接器\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e桥接器 可以让你从其他服务发现机制(Docker，Kubernetes，Consul\u0026#8230;\u0026#8203;)里导入导出服务\n每个桥接器决定了服务如何导入导出。这不一定是双向操作。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可以实现 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html\"\u003eServiceImporter\u003c/a\u003e\u003c/code\u003e 接口，并用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#registerServiceImporter-io.vertx.servicediscovery.spi.ServiceImporter-io.vertx.core.json.JsonObject-\"\u003eregisterServiceImporter\u003c/a\u003e\u003c/code\u003e 来注册的方式，为自己提供桥接器。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e第二个参数是可选的，它可以配置桥接器。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当桥接器被注册时，\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html#start-io.vertx.core.Vertx-io.vertx.servicediscovery.spi.ServicePublisher-io.vertx.core.json.JsonObject-io.vertx.core.Promise-\"\u003estart\u003c/a\u003e\u003c/code\u003e 函数被调用。\n它让您可以配置桥接器。当桥接器被配置时，准备就绪并导入/导出初始服务后，它让给定的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/Future.html\"\u003eFuture\u003c/a\u003e\u003c/code\u003e 处于 \u003ccode\u003ecompleted\u003c/code\u003e 状态；如果bridge starts函数正在阻塞，则它必须使用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\"\u003eexecuteBlocking\u003c/a\u003e\u003c/code\u003e 构造，并设置给定的future对象为 \u003ccode\u003ecompleted\u003c/code\u003e 状态。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当服务发现组件停止，桥接器也随即停止。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html#close-io.vertx.core.Handler-\"\u003eclose\u003c/a\u003e\u003c/code\u003e 函数会清除资源，移除已经导入/导出的服务。这个函数必须设置返回的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/Future.html\"\u003eFuture\u003c/a\u003e\u003c/code\u003e 对象为 \u003ccode\u003ecompleted\u003c/code\u003e 状态,目的在于提醒调用者处理完成事件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e注意：在集群当中，只需要注册服务记录当中一个成员的桥接器即可，因为所有的服务记录都是互通的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_rxjava_2_api\"\u003e\u003ca class=\"anchor\" href=\"#_rxjava_2_api\"\u003e\u003c/a\u003eRxJava 2 API\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eService importers do not have a generated RxJava 2 implementation.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eYou must create an instance and wrap it with \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/reactivex/servicediscovery/spi/ServiceImporter.html\"\u003eServiceImporter\u003c/a\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eJsonObject defaultConf = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject();\nServiceImporter rxServiceImporter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ServiceImporter(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e KubernetesServiceImporter());\nserviceDiscovery.registerServiceImporter(rxServiceImporter, defaultConf);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_additional_bridges\"\u003e\u003ca class=\"anchor\" href=\"#_additional_bridges\"\u003e\u003c/a\u003e其他的桥接器支持\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x 服务发现组件除了支持桥接器机制以外，还提供了一些现成的桥接器。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_consul_bridge\"\u003e\u003ca class=\"anchor\" href=\"#_consul_bridge\"\u003e\u003c/a\u003eConsul 网桥\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eConsul服务发现网桥从 \u003ca href=\"http://consul.io\"\u003eConsul\u003c/a\u003e 导入服务到Vert.x服务发现。这个网桥链接了 Consul agent 服务 并周期性扫描以下服务：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e新导入的服务\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e移除 处于 \u003ccode\u003emaintenance\u003c/code\u003e 模式的服务或已经从consul中被移除的服务\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这个桥接器使用的是 Consul 的HTTP API接口。它不能将服务导出到Consul，并且也不支持服务的修改。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务的类型是通过 \u003ccode\u003etags\u003c/code\u003e 推断出来的，如果有一个 \u003ccode\u003etag\u003c/code\u003e 和已知的服务类型一样，那么就使用这种服务类型，如果没有匹配的，那么服务导入后将标记为unknown类型。目前暂时只支持http-endpoint类型。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_using_the_bridge\"\u003e\u003ca class=\"anchor\" href=\"#_using_the_bridge\"\u003e\u003c/a\u003e桥接器的使用\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMaven (\u003ccode\u003epom.xml\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eio.vertx\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003evertx-service-discovery-bridge-consul\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e4.0.3\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGradle (\u003ccode\u003ebuild.gradle\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003ecompile \u003cspan class=\"hljs-string\"\u003e'io.vertx:vertx-service-discovery-bridge-consul:4.0.3'\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e然后，在创建服务发现对象的时候，像下面这样注册桥接器：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eServiceDiscovery.create(vertx)\n    .registerServiceImporter(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ConsulServiceImporter(),\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject()\n            .put(\u003cspan class=\"hljs-string\"\u003e\"host\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e)\n            .put(\u003cspan class=\"hljs-string\"\u003e\"port\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8500\u003c/span\u003e)\n            .put(\u003cspan class=\"hljs-string\"\u003e\"scan-period\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e你可以做一些配置：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ehost\u003c/code\u003e 属性，配置 agent 的地址，默认是 \u003ccode\u003elocalhost\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eport\u003c/code\u003e 属性，配置 agent 的端口，默认的端口是 8500\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eacl_token\u003c/code\u003e 属性，配置 agent 的访问控制令牌，默认值是 null\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003escan-period\u003c/code\u003e 属性，配置扫描的频率，扫描的单位是毫秒（ms），默认是 2000 ms\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_kubernetes_bridge\"\u003e\u003ca class=\"anchor\" href=\"#_kubernetes_bridge\"\u003e\u003c/a\u003eKubernetes 桥接器\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eKubernetes 桥接器可以从Kubernetes（或者 Openshift v3）中导入服务到Vert.x的服务发现组件中。\nKubernetes的所有服务，都将映射为一条 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e ，目前桥接器只支持将服务从Kubernetes中导入到Vert.x中（反过来不行）。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eKubernetes中的服务，在导入到Vert.x后都会创建对应的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/Record.html\"\u003eRecord\u003c/a\u003e\u003c/code\u003e ，服务类型是通过 \u003ccode\u003eservice-type\u003c/code\u003e 标签推断出来，或者通过服务暴露的端口推断出来。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_using_the_bridge_2\"\u003e\u003ca class=\"anchor\" href=\"#_using_the_bridge_2\"\u003e\u003c/a\u003e桥接器的使用\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMaven (\u003ccode\u003epom.xml\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eio.vertx\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003evertx-service-discovery-bridge-kubernetes\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e4.0.3\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGradle ( \u003ccode\u003ebuild.gradle\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003ecompile \u003cspan class=\"hljs-string\"\u003e'io.vertx:vertx-service-discovery-bridge-kubernetes:4.0.3'\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e然后，当创建服务发现时，按如下注册桥接器：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eJsonObject defaultConf = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject();\nserviceDiscovery.registerServiceImporter(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e KubernetesServiceImporter(), defaultConf);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_configuring_the_bridge\"\u003e\u003ca class=\"anchor\" href=\"#_configuring_the_bridge\"\u003e\u003c/a\u003e桥接器的配置\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e桥接器的配置项有：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eOAuth token（默认是使用 \u003ccode\u003e/var/run/secrets/kubernetes.io/serviceaccount/token\u003c/code\u003e 中的内容）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务搜索的命名空间（默认是`default`）\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e请注意，应用程序必须能够访问 Kubernetes 并且能够读取所选择的命名空间。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_the_service_to_record_mapping\"\u003e\u003ca class=\"anchor\" href=\"#_the_service_to_record_mapping\"\u003e\u003c/a\u003e服务记录的映射\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务记录按照如下的步骤进行创建：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e从 \u003ccode\u003eservice.type\u003c/code\u003e 中推断出服务类型；如果没有设置，那么服务类型被设置为 \u003ccode\u003eunknown\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务记录的名称就是服务的名称\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务的标签（label）都被映射为服务记录的元数据\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e此外还会加上：\u003ccode\u003ekubernetes.uuid\u003c/code\u003e , \u003ccode\u003ekubernetes.namespace\u003c/code\u003e , \u003ccode\u003ekubernetes.name\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003elocation\u003c/code\u003e 信息将从服务的第一个端口推断出来\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e对于 HTTP 端点，如果服务带有值为 \u003ccode\u003etrue\u003c/code\u003e 的 \u003ccode\u003essl\u003c/code\u003e (\u003ccode\u003ehttps\u003c/code\u003e) 标签的话，那么服务记录的 \u003ccode\u003essl\u003c/code\u003e (\u003ccode\u003ehttps\u003c/code\u003e)属性将被设置为 \u003ccode\u003etrue\u003c/code\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_dynamics\"\u003e\u003ca class=\"anchor\" href=\"#_dynamics\"\u003e\u003c/a\u003e动态性\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eKubernetes 桥接器将会在启动(\u003ccode\u003estart\u003c/code\u003e)的时候导入所有的服务，在停止(\u003ccode\u003estop\u003c/code\u003e)的时候移除所有的服务。在运行期间，它将监听 Kubernetes 的服务，并且动态地导入新加入的服务，移除被删除的服务。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_supported_types\"\u003e\u003ca class=\"anchor\" href=\"#_supported_types\"\u003e\u003c/a\u003e支持的类型\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e桥接器使用 \u003ccode\u003eservice-type\u003c/code\u003e 标签来指定类型。另外，它还检查服务的端口，支持如下：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e80，443，8080-9000： HTTP端点\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e5432，5433：JDBC数据源（PostGreSQL）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e3306，13306：JDBC数据源（MySql）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e6379: Redis 数据源\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eports 27017, 27018 和 27019: MongoDB 数据源\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果 \u003ccode\u003eservice-type\u003c/code\u003e 存在，那么将覆盖端口的默认配置\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eUnresolved directive in index.adoc - include::zookeeper-bridge.adoc[]\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_docker_links_bridge\"\u003e\u003ca class=\"anchor\" href=\"#_docker_links_bridge\"\u003e\u003c/a\u003eDocker Links 桥接器\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eDocker Links 桥接器可以从 Docker Links 中导入服务到 Vert.x 的服务发现组件中。当你将一个Docker容器与另外一个Docker容器链接在一起(link)的时候，Docker将会注入一组环境变量。该桥接器将分析这些环境变量，并且针对每个链接(link)，生成一个服务记录。服务记录的类型从 \u003ccode\u003eservice.type\u003c/code\u003e 属性中推断；如果没有设置，那么服务类型将被设置为 \u003ccode\u003eunknown\u003c/code\u003e 。目前暂时只支持 \u003ccode\u003ehttp-endpoint\u003c/code\u003e 服务类型。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e由于Docker容器只在启动的时候创建链接，所以这个桥接器只会在启动的时候导入服务记录，然后此后就都不改变了。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_using_the_bridge_3\"\u003e\u003ca class=\"anchor\" href=\"#_using_the_bridge_3\"\u003e\u003c/a\u003e桥接器的使用\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMaven (\u003ccode\u003epom.xml\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eio.vertx\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003evertx-service-discovery-bridge-docker\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e4.0.3\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGradle ( \u003ccode\u003ebuild.gradle\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003ecompile \u003cspan class=\"hljs-string\"\u003e'io.vertx:vertx-service-discovery-bridge-docker:4.0.3'\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e创建服务发现对象时，注册桥接器的示例：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eServiceDiscovery.create(vertx)\n    .registerServiceImporter(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e DockerLinksServiceImporter(), \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这种桥接器不需要进一步的配置。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_additional_backends\"\u003e\u003ca class=\"anchor\" href=\"#_additional_backends\"\u003e\u003c/a\u003e其他的后台支持\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e除了此库支持的后台之外，Vert.x服务发现还提供了其他后台以供您在自己的应用程序中使用。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_redis_backend\"\u003e\u003ca class=\"anchor\" href=\"#_redis_backend\"\u003e\u003c/a\u003eRedis backend\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e服务发现组件通过实现 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html\"\u003eServiceDiscoveryBackend\u003c/a\u003e\u003c/code\u003e SPI提供了一种可插拔的存储后端扩展机制，这是以Redis为基础的SPI的实现。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_using_the_redis_backend\"\u003e\u003ca class=\"anchor\" href=\"#_using_the_redis_backend\"\u003e\u003c/a\u003e使用 Redis 存储后端\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要使用 Redis 存储后端，需要将如下的依赖包加入到依赖配置文件中：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMaven ( \u003ccode\u003epom.xml\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eio.vertx\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003evertx-service-discovery-backend-redis\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e4.0.3\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGradle ( \u003ccode\u003ebuild.gradle\u003c/code\u003e 文件):\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003ecompile \u003cspan class=\"hljs-string\"\u003e'io.vertx:vertx-service-discovery-backend-redis:4.0.3'\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e需要注意的是，你只能在 \u003ccode\u003eclasspath\u003c/code\u003e 中指定一个SPI的实现；如果没有指定，那么将使用默认的存储后端。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect3\"\u003e\n\u003ch4 id=\"_configuration\"\u003e\u003ca class=\"anchor\" href=\"#_configuration\"\u003e\u003c/a\u003e配置\u003c/h4\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eRedis存储后端是基于 \u003ca href=\"http://vertx.io/docs/vertx-redis-client/java\"\u003evertx-redis-client\u003c/a\u003e 实现的，这个配置是客户端配置以及在Redis上 \u003ccode\u003ekey\u003c/code\u003e 的存储记录\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e下面是一个示例：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eServiceDiscovery.create(vertx, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ServiceDiscoveryOptions()\n    .setBackendConfiguration(\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject()\n            .put(\u003cspan class=\"hljs-string\"\u003e\"connectionString\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"redis://localhost:6379\"\u003c/span\u003e)\n            .put(\u003cspan class=\"hljs-string\"\u003e\"key\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"records\"\u003c/span\u003e)\n    ));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e值得注意的一点是，配置是在 \u003ccode\u003esetBackendConfiguration\u003c/code\u003e 方法中传入的（如果使用JSON，则传递给 \u003ccode\u003ebackendConfiguration\u003c/code\u003e 对象:\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eServiceDiscovery.create(vertx,\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ServiceDiscoveryOptions(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject()\n    .put(\u003cspan class=\"hljs-string\"\u003e\"backendConfiguration\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e JsonObject().put(\u003cspan class=\"hljs-string\"\u003e\"connectionString\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"redis://localhost:6379\"\u003c/span\u003e).put(\u003cspan class=\"hljs-string\"\u003e\"key\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"my-records\"\u003c/span\u003e)\n)));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e","version":"4.0.3"},"__N_SSG":true},"page":"/docs/[[...slug]]","query":{"slug":["4.0.3","vertx-service-discovery","java"]},"buildId":"S6bD3CR4E3XVmuP6-mFzk","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-9a5c89434732593ca2fd.js"></script><script src="/_next/static/chunks/main-b6e20584df76f29b6f35.js" async=""></script><script src="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" async=""></script><script src="/_next/static/chunks/framework.fcef98db13e2318579fb.js" async=""></script><script src="/_next/static/chunks/commons.5b8771ac6e8a338f82f1.js" async=""></script><script src="/_next/static/chunks/styles.7064a0f84b2a7c13404a.js" async=""></script><script src="/_next/static/chunks/pages/_app-3dbbc9c041333077c167.js" async=""></script><script src="/_next/static/chunks/5df0631eea625b022d3730b3f1bf573e1b8deb37.2c5d42edba8dda0b0ba3.js" async=""></script><script src="/_next/static/chunks/31acfd8439b7c9eee4abe9f59c7500d6c943ee0d.c89fc1fca127558204bd.js" async=""></script><script src="/_next/static/chunks/pages/docs/%5B%5B...slug%5D%5D-3a425d1828d3af7aa498.js" async=""></script><script src="/_next/static/S6bD3CR4E3XVmuP6-mFzk/_buildManifest.js" async=""></script><script src="/_next/static/S6bD3CR4E3XVmuP6-mFzk/_ssgManifest.js" async=""></script></body></html>