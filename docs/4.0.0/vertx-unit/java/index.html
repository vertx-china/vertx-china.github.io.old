<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="description" content="Vert.x | Reactive applications on the JVM"/><meta name="robots" content="index,follow"/><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,400" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&amp;display=swap" rel="stylesheet"/><link rel="shortcut icon" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48x48.png"/><link rel="alternate" type="application/rss+xml" href="/feed/rss.xml"/><link rel="alternate" type="application/atom+xml" href="/feed/atom.xml"/><link rel="alternate" type="application/json" href="/feed/feed.json"/><title>Vert.x 单元测试 | Eclipse Vert.x</title><link rel="preload" href="https://api.github.com/repos/vert-x3/vertx-unit" as="fetch" crossorigin="anonymous"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/styles.f20dca63.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.f20dca63.chunk.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-b6e20584df76f29b6f35.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.fcef98db13e2318579fb.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.5b8771ac6e8a338f82f1.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.7064a0f84b2a7c13404a.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3dbbc9c041333077c167.js" as="script"/><link rel="preload" href="/_next/static/chunks/5df0631eea625b022d3730b3f1bf573e1b8deb37.3b9874ba65db13e7d868.js" as="script"/><link rel="preload" href="/_next/static/chunks/31acfd8439b7c9eee4abe9f59c7500d6c943ee0d.271e32a961c78bfd051e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/docs/%5B%5B...slug%5D%5D-f144718c033f8d0b431b.js" as="script"/></head><body><div id="__next"><main class="page docs"><header><div class="navbar"><div class="navbar-content container"><div class="navbar-logo"><a href="/"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAxMTI1LjYgMzE1LjIiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZT4uc3Qwe2ZpbGw6Izc4MmE5MX08L3N0eWxlPjxwYXRoIGQ9Ik0xMjAuOSAyMTQuMkwxOTAuNSAwaDUyLjNsLTk4LjUgMjczLjhIOTguMkwwIDBoNTIuMWw2OC44IDIxNC4yem0yOTEuMi02Mi42SDI5OS42djg0LjJINDMxdjM4SDI1MlYwaDE3Ny43djM4LjRIMjk5LjZWMTE0aDExMi41djM3LjZ6bTgzLjctMTEzLjJINTQ2YzE2LjUuMyAyOSA0LjQgMzcuMyAxMi40IDguMyA4IDEyLjUgMTkuNCAxMi41IDM0IDAgMTQtNC41IDI1LjEtMTMuNSAzMy4yLTkgOC4xLTIxLjYgMTIuMS0zNy42IDEyLjFoLTI3LjF2MjQuMmw4Ni4xIDExOS41aDUxdi0yLjRsLTc3LjItMTA2LjdjMjQuOS01LjUgNDMuMy0yMS43IDUyLjYtMzUuOSA4LjItMTIuNiAxMy4zLTI3LjcgMTMuMy00NiAwLTI2LjgtOC42LTQ3LjQtMjUuOC02MS41QzYwMC41IDcuMSA1NzYuMSAwIDU0NC41IDBoLTk2LjN2MjczLjhoNDcuNiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDUyLjMgMTU3LjdsLTQxLjUgNjIuNyAyOS43IDUzLjRoODUuMXoiLz48Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSI4MjcuOSIgY3k9IjI3NC43IiByPSI0MC41Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTEwMzcgMGwtNDcuNiA3NC4yTDk0OSAwaC04NGw4NS4zIDEzNS44LTY3LjEgMTA1LjdjNS43IDkuNSA5LjEgMjAuNSA5LjIgMzIuNGg1MC4xTDExMjEuMyAwSDEwMzd6Ii8+PHBhdGggZD0iTTc2My41IDI3My44Yy4xLTkuOSAyLjUtMTkuMiA2LjYtMjcuNVYzOC40aDg1LjRWMEg2MzguMnYzOC40aDg0LjZ2MjM1LjRoNDAuN3oiLz48L3N2Zz4=" alt="Vert.x Logo"/></a></div><div class="navbar-collapse-button"><span></span><span></span><span></span></div><div class="navbar-right"><div class="navbar-menu"><span class="navbar-menu-item with-drop-down"><div class="dropdown"><a class="dropdown-title">开始<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu"><a href="/introduction-to-vertx-and-reactive/"><li class="dropdown-item">简介</li></a><a href="/get-started/"><li class="dropdown-item">开始</li></a><a href="https://start.vertx.io/" target="_blank" rel="noreferrer"><li class="dropdown-item">App generator <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a></ul></div></span><a class="navbar-menu-item" href="/docs/">文档</a><span class="navbar-menu-item with-drop-down"><div class="dropdown"><a class="dropdown-title">资源<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu"><a href="/faq/"><li class="dropdown-item">答疑</li></a><a href="/channels/"><li class="dropdown-item">Channels</li></a><a href="https://how-to.vertx.io/" target="_blank" rel="noreferrer"><li class="dropdown-item">How-To’s <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a><a href="https://github.com/vert-x3/vertx-eventbus-bridge-clients" target="_blank" rel="noreferrer"><li class="dropdown-item">EventBus Bridge Clients <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="external-link-icon"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></li></a></ul></div></span><a class="navbar-menu-item" href="/blog/">博客</a><a class="navbar-menu-item" href="/community/">社区</a><a class="navbar-menu-item" href="/translation/">翻译团队</a></div><div class="navbar-social"><a href="https://github.com/vert-x3/vertx-awesome" class="navbar-social-link" title="Awesome Vert.x" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="List of awesome Vert.x projects"><title>Awesome Vert.x</title><path d="M24 11.438l-6.154-5.645-.865.944 5.128 4.7H1.895l5.128-4.705-.865-.943-6.154 5.649H0v3.72c0 1.683 1.62 3.053 3.61 3.053h3.795c1.99 0 3.61-1.37 3.61-3.051v-2.446h1.97v2.446c0 1.68 1.62 3.051 3.61 3.051h3.794c1.99 0 3.61-1.37 3.61-3.051v-3.721z"></path></svg></a><a href="https://stackoverflow.com/questions/tagged/vert.x" class="navbar-social-link" title="Stack Overflow" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Stack Overflow questions related to Vert.x"><title>Stack Overflow</title><path d="M18.986 21.865v-6.404h2.134V24H1.844v-8.539h2.13v6.404h15.012zM6.111 19.731H16.85v-2.137H6.111v2.137zm.259-4.852l10.48 2.189.451-2.07-10.478-2.187-.453 2.068zm1.359-5.056l9.705 4.53.903-1.95-9.706-4.53-.902 1.936v.014zm2.715-4.785l8.217 6.855 1.359-1.62-8.216-6.853-1.35 1.617-.01.001zM15.751 0l-1.746 1.294 6.405 8.604 1.746-1.294L15.749 0h.002z"></path></svg></a><a href="https://www.youtube.com/channel/UCGN6L3tRhs92Uer3c6VxOSA" class="navbar-social-link" title="YouTube" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="YouTube channel of Vert.x"><title>YouTube</title><path d="M23.499 6.203a3.008 3.008 0 00-2.089-2.089c-1.87-.501-9.4-.501-9.4-.501s-7.509-.01-9.399.501a3.008 3.008 0 00-2.088 2.09A31.258 31.26 0 000 12.01a31.258 31.26 0 00.523 5.785 3.008 3.008 0 002.088 2.089c1.869.502 9.4.502 9.4.502s7.508 0 9.399-.502a3.008 3.008 0 002.089-2.09 31.258 31.26 0 00.5-5.784 31.258 31.26 0 00-.5-5.808zm-13.891 9.4V8.407l6.266 3.604z"></path></svg></a><a href="https://discord.gg/KzEMwP2" class="navbar-social-link" title="Discord" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Eclipse Vert.x channel on Discord"><title>Discord</title><path d="M20.222 0c1.406 0 2.54 1.137 2.607 2.475V24l-2.677-2.273-1.47-1.338-1.604-1.398.67 2.205H3.71c-1.402 0-2.54-1.065-2.54-2.476V2.48C1.17 1.142 2.31.003 3.715.003h16.5L20.222 0zm-6.118 5.683h-.03l-.202.2c2.073.6 3.076 1.537 3.076 1.537-1.336-.668-2.54-1.002-3.744-1.137-.87-.135-1.74-.064-2.475 0h-.2c-.47 0-1.47.2-2.81.735-.467.203-.735.336-.735.336s1.002-1.002 3.21-1.537l-.135-.135s-1.672-.064-3.477 1.27c0 0-1.805 3.144-1.805 7.02 0 0 1 1.74 3.743 1.806 0 0 .4-.533.805-1.002-1.54-.468-2.14-1.404-2.14-1.404s.134.066.335.2h.06c.03 0 .044.015.06.03v.006c.016.016.03.03.06.03.33.136.66.27.93.4.466.202 1.065.403 1.8.536.93.135 1.996.2 3.21 0 .6-.135 1.2-.267 1.8-.535.39-.2.87-.4 1.397-.737 0 0-.6.936-2.205 1.404.33.466.795 1 .795 1 2.744-.06 3.81-1.8 3.87-1.726 0-3.87-1.815-7.02-1.815-7.02-1.635-1.214-3.165-1.26-3.435-1.26l.056-.02zm.168 4.413c.703 0 1.27.6 1.27 1.335 0 .74-.57 1.34-1.27 1.34-.7 0-1.27-.6-1.27-1.334.002-.74.573-1.338 1.27-1.338zm-4.543 0c.7 0 1.266.6 1.266 1.335 0 .74-.57 1.34-1.27 1.34-.7 0-1.27-.6-1.27-1.334 0-.74.57-1.338 1.27-1.338z"></path></svg></a><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx" class="navbar-social-link" title="Vert.x User Group" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="A Google group for Vert.x users"><title>Vert.x User Group</title><path d="M.92 3.332c-.776 0-1.216.67-.692 1.383l2.537 4.403v7.86c0 2.013 1.467 3.69 3.459 3.69H20.31a3.75 3.75 0 003.69-3.69V7.043a3.723 3.723 0 00-3.668-3.71zm5.786 3.71H20.1c.587 0 1.153.357 1.153.923 0 .566-.566.922-1.153.922H6.706c-.587 0-1.153-.356-1.153-.922 0-.566.566-.923 1.153-.923zm0 3.69H20.1c.587 0 1.153.356 1.153.922 0 .566-.566.922-1.153.922H6.706c-.587 0-1.153-.356-1.153-.922 0-.566.566-.922 1.153-.922zm-.021 3.71h9.705c.587 0 1.153.356 1.153.922 0 .566-.566.923-1.153.923H6.685c-.587 0-1.153-.357-1.153-.923 0-.566.566-.922 1.153-.922Z"></path></svg></a><a href="https://shang.qq.com/wpa/qunwpa?idkey=587f58cacb9557e3291b46098e0fe09427b98a1c0f866da23c04c2762bc7e2ad" class="navbar-social-link" title="Vert.x中国用户组QQ群" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24" aria-label="Vert.x中国用户组QQ群"><title>Vert.x中国用户组QQ群</title><path d="M21.395 15.035a39.548 39.548 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a38.97 38.97 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673zM12.662 4.846c.039-1.052.659-1.878 1.385-1.846s1.281.912 1.242 1.964c-.039 1.051-.659 1.878-1.385 1.846s-1.282-.912-1.242-1.964zM9.954 3c.725-.033 1.345.794 1.384 1.846.04 1.052-.517 1.931-1.242 1.963-.726.033-1.346-.794-1.385-1.845C8.672 3.912 9.228 3.033 9.954 3zM7.421 8.294c.194-.43 2.147-.908 4.566-.908h.026c2.418 0 4.372.479 4.566.908a.14.14 0 0 1 .014.061c0 .031-.01.059-.026.083-.163.238-2.333 1.416-4.553 1.416h-.026c-2.221 0-4.39-1.178-4.553-1.416a.136.136 0 0 1-.014-.144zm10.422 8.622c-.22 3.676-2.403 5.987-5.774 6.021h-.137c-3.37-.033-5.554-2.345-5.773-6.021-.081-1.35.001-2.496.147-3.43.318.063.638.122.958.176v3.506s1.658.334 3.318.103v-3.225c.488.027.96.04 1.406.034h.025c1.678.021 3.714-.204 5.683-.594.146.934.227 2.08.147 3.43zM10.48 5.804c.313-.041.542-.409.508-.825-.033-.415-.314-.72-.629-.679-.313.04-.541.409-.508.824.034.417.315.72.629.68zM14.479 5.156c.078.037.221.042.289-.146.035-.095.025-.165-.009-.214-.023-.033-.133-.118-.371-.176-.904-.22-1.341.384-1.405.499-.04.072-.012.176.056.227.067.051.139.037.179-.006.58-.628 1.21-.208 1.261-.184z"></path></svg></a></div></div></div></div></header><div class="page-content docs-content"><div class="container"><div class="docs-content-wrapper"><aside class=""><div class="docs-content-wrapper-sidebar"><div class="search-panel"><div class="search"><input type="text" placeholder="Search..." value=""/><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon-delete"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg></div><ul class="search-results"></ul><div class="search-results-none">No results.</div></div><div class="docs-content-toc"><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">介绍</a></li>
<li><a href="#_writing_a_test_suite">编写一个测试套件</a></li>
<li><a href="#_asserting">断言</a>
<ul class="sectlevel2">
<li><a href="#_assertequals">assertEquals</a></li>
<li><a href="#_assertnotequals">assertNotEquals</a></li>
<li><a href="#_assertnull">assertNull</a></li>
<li><a href="#_assertnotnull">assertNotNull</a></li>
<li><a href="#_assertinrange">assertInRange</a></li>
<li><a href="#_asserttrue_and_assertfalse">断言成功以及断言失败</a></li>
<li><a href="#_failing">失败</a></li>
<li><a href="#_using_third_party_assertion_framework">使用第三方断言框架</a></li>
</ul>
</li>
<li><a href="#_asynchronous_testing">异步测试</a></li>
<li><a href="#_asynchronous_assertions">异步断言</a></li>
<li><a href="#_repeating_test">重复测试</a></li>
<li><a href="#_sharing_objects">共享对象</a></li>
<li><a href="#_running">运行</a>
<ul class="sectlevel2">
<li><a href="#_test_suite_completion">测试套件执行完毕</a></li>
<li><a href="#_time_out">超时</a></li>
<li><a href="#_event_loop">事件循环（Event loop）</a></li>
</ul>
</li>
<li><a href="#_reporting">测试报告</a>
<ul class="sectlevel2">
<li><a href="#_console_reporting">控制台报告</a></li>
<li><a href="#_file_reporting">文件报告</a></li>
<li><a href="#_log_reporting">日志报告</a></li>
<li><a href="#_event_bus_reporting">事件总线报告</a></li>
</ul>
</li>
<li><a href="#_vertx_integration">Vertx 整合</a></li>
<li><a href="#_junit_integration">Junit 整合</a>
<ul class="sectlevel2">
<li><a href="#_running_a_test_on_a_vert_x_context">在 Vert.x 上下文中执行一个测试</a></li>
<li><a href="#_timeout">超时</a></li>
<li><a href="#_parameterized_tests">参数化测试</a></li>
<li><a href="#_repeating_a_test">重复测试</a></li>
<li><a href="#_using_with_other_assertion_libraries">用其他断言库</a></li>
</ul>
</li>
<li><a href="#_java_language_integration">Java 语言整合</a>
<ul class="sectlevel2">
<li><a href="#_test_suite_integration">测试套件整合</a></li>
</ul>
</li>
</ul>
</div></div></div></aside><div class="docs-content-sidebar-toggle"><div style="position:relative"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></div></div><div class="docs-content-inner"><div class="docs-content-metadata"><div class="docs-content-metadata-left"><div class="docs-content-metadata-repo"><div class="github-stars"><a href="https://github.com/vert-x3/vertx-unit"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>null stars</a></div></div><div><a href="https://vertx.io/docs/apidocs"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg> API</a></div><div class="docs-content-metadata-examples"><a href="https://github.com/vert-x3/vertx-examples/tree/4.x/unit-examples"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg> Examples</a></div><div class="docs-content-metadata-edit"><a href="https://github.com/vertx-china/vertx-web-site/tree/master/docs/translation/vertx-unit/java"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg> 改进翻译</a></div><span class="docs-content-metadata-version"><div class="dropdown"><a class="dropdown-title">v4.0.3<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></a><ul class="dropdown-menu align-right"><a href="/docs/vertx-unit/java/"><li class="dropdown-item active has-active-siblings"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="dropdown-check-icon"><polyline points="20 6 9 17 4 12"></polyline></svg>Latest (v<!-- -->4.0.3<!-- -->)</li></a><a href="/docs/3.9.6/vertx-unit/java/"><li class="dropdown-item has-active-siblings">v<!-- -->3.9.6</li></a></ul></div></span></div></div><div><h1>Vertx unit</h1>

<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>异步多语言单元测试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Unit 用多语言的异步API在JVM上 运行单元测试。
Vert.x Unit 借鉴了已有的测试框架，例如 <a href="http://junit.org">JUnit</a> or <a href="http://qunitjs.com">QUnit</a>
并同时遵循了Vert.x的做法。</p>
</div>
<div class="paragraph">
<p>所以 Vert.x Unit 自然就成为了测试 Vert.x 应用的选择。</p>
</div>
<div class="paragraph">
<p>要使用 Vert.x Unit，
那么请添加如下依赖：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven （在您的 <code>pom.xml</code> 文件）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vertx-unit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle （在您的 <code>build.gradle</code> 文件）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">testCompile ${io.vertx}:${vertx-unit}:<span class="hljs-number">4.0</span><span class="hljs-number">.0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x Unit 能够以各种方式使用并可以在您代码中任何位置运行，它仅以正确的方式报告执行结果。
以下示例展示了一个最简的测试用例套件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-string">"the_test_suite"</span>);
suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  String s = <span class="hljs-string">"value"</span>;
  context.assertEquals(<span class="hljs-string">"value"</span>, s);
});
suite.run();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>run</code> 方法执行了整个套件并且执行套件中所有的测试用例。
测试用例套件可能失败也可能通过。如果外界不关心测试结果，
那么测试用例的通过与否便不重要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-string">"the_test_suite"</span>);
suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  String s = <span class="hljs-string">"value"</span>;
  context.assertEquals(<span class="hljs-string">"value"</span>, s);
});
suite.run(<span class="hljs-keyword">new</span> TestOptions().addReporter(<span class="hljs-keyword">new</span> ReportOptions().setTo(<span class="hljs-string">"console"</span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行之时，测试套件会在控制台报告每一步的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Begin test suite the_test_suite
Begin test my_test
Passed my_test
End test suite the_test_suite , run: 1, Failures: 0, Errors: 0</pre>
</div>
</div>
<div class="paragraph">
<p><code>reporters</code> 选项配置了套件执行器的reporter，用以报告测试用例执行结果，
更多信息详见 <a href="#reporting">[reporting]</a> 章节</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_a_test_suite"><a class="anchor" href="#_writing_a_test_suite"></a>编写一个测试套件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>测试套件是一系列测试用例组成的有名称的集合，测试用例则是一个直接回调。
套件生命周期中可以设置回调函数，这些函数可以在执行测试用例前后执行，
也可以在用作初始化/发布服务的套件前后。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-string">"the_test_suite"</span>);
suite.test(<span class="hljs-string">"my_test_case_1"</span>, context -&gt; {
  <span class="hljs-comment">// Test 1</span>
});
suite.test(<span class="hljs-string">"my_test_case_2"</span>, context -&gt; {
  <span class="hljs-comment">// Test 2</span>
});
suite.test(<span class="hljs-string">"my_test_case_3"</span>, context -&gt; {
  <span class="hljs-comment">// Test 3</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>流式API让测试用例可以作链式调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-string">"the_test_suite"</span>);
suite.test(<span class="hljs-string">"my_test_case_1"</span>, context -&gt; {
  <span class="hljs-comment">// Test 1</span>
}).test(<span class="hljs-string">"my_test_case_2"</span>, context -&gt; {
  <span class="hljs-comment">// Test 2</span>
}).test(<span class="hljs-string">"my_test_case_3"</span>, context -&gt; {
  <span class="hljs-comment">// Test 3</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试用例的声明顺序并不保证其执行顺序，所以测试用例不可以依赖于其他测试用例来运行。
这不是一个好的做法。</p>
</div>
<div class="paragraph">
<p>Vert.x Unit 提供了 <em>before</em> 和 <em>after</em> 回调来作总体的启动或清理资源操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-string">"the_test_suite"</span>);
suite.before(context -&gt; {
  <span class="hljs-comment">// 测试套件启动</span>
}).test(<span class="hljs-string">"my_test_case_1"</span>, context -&gt; {
  <span class="hljs-comment">// Test 1</span>
}).test(<span class="hljs-string">"my_test_case_2"</span>, context -&gt; {
  <span class="hljs-comment">// Test 2</span>
}).test(<span class="hljs-string">"my_test_case_3"</span>, context -&gt; {
  <span class="hljs-comment">// Test 3</span>
}).after(context -&gt; {
  <span class="hljs-comment">// 测试套件清理资源</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些方法的声明顺序并不重要，示例中在用例之前声明 <em>before</em> ，
在用例之后声明 <em>after</em> ，
然而在运行套件之前，他们可以在任何位置声明，</p>
</div>
<div class="paragraph">
<p><em>before</em> 回调函数执行于所有测试用例之前，如果其运行失败，
则整个测试套件将停止运行并报告失败结果。 <em>after</em> 回调函数在整个测试套件中最后执行，
除非 <em>before</em> 回调函数运行失败。</p>
</div>
<div class="paragraph">
<p>类似的，Vert.x Unit 提供了 <em>beforeEach</em> 和 <em>afterEach</em> 回调，
在每一个测试用例前后执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-string">"the_test_suite"</span>);
suite.beforeEach(context -&gt; {
  <span class="hljs-comment">// 测试用例启动</span>
}).test(<span class="hljs-string">"my_test_case_1"</span>, context -&gt; {
  <span class="hljs-comment">// Test 1</span>
}).test(<span class="hljs-string">"my_test_case_2"</span>, context -&gt; {
  <span class="hljs-comment">// Test 2</span>
}).test(<span class="hljs-string">"my_test_case_3"</span>, context -&gt; {
  <span class="hljs-comment">// Test 3</span>
}).afterEach(context -&gt; {
  <span class="hljs-comment">// 测试用例资源清理</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>beforeEach</em> 回调函数执行于每一个测试用例之前，一旦其运行失败，那测试用例将不再被执行，
并报告失败结果。 <em>afterEach</em> 回调函数仅在测试用例之后被执行，
除非 <em>beforeEach</em> 函数运行失败。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_asserting"><a class="anchor" href="#_asserting"></a>断言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Unit 提供了 <code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html">TestContext</a></code> 对象用来在测试用例中作断言操作。
<em>context</em> 对象提供了用于断言的常用方法。</p>
</div>
<div class="sect2">
<h3 id="_assertequals"><a class="anchor" href="#_assertequals"></a>assertEquals</h3>
<div class="paragraph">
<p>断言两个对象相等，适用于 <em>基本类型</em> 和 <em>json类型</em> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  context.assertEquals(<span class="hljs-number">10</span>, callbackCount);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一个重载的方法用于提供测试信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  context.assertEquals(<span class="hljs-number">10</span>, callbackCount, <span class="hljs-string">"Should have been 10 instead of "</span> + callbackCount);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常地，每一个断言函数都提供了重载的版本。</p>
</div>
</div>
<div class="sect2">
<h3 id="_assertnotequals"><a class="anchor" href="#_assertnotequals"></a>assertNotEquals</h3>
<div class="paragraph">
<p>与 <em>assertEquals</em> 相反。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  context.assertNotEquals(<span class="hljs-number">10</span>, callbackCount);
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_assertnull"><a class="anchor" href="#_assertnull"></a>assertNull</h3>
<div class="paragraph">
<p>断言一个对象是null，适用于 <em>基本类型</em> 和 <em>json类型</em> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  context.assertNull(<span class="hljs-keyword">null</span>);
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_assertnotnull"><a class="anchor" href="#_assertnotnull"></a>assertNotNull</h3>
<div class="paragraph">
<p>与 <em>assertNull</em> 相反。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  context.assertNotNull(<span class="hljs-string">"not null!"</span>);
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_assertinrange"><a class="anchor" href="#_assertinrange"></a>assertInRange</h3>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html#assertInRange-double-double-double-">assertInRange</a></code> 方法作用于实数范围。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>suite.test("my_test_case", context -&gt; {

  // 断言0.1 在误差范围 +/- 0.5范围内等于0.2

  context.assertInRange(0.1, 0.2, 0.5);
});</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asserttrue_and_assertfalse"><a class="anchor" href="#_asserttrue_and_assertfalse"></a>断言成功以及断言失败</h3>
<div class="paragraph">
<p>对于布尔表达式的断言。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  context.assertTrue(<span class="hljs-keyword">var</span>);
  context.assertFalse(value &gt; <span class="hljs-number">10</span>);
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_failing"><a class="anchor" href="#_failing"></a>失败</h3>
<div class="paragraph">
<p>最后但并非最不重要的，<em>test</em> 提供了一个 <em>fail</em> 方法用来抛出断言错误的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  context.fail(<span class="hljs-string">"That should never happen"</span>);
  <span class="hljs-comment">// 剩下的代码不会执行。</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>失败</code> 对象本身既可以是 <em>string</em> 也可以是一个 <em>error</em> 。
<em>error</em> 对象取决于所使用的编程语言，对于 Java 或者 Groovy 而言，可以是任何 <em>Throwable</em> 的子类，
对于 JavaScript 则是一个 <em>error</em> ，对于 Ruby 则是一个 <em>Exception</em>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_third_party_assertion_framework"><a class="anchor" href="#_using_third_party_assertion_framework"></a>使用第三方断言框架</h3>
<div class="paragraph">
<p>您也可以用任何其他的断言框架，例如比较流行的 <em>hamcrest</em> 和 <em>assertj</em> 。
我们建议您用 <code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html#verify-io.vertx.core.Handler-">verify</a></code> ，
使用我们提供的 <em>处理器（Handler）</em> 来执行断言。
这样的话，我们才能正确的处理异步测试的结束动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; context.verify(v -&gt; {
  <span class="hljs-comment">// 这里 junit中的 Assert 对象可以是 assertj hamcrest或其他库中的Assert对象</span>
  <span class="hljs-comment">// 甚至可以手动抛出 AssertionError</span>
  Assert.assertNotNull(<span class="hljs-string">"not null!"</span>);
  Assert.assertEquals(<span class="hljs-number">10</span>, callbackCount);
}));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_asynchronous_testing"><a class="anchor" href="#_asynchronous_testing"></a>异步测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前述示例的前提是，假设所有的测试用例在各自回调之后会结束，
这是测试用例回调函数的默认行为。在测试用例回调函数之后结束测试是可取的，
例如：</p>
</div>
<div class="listingblock">
<div class="title">Async 对象异步的完成测试用例</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  Async async = context.async();
  eventBus.consumer(<span class="hljs-string">"the-address"</span>, msg -&gt; {
    <b class="conum">(2)</b>
    async.complete();
  });
  <b class="conum">(1)</b>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>回调函数结束，但是测试用例没结束</p>
</li>
<li>
<p>总线事件的回调函数来终止测试</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>用 <code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html#async--">async</a></code> 方法创建一个 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html">Async</a></code> 对象表示测试用例还未结束。
当执行 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html#complete--">complete</a></code> 方法时，
测试用例才算结束。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
当 <code>complete</code> 回调函数未被执行时，测试用例会在指定超时时间之后失败。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>同一个测试用例中可以创建多个 <code>Async</code> 对象，
必须调用所有Async对象的 <em>completed</em> 方法来终止测试。</p>
</div>
<div class="listingblock">
<div class="title">多个Async对象合作</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {

  HttpClient client = vertx.createHttpClient();
  client.request(HttpMethod.GET, <span class="hljs-number">8080</span>, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"/"</span>, context.asyncAssertSuccess(req -&gt; {
      req.send(context.asyncAssertSuccess(resp -&gt; {
        context.assertEquals(<span class="hljs-number">200</span>, resp.statusCode());
      }));
    }));

  Async async = context.async();
  vertx.eventBus().consumer(<span class="hljs-string">"the-address"</span>, msg -&gt; {
    async.complete();
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Async 对象也可以用在 <em>before</em> 或 <em>after</em> 回调中，
这将很方便的在 <em>before</em> 回调中，实现依赖于多个异步结果的启动操作：</p>
</div>
<div class="listingblock">
<div class="title">执行测试用例之前异步启动 http server</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.before(context -&gt; {
  Async async = context.async();
  HttpServer server = vertx.createHttpServer();
  server.requestHandler(requestHandler);
  server.listen(<span class="hljs-number">8080</span>, ar -&gt; {
    context.assertTrue(ar.succeeded());
    async.complete();
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以等待 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html">Async</a></code> 直到其结束，
类似Java的 count-down latch：</p>
</div>
<div class="listingblock">
<div class="title">Wait for completion</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Async async = context.async();
HttpServer server = vertx.createHttpServer();
server.requestHandler(requestHandler);
server.listen(<span class="hljs-number">8080</span>, ar -&gt; {
  context.assertTrue(ar.succeeded());
  async.complete();
});

<span class="hljs-comment">// Wait until completion</span>
async.awaitSuccess();</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
该方法不应该在事件循环（event loop）上执行！
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Async 可以创建一个初始计数值，
当用 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html#countDown--">countDown</a></code> 方法将 count-down 的值减到0时：</p>
</div>
<div class="listingblock">
<div class="title">等待，直到count-down值为0</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Async async = context.async(<span class="hljs-number">2</span>);
HttpServer server = vertx.createHttpServer();
server.requestHandler(requestHandler);
server.listen(<span class="hljs-number">8080</span>, ar -&gt; {
  context.assertTrue(ar.succeeded());
  async.countDown();
});

vertx.setTimer(<span class="hljs-number">1000</span>, id -&gt; {
  async.complete();
});

<span class="hljs-comment">// Wait until completion of the timer and the http request</span>
async.awaitSuccess();</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用Async的 <code>complete()</code> 方法会像往常一样结束，实际上它将count-down值直接设置为 <code>0</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_asynchronous_assertions"><a class="anchor" href="#_asynchronous_assertions"></a>异步断言</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html">TestContext</a></code> 提供了很有用的方法，这些方法提供了强大的异步测试框架：</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess--">asyncAssertSuccess</a></code> 方法返回一个类似 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html">Async</a></code> {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象，
它在运行成功时执行 <code>Async</code> 对象，并在失败时，
让整个测试用例失败，并返回失败原因。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Async async = context.async();
vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    async.complete();
  } <span class="hljs-keyword">else</span> {
    context.fail(ar.cause());
  }
});

<span class="hljs-comment">// 可用如下代替</span>

vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, context.asyncAssertSuccess());</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess-io.vertx.core.Handler-">asyncAssertSuccess</a></code> 方法返回一个类似于 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html">Async</a></code> 的 {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象，
运行成功时它执行了代理 {@literal Handler&lt;T&gt;} ，
而在运行出错时让整个测试用例失败，并返回错误原因。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicBoolean started = <span class="hljs-keyword">new</span> AtomicBoolean();
Async async = context.async();
vertx.deployVerticle(<span class="hljs-keyword">new</span> AbstractVerticle() {
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    started.set(<span class="hljs-keyword">true</span>);
  }
}, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    context.assertTrue(started.get());
    async.complete();
  } <span class="hljs-keyword">else</span> {
    context.fail(ar.cause());
  }
});

<span class="hljs-comment">// Can be replaced by</span>

vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, context.asyncAssertSuccess(id -&gt; {
  context.assertTrue(started.get());
}));</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>Handler</code> 退出时，Async对象同时也会处于 <code>completed</code> 状态，除非Async对象在函数调用期间被创建，
这会在 <em>链式</em> 异步操作时提供方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Async async = context.async();
vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, ar1 -&gt; {
  <span class="hljs-keyword">if</span> (ar1.succeeded()) {
    vertx.deployVerticle(<span class="hljs-string">"my.otherverticle"</span>, ar2 -&gt; {
      <span class="hljs-keyword">if</span> (ar2.succeeded()) {
        async.complete();
      } <span class="hljs-keyword">else</span> {
        context.fail(ar2.cause());
      }
    });
  } <span class="hljs-keyword">else</span> {
    context.fail(ar1.cause());
  }
});

<span class="hljs-comment">// Can be replaced by</span>

vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, context.asyncAssertSuccess(id -&gt;
        vertx.deployVerticle(<span class="hljs-string">"my_otherverticle"</span>, context.asyncAssertSuccess())
));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure--">asyncAssertFailure</a></code> 方法返回了一个类似 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html">Async</a></code> 的 {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象,
它在运行失败时执行 <code>Async</code> ，
并在成功时让测试用例失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Async async = context.async();
vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    context.fail();
  } <span class="hljs-keyword">else</span> {
    async.complete();
  }
});

<span class="hljs-comment">// 可用如下代替</span>

vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, context.asyncAssertFailure());</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure-io.vertx.core.Handler-">asyncAssertFailure</a></code> 方法返回一个类似 <code><a href="../../apidocs/io/vertx/ext/unit/Async.html">Async</a></code> 的  {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象，
它在运行失败时，
执行代理处理器 {@literal Handler&lt;Throwable&gt;} ，
并在执行成功时让测试用例失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Async async = context.async();
vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    context.fail();
  } <span class="hljs-keyword">else</span> {
    context.assertTrue(ar.cause() <span class="hljs-keyword">instanceof</span> IllegalArgumentException);
    async.complete();
  }
});

<span class="hljs-comment">// 可用如下代替</span>

vertx.deployVerticle(<span class="hljs-string">"my.verticle"</span>, context.asyncAssertFailure(cause -&gt; {
  context.assertTrue(cause <span class="hljs-keyword">instanceof</span> IllegalArgumentException);
}));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Handler</code> 退出时，这个Async也会处于完成状态，除非在执行过程中，创建了新的Async对象</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_repeating_test"><a class="anchor" href="#_repeating_test"></a>重复测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当测试随机条件或测试不经常失败时，例如在竞争条件下，
为了增加测试失败的可能性，多次运行同一测试是个方便的方式。</p>
</div>
<div class="listingblock">
<div class="title">重复一个测试</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite.create(<span class="hljs-string">"my_suite"</span>).test(<span class="hljs-string">"my_test"</span>, <span class="hljs-number">1000</span>, context -&gt; {
  <span class="hljs-comment">// 这里会执行1000次</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果声明了 <em>beforeEach</em> 和 <em>afterEach</em> 回调，那么每当测试用例执行一次，它们也会被执行一次。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
重复的测试用例是顺序执行的
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sharing_objects"><a class="anchor" href="#_sharing_objects"></a>共享对象</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html">TestContext</a></code> 对象提供了 <code>get</code>/<code>put</code>/<code>remove</code> 操作，用于在回调函数之间共享状态。</p>
</div>
<div class="paragraph">
<p>在 <em>before</em> 回调函数中添加的任何对象都可以在其他回调函数中访问到。
每一个测试用例都会操作一个共享状态的副本。所以，对于共享状态的更新仅仅在一个测试用例之内有效。</p>
</div>
<div class="listingblock">
<div class="title">在回调函数之间共享状态</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite.create(<span class="hljs-string">"my_suite"</span>).before(context -&gt; {

  <span class="hljs-comment">// cases host对于所有的测试用例可见</span>
  context.put(<span class="hljs-string">"host"</span>, <span class="hljs-string">"localhost"</span>);

}).beforeEach(context -&gt; {

  <span class="hljs-comment">// 为每一个测试用例生成一个port</span>
  <span class="hljs-keyword">int</span> port = helper.randomPort();

  <span class="hljs-comment">// 获取host</span>
  String host = context.get(<span class="hljs-string">"host"</span>);

  <span class="hljs-comment">// 启动服务</span>
  Async async = context.async();
  HttpServer server = vertx.createHttpServer();
  server.requestHandler(req -&gt; {
    req.response().setStatusCode(<span class="hljs-number">200</span>).end();
  });
  server.listen(port, host, ar -&gt; {
    context.assertTrue(ar.succeeded());
    context.put(<span class="hljs-string">"port"</span>, port);
    async.complete();
  });

}).test(<span class="hljs-string">"my_test"</span>, context -&gt; {

  <span class="hljs-comment">// 获取共享状态</span>
  <span class="hljs-keyword">int</span> port = context.get(<span class="hljs-string">"port"</span>);
  String host = context.get(<span class="hljs-string">"host"</span>);

  <span class="hljs-comment">// 发送请求</span>
  HttpClient client = vertx.createHttpClient();
  client.request(HttpMethod.GET, port, host, <span class="hljs-string">"/resource"</span>, context.asyncAssertSuccess(req -&gt; {
    req.send(context.asyncAssertSuccess(resp -&gt; {
      context.assertEquals(<span class="hljs-number">200</span>, resp.statusCode());
    }));
  }));
});</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
只有java才能共享所有类型的对象，其他语言只能共享基本类型和json类型。
其他类型对象的共享操作应该利用当前编程语言的特性来实现。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running"><a class="anchor" href="#_running"></a>运行</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当创建了一个测试套件，除非调用 <code><a href="../../apidocs/io/vertx/ext/unit/TestSuite.html#run--">run</a></code> 方法，否则测试用例不会执行。</p>
</div>
<div class="listingblock">
<div class="title">运行一个测试套件</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个测试套件也可以用指定的 <code><a href="../../apidocs/io/vertx/core/Vertx.html">Vertx</a></code> 来运行：</p>
</div>
<div class="listingblock">
<div class="title">提供一个Vertx对象来执行测试用例</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.run(vertx);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>Vertx</code> 对象来运行时，测试套件则会使用该Vert.x对象的 eventloop 来运行测试用例，
更多信息详见 <a href="#event_loop">[event_loop]</a> 一章。</p>
</div>
<div class="paragraph">
<p>一个测试套件可以用Vert.x命令行接口来执行，即使用 <code>vertx test</code> 命令：</p>
</div>
<div class="listingblock">
<div class="title">用Vert.x CLI 执行测试用例</div>
<div class="content">
<pre class="highlight"><code>&gt; vertx test the_test_suite.js
Begin test suite the_test_suite
Succeeded in deploying verticle
Begin test my_test_case
Passed my_test_case
End test suite my_suite , run: 1, Failures: 0, Errors: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种测试套件仅仅需要通过 <code><a href="../../apidocs/io/vertx/ext/unit/TestSuite.html#run--">run</a></code> 命令来执行，
<code>vertx test</code> 命令则负责配置报告和超时等。
例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-string">"the_test_suite"</span>);
suite.test(<span class="hljs-string">"my_test_case"</span>, context -&gt; {
  String s = <span class="hljs-string">"value"</span>;
  context.assertEquals(<span class="hljs-string">"value"</span>, s);
});
suite.run();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>vertx test</code> 命令扩展了 <code>vertx run</code> 命令。它改变了JVM的退出行为，
当测试套件开始执行，并且返回了测试结果（例如success (0) or failure (1)）的时候，JVM才会退出。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
同一个Verticle中可以执行多个测试套件，
Vert.x Unit会等待所有的测试套件执行完成。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_test_suite_completion"><a class="anchor" href="#_test_suite_completion"></a>测试套件执行完毕</h3>
<div class="paragraph">
<p>我们没办法假设测试套件将何时执行完毕，
如果有代码需要在测试用例执行完毕之后才执行，
那么这段代码要声明在 <em>after</em> 回调函数中或者让其作为 <code><a href="../../apidocs/io/vertx/ext/unit/Completion.html">Completion</a></code> 的回调。</p>
</div>
<div class="listingblock">
<div class="title">测试套件 <em>执行回调函数</em></div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestCompletion completion = suite.run(vertx);

<span class="hljs-comment">// 普通的完成回调函数</span>
completion.handler(ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    System.out.println(<span class="hljs-string">"Test suite passed!"</span>);
  } <span class="hljs-keyword">else</span> {
    System.out.println(<span class="hljs-string">"Test suite failed:"</span>);
    ar.cause().printStackTrace();
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/Completion.html">Completion</a></code> 对象也提供了 <code><a href="../../apidocs/io/vertx/ext/unit/Completion.html#resolve-io.vertx.core.Promise-">resolve</a></code> 方法，
该方法接收 <code>Promise</code> 对象参数，这个 <code>Promise</code> 会在测试套件执行时被触发通知。</p>
</div>
<div class="listingblock">
<div class="title">用测试套件解析初始Promise</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestCompletion completion = suite.run();

<span class="hljs-comment">// 当测试套件执行完毕，Promise则被解析</span>
completion.resolve(startPromise);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以轻松的创建一个 <em>test</em> Verticle，这个Verticle是由测试套件部署起来的，
而部署Verticle的代码中可以很容易的知悉成功或者失败。</p>
</div>
<div class="paragraph">
<p>completion 对象也可以像 count-down latch 一样使用，他会阻塞直至测试套件执行完。
这应该用于当前线程与测试套件线程不一样时的场景。</p>
</div>
<div class="listingblock">
<div class="title">阻塞至测试套件执行完毕</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Completion completion = suite.run();

<span class="hljs-comment">//  阻塞至测试套件执行完毕</span>
completion.await();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>await</code> 方法在线程被interrupt或者超时的时候抛出异常。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/Completion.html#awaitSuccess--">awaitSuccess</a></code> 方法是一个变种，
它在测试套件运行失败时抛出异常</p>
</div>
<div class="listingblock">
<div class="title">阻塞至测试套件执行成功</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Completion completion = suite.run();

<span class="hljs-comment">// 阻塞至测试套件执行成功 否则抛出异常</span>
completion.awaitSuccess();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_time_out"><a class="anchor" href="#_time_out"></a>超时</h3>
<div class="paragraph">
<p>测试套件中的每一个测试用例都必须在超时时间内执行完毕。默认超时时间是 <em>2分钟</em> ，
超时时间可以用 <em>test options</em> 来设置：</p>
</div>
<div class="listingblock">
<div class="title">设置测试套件的超时时间</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestOptions options = <span class="hljs-keyword">new</span> TestOptions().setTimeout(<span class="hljs-number">10000</span>);

<span class="hljs-comment">// 10秒超时时间</span>
suite.run(options);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_loop"><a class="anchor" href="#_event_loop"></a>事件循环（Event loop）</h3>
<div class="paragraph">
<p>Vert.x Unit 是一系列task的执行过程，每个task由前一个task的完成动作来触发。
这些task负责平衡eventloop的调度，
但是这取决于当前执行上下文（例如，测试套件在 <code>main</code> 方法中执行，或者嵌入一个verticle ）
是否配置了 <code>Vertx</code> 对象。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/TestOptions.html#setUseEventLoop-java.lang.Boolean-">setUseEventLoop</a></code>
以配置事件循环（event loop）的使用方式：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 事件循环（Event loop）的使用</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">useEventLoop:null</th>
<th class="tableblock halign-left valign-top">useEventLoop:true</th>
<th class="tableblock halign-left valign-top">useEventLoop:false</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Vertx</code> instance</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 vertx event loop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 vertx event loop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制不使用 event loop</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 <code>Verticle</code> 中</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用当前 event loop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用当前 event loop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制不使用 event loop</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 <em>main</em> 方法中</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不使用 event loop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不使用 event loop</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>useEventLoop</code> 默认为 <code>null</code> , 这说明，
如果条件允许则使用一个event loop，当没有event loop 可用时，不使用event loop。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reporting"><a class="anchor" href="#_reporting"></a>测试报告</h2>
<div class="sectionbody">
<div class="paragraph">
<p>测试报告是测试套件中的重要部分，
Vert.x Unit可以用不同配置来运行不同的 reporter。</p>
</div>
<div class="paragraph">
<p>默认情况下，不配置reporter，但是当运行测试套件时，
可以用 <em>test options</em> 来配置一个或多个 reporter：</p>
</div>
<div class="listingblock">
<div class="title">使用终端reporter并将其用作junit xml文件</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReportOptions consoleReport = <span class="hljs-keyword">new</span> ReportOptions().
    setTo(<span class="hljs-string">"console"</span>);

<span class="hljs-comment">// 将Junit报告信息文件放在当前目录</span>
ReportOptions junitReport = <span class="hljs-keyword">new</span> ReportOptions().
    setTo(<span class="hljs-string">"file:."</span>).
    setFormat(<span class="hljs-string">"junit"</span>);

suite.run(<span class="hljs-keyword">new</span> TestOptions().
        addReporter(consoleReport).
        addReporter(junitReport)
);</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_console_reporting"><a class="anchor" href="#_console_reporting"></a>控制台报告</h3>
<div class="paragraph">
<p>将信息报告至JVM的 <code>System.out</code> 和 <code>System.err</code> ：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">报告至</dt>
<dd>
<p><em>终端</em></p>
</dd>
<dt class="hdlist1">格式</dt>
<dd>
<p><em>常规</em> 或 <em>junit</em></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_file_reporting"><a class="anchor" href="#_file_reporting"></a>文件报告</h3>
<div class="paragraph">
<p>如果想将报告输出至文件，您必须提供一个 <code>Vertx</code> 对象：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">to</dt>
<dd>
<p><em>file</em> <code>:</code> <em>dir name</em></p>
</dd>
<dt class="hdlist1">格式</dt>
<dd>
<p><em>simple</em> 或 <em>junit</em></p>
</dd>
<dt class="hdlist1">示例</dt>
<dd>
<p><code>file:.</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>文件reporter会在配置的目录中创建文件，这些文件会以测试套件的名称和格式来命名
（例如， <em>常规格式</em> 创建 <em>txt</em> 文件，_
junit格式_ 创建 <em>xml</em> 文件）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_log_reporting"><a class="anchor" href="#_log_reporting"></a>日志报告</h3>
<div class="paragraph">
<p>如果要向logger发送报告，您必须提供一个 <code>Vertx</code> 对象：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">to</dt>
<dd>
<p><em>log</em> <code>:</code> <em>logger name</em></p>
</dd>
<dt class="hdlist1">示例</dt>
<dd>
<p><code>log:mylogger</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_reporting"><a class="anchor" href="#_event_bus_reporting"></a>事件总线报告</h3>
<div class="paragraph">
<p>如果要向事件总线报告事件，那么您必须提供一个 <code>Vertx</code> 对象：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">to</dt>
<dd>
<p><em>bus</em> <code>:</code> <em>event bus address</em></p>
</dd>
<dt class="hdlist1">示例</dt>
<dd>
<p><code>bus:the-address</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>它将测试套件的执行过程和报告解耦合。</p>
</div>
<div class="paragraph">
<p>通过事件总线发送的消息可以通过 <code><a href="../../apidocs/io/vertx/ext/unit/collect/EventBusCollector.html">EventBusCollector</a></code> 来收集起来，
并实现自定义报告</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EventBusCollector collector = EventBusCollector.create(
    vertx,
    <span class="hljs-keyword">new</span> ReportingOptions().addReporter(
        <span class="hljs-keyword">new</span> ReportOptions().setTo(<span class="hljs-string">"file:report.xml"</span>).setFormat(<span class="hljs-string">"junit"</span>)));

collector.register(<span class="hljs-string">"the-address"</span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vertx_integration"><a class="anchor" href="#_vertx_integration"></a>Vertx 整合</h2>
<div class="sectionbody">
<div class="paragraph">
<p>默认情况下，断言和失败必须在 <code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html">TestContext</a></code> 之内完成，另外 <em>断言失败</em> 仅仅在Vert.x Unit的调用下才会有效。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"my_test_case"</span>, ctx -&gt; {

  <span class="hljs-comment">// '失败'会被Vert.x Unit 报告</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"it failed!"</span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在一个常规的Vert.x回调中，会忽略失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.test(<span class="hljs-string">"test-server"</span>, testContext -&gt; {
  HttpServer server = vertx.createHttpServer().requestHandler(req -&gt; {
    <span class="hljs-keyword">if</span> (req.path().equals(<span class="hljs-string">"/somepath"</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Wrong path!"</span>);
    }
    req.response().end();
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 Vert.x 3.3 版本开始，您可以设置一个全局异常处理器来报告 event loop 没有捕捉到的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">suite.before(testContext -&gt; {

  <span class="hljs-comment">// 报告未被捕捉到到异常，以其作为 Vert.x Unit 失败事件</span>
  vertx.exceptionHandler(testContext.exceptionHandler());
});

suite.test(<span class="hljs-string">"test-server"</span>, testContext -&gt; {
  HttpServer server = vertx.createHttpServer().requestHandler(req -&gt; {
    <span class="hljs-keyword">if</span> (req.path().equals(<span class="hljs-string">"/somepath"</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Wrong path!"</span>);
    }
    req.response().end();
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果异常处理器设置在 <em>before</em> 部分，那么 <code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html">TestContext</a></code> 则会在 <em>before</em>,
<em>test</em> 和 <em>after</em> 部分之间共享。
所以将异常处理器置于 <em>before</em> 部分是一个正确到做法</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_junit_integration"><a class="anchor" href="#_junit_integration"></a>Junit 整合</h2>
<div class="sectionbody">
<div class="paragraph">
<p>尽管Vertx Unit是多语言的，且不是基于Junit的，但是您依然可以在Junit上运行Vert.x Unit测试套件以及测试用例，
并允许您将测试用例整合到JUnit，允许整合到您的build system，也可以整合到IDE中。</p>
</div>
<div class="listingblock">
<div class="title">将一个Java类作为JUnit测试套件</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@RunWith</span>(VertxUnitRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">JUnitTestSuite</span> </span>{
  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSomething</span><span class="hljs-params">(TestContext context)</span> </span>{
    context.assertFalse(<span class="hljs-keyword">false</span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunner.html">VertxUnitRunner</a></code> 使用Junit注解来对这个类进行解析，
并创建该类对象之后创建测试套件。
该类中的方法应该在参数中声明一个 <code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html">TestContext</a></code> 参数
，不声明该参数也是可以的。
然而 <code>TestContext</code> 是在异步测试过程中能够获取相关Vertx对象的唯一方式。</p>
</div>
<div class="paragraph">
<p>在Groovy语言中，
用 <code>io.vertx.groovy.ext.unit.junit.VertxUnitRunner</code> 也可以达到整合Junit的目的。</p>
</div>
<div class="sect2">
<h3 id="_running_a_test_on_a_vert_x_context"><a class="anchor" href="#_running_a_test_on_a_vert_x_context"></a>在 Vert.x 上下文中执行一个测试</h3>
<div class="paragraph">
<p>默认情况下执行测试方法的是Junit线程。
<code><a href="../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html">RunTestOnContext</a></code> Junit rule可以改变这个行为，使测试方法都运行于 Vert.x event loop 线程。</p>
</div>
<div class="paragraph">
<p>因此，当某状态在测试方法/Vert.x处理器之间共享时，您就需要小心了，因为他们并不是在同一个线程上运行的，
例如，在Vert.x处理器中累加一个计数器然后在测试方法中断言计数器的值。
使用恰当地同步机制是解决此问题的一种方式，
另外还可以在Vert.x context中执行测试方法，这样共享状态则会在处理器之间传播。</p>
</div>
<div class="paragraph">
<p>以此目的，<code><a href="../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html">RunTestOnContext</a></code> rule 需要一个 <code><a href="../../apidocs/io/vertx/core/Vertx.html">Vertx</a></code> 对象。
您可以主动提供这个对象，如果不提供，这个 rule 会隐式创建它。
这个对象可以在测试执行过程中获取，
这也使该rule成为管理Vert.x实例的一种方式。</p>
</div>
<div class="listingblock">
<div class="title">运行一个Java类作为JUnit测试套件</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@RunWith</span>(VertxUnitRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RunOnContextJUnitTestSuite</span> </span>{

  <span class="hljs-meta">@Rule</span>
  <span class="hljs-keyword">public</span> RunTestOnContext rule = <span class="hljs-keyword">new</span> RunTestOnContext();

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSomething</span><span class="hljs-params">(TestContext context)</span> </span>{
    <span class="hljs-comment">// 使用这个隐式创建的vertx对象</span>
    Vertx vertx = rule.vertx();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>rule可以用 {@literal @Rule} 或 {@literal @ClassRule} 注解修饰，
前者管理每个测试的Vert.x对象，后者则管理该测试类中所有测试方法相关的那一个Vertx对象。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
切记，用这个rule的时候您不可以阻塞 event loop 。使用像 <code>CountDownLatch</code> 类的做法，
则必须要小心。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_timeout"><a class="anchor" href="#_timeout"></a>超时</h3>
<div class="paragraph">
<p>Vert.x Unit 默认超时时间两分钟，这可以用 <code>@Test</code> 注解中的 <code>timeout</code> 属性来指定：</p>
</div>
<div class="listingblock">
<div class="title">在测试方法级别配置超时时间</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JunitTestWithTimeout</span> </span>{

  <span class="hljs-meta">@Test</span>(timeout = <span class="hljs-number">1000l</span>)
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSomething</span><span class="hljs-params">(TestContext context)</span> </span>{
    <span class="hljs-comment">//...</span>
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于更全局的配置，可以用 <code><a href="../../apidocs/io/vertx/ext/unit/junit/Timeout.html">Timeout</a></code> rule：</p>
</div>
<div class="listingblock">
<div class="title">类级别超时时间配置</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@RunWith</span>(VertxUnitRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TimeoutTestSuite</span> </span>{

  <span class="hljs-meta">@Rule</span>
  <span class="hljs-keyword">public</span> Timeout rule = Timeout.seconds(<span class="hljs-number">1</span>);

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSomething</span><span class="hljs-params">(TestContext context)</span> </span>{
    <span class="hljs-comment">//...</span>
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<code>@Test</code> 的超时设置会覆盖 <code><a href="../../apidocs/io/vertx/ext/unit/junit/Timeout.html">Timeout</a></code> rule 的配置。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameterized_tests"><a class="anchor" href="#_parameterized_tests"></a>参数化测试</h3>
<div class="paragraph">
<p>JUnit提供了非常有用的 <code>参数化</code> 测试，
Vert.x Unit 测试可以利用 <code><a href="../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunnerWithParametersFactory.html">VertxUnitRunnerWithParametersFactory</a></code> 来指定执行器：</p>
</div>
<div class="listingblock">
<div class="title">运行参数化的Vert.x Unit测试</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@RunWith</span>(Parameterized<span class="hljs-class">.<span class="hljs-keyword">class</span>)
@<span class="hljs-title">Parameterized</span>.<span class="hljs-title">UseParametersRunnerFactory</span>(<span class="hljs-title">VertxUnitRunnerWithParametersFactory</span>.<span class="hljs-title">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SimpleParameterizedTest</span> </span>{

  <span class="hljs-meta">@Parameterized</span>.<span class="hljs-function">Parameters
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Iterable&lt;Integer&gt; <span class="hljs-title">data</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleParameterizedTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
    <span class="hljs-comment">//...</span>
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSomething</span><span class="hljs-params">(TestContext context)</span> </span>{
    <span class="hljs-comment">// 用当前值来执行测试方法</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy语言中，您可以用 <code>io.vertx.groovy.ext.unit.junit.VertxUnitRunnerWithParametersFactory</code> 来实现参数化测试：</p>
</div>
</div>
<div class="sect2">
<h3 id="_repeating_a_test"><a class="anchor" href="#_repeating_a_test"></a>重复测试</h3>
<div class="paragraph">
<p>当测试随机条件或测试不经常失败时，例如在竞争条件下，
为了增加测试失败的可能性，多次运行同一测试是个方便的方式。</p>
</div>
<div class="paragraph">
<p>如果用Junit，测试用例必须用 <code><a href="../../apidocs/io/vertx/ext/unit/junit/Repeat.html">@Repeat</a></code> 注解修饰，来指定重复执行。
测试用例也必须定义根据自身规则定义 <code><a href="../../apidocs/io/vertx/ext/unit/junit/RepeatRule.html">RepeatRule</a></code> 。</p>
</div>
<div class="listingblock">
<div class="title">用Junit重复测试</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-meta">@RunWith</span>(VertxUnitRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RepeatingTest</span> </span>{

  <span class="hljs-meta">@Rule</span>
  <span class="hljs-keyword">public</span> RepeatRule rule = <span class="hljs-keyword">new</span> RepeatRule();

  <span class="hljs-meta">@Repeat</span>(<span class="hljs-number">1000</span>)
  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSomething</span><span class="hljs-params">(TestContext context)</span> </span>{
    <span class="hljs-comment">// 执行1000次</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果声明了RepeatRule，那么 <em>before</em> 和 <em>after</em> 方法会在每次执行测试方法时都执行一次。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
重复测试是顺序执行
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_using_with_other_assertion_libraries"><a class="anchor" href="#_using_with_other_assertion_libraries"></a>用其他断言库</h3>
<div class="paragraph">
<p>Vert.x Unit 的可用性从 Vert.x 3.3 开始有了巨大的提升。您可以用
<a href="http://hamcrest.org/">Hamcrest</a> ，
<a href="http://joel-costigliola.github.io/assertj/">AssertJ</a> ，
<a href="https://github.com/rest-assured/rest-assured/">Rest Assured</a> ，甚至其他您想用的断言库来写测试用例。这是由 <a href="#vertx_integration">[vertx_integration]</a> 章节里介绍的全局异常处理器的机制实现的。</p>
</div>
<div class="paragraph">
<p>您可以在 <a href="https://github.com/vert-x3/vertx-examples/tree/master/unit-examples">vertx-examples</a> 工程中，
找到Vert.x Unit中用 Hamcrest 和 AssertJ 的示例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_language_integration"><a class="anchor" href="#_java_language_integration"></a>Java 语言整合</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_test_suite_integration"><a class="anchor" href="#_test_suite_integration"></a>测试套件整合</h3>
<div class="paragraph">
<p>Java语言提供了class，
而且可以用如下映射规则来直接利用Java class创建测试套件：</p>
</div>
<div class="paragraph">
<p>检查 <code>测试套件对象</code> 的参数和方法，保留带有 <code><a href="../../apidocs/io/vertx/ext/unit/TestContext.html">TestContext</a></code> 参数的public且非静态方法并通过方法名映射到Vert.x Unit测试套件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>before</code> : before callback</p>
</li>
<li>
<p><code>after</code> : after callback</p>
</li>
<li>
<p><code>beforeEach</code> : beforeEach callback</p>
</li>
<li>
<p><code>afterEach</code> : afterEach callback</p>
</li>
<li>
<p>以 <em>test</em> 开头的名称: 以方法名命名的测试用例</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">用Java类写的测试套件</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestSuite</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSomething</span><span class="hljs-params">(TestContext context)</span> </span>{
    context.assertFalse(<span class="hljs-keyword">false</span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个类可以很容易的转化成Vert.x 测试套件：</p>
</div>
<div class="listingblock">
<div class="title">从Java对象创建测试套件</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TestSuite suite = TestSuite.create(<span class="hljs-keyword">new</span> MyTestSuite());</code></pre>
</div>
</div>
</div>
</div>
</div></div></div></div></div></div><footer><div class="container"><div class="footer-nav-section"><div class="footer-nav-list footer-logo"><a href="/"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAxMTI1LjYgMzE1LjIiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZT4uc3Qwe2ZpbGw6Izc4MmE5MX08L3N0eWxlPjxwYXRoIGQ9Ik0xMjAuOSAyMTQuMkwxOTAuNSAwaDUyLjNsLTk4LjUgMjczLjhIOTguMkwwIDBoNTIuMWw2OC44IDIxNC4yem0yOTEuMi02Mi42SDI5OS42djg0LjJINDMxdjM4SDI1MlYwaDE3Ny43djM4LjRIMjk5LjZWMTE0aDExMi41djM3LjZ6bTgzLjctMTEzLjJINTQ2YzE2LjUuMyAyOSA0LjQgMzcuMyAxMi40IDguMyA4IDEyLjUgMTkuNCAxMi41IDM0IDAgMTQtNC41IDI1LjEtMTMuNSAzMy4yLTkgOC4xLTIxLjYgMTIuMS0zNy42IDEyLjFoLTI3LjF2MjQuMmw4Ni4xIDExOS41aDUxdi0yLjRsLTc3LjItMTA2LjdjMjQuOS01LjUgNDMuMy0yMS43IDUyLjYtMzUuOSA4LjItMTIuNiAxMy4zLTI3LjcgMTMuMy00NiAwLTI2LjgtOC42LTQ3LjQtMjUuOC02MS41QzYwMC41IDcuMSA1NzYuMSAwIDU0NC41IDBoLTk2LjN2MjczLjhoNDcuNiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDUyLjMgMTU3LjdsLTQxLjUgNjIuNyAyOS43IDUzLjRoODUuMXoiLz48Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSI4MjcuOSIgY3k9IjI3NC43IiByPSI0MC41Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTEwMzcgMGwtNDcuNiA3NC4yTDk0OSAwaC04NGw4NS4zIDEzNS44LTY3LjEgMTA1LjdjNS43IDkuNSA5LjEgMjAuNSA5LjIgMzIuNGg1MC4xTDExMjEuMyAwSDEwMzd6Ii8+PHBhdGggZD0iTTc2My41IDI3My44Yy4xLTkuOSAyLjUtMTkuMiA2LjYtMjcuNVYzOC40aDg1LjRWMEg2MzguMnYzOC40aDg0LjZ2MjM1LjRoNDAuN3oiLz48L3N2Zz4=" alt="Vert.x Logo"/></a></div><div class="footer-nav-list"><h5>Eclipse Vert.x</h5><ul class=""><li><a class="navbar-menu-item" href="/docs/">文档</a></li><li><a href="/download/">下载</a></li><li><a href="/blog/">博客</a></li><li><a href="/community/">社区</a></li><li><a href="/translation/">翻译团队</a></li><li><a href="https://github.com/eclipse-vertx/vert.x">GitHub</a></li><li><a href="https://github.com/vertx-china/vertx-web-site">翻译GitHub</a></li></ul></div><div class="footer-nav-list"><h5>资源</h5><ul class=""><li><a href="/faq/">答疑</a></li><li><a href="/channels/">Channels</a></li><li><a href="https://how-to.vertx.io/">How-To’s</a></li><li><a href="https://start.vertx.io/">App Generator</a></li></ul></div><div class="footer-nav-list"><h5>Eclipse</h5><ul class=""><li><a href="https://www.eclipse.org/">Eclipse Foundation</a></li><li><a href="https://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li><li><a href="https://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li><li><a href="https://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li><li><a href="https://www.eclipse.org/legal/">Legal Resources</a></li></ul></div></div><div class="footer-copyright"><div class="footer-copyright-remarks">© <!-- -->2021<!-- --> Eclipse Vert.x<br/>Eclipse Vert.x is open source and dual-licensed under the <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="noopener noreferrer">Eclipse Public License 2.0</a> and the <a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache License 2.0</a>. <br class="footer-copyright-break"/>Website design by <a href="https://michelkraemer.com" target="_blank" rel="noopener noreferrer">Michel Krämer</a>.</div><div class="footer-copyright-eclipse-logo"><a href="https://www.eclipse.org/" target="_blank" rel="noopener noreferrer"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjAiIHk9IjAiIHZpZXdCb3g9IjAgMCAyODEuMyA5MS4xIiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGU+LnN0MHtmaWxsOiNmNzk0MjJ9LnN0MXtmaWxsOiMzZDNjM2J9PC9zdHlsZT48ZyBpZD0iTGF5ZXJfMV8xXyI+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI2NS43IDg0TDI1NyA3M2gtMi43djE3LjdoMy4zdi0xMmw5LjMgMTJoMi4xVjczaC0zLjN2MTF6bS0zMi40LTguM2M0LjIgMCA1LjggMy4zIDUuOCA2LjNzLTEuNiA2LTUuOCA2LTUuNy0zLjEtNS44LTYgMS43LTYuMyA1LjgtNi4zem0wLTNjLTYuMSAwLTkuMSA0LjctOS4xIDkuMyAwIDQuNyAyLjkgOS4xIDkuMSA5LjFzOS00LjYgOS4xLTkuMi0zLTkuMi05LjEtOS4yem0tMjEuMiAxOFY3M2gtMy4zdjE3LjdoMy4zem0tMjMuNiAwaDMuM1Y3Nmg1LjZ2LTNoLTE0LjZ2M2g1LjZsLjEgMTQuN3ptLTE4LjktNi41SDE2M2wzLjMtNy42IDMuMyA3LjZ6bTIuOCA2LjVoMy42TDE2OC4yIDczaC0zLjZsLTggMTcuN2gzLjZsMS41LTMuM2g5LjNsMS40IDMuM3ptLTM4LTE0LjZoMy42YzMuOSAwIDUuNSAyLjggNS41IDUuNS4xIDIuOC0xLjUgNS44LTUuNSA1LjhoLTMuNlY3Ni4xem0zLjctMy4xaC02Ljl2MTcuN2g2LjljNi4yIDAgOC45LTQuNSA4LjktOXMtMi44LTguNy04LjktOC43em0tMjIuNCAxMUwxMDcgNzNoLTIuN3YxNy43aDMuM3YtMTJsOS4zIDEyaDIuMVY3M2gtMy4zdjExek04OC4yIDczdjEwLjJjMCAzLTEuNiA0LjktNC4zIDQuOXMtNC42LTEuNy00LjYtNC45VjczSDc2djEwLjFjMCA1LjMgMy42IDcuOSA3LjkgNy45IDQuNCAwIDcuNy0yLjcgNy43LTcuOVY3M2gtMy40em0tMzMgMi43YzQuMiAwIDUuOCAzLjMgNS44IDYuM3MtMS42IDYtNS44IDYtNS43LTMuMS01LjgtNiAxLjctNi4zIDUuOC02LjN6bTAtM2MtNi4xIDAtOS4xIDQuNy05LjEgOS4zczIuOSA5LjEgOS4xIDkuMSA5LTQuNiA5LjEtOS4yLTMtOS4yLTkuMS05LjJ6bS0yOS43IDE4di02LjVoOC45di0zLjFoLTguOXYtNC44aDkuNFY3M0gyMi4ydjE3LjZoMy4zeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yNjkuNCA1NC40aC0yMi4ydi04LjloMjEuNHYtNi45aC0yMS40di05LjFoMjIuMnYtNy4yaC0yOS42djM5LjVoMjkuNnYtNy40em0tNDAtMjUuNmMtMy02LjEtOS40LTcuOC0xNS41LTcuOC03LjMgMC0xNS4zIDMuNC0xNS4zIDExLjUgMCA4LjkgNy40IDExIDE1LjUgMTIgNS4yLjYgOS4xIDIuMSA5LjEgNS44IDAgNC4zLTQuNCA1LjktOS4xIDUuOXMtOS40LTEuOS0xMS4xLTYuM2wtNi4yIDMuMmMyLjkgNy4yIDkuMSA5LjcgMTcuMiA5LjcgOC44IDAgMTYuNi0zLjggMTYuNi0xMi42IDAtOS40LTcuNy0xMS42LTE1LjktMTIuNi00LjctLjYtOC44LTEuNS04LjgtNSAwLTIuOSAyLjYtNS4yIDguMi01LjIgNC4zIDAgOCAyLjIgOS40IDQuNGw1LjktM3pNMTc2IDIyLjJjLTYuMi0uMS0xMi40IDAtMTguNiAwdjM5LjVoNy40VjUwLjFIMTc2YzE5LjQgMCAxOS40LTI3LjkgMC0yNy45em0tMTEuMSA3LjFIMTc2YzkuNSAwIDkuNSAxNCAwIDE0aC0xMS4ybC4xLTE0em0tMTggMzIuNVYyMi4yaC03LjR2MzkuNWw3LjQuMXptLTQ0LTM5LjZ2MzkuNWgyNy43di02LjloLTIwLjNWMjIuMmgtNy40ek05MC43IDUxLjdjLTIuNyAyLjUtNi4yIDQtOS45IDQtOS44IDAtMTMuNS02LjgtMTMuNi0xMy40czQuMS0xMy43IDEzLjYtMTMuN2MzLjUtLjEgNyAxLjMgOS41IDMuN2w1LTQuOGMtMy44LTMuOS05LjEtNi0xNC41LTYtMTQuMyAwLTIxIDEwLjUtMjAuOSAyMC44czYuMyAyMC4zIDIwLjkgMjAuM2M1LjYuMSAxMS0yIDE1LTUuOWwtNS4xLTV6bS0zOSAyLjdIMjkuNXYtOC45aDIxLjR2LTYuOUgyOS41di05LjFoMjIuMnYtNy4ySDIyLjJ2MzkuNWgyOS42bC0uMS03LjR6Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTkuOCAxOC4yQzE4LjggNC4xIDM2LjktLjggNTIuMSA2bC0xLS43QzM1LjctNC42IDE1LjItLjEgNS4zIDE1LjNzLTUuNCAzNS45IDEwIDQ1LjhsMS4xLjZDMy44IDUwLjguOCAzMi4zIDkuOCAxOC4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yNzIuMiAyNi4xYzAtMi41IDIuMS00LjYgNC42LTQuNiAyLjUgMCA0LjYgMi4xIDQuNiA0LjYgMCAyLjUtMi4xIDQuNi00LjYgNC42LTIuNiAwLTQuNi0yLjEtNC42LTQuNnptOC42IDBjMC0yLjItMS44LTQuMS00LTQuMXMtNC4xIDEuOC00LjEgNC4xYzAgMi4yIDEuNyA0IDMuOSA0LjFoLjFjMi4zIDAgNC4xLTEuOCA0LjEtNC4xem0tNi0yLjVoMi4zYzEuMSAwIDEuOS41IDEuOSAxLjYgMCAuNy0uNCAxLjMtMS4xIDEuNWwxLjIgMS43aC0xLjRsLTEtMS41aC0uN3YxLjVoLTEuMWwtLjEtNC44em0yLjIgMi4zYy41IDAgLjgtLjMuOC0uN3MtLjMtLjctLjgtLjdoLTF2MS4zbDEgLjF6Ii8+PC9nPjwvc3ZnPg==" alt="Eclipse foundation Logo"/></a></div></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"4.0.0/vertx-unit/java","title":"Vertx unit","fallbackGitHubStars":null,"toc":"\u003cdiv id=\"toc\" class=\"toc\"\u003e\n\u003cdiv id=\"toctitle\"\u003eTable of Contents\u003c/div\u003e\n\u003cul class=\"sectlevel1\"\u003e\n\u003cli\u003e\u003ca href=\"#_introduction\"\u003e介绍\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_writing_a_test_suite\"\u003e编写一个测试套件\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_asserting\"\u003e断言\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_assertequals\"\u003eassertEquals\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_assertnotequals\"\u003eassertNotEquals\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_assertnull\"\u003eassertNull\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_assertnotnull\"\u003eassertNotNull\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_assertinrange\"\u003eassertInRange\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_asserttrue_and_assertfalse\"\u003e断言成功以及断言失败\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_failing\"\u003e失败\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_using_third_party_assertion_framework\"\u003e使用第三方断言框架\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_asynchronous_testing\"\u003e异步测试\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_asynchronous_assertions\"\u003e异步断言\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_repeating_test\"\u003e重复测试\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_sharing_objects\"\u003e共享对象\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_running\"\u003e运行\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_test_suite_completion\"\u003e测试套件执行完毕\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_time_out\"\u003e超时\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_event_loop\"\u003e事件循环（Event loop）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_reporting\"\u003e测试报告\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_console_reporting\"\u003e控制台报告\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_file_reporting\"\u003e文件报告\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_log_reporting\"\u003e日志报告\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_event_bus_reporting\"\u003e事件总线报告\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_vertx_integration\"\u003eVertx 整合\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_junit_integration\"\u003eJunit 整合\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_running_a_test_on_a_vert_x_context\"\u003e在 Vert.x 上下文中执行一个测试\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_timeout\"\u003e超时\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_parameterized_tests\"\u003e参数化测试\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_repeating_a_test\"\u003e重复测试\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_using_with_other_assertion_libraries\"\u003e用其他断言库\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_java_language_integration\"\u003eJava 语言整合\u003c/a\u003e\n\u003cul class=\"sectlevel2\"\u003e\n\u003cli\u003e\u003ca href=\"#_test_suite_integration\"\u003e测试套件整合\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e","contents":"\u003ch1\u003eVertx unit\u003c/h1\u003e\n\n\u003cdiv id=\"preamble\"\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e异步多语言单元测试。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_introduction\"\u003e\u003ca class=\"anchor\" href=\"#_introduction\"\u003e\u003c/a\u003e介绍\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Unit 用多语言的异步API在JVM上 运行单元测试。\nVert.x Unit 借鉴了已有的测试框架，例如 \u003ca href=\"http://junit.org\"\u003eJUnit\u003c/a\u003e or \u003ca href=\"http://qunitjs.com\"\u003eQUnit\u003c/a\u003e\n并同时遵循了Vert.x的做法。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e所以 Vert.x Unit 自然就成为了测试 Vert.x 应用的选择。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e要使用 Vert.x Unit，\n那么请添加如下依赖：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMaven （在您的 \u003ccode\u003epom.xml\u003c/code\u003e 文件）：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eio.vertx\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003evertx-unit\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e4.0.0\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\n \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u0026gt;\u003c/span\u003etest\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGradle （在您的 \u003ccode\u003ebuild.gradle\u003c/code\u003e 文件）：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003etestCompile ${io.vertx}:${vertx-unit}:\u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Unit 能够以各种方式使用并可以在您代码中任何位置运行，它仅以正确的方式报告执行结果。\n以下示例展示了一个最简的测试用例套件。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"the_test_suite\"\u003c/span\u003e);\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  String s = \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e;\n  context.assertEquals(\u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e, s);\n});\nsuite.run();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003erun\u003c/code\u003e 方法执行了整个套件并且执行套件中所有的测试用例。\n测试用例套件可能失败也可能通过。如果外界不关心测试结果，\n那么测试用例的通过与否便不重要。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"the_test_suite\"\u003c/span\u003e);\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  String s = \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e;\n  context.assertEquals(\u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e, s);\n});\nsuite.run(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TestOptions().addReporter(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ReportOptions().setTo(\u003cspan class=\"hljs-string\"\u003e\"console\"\u003c/span\u003e)));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e执行之时，测试套件会在控制台报告每一步的结果：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003eBegin test suite the_test_suite\nBegin test my_test\nPassed my_test\nEnd test suite the_test_suite , run: 1, Failures: 0, Errors: 0\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003ereporters\u003c/code\u003e 选项配置了套件执行器的reporter，用以报告测试用例执行结果，\n更多信息详见 \u003ca href=\"#reporting\"\u003e[reporting]\u003c/a\u003e 章节\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_writing_a_test_suite\"\u003e\u003ca class=\"anchor\" href=\"#_writing_a_test_suite\"\u003e\u003c/a\u003e编写一个测试套件\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e测试套件是一系列测试用例组成的有名称的集合，测试用例则是一个直接回调。\n套件生命周期中可以设置回调函数，这些函数可以在执行测试用例前后执行，\n也可以在用作初始化/发布服务的套件前后。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"the_test_suite\"\u003c/span\u003e);\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_1\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 1\u003c/span\u003e\n});\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_2\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 2\u003c/span\u003e\n});\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_3\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 3\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e流式API让测试用例可以作链式调用：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"the_test_suite\"\u003c/span\u003e);\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_1\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 1\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_2\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 2\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_3\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 3\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e测试用例的声明顺序并不保证其执行顺序，所以测试用例不可以依赖于其他测试用例来运行。\n这不是一个好的做法。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Unit 提供了 \u003cem\u003ebefore\u003c/em\u003e 和 \u003cem\u003eafter\u003c/em\u003e 回调来作总体的启动或清理资源操作：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"the_test_suite\"\u003c/span\u003e);\nsuite.before(context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 测试套件启动\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_1\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 1\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_2\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 2\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_3\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 3\u003c/span\u003e\n}).after(context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 测试套件清理资源\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这些方法的声明顺序并不重要，示例中在用例之前声明 \u003cem\u003ebefore\u003c/em\u003e ，\n在用例之后声明 \u003cem\u003eafter\u003c/em\u003e ，\n然而在运行套件之前，他们可以在任何位置声明，\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003cem\u003ebefore\u003c/em\u003e 回调函数执行于所有测试用例之前，如果其运行失败，\n则整个测试套件将停止运行并报告失败结果。 \u003cem\u003eafter\u003c/em\u003e 回调函数在整个测试套件中最后执行，\n除非 \u003cem\u003ebefore\u003c/em\u003e 回调函数运行失败。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e类似的，Vert.x Unit 提供了 \u003cem\u003ebeforeEach\u003c/em\u003e 和 \u003cem\u003eafterEach\u003c/em\u003e 回调，\n在每一个测试用例前后执行：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"the_test_suite\"\u003c/span\u003e);\nsuite.beforeEach(context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 测试用例启动\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_1\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 1\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_2\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 2\u003c/span\u003e\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case_3\"\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Test 3\u003c/span\u003e\n}).afterEach(context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 测试用例资源清理\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003cem\u003ebeforeEach\u003c/em\u003e 回调函数执行于每一个测试用例之前，一旦其运行失败，那测试用例将不再被执行，\n并报告失败结果。 \u003cem\u003eafterEach\u003c/em\u003e 回调函数仅在测试用例之后被执行，\n除非 \u003cem\u003ebeforeEach\u003c/em\u003e 函数运行失败。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_asserting\"\u003e\u003ca class=\"anchor\" href=\"#_asserting\"\u003e\u003c/a\u003e断言\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Unit 提供了 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\"\u003eTestContext\u003c/a\u003e\u003c/code\u003e 对象用来在测试用例中作断言操作。\n\u003cem\u003econtext\u003c/em\u003e 对象提供了用于断言的常用方法。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_assertequals\"\u003e\u003ca class=\"anchor\" href=\"#_assertequals\"\u003e\u003c/a\u003eassertEquals\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e断言两个对象相等，适用于 \u003cem\u003e基本类型\u003c/em\u003e 和 \u003cem\u003ejson类型\u003c/em\u003e 。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  context.assertEquals(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, callbackCount);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e有一个重载的方法用于提供测试信息：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  context.assertEquals(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, callbackCount, \u003cspan class=\"hljs-string\"\u003e\"Should have been 10 instead of \"\u003c/span\u003e + callbackCount);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e通常地，每一个断言函数都提供了重载的版本。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_assertnotequals\"\u003e\u003ca class=\"anchor\" href=\"#_assertnotequals\"\u003e\u003c/a\u003eassertNotEquals\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e与 \u003cem\u003eassertEquals\u003c/em\u003e 相反。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  context.assertNotEquals(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, callbackCount);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_assertnull\"\u003e\u003ca class=\"anchor\" href=\"#_assertnull\"\u003e\u003c/a\u003eassertNull\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e断言一个对象是null，适用于 \u003cem\u003e基本类型\u003c/em\u003e 和 \u003cem\u003ejson类型\u003c/em\u003e 。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  context.assertNull(\u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_assertnotnull\"\u003e\u003ca class=\"anchor\" href=\"#_assertnotnull\"\u003e\u003c/a\u003eassertNotNull\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e与 \u003cem\u003eassertNull\u003c/em\u003e 相反。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  context.assertNotNull(\u003cspan class=\"hljs-string\"\u003e\"not null!\"\u003c/span\u003e);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_assertinrange\"\u003e\u003ca class=\"anchor\" href=\"#_assertinrange\"\u003e\u003c/a\u003eassertInRange\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#assertInRange-double-double-double-\"\u003eassertInRange\u003c/a\u003e\u003c/code\u003e 方法作用于实数范围。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre\u003esuite.test(\"my_test_case\", context -\u0026gt; {\n\n  // 断言0.1 在误差范围 +/- 0.5范围内等于0.2\n\n  context.assertInRange(0.1, 0.2, 0.5);\n});\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_asserttrue_and_assertfalse\"\u003e\u003ca class=\"anchor\" href=\"#_asserttrue_and_assertfalse\"\u003e\u003c/a\u003e断言成功以及断言失败\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e对于布尔表达式的断言。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  context.assertTrue(\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e);\n  context.assertFalse(value \u0026gt; \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_failing\"\u003e\u003ca class=\"anchor\" href=\"#_failing\"\u003e\u003c/a\u003e失败\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e最后但并非最不重要的，\u003cem\u003etest\u003c/em\u003e 提供了一个 \u003cem\u003efail\u003c/em\u003e 方法用来抛出断言错误的异常：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  context.fail(\u003cspan class=\"hljs-string\"\u003e\"That should never happen\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// 剩下的代码不会执行。\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e失败\u003c/code\u003e 对象本身既可以是 \u003cem\u003estring\u003c/em\u003e 也可以是一个 \u003cem\u003eerror\u003c/em\u003e 。\n\u003cem\u003eerror\u003c/em\u003e 对象取决于所使用的编程语言，对于 Java 或者 Groovy 而言，可以是任何 \u003cem\u003eThrowable\u003c/em\u003e 的子类，\n对于 JavaScript 则是一个 \u003cem\u003eerror\u003c/em\u003e ，对于 Ruby 则是一个 \u003cem\u003eException\u003c/em\u003e。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_using_third_party_assertion_framework\"\u003e\u003ca class=\"anchor\" href=\"#_using_third_party_assertion_framework\"\u003e\u003c/a\u003e使用第三方断言框架\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您也可以用任何其他的断言框架，例如比较流行的 \u003cem\u003ehamcrest\u003c/em\u003e 和 \u003cem\u003eassertj\u003c/em\u003e 。\n我们建议您用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#verify-io.vertx.core.Handler-\"\u003everify\u003c/a\u003e\u003c/code\u003e ，\n使用我们提供的 \u003cem\u003e处理器（Handler）\u003c/em\u003e 来执行断言。\n这样的话，我们才能正确的处理异步测试的结束动作。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; context.verify(v -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 这里 junit中的 Assert 对象可以是 assertj hamcrest或其他库中的Assert对象\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 甚至可以手动抛出 AssertionError\u003c/span\u003e\n  Assert.assertNotNull(\u003cspan class=\"hljs-string\"\u003e\"not null!\"\u003c/span\u003e);\n  Assert.assertEquals(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, callbackCount);\n}));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_asynchronous_testing\"\u003e\u003ca class=\"anchor\" href=\"#_asynchronous_testing\"\u003e\u003c/a\u003e异步测试\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e前述示例的前提是，假设所有的测试用例在各自回调之后会结束，\n这是测试用例回调函数的默认行为。在测试用例回调函数之后结束测试是可取的，\n例如：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003eAsync 对象异步的完成测试用例\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  Async async = context.async();\n  eventBus.consumer(\u003cspan class=\"hljs-string\"\u003e\"the-address\"\u003c/span\u003e, msg -\u0026gt; {\n    \u003cb class=\"conum\"\u003e(2)\u003c/b\u003e\n    async.complete();\n  });\n  \u003cb class=\"conum\"\u003e(1)\u003c/b\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"colist arabic\"\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e回调函数结束，但是测试用例没结束\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e总线事件的回调函数来终止测试\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#async--\"\u003easync\u003c/a\u003e\u003c/code\u003e 方法创建一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html\"\u003eAsync\u003c/a\u003e\u003c/code\u003e 对象表示测试用例还未结束。\n当执行 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html#complete--\"\u003ecomplete\u003c/a\u003e\u003c/code\u003e 方法时，\n测试用例才算结束。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n当 \u003ccode\u003ecomplete\u003c/code\u003e 回调函数未被执行时，测试用例会在指定超时时间之后失败。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e同一个测试用例中可以创建多个 \u003ccode\u003eAsync\u003c/code\u003e 对象，\n必须调用所有Async对象的 \u003cem\u003ecompleted\u003c/em\u003e 方法来终止测试。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e多个Async对象合作\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n\n  HttpClient client = vertx.createHttpClient();\n  client.request(HttpMethod.GET, \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e, context.asyncAssertSuccess(req -\u0026gt; {\n      req.send(context.asyncAssertSuccess(resp -\u0026gt; {\n        context.assertEquals(\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, resp.statusCode());\n      }));\n    }));\n\n  Async async = context.async();\n  vertx.eventBus().consumer(\u003cspan class=\"hljs-string\"\u003e\"the-address\"\u003c/span\u003e, msg -\u0026gt; {\n    async.complete();\n  });\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAsync 对象也可以用在 \u003cem\u003ebefore\u003c/em\u003e 或 \u003cem\u003eafter\u003c/em\u003e 回调中，\n这将很方便的在 \u003cem\u003ebefore\u003c/em\u003e 回调中，实现依赖于多个异步结果的启动操作：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e执行测试用例之前异步启动 http server\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.before(context -\u0026gt; {\n  Async async = context.async();\n  HttpServer server = vertx.createHttpServer();\n  server.requestHandler(requestHandler);\n  server.listen(\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e, ar -\u0026gt; {\n    context.assertTrue(ar.succeeded());\n    async.complete();\n  });\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您也可以等待 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html\"\u003eAsync\u003c/a\u003e\u003c/code\u003e 直到其结束，\n类似Java的 count-down latch：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003eWait for completion\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eAsync async = context.async();\nHttpServer server = vertx.createHttpServer();\nserver.requestHandler(requestHandler);\nserver.listen(\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e, ar -\u0026gt; {\n  context.assertTrue(ar.succeeded());\n  async.complete();\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// Wait until completion\u003c/span\u003e\nasync.awaitSuccess();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock warning\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e警告\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n该方法不应该在事件循环（event loop）上执行！\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eAsync 可以创建一个初始计数值，\n当用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html#countDown--\"\u003ecountDown\u003c/a\u003e\u003c/code\u003e 方法将 count-down 的值减到0时：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e等待，直到count-down值为0\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eAsync async = context.async(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\nHttpServer server = vertx.createHttpServer();\nserver.requestHandler(requestHandler);\nserver.listen(\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e, ar -\u0026gt; {\n  context.assertTrue(ar.succeeded());\n  async.countDown();\n});\n\nvertx.setTimer(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, id -\u0026gt; {\n  async.complete();\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// Wait until completion of the timer and the http request\u003c/span\u003e\nasync.awaitSuccess();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e调用Async的 \u003ccode\u003ecomplete()\u003c/code\u003e 方法会像往常一样结束，实际上它将count-down值直接设置为 \u003ccode\u003e0\u003c/code\u003e 。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_asynchronous_assertions\"\u003e\u003ca class=\"anchor\" href=\"#_asynchronous_assertions\"\u003e\u003c/a\u003e异步断言\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\"\u003eTestContext\u003c/a\u003e\u003c/code\u003e 提供了很有用的方法，这些方法提供了强大的异步测试框架：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess--\"\u003easyncAssertSuccess\u003c/a\u003e\u003c/code\u003e 方法返回一个类似 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html\"\u003eAsync\u003c/a\u003e\u003c/code\u003e {@literal Handler\u0026lt;AsyncResult\u0026lt;T\u0026gt;\u0026gt;} 对象，\n它在运行成功时执行 \u003ccode\u003eAsync\u003c/code\u003e 对象，并在失败时，\n让整个测试用例失败，并返回失败原因。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eAsync async = context.async();\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    async.complete();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    context.fail(ar.cause());\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 可用如下代替\u003c/span\u003e\n\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, context.asyncAssertSuccess());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess-io.vertx.core.Handler-\"\u003easyncAssertSuccess\u003c/a\u003e\u003c/code\u003e 方法返回一个类似于 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html\"\u003eAsync\u003c/a\u003e\u003c/code\u003e 的 {@literal Handler\u0026lt;AsyncResult\u0026lt;T\u0026gt;\u0026gt;} 对象，\n运行成功时它执行了代理 {@literal Handler\u0026lt;T\u0026gt;} ，\n而在运行出错时让整个测试用例失败，并返回错误原因。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eAtomicBoolean started = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e AtomicBoolean();\nAsync async = context.async();\nvertx.deployVerticle(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e AbstractVerticle() {\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estart\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethrows\u003c/span\u003e Exception \u003c/span\u003e{\n    started.set(\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e);\n  }\n}, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    context.assertTrue(started.get());\n    async.complete();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    context.fail(ar.cause());\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// Can be replaced by\u003c/span\u003e\n\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, context.asyncAssertSuccess(id -\u0026gt; {\n  context.assertTrue(started.get());\n}));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当 \u003ccode\u003eHandler\u003c/code\u003e 退出时，Async对象同时也会处于 \u003ccode\u003ecompleted\u003c/code\u003e 状态，除非Async对象在函数调用期间被创建，\n这会在 \u003cem\u003e链式\u003c/em\u003e 异步操作时提供方便：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eAsync async = context.async();\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, ar1 -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar1.succeeded()) {\n    vertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.otherverticle\"\u003c/span\u003e, ar2 -\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar2.succeeded()) {\n        async.complete();\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        context.fail(ar2.cause());\n      }\n    });\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    context.fail(ar1.cause());\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// Can be replaced by\u003c/span\u003e\n\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, context.asyncAssertSuccess(id -\u0026gt;\n        vertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my_otherverticle\"\u003c/span\u003e, context.asyncAssertSuccess())\n));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure--\"\u003easyncAssertFailure\u003c/a\u003e\u003c/code\u003e 方法返回了一个类似 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html\"\u003eAsync\u003c/a\u003e\u003c/code\u003e 的 {@literal Handler\u0026lt;AsyncResult\u0026lt;T\u0026gt;\u0026gt;} 对象,\n它在运行失败时执行 \u003ccode\u003eAsync\u003c/code\u003e ，\n并在成功时让测试用例失败。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eAsync async = context.async();\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    context.fail();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    async.complete();\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 可用如下代替\u003c/span\u003e\n\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, context.asyncAssertFailure());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure-io.vertx.core.Handler-\"\u003easyncAssertFailure\u003c/a\u003e\u003c/code\u003e 方法返回一个类似 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Async.html\"\u003eAsync\u003c/a\u003e\u003c/code\u003e 的  {@literal Handler\u0026lt;AsyncResult\u0026lt;T\u0026gt;\u0026gt;} 对象，\n它在运行失败时，\n执行代理处理器 {@literal Handler\u0026lt;Throwable\u0026gt;} ，\n并在执行成功时让测试用例失败。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eAsync async = context.async();\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    context.fail();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    context.assertTrue(ar.cause() \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e IllegalArgumentException);\n    async.complete();\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 可用如下代替\u003c/span\u003e\n\nvertx.deployVerticle(\u003cspan class=\"hljs-string\"\u003e\"my.verticle\"\u003c/span\u003e, context.asyncAssertFailure(cause -\u0026gt; {\n  context.assertTrue(cause \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e IllegalArgumentException);\n}));\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003eHandler\u003c/code\u003e 退出时，这个Async也会处于完成状态，除非在执行过程中，创建了新的Async对象\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_repeating_test\"\u003e\u003ca class=\"anchor\" href=\"#_repeating_test\"\u003e\u003c/a\u003e重复测试\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当测试随机条件或测试不经常失败时，例如在竞争条件下，\n为了增加测试失败的可能性，多次运行同一测试是个方便的方式。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e重复一个测试\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"my_suite\"\u003c/span\u003e).test(\u003cspan class=\"hljs-string\"\u003e\"my_test\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, context -\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 这里会执行1000次\u003c/span\u003e\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果声明了 \u003cem\u003ebeforeEach\u003c/em\u003e 和 \u003cem\u003eafterEach\u003c/em\u003e 回调，那么每当测试用例执行一次，它们也会被执行一次。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n重复的测试用例是顺序执行的\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_sharing_objects\"\u003e\u003ca class=\"anchor\" href=\"#_sharing_objects\"\u003e\u003c/a\u003e共享对象\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\"\u003eTestContext\u003c/a\u003e\u003c/code\u003e 对象提供了 \u003ccode\u003eget\u003c/code\u003e/\u003ccode\u003eput\u003c/code\u003e/\u003ccode\u003eremove\u003c/code\u003e 操作，用于在回调函数之间共享状态。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在 \u003cem\u003ebefore\u003c/em\u003e 回调函数中添加的任何对象都可以在其他回调函数中访问到。\n每一个测试用例都会操作一个共享状态的副本。所以，对于共享状态的更新仅仅在一个测试用例之内有效。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e在回调函数之间共享状态\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"my_suite\"\u003c/span\u003e).before(context -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// cases host对于所有的测试用例可见\u003c/span\u003e\n  context.put(\u003cspan class=\"hljs-string\"\u003e\"host\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e);\n\n}).beforeEach(context -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 为每一个测试用例生成一个port\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e port = helper.randomPort();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 获取host\u003c/span\u003e\n  String host = context.get(\u003cspan class=\"hljs-string\"\u003e\"host\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 启动服务\u003c/span\u003e\n  Async async = context.async();\n  HttpServer server = vertx.createHttpServer();\n  server.requestHandler(req -\u0026gt; {\n    req.response().setStatusCode(\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e).end();\n  });\n  server.listen(port, host, ar -\u0026gt; {\n    context.assertTrue(ar.succeeded());\n    context.put(\u003cspan class=\"hljs-string\"\u003e\"port\"\u003c/span\u003e, port);\n    async.complete();\n  });\n\n}).test(\u003cspan class=\"hljs-string\"\u003e\"my_test\"\u003c/span\u003e, context -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 获取共享状态\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e port = context.get(\u003cspan class=\"hljs-string\"\u003e\"port\"\u003c/span\u003e);\n  String host = context.get(\u003cspan class=\"hljs-string\"\u003e\"host\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 发送请求\u003c/span\u003e\n  HttpClient client = vertx.createHttpClient();\n  client.request(HttpMethod.GET, port, host, \u003cspan class=\"hljs-string\"\u003e\"/resource\"\u003c/span\u003e, context.asyncAssertSuccess(req -\u0026gt; {\n    req.send(context.asyncAssertSuccess(resp -\u0026gt; {\n      context.assertEquals(\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, resp.statusCode());\n    }));\n  }));\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock warning\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e警告\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n只有java才能共享所有类型的对象，其他语言只能共享基本类型和json类型。\n其他类型对象的共享操作应该利用当前编程语言的特性来实现。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_running\"\u003e\u003ca class=\"anchor\" href=\"#_running\"\u003e\u003c/a\u003e运行\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当创建了一个测试套件，除非调用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestSuite.html#run--\"\u003erun\u003c/a\u003e\u003c/code\u003e 方法，否则测试用例不会执行。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e运行一个测试套件\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.run();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这个测试套件也可以用指定的 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/Vertx.html\"\u003eVertx\u003c/a\u003e\u003c/code\u003e 来运行：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e提供一个Vertx对象来执行测试用例\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.run(vertx);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当使用 \u003ccode\u003eVertx\u003c/code\u003e 对象来运行时，测试套件则会使用该Vert.x对象的 eventloop 来运行测试用例，\n更多信息详见 \u003ca href=\"#event_loop\"\u003e[event_loop]\u003c/a\u003e 一章。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e一个测试套件可以用Vert.x命令行接口来执行，即使用 \u003ccode\u003evertx test\u003c/code\u003e 命令：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e用Vert.x CLI 执行测试用例\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u0026gt; vertx test the_test_suite.js\nBegin test suite the_test_suite\nSucceeded in deploying verticle\nBegin test my_test_case\nPassed my_test_case\nEnd test suite my_suite , run: 1, Failures: 0, Errors: 0\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这种测试套件仅仅需要通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestSuite.html#run--\"\u003erun\u003c/a\u003e\u003c/code\u003e 命令来执行，\n\u003ccode\u003evertx test\u003c/code\u003e 命令则负责配置报告和超时等。\n例如：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-string\"\u003e\"the_test_suite\"\u003c/span\u003e);\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, context -\u0026gt; {\n  String s = \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e;\n  context.assertEquals(\u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e, s);\n});\nsuite.run();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003evertx test\u003c/code\u003e 命令扩展了 \u003ccode\u003evertx run\u003c/code\u003e 命令。它改变了JVM的退出行为，\n当测试套件开始执行，并且返回了测试结果（例如success (0) or failure (1)）的时候，JVM才会退出。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n同一个Verticle中可以执行多个测试套件，\nVert.x Unit会等待所有的测试套件执行完成。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_test_suite_completion\"\u003e\u003ca class=\"anchor\" href=\"#_test_suite_completion\"\u003e\u003c/a\u003e测试套件执行完毕\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e我们没办法假设测试套件将何时执行完毕，\n如果有代码需要在测试用例执行完毕之后才执行，\n那么这段代码要声明在 \u003cem\u003eafter\u003c/em\u003e 回调函数中或者让其作为 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Completion.html\"\u003eCompletion\u003c/a\u003e\u003c/code\u003e 的回调。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e测试套件 \u003cem\u003e执行回调函数\u003c/em\u003e\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestCompletion completion = suite.run(vertx);\n\n\u003cspan class=\"hljs-comment\"\u003e// 普通的完成回调函数\u003c/span\u003e\ncompletion.handler(ar -\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ar.succeeded()) {\n    System.out.println(\u003cspan class=\"hljs-string\"\u003e\"Test suite passed!\"\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    System.out.println(\u003cspan class=\"hljs-string\"\u003e\"Test suite failed:\"\u003c/span\u003e);\n    ar.cause().printStackTrace();\n  }\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Completion.html\"\u003eCompletion\u003c/a\u003e\u003c/code\u003e 对象也提供了 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Completion.html#resolve-io.vertx.core.Promise-\"\u003eresolve\u003c/a\u003e\u003c/code\u003e 方法，\n该方法接收 \u003ccode\u003ePromise\u003c/code\u003e 对象参数，这个 \u003ccode\u003ePromise\u003c/code\u003e 会在测试套件执行时被触发通知。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e用测试套件解析初始Promise\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestCompletion completion = suite.run();\n\n\u003cspan class=\"hljs-comment\"\u003e// 当测试套件执行完毕，Promise则被解析\u003c/span\u003e\ncompletion.resolve(startPromise);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这样可以轻松的创建一个 \u003cem\u003etest\u003c/em\u003e Verticle，这个Verticle是由测试套件部署起来的，\n而部署Verticle的代码中可以很容易的知悉成功或者失败。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003ecompletion 对象也可以像 count-down latch 一样使用，他会阻塞直至测试套件执行完。\n这应该用于当前线程与测试套件线程不一样时的场景。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e阻塞至测试套件执行完毕\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eCompletion completion = suite.run();\n\n\u003cspan class=\"hljs-comment\"\u003e//  阻塞至测试套件执行完毕\u003c/span\u003e\ncompletion.await();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 方法在线程被interrupt或者超时的时候抛出异常。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/Completion.html#awaitSuccess--\"\u003eawaitSuccess\u003c/a\u003e\u003c/code\u003e 方法是一个变种，\n它在测试套件运行失败时抛出异常\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e阻塞至测试套件执行成功\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eCompletion completion = suite.run();\n\n\u003cspan class=\"hljs-comment\"\u003e// 阻塞至测试套件执行成功 否则抛出异常\u003c/span\u003e\ncompletion.awaitSuccess();\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_time_out\"\u003e\u003ca class=\"anchor\" href=\"#_time_out\"\u003e\u003c/a\u003e超时\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e测试套件中的每一个测试用例都必须在超时时间内执行完毕。默认超时时间是 \u003cem\u003e2分钟\u003c/em\u003e ，\n超时时间可以用 \u003cem\u003etest options\u003c/em\u003e 来设置：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e设置测试套件的超时时间\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestOptions options = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TestOptions().setTimeout(\u003cspan class=\"hljs-number\"\u003e10000\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 10秒超时时间\u003c/span\u003e\nsuite.run(options);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_event_loop\"\u003e\u003ca class=\"anchor\" href=\"#_event_loop\"\u003e\u003c/a\u003e事件循环（Event loop）\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Unit 是一系列task的执行过程，每个task由前一个task的完成动作来触发。\n这些task负责平衡eventloop的调度，\n但是这取决于当前执行上下文（例如，测试套件在 \u003ccode\u003emain\u003c/code\u003e 方法中执行，或者嵌入一个verticle ）\n是否配置了 \u003ccode\u003eVertx\u003c/code\u003e 对象。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestOptions.html#setUseEventLoop-java.lang.Boolean-\"\u003esetUseEventLoop\u003c/a\u003e\u003c/code\u003e\n以配置事件循环（event loop）的使用方式：\u003c/p\u003e\n\u003c/div\u003e\n\u003ctable class=\"tableblock frame-all grid-all stretch\"\u003e\n\u003ccaption class=\"title\"\u003eTable 1. 事件循环（Event loop）的使用\u003c/caption\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 25%;\"\u003e\n\u003ccol style=\"width: 25%;\"\u003e\n\u003ccol style=\"width: 25%;\"\u003e\n\u003ccol style=\"width: 25%;\"\u003e\n\u003c/colgroup\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth class=\"tableblock halign-left valign-top\"\u003e\u003c/th\u003e\n\u003cth class=\"tableblock halign-left valign-top\"\u003euseEventLoop:null\u003c/th\u003e\n\u003cth class=\"tableblock halign-left valign-top\"\u003euseEventLoop:true\u003c/th\u003e\n\u003cth class=\"tableblock halign-left valign-top\"\u003euseEventLoop:false\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e\u003ccode\u003eVertx\u003c/code\u003e instance\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e使用 vertx event loop\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e使用 vertx event loop\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e强制不使用 event loop\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e在 \u003ccode\u003eVerticle\u003c/code\u003e 中\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e使用当前 event loop\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e使用当前 event loop\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e强制不使用 event loop\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e在 \u003cem\u003emain\u003c/em\u003e 方法中\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e不使用 event loop\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e错误\u003c/p\u003e\u003c/td\u003e\n\u003ctd class=\"tableblock halign-left valign-top\"\u003e\u003cp class=\"tableblock\"\u003e不使用 event loop\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003euseEventLoop\u003c/code\u003e 默认为 \u003ccode\u003enull\u003c/code\u003e , 这说明，\n如果条件允许则使用一个event loop，当没有event loop 可用时，不使用event loop。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_reporting\"\u003e\u003ca class=\"anchor\" href=\"#_reporting\"\u003e\u003c/a\u003e测试报告\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e测试报告是测试套件中的重要部分，\nVert.x Unit可以用不同配置来运行不同的 reporter。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e默认情况下，不配置reporter，但是当运行测试套件时，\n可以用 \u003cem\u003etest options\u003c/em\u003e 来配置一个或多个 reporter：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e使用终端reporter并将其用作junit xml文件\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eReportOptions consoleReport = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ReportOptions().\n    setTo(\u003cspan class=\"hljs-string\"\u003e\"console\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 将Junit报告信息文件放在当前目录\u003c/span\u003e\nReportOptions junitReport = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ReportOptions().\n    setTo(\u003cspan class=\"hljs-string\"\u003e\"file:.\"\u003c/span\u003e).\n    setFormat(\u003cspan class=\"hljs-string\"\u003e\"junit\"\u003c/span\u003e);\n\nsuite.run(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TestOptions().\n        addReporter(consoleReport).\n        addReporter(junitReport)\n);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_console_reporting\"\u003e\u003ca class=\"anchor\" href=\"#_console_reporting\"\u003e\u003c/a\u003e控制台报告\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e将信息报告至JVM的 \u003ccode\u003eSystem.out\u003c/code\u003e 和 \u003ccode\u003eSystem.err\u003c/code\u003e ：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"dlist\"\u003e\n\u003cdl\u003e\n\u003cdt class=\"hdlist1\"\u003e报告至\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003cem\u003e终端\u003c/em\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003e格式\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003cem\u003e常规\u003c/em\u003e 或 \u003cem\u003ejunit\u003c/em\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003c/dl\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_file_reporting\"\u003e\u003ca class=\"anchor\" href=\"#_file_reporting\"\u003e\u003c/a\u003e文件报告\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果想将报告输出至文件，您必须提供一个 \u003ccode\u003eVertx\u003c/code\u003e 对象：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"dlist\"\u003e\n\u003cdl\u003e\n\u003cdt class=\"hdlist1\"\u003eto\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003cem\u003efile\u003c/em\u003e \u003ccode\u003e:\u003c/code\u003e \u003cem\u003edir name\u003c/em\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003e格式\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003cem\u003esimple\u003c/em\u003e 或 \u003cem\u003ejunit\u003c/em\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003e示例\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003ccode\u003efile:.\u003c/code\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003c/dl\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e文件reporter会在配置的目录中创建文件，这些文件会以测试套件的名称和格式来命名\n（例如， \u003cem\u003e常规格式\u003c/em\u003e 创建 \u003cem\u003etxt\u003c/em\u003e 文件，_\njunit格式_ 创建 \u003cem\u003exml\u003c/em\u003e 文件）。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_log_reporting\"\u003e\u003ca class=\"anchor\" href=\"#_log_reporting\"\u003e\u003c/a\u003e日志报告\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果要向logger发送报告，您必须提供一个 \u003ccode\u003eVertx\u003c/code\u003e 对象：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"dlist\"\u003e\n\u003cdl\u003e\n\u003cdt class=\"hdlist1\"\u003eto\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003cem\u003elog\u003c/em\u003e \u003ccode\u003e:\u003c/code\u003e \u003cem\u003elogger name\u003c/em\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003e示例\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003ccode\u003elog:mylogger\u003c/code\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003c/dl\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_event_bus_reporting\"\u003e\u003ca class=\"anchor\" href=\"#_event_bus_reporting\"\u003e\u003c/a\u003e事件总线报告\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果要向事件总线报告事件，那么您必须提供一个 \u003ccode\u003eVertx\u003c/code\u003e 对象：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"dlist\"\u003e\n\u003cdl\u003e\n\u003cdt class=\"hdlist1\"\u003eto\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003cem\u003ebus\u003c/em\u003e \u003ccode\u003e:\u003c/code\u003e \u003cem\u003eevent bus address\u003c/em\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003cdt class=\"hdlist1\"\u003e示例\u003c/dt\u003e\n\u003cdd\u003e\n\u003cp\u003e\u003ccode\u003ebus:the-address\u003c/code\u003e\u003c/p\u003e\n\u003c/dd\u003e\n\u003c/dl\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e它将测试套件的执行过程和报告解耦合。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e通过事件总线发送的消息可以通过 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/collect/EventBusCollector.html\"\u003eEventBusCollector\u003c/a\u003e\u003c/code\u003e 来收集起来，\n并实现自定义报告\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eEventBusCollector collector = EventBusCollector.create(\n    vertx,\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ReportingOptions().addReporter(\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ReportOptions().setTo(\u003cspan class=\"hljs-string\"\u003e\"file:report.xml\"\u003c/span\u003e).setFormat(\u003cspan class=\"hljs-string\"\u003e\"junit\"\u003c/span\u003e)));\n\ncollector.register(\u003cspan class=\"hljs-string\"\u003e\"the-address\"\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_vertx_integration\"\u003e\u003ca class=\"anchor\" href=\"#_vertx_integration\"\u003e\u003c/a\u003eVertx 整合\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e默认情况下，断言和失败必须在 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\"\u003eTestContext\u003c/a\u003e\u003c/code\u003e 之内完成，另外 \u003cem\u003e断言失败\u003c/em\u003e 仅仅在Vert.x Unit的调用下才会有效。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"my_test_case\"\u003c/span\u003e, ctx -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// '失败'会被Vert.x Unit 报告\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RuntimeException(\u003cspan class=\"hljs-string\"\u003e\"it failed!\"\u003c/span\u003e);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在一个常规的Vert.x回调中，会忽略失败：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.test(\u003cspan class=\"hljs-string\"\u003e\"test-server\"\u003c/span\u003e, testContext -\u0026gt; {\n  HttpServer server = vertx.createHttpServer().requestHandler(req -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (req.path().equals(\u003cspan class=\"hljs-string\"\u003e\"/somepath\"\u003c/span\u003e)) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e AssertionError(\u003cspan class=\"hljs-string\"\u003e\"Wrong path!\"\u003c/span\u003e);\n    }\n    req.response().end();\n  });\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e从 Vert.x 3.3 版本开始，您可以设置一个全局异常处理器来报告 event loop 没有捕捉到的异常：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003esuite.before(testContext -\u0026gt; {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 报告未被捕捉到到异常，以其作为 Vert.x Unit 失败事件\u003c/span\u003e\n  vertx.exceptionHandler(testContext.exceptionHandler());\n});\n\nsuite.test(\u003cspan class=\"hljs-string\"\u003e\"test-server\"\u003c/span\u003e, testContext -\u0026gt; {\n  HttpServer server = vertx.createHttpServer().requestHandler(req -\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (req.path().equals(\u003cspan class=\"hljs-string\"\u003e\"/somepath\"\u003c/span\u003e)) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e AssertionError(\u003cspan class=\"hljs-string\"\u003e\"Wrong path!\"\u003c/span\u003e);\n    }\n    req.response().end();\n  });\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果异常处理器设置在 \u003cem\u003ebefore\u003c/em\u003e 部分，那么 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\"\u003eTestContext\u003c/a\u003e\u003c/code\u003e 则会在 \u003cem\u003ebefore\u003c/em\u003e,\n\u003cem\u003etest\u003c/em\u003e 和 \u003cem\u003eafter\u003c/em\u003e 部分之间共享。\n所以将异常处理器置于 \u003cem\u003ebefore\u003c/em\u003e 部分是一个正确到做法\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_junit_integration\"\u003e\u003ca class=\"anchor\" href=\"#_junit_integration\"\u003e\u003c/a\u003eJunit 整合\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e尽管Vertx Unit是多语言的，且不是基于Junit的，但是您依然可以在Junit上运行Vert.x Unit测试套件以及测试用例，\n并允许您将测试用例整合到JUnit，允许整合到您的build system，也可以整合到IDE中。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e将一个Java类作为JUnit测试套件\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@RunWith\u003c/span\u003e(VertxUnitRunner\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\n\u003cspan class=\"hljs-title\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eJUnitTestSuite\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TestContext context)\u003c/span\u003e \u003c/span\u003e{\n    context.assertFalse(\u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunner.html\"\u003eVertxUnitRunner\u003c/a\u003e\u003c/code\u003e 使用Junit注解来对这个类进行解析，\n并创建该类对象之后创建测试套件。\n该类中的方法应该在参数中声明一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\"\u003eTestContext\u003c/a\u003e\u003c/code\u003e 参数\n，不声明该参数也是可以的。\n然而 \u003ccode\u003eTestContext\u003c/code\u003e 是在异步测试过程中能够获取相关Vertx对象的唯一方式。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e在Groovy语言中，\n用 \u003ccode\u003eio.vertx.groovy.ext.unit.junit.VertxUnitRunner\u003c/code\u003e 也可以达到整合Junit的目的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_running_a_test_on_a_vert_x_context\"\u003e\u003ca class=\"anchor\" href=\"#_running_a_test_on_a_vert_x_context\"\u003e\u003c/a\u003e在 Vert.x 上下文中执行一个测试\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e默认情况下执行测试方法的是Junit线程。\n\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html\"\u003eRunTestOnContext\u003c/a\u003e\u003c/code\u003e Junit rule可以改变这个行为，使测试方法都运行于 Vert.x event loop 线程。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e因此，当某状态在测试方法/Vert.x处理器之间共享时，您就需要小心了，因为他们并不是在同一个线程上运行的，\n例如，在Vert.x处理器中累加一个计数器然后在测试方法中断言计数器的值。\n使用恰当地同步机制是解决此问题的一种方式，\n另外还可以在Vert.x context中执行测试方法，这样共享状态则会在处理器之间传播。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e以此目的，\u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html\"\u003eRunTestOnContext\u003c/a\u003e\u003c/code\u003e rule 需要一个 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/core/Vertx.html\"\u003eVertx\u003c/a\u003e\u003c/code\u003e 对象。\n您可以主动提供这个对象，如果不提供，这个 rule 会隐式创建它。\n这个对象可以在测试执行过程中获取，\n这也使该rule成为管理Vert.x实例的一种方式。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e运行一个Java类作为JUnit测试套件\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@RunWith\u003c/span\u003e(VertxUnitRunner\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\n\u003cspan class=\"hljs-title\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRunOnContextJUnitTestSuite\u003c/span\u003e \u003c/span\u003e{\n\n  \u003cspan class=\"hljs-meta\"\u003e@Rule\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e RunTestOnContext rule = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RunTestOnContext();\n\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TestContext context)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// 使用这个隐式创建的vertx对象\u003c/span\u003e\n    Vertx vertx = rule.vertx();\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003erule可以用 {@literal @Rule} 或 {@literal @ClassRule} 注解修饰，\n前者管理每个测试的Vert.x对象，后者则管理该测试类中所有测试方法相关的那一个Vertx对象。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock warning\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e警告\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n切记，用这个rule的时候您不可以阻塞 event loop 。使用像 \u003ccode\u003eCountDownLatch\u003c/code\u003e 类的做法，\n则必须要小心。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_timeout\"\u003e\u003ca class=\"anchor\" href=\"#_timeout\"\u003e\u003c/a\u003e超时\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Unit 默认超时时间两分钟，这可以用 \u003ccode\u003e@Test\u003c/code\u003e 注解中的 \u003ccode\u003etimeout\u003c/code\u003e 属性来指定：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e在测试方法级别配置超时时间\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eJunitTestWithTimeout\u003c/span\u003e \u003c/span\u003e{\n\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e(timeout = \u003cspan class=\"hljs-number\"\u003e1000l\u003c/span\u003e)\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TestContext context)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n  }\n\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e对于更全局的配置，可以用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/Timeout.html\"\u003eTimeout\u003c/a\u003e\u003c/code\u003e rule：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e类级别超时时间配置\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@RunWith\u003c/span\u003e(VertxUnitRunner\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\n\u003cspan class=\"hljs-title\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eTimeoutTestSuite\u003c/span\u003e \u003c/span\u003e{\n\n  \u003cspan class=\"hljs-meta\"\u003e@Rule\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e Timeout rule = Timeout.seconds(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TestContext context)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n\u003ccode\u003e@Test\u003c/code\u003e 的超时设置会覆盖 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/Timeout.html\"\u003eTimeout\u003c/a\u003e\u003c/code\u003e rule 的配置。\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_parameterized_tests\"\u003e\u003ca class=\"anchor\" href=\"#_parameterized_tests\"\u003e\u003c/a\u003e参数化测试\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eJUnit提供了非常有用的 \u003ccode\u003e参数化\u003c/code\u003e 测试，\nVert.x Unit 测试可以利用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunnerWithParametersFactory.html\"\u003eVertxUnitRunnerWithParametersFactory\u003c/a\u003e\u003c/code\u003e 来指定执行器：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e运行参数化的Vert.x Unit测试\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@RunWith\u003c/span\u003e(Parameterized\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\n@\u003cspan class=\"hljs-title\"\u003eParameterized\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eUseParametersRunnerFactory\u003c/span\u003e(\u003cspan class=\"hljs-title\"\u003eVertxUnitRunnerWithParametersFactory\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eclass\u003c/span\u003e)\n\u003cspan class=\"hljs-title\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSimpleParameterizedTest\u003c/span\u003e \u003c/span\u003e{\n\n  \u003cspan class=\"hljs-meta\"\u003e@Parameterized\u003c/span\u003e.\u003cspan class=\"hljs-function\"\u003eParameters\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e Iterable\u0026lt;Integer\u0026gt; \u003cspan class=\"hljs-title\"\u003edata\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Arrays.asList(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSimpleParameterizedTest\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e value)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TestContext context)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// 用当前值来执行测试方法\u003c/span\u003e\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eGroovy语言中，您可以用 \u003ccode\u003eio.vertx.groovy.ext.unit.junit.VertxUnitRunnerWithParametersFactory\u003c/code\u003e 来实现参数化测试：\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_repeating_a_test\"\u003e\u003ca class=\"anchor\" href=\"#_repeating_a_test\"\u003e\u003c/a\u003e重复测试\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e当测试随机条件或测试不经常失败时，例如在竞争条件下，\n为了增加测试失败的可能性，多次运行同一测试是个方便的方式。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果用Junit，测试用例必须用 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/Repeat.html\"\u003e@Repeat\u003c/a\u003e\u003c/code\u003e 注解修饰，来指定重复执行。\n测试用例也必须定义根据自身规则定义 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/junit/RepeatRule.html\"\u003eRepeatRule\u003c/a\u003e\u003c/code\u003e 。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e用Junit重复测试\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@RunWith\u003c/span\u003e(VertxUnitRunner\u003cspan class=\"hljs-class\"\u003e.\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\n\u003cspan class=\"hljs-title\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRepeatingTest\u003c/span\u003e \u003c/span\u003e{\n\n  \u003cspan class=\"hljs-meta\"\u003e@Rule\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e RepeatRule rule = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RepeatRule();\n\n  \u003cspan class=\"hljs-meta\"\u003e@Repeat\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e)\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TestContext context)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// 执行1000次\u003c/span\u003e\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e如果声明了RepeatRule，那么 \u003cem\u003ebefore\u003c/em\u003e 和 \u003cem\u003eafter\u003c/em\u003e 方法会在每次执行测试方法时都执行一次。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"admonitionblock note\"\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd class=\"icon\"\u003e\n\u003cdiv class=\"title\"\u003e注意\u003c/div\u003e\n\u003c/td\u003e\n\u003ctd class=\"content\"\u003e\n重复测试是顺序执行\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_using_with_other_assertion_libraries\"\u003e\u003ca class=\"anchor\" href=\"#_using_with_other_assertion_libraries\"\u003e\u003c/a\u003e用其他断言库\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eVert.x Unit 的可用性从 Vert.x 3.3 开始有了巨大的提升。您可以用\n\u003ca href=\"http://hamcrest.org/\"\u003eHamcrest\u003c/a\u003e ，\n\u003ca href=\"http://joel-costigliola.github.io/assertj/\"\u003eAssertJ\u003c/a\u003e ，\n\u003ca href=\"https://github.com/rest-assured/rest-assured/\"\u003eRest Assured\u003c/a\u003e ，甚至其他您想用的断言库来写测试用例。这是由 \u003ca href=\"#vertx_integration\"\u003e[vertx_integration]\u003c/a\u003e 章节里介绍的全局异常处理器的机制实现的。\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e您可以在 \u003ca href=\"https://github.com/vert-x3/vertx-examples/tree/master/unit-examples\"\u003evertx-examples\u003c/a\u003e 工程中，\n找到Vert.x Unit中用 Hamcrest 和 AssertJ 的示例。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"sect1\"\u003e\n\u003ch2 id=\"_java_language_integration\"\u003e\u003ca class=\"anchor\" href=\"#_java_language_integration\"\u003e\u003c/a\u003eJava 语言整合\u003c/h2\u003e\n\u003cdiv class=\"sectionbody\"\u003e\n\u003cdiv class=\"sect2\"\u003e\n\u003ch3 id=\"_test_suite_integration\"\u003e\u003ca class=\"anchor\" href=\"#_test_suite_integration\"\u003e\u003c/a\u003e测试套件整合\u003c/h3\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003eJava语言提供了class，\n而且可以用如下映射规则来直接利用Java class创建测试套件：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e检查 \u003ccode\u003e测试套件对象\u003c/code\u003e 的参数和方法，保留带有 \u003ccode\u003e\u003ca href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\"\u003eTestContext\u003c/a\u003e\u003c/code\u003e 参数的public且非静态方法并通过方法名映射到Vert.x Unit测试套件：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"ulist\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ebefore\u003c/code\u003e : before callback\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eafter\u003c/code\u003e : after callback\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ebeforeEach\u003c/code\u003e : beforeEach callback\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eafterEach\u003c/code\u003e : afterEach callback\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e以 \u003cem\u003etest\u003c/em\u003e 开头的名称: 以方法名命名的测试用例\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e用Java类写的测试套件\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyTestSuite\u003c/span\u003e \u003c/span\u003e{\n\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TestContext context)\u003c/span\u003e \u003c/span\u003e{\n    context.assertFalse(\u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"paragraph\"\u003e\n\u003cp\u003e这个类可以很容易的转化成Vert.x 测试套件：\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"listingblock\"\u003e\n\u003cdiv class=\"title\"\u003e从Java对象创建测试套件\u003c/div\u003e\n\u003cdiv class=\"content\"\u003e\n\u003cpre class=\"highlight\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003eTestSuite suite = TestSuite.create(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MyTestSuite());\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e","version":"4.0.0"},"__N_SSG":true},"page":"/docs/[[...slug]]","query":{"slug":["4.0.0","vertx-unit","java"]},"buildId":"1FXEv1LGMjjhD_u9OmLFZ","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-9a5c89434732593ca2fd.js"></script><script src="/_next/static/chunks/main-b6e20584df76f29b6f35.js" async=""></script><script src="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" async=""></script><script src="/_next/static/chunks/framework.fcef98db13e2318579fb.js" async=""></script><script src="/_next/static/chunks/commons.5b8771ac6e8a338f82f1.js" async=""></script><script src="/_next/static/chunks/styles.7064a0f84b2a7c13404a.js" async=""></script><script src="/_next/static/chunks/pages/_app-3dbbc9c041333077c167.js" async=""></script><script src="/_next/static/chunks/5df0631eea625b022d3730b3f1bf573e1b8deb37.3b9874ba65db13e7d868.js" async=""></script><script src="/_next/static/chunks/31acfd8439b7c9eee4abe9f59c7500d6c943ee0d.271e32a961c78bfd051e.js" async=""></script><script src="/_next/static/chunks/pages/docs/%5B%5B...slug%5D%5D-f144718c033f8d0b431b.js" async=""></script><script src="/_next/static/1FXEv1LGMjjhD_u9OmLFZ/_buildManifest.js" async=""></script><script src="/_next/static/1FXEv1LGMjjhD_u9OmLFZ/_ssgManifest.js" async=""></script></body></html>