{"pageProps":{"slug":"4.0.0/vertx-grpc/java","title":"Vert.x gRPC","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_grpc_types\">gRPC类型</a></li>\n<li><a href=\"#_a_simple_hello_world\">一个简单的 Hello World</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_compile_the_rpc_definition\">编译RPC的定义</a></li>\n<li><a href=\"#_grpc_server\">gRPC 服务</a></li>\n<li><a href=\"#_grpc_client\">gRPC 客户端</a></li>\n</ul>\n</li>\n<li><a href=\"#_advanced_configuration\">高级配置</a></li>\n<li><a href=\"#_native_transports\">本地传输</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x gRPC</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>可以在维基百科看到对gRPC全面的介绍</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>gRPC是一个由谷歌开发的开源远程方法调用（RPC）系统。它用HTTP/2作为\n传输协议，以协议Buffer作为接口描述语言，它提供一些特性，例如认证、\n双向streaming和flow的控制，阻塞或非阻塞绑定，和\n撤销、超时操作。它\n为很多语言生成跨平台客户端和服务端。</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x gRPV是一个将谷歌风格gRPC编程风格对应到Vert.x风格的模块。作为这个模块的用户，\n您会更加习惯于用Vert.x Streams和Futures的编码风格从而体验到\ngRPC的好处。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多关于gRPC的信息请查看官方文档 <a href=\"http://www.grpc.io/\" class=\"bare\">http://www.grpc.io/</a> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x gRPC 额外支持：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>用Verticle横向扩展gRPC服务</p>\n</li>\n<li>\n<p>非阻塞的本地传输</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_grpc_types\"><a class=\"anchor\" href=\"#_grpc_types\"></a>gRPC类型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>用gRPC，您将受益于HTTP/2协议，这意味着您会获得异步流的支持，\n同时您的远程方法调用会有如下特性：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>客户端发出stream请求，服务端响应单个对象</p>\n</li>\n<li>\n<p>客户端发出stream请求，服务端响应stream</p>\n</li>\n<li>\n<p>客户端发送单个对象请求，服务端响应单个对象</p>\n</li>\n<li>\n<p>客户端发送单个对象请求，服务端响应stream</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>尽管对于非专业认识来讲，这也许看起来和其他基于HTTP协议实现的RPC没有区别，但您需要注意一点，\n那就是在HTTP/2协议下，在响应到达之前您的请求不必完成。这意味着\n您的通信通道是全双工的。全双工允可以减小响应延迟并且增强应用的响应能力。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_a_simple_hello_world\"><a class=\"anchor\" href=\"#_a_simple_hello_world\"></a>一个简单的 Hello World</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了开始您的第一个Hello World示例，您需要定义协议。gRPC要求\n用 <code>protobuffer</code> 格式来定义协议。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-proto\" data-lang=\"proto\">syntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"examples\";\noption java_outer_classname = \"HelloWorldProto\";\npackage helloworld;\n\n// 服务定义。\nservice Greeter {\n // 发送请求\n rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// 包含用户名字的请求消息\nmessage HelloRequest {\n string name = 1;\n}\n\n// 包含请求信息的响应消息\nmessage HelloReply {\n string message = 1;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这是一个非常普通的示例，用来展示单次请求单次响应。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_compile_the_rpc_definition\"><a class=\"anchor\" href=\"#_compile_the_rpc_definition\"></a>编译RPC的定义</h3>\n<div class=\"paragraph\">\n<p>要用前述的定义，那么我们需要将其编译。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您 <a href=\"https://github.com/google/protobuf/tree/master/java#installation---without-maven\">喜欢</a> ，您可以用 <code>protoc</code> 编译器来编译原始文件，您也可以添加如下依赖：</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您用Apache Maven，您需要添加如下插件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.6.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.2.0:exe:${os.detected.classifier}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocArtifact</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginId</span>&gt;</span>grpc-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginId</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:${vertx.grpc.version}:exe:${os.detected.classifier}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugins</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${stack.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mainClass</span>&gt;</span>io.vertx.grpc.protoc.plugin.VertxGrpcGenerator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mainClass</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugins</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">executions</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">execution</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">outputDirectory</span>&gt;</span>${project.basedir}/src/main/java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">outputDirectory</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goals</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile-custom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goals</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">execution</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">execution</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>test-compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goals</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>test-compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>test-compile-custom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goals</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">execution</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">executions</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>${os.detected.classifier}</code> 属性在构建时用来区分操作系统，在苹果系统（OSX）中，\n需要替换为 <em>osx-x86_64</em> ，其他同理。要使用它，您需要在 <code>pom.xml</code> 文件中添加 <a href=\"https://github.com/trustin/os-maven-plugin\">os-maven-plugin</a>\n插件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n ...\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">extensions</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">extension</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>kr.motd.maven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>os-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.4.1.Final<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">extension</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">extensions</span>&gt;</span>\n ...\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个插件会编译 <code>src/main/proto</code> 目录下的原始文件，并且使其对您的项目可用。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您正在用Gradle，那么您需要加入如下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">...\napply <span class=\"hljs-string\">plugin:</span> <span class=\"hljs-string\">'com.google.protobuf'</span>\n...\nbuildscript {\n ...\n dependencies {\n   <span class=\"hljs-comment\">// ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions</span>\n   classpath <span class=\"hljs-string\">'com.google.protobuf:protobuf-gradle-plugin:0.8.0'</span>\n }\n}\n...\nprotobuf {\n protoc {\n   artifact = <span class=\"hljs-string\">'com.google.protobuf:protoc:3.2.0'</span>\n }\n plugins {\n   grpc {\n     artifact = <span class=\"hljs-string\">\"io.grpc:protoc-gen-grpc-java:1.25.0\"</span>\n   }\n   vertx {\n     artifact = <span class=\"hljs-string\">\"io.vertx:vertx-grpc-protoc-plugin:${vertx.grpc.version}\"</span>\n   }\n }\n generateProtoTasks {\n   all()*.plugins {\n     grpc\n     vertx\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个插件会编译 <code>build/generated/source/proto/main</code> 目录下的原始文件，然后使其对项目可用。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_grpc_server\"><a class=\"anchor\" href=\"#_grpc_server\"></a>gRPC 服务</h3>\n<div class=\"paragraph\">\n<p>您已经拥有您的RPC基础代码，现在该实现您自己的服务器了。由前述可知，\n我们的服务需要实现 <code>sayHello</code> 方法，该方法接收 <code>HelloRequest</code> 对象，然后返回\n一个 <code>HelloReply</code> 对象，所以 您可以像如下实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GreeterGrpc.GreeterImplBase service = <span class=\"hljs-keyword\">new</span> GreeterGrpc.GreeterImplBase() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(\n    HelloRequest request,\n    StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>{\n\n    responseObserver.onNext(\n      HelloReply.newBuilder()\n        .setMessage(request.getName())\n        .build());\n    responseObserver.onCompleted();\n  }\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您愿意，您可以让它在服务上可用。Vert.x使服务的创建变得很简单，\n您只需要添加如下代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">\"my.host\"</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(service)\n  .build();\n\n<span class=\"hljs-comment\">// 异步启动</span>\nrpcServer.start();</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_vert_x_future_and_streams\"><a class=\"anchor\" href=\"#_using_vert_x_future_and_streams\"></a>使用Vert.x future和streams</h4>\n<div class=\"paragraph\">\n<p>前述示例通过gRPC异步架构（ 例如 <code>io.grpc.stub.StreamObserver</code> ）进行异步处理的方式来使用gRPC服务。\n这些代码由 protoc 编译器生成。</p>\n</div>\n<div class=\"paragraph\">\n<p>上述插件的配置作用于以下插件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${stack.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mainClass</span>&gt;</span>io.vertx.grpc.protoc.plugin.VertxGrpcGenerator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mainClass</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugin</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它用Vert.x的异步架构（ 例如 <code>Future</code> 或 <code>ReadStream</code> 或 <code>WriteStream</code> ）生成服务版本，这样在Vert.x生态中更加方便。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxGreeterGrpc.GreeterVertxImplBase service =\n  <span class=\"hljs-keyword\">new</span> VertxGreeterGrpc.GreeterVertxImplBase() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;HelloReply&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture(\n        HelloReply.newBuilder()\n          .setMessage(request.getName())\n          .build());\n    }\n  };</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_gzip_compression\"><a class=\"anchor\" href=\"#_server_gzip_compression\"></a>服务 gzip 压缩</h4>\n<div class=\"paragraph\">\n<p>您可以启用gzip压缩来告诉服务端来返回压缩的响应\n（服务器会自动处理压缩过的请求）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxGreeterGrpc.GreeterVertxImplBase service =\n  <span class=\"hljs-keyword\">new</span> VertxGreeterGrpc.GreeterVertxImplBase() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;HelloReply&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture(\n        HelloReply.newBuilder()\n          .setMessage(request.getName())\n          .build());\n    }\n  }\n    .withCompression(<span class=\"hljs-string\">\"gzip\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>withCompression</code> 配置是由Vert.x gRPC protoc 插件生成。\n您也可以在默认服务上启用压缩功能\n（将 <code>ResponseObserver</code> 转换成 <code>ServerCallStreamObserver</code> 并在响应之前调用 <code>setCompression</code> ）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GreeterGrpc.GreeterImplBase service = <span class=\"hljs-keyword\">new</span> GreeterGrpc.GreeterImplBase() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(\n    HelloRequest request,\n    StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>{\n\n    ((ServerCallStreamObserver) responseObserver)\n      .setCompression(<span class=\"hljs-string\">\"gzip\"</span>);\n\n    responseObserver.onNext(\n      HelloReply.newBuilder()\n        .setMessage(request.getName())\n        .build());\n\n    responseObserver.onCompleted();\n  }\n};</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n只要服务端支持，您可以使用任何其他的压缩器，在构建 <code>ManagedChannel</code> 时注册它们。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_ssl_configuration\"><a class=\"anchor\" href=\"#_ssl_configuration\"></a>SSL 配置</h4>\n<div class=\"paragraph\">\n<p>前一个例子很简单，但您的RPC并不安全。为了让RPC更安全，我们应该启用SSL/TLS：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxServerBuilder builder = VertxServerBuilder.forPort(vertx, <span class=\"hljs-number\">8080</span>)\n  .useSsl(options -&gt; options\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n    .setUseAlpn(<span class=\"hljs-keyword\">true</span>)\n    .setKeyStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions()\n      .setPath(<span class=\"hljs-string\">\"server-keystore.jks\"</span>)\n      .setPassword(<span class=\"hljs-string\">\"secret\"</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>恭喜您拥有了第一个gRPC服务。</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n因为gRPC用HTTP/2作为传输协议，SSL/TLS服务的启用必须拥有 <a href=\"https://wikipedia.org/wiki/Application-Layer_Protocol_Negotiation\">Application-Layer Protocol Negotiation</a>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_scaling\"><a class=\"anchor\" href=\"#_server_scaling\"></a>服务横向扩展</h4>\n<div class=\"paragraph\">\n<p>如果你将一个Verticle部署了多个实例，gRPC服务将\n在verticle event-loops上横向扩展。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.deployVerticle(\n\n  <span class=\"hljs-comment\">// Verticle supplier - 被调用了4次</span>\n  () -&gt; <span class=\"hljs-keyword\">new</span> AbstractVerticle() {\n\n    BindableService service = <span class=\"hljs-keyword\">new</span> GreeterGrpc.GreeterImplBase() {\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(\n        HelloRequest request,\n        StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>{\n\n        responseObserver.onNext(\n          HelloReply.newBuilder()\n            .setMessage(request.getName())\n            .build());\n\n        responseObserver.onCompleted();\n      }\n    };\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n      VertxServerBuilder\n        .forAddress(vertx, <span class=\"hljs-string\">\"my.host\"</span>, <span class=\"hljs-number\">8080</span>)\n        .addService(service)\n        .build()\n        .start();\n    }\n  },\n\n  <span class=\"hljs-comment\">// 部署4个实例，即服务以4个eventloop的形式做了横向扩展。</span>\n  <span class=\"hljs-keyword\">new</span> DeploymentOptions()\n    .setInstances(<span class=\"hljs-number\">4</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_blockingserverinterceptor\"><a class=\"anchor\" href=\"#_blockingserverinterceptor\"></a>BlockingServerInterceptor</h4>\n<div class=\"paragraph\">\n<p>gRPC <a href=\"https://grpc.io/grpc-java/javadoc/io/grpc/ServerInterceptor.html\">ServerInterceptor</a> 是一个机制，\n该机制在向服务端发起请求之前拦截该方法调用。\n它有着同步的行为并且在Vert.x event loop上执行。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">\"my.host\"</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(ServerInterceptors.intercept(service, myInterceptor))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>假设我们有一个拦截器，它阻塞了eventloop：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ServerInterceptor</span> </span>{\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> &lt;Q, A&gt; ServerCall.<span class=\"hljs-function\">Listener&lt;Q&gt; <span class=\"hljs-title\">interceptCall</span><span class=\"hljs-params\">(\n    ServerCall&lt;Q, A&gt; call, Metadata headers, ServerCallHandler&lt;Q, A&gt; next)</span> </span>{\n    <span class=\"hljs-comment\">// 例如做一些复杂操作并更新元数据。</span>\n    <span class=\"hljs-keyword\">return</span> next.startCall(call, headers);\n  }\n}\nMyInterceptor myInterceptor = <span class=\"hljs-keyword\">new</span> MyInterceptor();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了避免阻塞，您应该包装这个拦截器，让它在Vert.x的worker线程上执行。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServerInterceptor wrapped =\n  BlockingServerInterceptor.wrap(vertx, myInterceptor);\n\n<span class=\"hljs-comment\">// 创建服务</span>\nVertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">\"my.host\"</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(ServerInterceptors.intercept(service, wrapped))\n  .build();\n\n<span class=\"hljs-comment\">// 开启</span>\nrpcServer.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_context_server_interceptor\"><a class=\"anchor\" href=\"#_context_server_interceptor\"></a>Context Server Interceptor</h4>\n<div class=\"paragraph\">\n<p>一个 abstract context server interceptor 允许拦截向服务发起的请求并提取元数据\n到Vert.x context。这个Context不依赖于thread locals，所以使用Vert.x API是安全的。\n这个拦截器应该在首位（或者首先添加到拦截器列表的其中之一）</p>\n</div>\n<div class=\"paragraph\">\n<p>session id 则是一个典型的用法。一个客户端可以创建客户端拦截器并向所有连接设置一个session id:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Metadata extraHeaders = <span class=\"hljs-keyword\">new</span> Metadata();\nextraHeaders.put(\n  Metadata.Key.of(<span class=\"hljs-string\">\"sessionId\"</span>, Metadata.ASCII_STRING_MARSHALLER), theSessionId);\n\nClientInterceptor clientInterceptor = MetadataUtils\n  .newAttachHeadersInterceptor(extraHeaders);\n\nchannel = VertxChannelBuilder.forAddress(vertx, <span class=\"hljs-string\">\"localhost\"</span>, port)\n  .intercept(clientInterceptor)\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在服务端一侧，可以像如下添加拦截器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">BindableService service = <span class=\"hljs-keyword\">new</span> VertxGreeterGrpc.GreeterVertxImplBase() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;HelloReply&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(\n      HelloReply.newBuilder().setMessage(<span class=\"hljs-string\">\"Hello \"</span> + request.getName()).build());\n  }\n};\n\nServerInterceptor contextInterceptor = <span class=\"hljs-keyword\">new</span> ContextServerInterceptor() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(Metadata metadata, ConcurrentMap&lt;String, String&gt; context)</span> </span>{\n    context.put(<span class=\"hljs-string\">\"sessionId\"</span>, metadata.get(SESSION_ID_METADATA_KEY));\n  }\n};\n\n<span class=\"hljs-comment\">// 创建服务</span>\nVertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">\"my.host\"</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(ServerInterceptors.intercept(service, contextInterceptor))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_grpc_client\"><a class=\"anchor\" href=\"#_grpc_client\"></a>gRPC 客户端</h3>\n<div class=\"paragraph\">\n<p>没有客户端的服务端是没用的，所以我们创建一个客户端。创建客户端和创建服务端的步骤有重叠。\n首先我们需要预先有一个RPC的定义，否则就不会有服务端，然后这个相同的定义会被编译。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意：编译器即生成基本服务也会生成客户端存根，所以如果您已经编译了一次，那么您就无需再次编译。</p>\n</div>\n<div class=\"paragraph\">\n<p>每一个客户端存根都必须有一个服务端通信channel相对应，\n所以首先我们需要创建一个gRPC channel：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ManagedChannel channel = VertxChannelBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-number\">8080</span>)\n  .usePlaintext()\n  .build();\n\n<span class=\"hljs-comment\">// 获取一个存根来与远程服务交互</span>\nGreeterGrpc.GreeterStub stub = GreeterGrpc.newStub(channel);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦存根生成，我们可以和服务端进行交互，此时这会更加简单，因为存根已经提供了\n正确的方法定义和正确的参数类型定义：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HelloRequest request = HelloRequest.newBuilder().setName(<span class=\"hljs-string\">\"Julien\"</span>).build();\n\n<span class=\"hljs-comment\">// 调用远程服务</span>\nstub.sayHello(request, <span class=\"hljs-keyword\">new</span> StreamObserver&lt;HelloReply&gt;() {\n  <span class=\"hljs-keyword\">private</span> HelloReply helloReply;\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(HelloReply helloReply)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.helloReply = helloReply;\n  }\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable throwable)</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"Coult not reach server \"</span> + throwable.getMessage());\n  }\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"Got the server response: \"</span> + helloReply.getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_vert_x_future_and_streams_2\"><a class=\"anchor\" href=\"#_using_vert_x_future_and_streams_2\"></a>使用 Vert.x 的 future 和 streams</h4>\n<div class=\"paragraph\">\n<p>前述示例用一个gRPC客户端基于gRPC异步架构（例如 <code>io.grpc.stub.StreamObserver</code> ）来执行异步操作。\n代码是由 protoc 编译器生成的。</p>\n</div>\n<div class=\"paragraph\">\n<p>上述配置作用于下列插件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${stack.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mainClass</span>&gt;</span>io.vertx.grpc.protoc.plugin.VertxGrpcGenerator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mainClass</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugin</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它用Vert.x的异步架构（ 例如 <code>Future</code> 或 <code>ReadStream</code> 或 <code>WriteStream</code> ）生成客户端版本，这样在Vert.x生态中更加方便。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HelloRequest request = HelloRequest.newBuilder().setName(<span class=\"hljs-string\">\"Julien\"</span>).build();\n\n<span class=\"hljs-comment\">// Call the remote service</span>\nFuture&lt;HelloReply&gt; future = stub.sayHello(request);\n\n<span class=\"hljs-comment\">// Listen to completion events</span>\nfuture\n  .onSuccess(helloReply -&gt; System.out.println(<span class=\"hljs-string\">\"Got the server response: \"</span> + helloReply.getMessage())).onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">\"Coult not reach server \"</span> + err));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_client_gzip_compression\"><a class=\"anchor\" href=\"#_client_gzip_compression\"></a>客户端gzip压缩</h4>\n<div class=\"paragraph\">\n<p>您可以启用gzip压缩来让客户端发送压缩消息。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GreeterGrpc.GreeterStub stub = GreeterGrpc\n  .newStub(channel)\n  .withCompression(<span class=\"hljs-string\">\"gzip\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n只要客户端支持，您可以使用任何其他的压缩器，他们在构建 <code>ManagedChannel</code> 时被注册。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_ssl_configuration_2\"><a class=\"anchor\" href=\"#_ssl_configuration_2\"></a>SSL 配置</h4>\n<div class=\"paragraph\">\n<p>如果您先前启用了SSL，那么您的客户端也必须用SSL，我们需要像如下配置channel：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ManagedChannel channel = VertxChannelBuilder.\n  forAddress(vertx, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-number\">8080</span>)\n  .useSsl(options -&gt; options\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n    .setUseAlpn(<span class=\"hljs-keyword\">true</span>)\n    .setTrustStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions()\n      .setPath(<span class=\"hljs-string\">\"client-truststore.jks\"</span>)\n      .setPassword(<span class=\"hljs-string\">\"secret\"</span>)))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n因为gRPC用了 HTTP/2 作为传输协议，客户端SSL/TLS的启用必须有 <a href=\"https://wikipedia.org/wiki/Application-Layer_Protocol_Negotiation\">Application-Layer Protocol Negotiation</a>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_advanced_configuration\"><a class=\"anchor\" href=\"#_advanced_configuration\"></a>高级配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>直到现在，所有的gRPC示例都使用标准的默认配置，但是还有更多的配置项。如果您需要完整控制服务端的配置，\n那么您应该查阅文档： <code><a href=\"../../apidocs/io/vertx/grpc/VertxServerBuilder.html\">VertxServerBuilder</a></code> ，\n如果您需要控制客户端channel，则查阅 <code><a href=\"../../apidocs/io/vertx/grpc/VertxChannelBuilder.html\">VertxChannelBuilder</a></code> 。 Vert.x gRPC继承了 grpc-java 项目（Netty传输），因此建议阅读其 <a href=\"http://www.grpc.io/grpc-java/javadoc/\">文档</a></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_native_transports\"><a class=\"anchor\" href=\"#_native_transports\"></a>本地传输</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>客户端和服务端可以用Netty的本地传输来部署，这是在创建Vert.x实例时实现的。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx.vertx(<span class=\"hljs-keyword\">new</span> VertxOptions().setPreferNativeTransport(<span class=\"hljs-keyword\">true</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>了解更多本地传输的信息，请查阅 Vert.x Core 文档。</p>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}