{"pageProps":{"categories":["releases","guides","security","news"],"post":{"meta":{"title":"Building services and APIs with AMQP 1.0","category":"guides","authors":[{"name":"Jakub Scholz","github_id":"scholzj"}],"summary":"Microservices and APIs are everywhere. Everyone talks about them, presentation slides are full of them ... some people are actually even building them."},"date":"2017-01-25","slug":"building-services-and-apis-with-amqp-1-0","readingTime":{"text":"8 min read","minutes":7.475,"time":448500,"words":1495},"content":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      h2: \"h2\",\n      ul: \"ul\",\n      li: \"li\",\n      pre: \"pre\",\n      code: \"code\",\n      span: \"span\",\n      img: \"img\"\n    }, props.components), {Alert, Link} = _components;\n    if (!Alert) _missingMdxReference(\"Alert\", true);\n    if (!Link) _missingMdxReference(\"Link\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"Mi­croser­vices and APIs are every­where. Every­one talks about them, pre­sen­ta­tion slides are full of them … some peo­ple are ac­tu­ally even build­ing them. Mi­croser­vices and APIs are of course not com­pletely new con­cepts and they are a bit over-​hyped. But in gen­eral the ideas be­hind them are not bad. Un­for­tu­nately, many peo­ple seem to be­lieve that the only way how to im­ple­ment an API in mi­croser­vice is to use HTTP and REST. That is of course not true. Mi­croser­vices and APIs can be based on many dif­fer­ent pro­to­cols and tech­nolo­gies. My fa­vorite one is of course \", _jsx(_components.a, {\n          href: \"http://www.amqp.org\",\n          children: \"AMQP\"\n        }), \". Don’t take me wrong, HTTP and REST is not nec­es­sar­ily bad. But in some cases AMQP is sim­ply bet­ter and cre­at­ing AMQP based APIs does not need to be com­pli­cated.\"]\n      }), \"\\n\", _jsx(Alert, {\n        info: true,\n        children: _jsxs(_components.p, {\n          children: [\"This is a re-​publication of the fol­low­ing \", _jsx(_components.a, {\n            href: \"http://blog.effectivemessaging.com/2017/01/building-services-and-apis-with-amqp-10.html\",\n            children: \"blog post\"\n          })]\n        })\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"livescore-service\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#livescore-service\"\n        }), \"LiveScore service\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"For demon­stra­tion, I will use a very sim­ple ser­vice for keep­ing scores of foot­ball games. It has very basic API. It has only three calls:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Add a new game\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Up­date a score of ex­ist­ing game\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"List the scores\\nThe AMQP vari­ants will be ad­di­tion­ally able to push live up­dates to the clients.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The demo is using Java and Vert.x toolkit. \", _jsx(Link, {\n          href: \"/\",\n          passHref: true,\n          children: _jsx(_components.a, {\n            href: \"\",\n            children: \"Vert.x\"\n          })\n        }), \" is cool and I def­i­nitely rec­om­mend it to every­one. But most of the stuff from the demo should be pos­si­ble also in any other pro­gram­ming lan­guages and/or frame­work.\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"http-api\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#http-api\"\n        }), \"HTTP API\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"HTTP im­ple­men­ta­tion of my ser­vice is a typ­i­cal REST API. Since it is very sim­ple, it ac­cepts re­quests only on one end­point – /api/v1.0/scores. New games are added as POST op­er­a­tions, scores are up­dated with PUT op­er­a­tions and list of all scores can be ob­tained with GET.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"With Vert.x, cre­at­ing HTTP/REST API is very easy. First the web router has to be cre­ated with all planned API calls:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [\"router = Router.router(vertx);  \\nrouter.route(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/api/v1.0/*\\\"\"\n          }), \").handler(BodyHandler.create());  \\nrouter.get(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/api/v1.0/scores\\\"\"\n          }), \").handler(\", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \"::getScores);  \\nrouter.post(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/api/v1.0/scores\\\"\"\n          }), \").handler(\", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \"::addGame);  \\nrouter.put(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/api/v1.0/scores\\\"\"\n          }), \").handler(\", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \"::setScore);  \\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then the HTTP server has to be cre­ated and linked with the router:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"HttpServerOptions\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"httpOptions\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"HttpServerOptions\"\n          }), \"();  \\nserver = vertx.createHttpServer(httpOptions)  \\n   .requestHandler(router::accept)  \\n   .listen(httpPort);  \\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"And fi­nally the han­dlers which will be trig­gered for each API call have to be im­ple­mented as well. The full code is on \", _jsx(_components.a, {\n          href: \"https://github.com/scholzj/livescore-demo-vertx-http\",\n          children: \"GitHub\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/images/blog/services-and-apis-with-amqp/HTTP-API.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The HTTP API doesn’t pro­vide any way how to au­to­mat­i­cally push the score up­dates to the clients. The clients sim­ply have to poll the ser­vice pe­ri­od­i­cally to get the up­dates. HTTP has of course some ways how to push live up­dates to clients. For ex­am­ple, with Web­Sock­ets or with chun­ked trans­fers. How­ever, these are not that easy to im­ple­ment. The ser­vice would also need to keep sep­a­rate con­nec­tion with every client and push the up­dates for each of them sep­a­rately.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"amqp-api\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#amqp-api\"\n        }), \"AMQP API\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Cre­at­ing the HTTP API was re­ally easy. Cre­at­ing an AMQP API has to be more com­pli­cated, right? We would need an AMQP server, which will lis­ten on some port, ac­cept the con­nec­tions, ses­sions, links and so on. There are usu­ally no nice and sim­ple to use li­braries for this.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Sure, this is one way how to do it. There is ac­tu­ally a nice li­brary called \", _jsx(_components.a, {\n          href: \"http://qpid.apache.org/proton/index.html\",\n          children: \"Apache Qpid Pro­ton\"\n        }), \". It has Java and C ver­sions and bind­ings into many other lan­guages (Go, C++, Python, …). It makes cre­at­ing your own AMQP server lot eas­ier. It will take care of de­cod­ing and en­cod­ing the AMQP pro­to­col, han­dling the con­nec­tions, ses­sions etc. But still, Qpid Pro­ton is not even nearly as easy to use as the HTTP router used for the HTTP API.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/images/blog/services-and-apis-with-amqp/AMQP-Server-API.png\",\n          alt: \"API with AMQP server\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Are there any eas­ier op­tions? What if all what is needed to cre­ate AMQP based API is a sim­ple AMQP client? Nor­mally, that should not be a pos­si­ble be­cause we need the API to lis­ten on some port for the clients to con­nect to it and send re­quests. And clients usu­ally don’t lis­ten on any ports. How­ever, Apache Qpid has some­thing called \", _jsx(_components.a, {\n          href: \"http://qpid.apache.org/components/dispatch-router/index.html\",\n          children: \"Dis­patch\"\n        }), \". It works as a light­weight AMQP router. Dis­patch will serve as the AMQP server which was miss­ing. It will take care of han­dling client con­nec­tions, se­cu­rity and shield the ser­vice from the ac­tual clients. All the ser­vice needs to do is to use AMQP client to con­nect to Dis­patch on pre­de­fined ad­dress and wait for the re­quest.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/images/blog/services-and-apis-with-amqp/AMQP-API.png\",\n          alt: \"AMQP API with Dispatch router\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Dis­patch needs to be con­fig­ured with three API entry points as ad­dresses:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-text\",\n          children: \"address {  \\n    prefix: /setScore  \\n    distribution: balanced  \\n}  \\naddress {  \\n    prefix: /getScore  \\n    distribution: balanced  \\n}  \\naddress {  \\n    prefix: /addGame  \\n    distribution: balanced  \\n}  \\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"LiveScore ser­vice will con­nect to these ad­dresses as a re­ceiver / con­sumer. Clients will con­nect to them as senders  /pro­duc­ers. And Dis­patch will take care of rout­ing the mes­sages be­tween the clients and the ser­vice. Clients can also cre­ate ad­di­tional re­ceivers so that the ser­vice is able to re­spond to their re­quests and spec­ify the ad­dress of the re­ceiver as the reply-​to header in the re­quest mes­sage. LiveScore ser­vice will au­to­mat­i­cally send the re­sponse to this ad­dress. But spec­i­fy­ing a reply-​to is not manda­tory. If the client wants, it can sim­ply fire the re­quest and for­get about the re­sponse.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"LiveScore ser­vice is using Vert.x AMQP Bridge which al­lows easy in­te­gra­tion be­tween the Vert.x Event Bus and the AMQP con­nec­tion to my router. The ser­vice starts the AMQP Bridge and if it suc­cess­fully con­nects to Dis­patch it cre­ates three re­ceivers for the API calls.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"AmqpBridgeOptions\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"options\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"AmqpBridgeOptions\"\n          }), \"().addEnabledSaslMechanism(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"ANONYMOUS\\\"\"\n          }), \");  \\nbridge = AmqpBridge.create(vertx, options);  \\nbridge.start(amqpHostname, amqpPort, res -> {  \\n   \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (res.succeeded())  \\n   {  \\n     bridge.createConsumer(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/setScore\\\"\"\n          }), \").setMaxBufferedMessages(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"100\"\n          }), \").handler(\", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \"::setScore);  \\n     bridge.createConsumer(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/getScores\\\"\"\n          }), \").setMaxBufferedMessages(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"100\"\n          }), \").handler(\", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \"::getScores);  \\n     bridge.createConsumer(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/addGame\\\"\"\n          }), \").setMaxBufferedMessages(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"100\"\n          }), \").handler(\", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \"::addGame);  \\n     fut.complete();  \\n   }  \\n   \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"else\"\n          }), \"  \\n   {  \\n     fut.fail(res.cause());  \\n   }  \\n});  \\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The only other thing which needs to be done is cre­at­ing han­dlers for han­dling the re­quests re­ceived from clients:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"getScores\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(Message<Object> msg)\"\n          }), \"  \\n{  \\n   \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \"(msg.replyAddress() != \", _jsx(_components.span, {\n            className: \"hljs-literal\",\n            children: \"null\"\n          }), \")  \\n   {  \\n     \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"JsonObject\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"response\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"JsonObject\"\n          }), \"();  \\n     response.put(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"application_properties\\\"\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"JsonObject\"\n          }), \"().put(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"status\\\"\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"200\"\n          }), \"));  \\n     response.put(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"body\\\"\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"JsonArray\"\n          }), \"(Json.encode(scoreService.getScores())).encode());  \\n     msg.reply(response);  \\n   }  \\n   \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"else\"\n          }), \"  \\n   {  \\n     LOG.warn(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"Received LiveScore/getScores request without reply to address\\\"\"\n          }), \");  \\n   }  \\n}  \\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Live broad­cast­ing of score up­dates is also very easy. New ad­dress has to be added into Dis­patch con­fig­u­ra­tion. This ad­dress will be used in op­po­site di­rec­tion. the ser­vice con­nects to it as sender / pro­ducer and clients which want to re­ceive the live up­dates cre­ate a re­ceiver against this ad­dress. What is im­por­tant, this ad­dress has to be marked as mul­ti­cast. Thanks to that every sin­gle mes­sage will be de­liv­ered to all con­nected clients and not just to one of them:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-text\",\n          children: \"address {  \\n    prefix: /liveScores  \\n    distribution: multicast  \\n}  \\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/images/blog/services-and-apis-with-amqp/AMQP-API-multicast.png\",\n          alt: \"Multicasting messages\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Thanks to the mul­ti­cast dis­tri­b­u­tion, the ser­vice doesn’t need to send a sep­a­rate up­date to every sin­gle client. It sends the mes­sage only once and dis­patch takes care of the rest.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"broadcastUpdates\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(Game game)\"\n          }), \"  \\n{  \\n   LOG.info(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"Broadcasting game update \\\"\"\n          }), \" + game);  \\n   \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"JsonObject\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"message\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"JsonObject\"\n          }), \"();  \\n   message.put(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"body\\\"\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"JsonObject\"\n          }), \"(Json.encode(game)).encode());  \\n   producer.send(message);  \\n} \\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Again, the com­plete source codes of the demo ser­vice are avail­able on \", _jsx(_components.a, {\n          href: \"https://github.com/scholzj/livescore-demo-vertx-amqp-bridge\",\n          children: \"GitHub\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"how-to-structure-amqp-apis\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#how-to-structure-amqp-apis\"\n        }), \"How to structure AMQP APIs?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Com­pared to HTTP and REST, AMQP gives its users a lot more free­dom when de­sign­ing the API. It isn’t tied up by the avail­able HTTP meth­ods.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"My LiveScore ser­vice is using the API end­points named ac­cord­ing to their func­tion:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"/LiveScore/ad­dGame\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"/LiveScore/setScore\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"/LiveScore/getScores\\nIt also uses HTTP sta­tus codes in ap­pli­ca­tion prop­er­ties of the dif­fer­ent mes­sages to de­scribe the re­sult of the re­quest and JSON as the mes­sage pay­load with the ac­tual re­quest and re­sponse.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Is that the best way? To be hon­est, I don’t know. Just for the re­quest en­cod­ing there are many dif­fer­ent op­tions. AMQP has its own en­cod­ings which sup­ports all pos­si­ble basic as well as more ad­vanced data types and struc­tures. But AMQP can also trans­fer any opaque data - be it JSON, XML, Google Pro­to­col Buffers or any­thing else. For sim­ple re­quest, the pay­load can be com­pletely skipped and ap­pli­ca­tion prop­er­ties can be used in­stead. And for every­one who re­ally loves HTTP/REST, one can also model the API in REST style as I did in an \", _jsx(_components.a, {\n          href: \"https://github.com/scholzj/livescore-demo-vertx-amqp-bridge-rest-style\",\n          children: \"al­ter­na­tive im­ple­men­ta­tion\"\n        }), \" of my demo ser­vice.\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"browser\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#browser\"\n        }), \"Browser\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"One of the en­vi­ron­ments where HTTP is so to say “at home” is browser. AMQP will prob­a­bly never be as “na­tive” pro­to­col for any browser as HTTP is. How­ever AMQP can be used even from browsers. It has Web­Socket bind­ing and there are Javascript AMQP li­braries - for ex­am­ple rhea. So AMQP can be also used re­ally every­where.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"decoupling\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#decoupling\"\n        }), \"Decoupling\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"It is im­por­tant to men­tion that the Dis­patch router doesn’t de­cou­ple the client from the ser­vice. If de­cou­pling is what is needed, it can be eas­ily achieved by re­plac­ing the Dis­patch router with some AMQP bro­ker. The bro­ker would de­cou­ple the client from the ser­vice with­out any changes in the ser­vice or clients.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"conclusion\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#conclusion\"\n        }), \"Conclusion\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"While cre­at­ing APIs using AMQP can be very easy, it doesn’t mean that AMQP is the best pro­to­col for all APIs. There are def­i­nitely APIs where HTTP is more suit­able. But in some use cases, AMQP has clear ad­van­tages. In my LiveScore ex­am­ple it is es­pe­cially one to many com­mu­ni­ca­tion. It is im­por­tant to keep the mind open and se­lect the best avail­able for given ser­vice.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},"prevPost":{"meta":{"title":"An Introduction to the Vert.x Context Object","category":"guides","authors":[{"name":"Jez Prime","github_id":"millross"}],"summary":"Under the hood, the vert.x Context class plays a critical part in maintaining the thread-safety guarantees of verticles. Most of the time, vert.x coders don't need to make use of Context objects directly."},"date":"2017-01-31","slug":"an-introduction-to-the-vert-x-context-object"},"nextPost":{"meta":{"title":"Internet of Things - Reactive and Asynchronous with Vert.x","category":"guides","authors":[{"name":"Paolo Patierno","github_id":"ppatierno"}],"summary":"I have to admit … before joining Red Hat I didn’t know about the Eclipse Vert.x project but it took me few days to fall in love with it!"},"date":"2016-12-29","slug":"internet-of-things-reactive-and-asynchronous-with-vert-x"},"relatedPosts":[{"meta":{"title":"Things to keep in mind concerning CSRF attacks","category":"guides","authors":[{"name":"Xhelal Likaj","github_id":"xhlika"}],"summary":"Eclipse Vert.x like most frameworks provides an anti-CSRF defense. However, no framework can prevent all attack vectors that exist in the web. Therefore, developers need to be aware of some dangers and common attack vectors concerning CSRF defenses."},"date":"2021-01-23","slug":"eclipse-vert-x-CSRF-concerns"},{"meta":{"title":"Some Rest with Vert.x","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"This post is part of the Introduction to Vert.x series. Let’s go a bit further this time and develop a CRUD-ish application"},"date":"2015-07-27","slug":"some-rest-with-vert-x"},{"meta":{"title":"Vert.x Web API Service Introduction","category":"guides","authors":[{"name":"Francesco Guardiani","github_id":"slinkydeveloper"}],"summary":"This blog post teaches you how to use the new module vertx-web-api-service to combine the Web Router and the OpenAPI Router Factory with service proxies."},"date":"2018-12-13","slug":"vert-x-web-api-service-introduction"}]},"__N_SSG":true}