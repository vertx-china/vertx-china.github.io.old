{"pageProps":{"slug":"4.2.3/vertx-web-graphql/java","title":"Vert.x Web GraphQL","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">由此开始</a></li>\n<li><a href=\"#_handlers_setup\">设置处理器</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_http\">HTTP</a></li>\n<li><a href=\"#_graphiql_ide\">GraphiQL IDE</a></li>\n<li><a href=\"#_graphql_over_websocket\">基于 WebSocket 的 GraphQL</a></li>\n<li><a href=\"#_apollo_websocketlink\">Apollo WebSocketLink</a></li>\n</ul>\n</li>\n<li><a href=\"#_fetching_data\">获取数据</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_working_with_callback_based_apis\">使用基于回调的API</a></li>\n<li><a href=\"#_working_with_vert_x_futures\">使用 Vert.x Future</a></li>\n<li><a href=\"#_providing_data_fetchers_with_some_context\">为数据获取器提供上下文</a></li>\n<li><a href=\"#_json_data_results\">JSON 类型数据结果</a></li>\n<li><a href=\"#_batch_loading\">批量加载</a></li>\n<li><a href=\"#_file_uploads\">文件上传</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxjava_3_api\">RxJava 3 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_setting_up_with_an_rxified_router\">配置 Rxified 路由</a></li>\n<li><a href=\"#_working_with_vert_x_rxified_apis\">使用 Vert.x 的 Rxified API</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Web GraphQL</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL 用 <a href=\"https://www.graphql-java.com\">GraphQL-Java</a> 库扩展了 Vert.x Web，您可以用它创建一个 GraphQL 的服务器。</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n这是一个 Vert.x Web GraphQL 的参考文档。\n强烈建议您先熟悉一下 GraphQL-Java API。\n您可以从此处开始阅读 <a href=\"https://www.graphql-java.com/documentation/v17/\">GraphQL-Java documentation</a>。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>由此开始</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>若要使用该模块，请在您的 Maven POM 文件的 <em>dependencies</em> 部分中添加以下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-graphql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或您使用的是Gradle：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-web-graphql:4.2.3&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handlers_setup\"><a class=\"anchor\" href=\"#_handlers_setup\"></a>设置处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_http\"><a class=\"anchor\" href=\"#_http\"></a>HTTP</h3>\n<div class=\"paragraph\">\n<p>为此您需要创建 Vert.x Web <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html\">Route</a></code> 以及 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphQL</span> <span class=\"hljs-variable\">graphQL</span> <span class=\"hljs-operator\">=</span> setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该处理器可处理 <code>GET</code> 以及 <code>POST</code> 请求。\n当然，您也可以限制处理器仅处理其中一种 HTTP 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphQL</span> <span class=\"hljs-variable\">graphQL</span> <span class=\"hljs-operator\">=</span> setupGraphQLJava();\n\nrouter.post(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> 需要 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> ，用于读取 <code>POST</code> 请求体内容。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_query_batching\"><a class=\"anchor\" href=\"#_query_batching\"></a>查询批处理</h4>\n<div class=\"paragraph\">\n<p>查询批处理将数组（而非单个对象）通过 post 方法发送到 GraphQL 端点（endpoint）。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL 可以处理此类请求，但该特性默认是被禁用的。\n如要启用，需创建带参数的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphQLHandlerOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GraphQLHandlerOptions</span>()\n  .setRequestBatchingEnabled(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-type\">GraphQLHandler</span> <span class=\"hljs-variable\">handler</span> <span class=\"hljs-operator\">=</span> GraphQLHandler.create(graphQL, options);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_graphiql_ide\"><a class=\"anchor\" href=\"#_graphiql_ide\"></a>GraphiQL IDE</h3>\n<div class=\"paragraph\">\n<p>在构建应用程序时，可以在 <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> 中很方便地测试您的 GraphQL 查询。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，您需要为 GraphiQL 资源创建一个路由（route）及相应的处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphiQLHandlerOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GraphiQLHandlerOptions</span>()\n  .setEnabled(<span class=\"hljs-literal\">true</span>);\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphiql/*&quot;</span>).handler(GraphiQLHandler.create(options));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>随后浏览以下地址 <a href=\"http://localhost:8080/graphiql/\" class=\"bare\">http://localhost:8080/graphiql/</a> 。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n出于安全考虑，默认情况下 GraphiQL 用户界面是禁用的。\n所以需要配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> 才能启用 GraphiQL 用户界面。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n当 Vert.x Web 在开发模式下运行时，将自动启用 GraphiQL。\n要启用开发模式，请将 <code>VERTXWEB_ENVIRONMENT</code> 环境变量或 <code>vertxweb.environment</code> 系统属性设置为 <code>dev</code> 。\n在这种情况下，创建 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> 时，无需设置 <code>GraphiQLHandlerOptions</code> 的 <code>enabled</code> 属性。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果您的应用程序受身份验证保护，则可以动态自定义 GraphiQL 发送的标头（headers）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">graphiQLHandler.graphiQLRequestHeaders(rc -&gt; {\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">token</span> <span class=\"hljs-operator\">=</span> rc.get(<span class=\"hljs-string\">&quot;token&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> MultiMap.caseInsensitiveMultiMap().add(<span class=\"hljs-string\">&quot;Authorization&quot;</span>, <span class=\"hljs-string\">&quot;Bearer &quot;</span> + token);\n});\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphiql/*&quot;</span>).handler(graphiQLHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请参考 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> 文档以获取更多详细信息。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_graphql_over_websocket\"><a class=\"anchor\" href=\"#_graphql_over_websocket\"></a>基于 WebSocket 的 GraphQL</h3>\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL 是兼容 <a href=\"https://github.com/enisdenjo/graphql-ws\">基于 Websocket 协议的 GraphQL</a> 的。</p>\n</div>\n<div class=\"paragraph\">\n<p>当您需要给您的 GraphQL schema 添加订阅时使用 websocket 进行通信非常有用，当然您也可以用其来进行查询和变更操作。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n默认情况下， 配置中并不包含一个默认的 <code>Origin</code> 属性。为了防御浏览器发送的 WebSocket\n跨域劫持攻击，我们建议您将 <code>Origin</code> 属性设置为您应用的\n网络源。这会强制服务器检查 WebSocket 的 <code>Origin</code> 以验证连接是否来自您的应用。这项检查非常重要，因为\n浏览器的同源策略并不限制 WebSocket 连接，因此一个攻击者可以轻松地从一个\n恶意网页连接您服务器上 GraphQL WS 处理器提供的 <code>ws://</code> 或 <code>wss://</code> 接口。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(GraphQLWSHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>客户端会要求支持 <code>graphql-transport-ws</code> websocket 子协议。\n因此，您需要在服务端的配置中将该协议加入到支持的子协议列表中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpServerOptions</span> <span class=\"hljs-variable\">httpServerOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerOptions</span>()\n  .addWebSocketSubProtocol(<span class=\"hljs-string\">&quot;graphql-transport-ws&quot;</span>);</code></pre>\n</div>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>为了让 HTTP 协议和 WebSocket 协议使用同一个 URI，您必须在 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> 之前将 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/ws/GraphQLWSHandler.html\">GraphQLWSHandler</a></code> 注册到 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code> 上：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>)\n  .handler(GraphQLWSHandler.create(graphQL))\n  .handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n一个 <code>DataFetcher</code> <em>订阅</em>  会返回一个 <code>org.reactivestreams.Publisher</code> 类型的实例。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_apollo_websocketlink\"><a class=\"anchor\" href=\"#_apollo_websocketlink\"></a>Apollo WebSocketLink</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <a href=\"https://www.apollographql.com/docs/link/links/ws/\">Apollo WebSocketLink</a> 连接 websocket。\n这对订阅 GraphQL schema 特别有帮助，但您亦可以使用 websocket 查询和变更。（译者注：GraphQL的三种操作类型的翻译及原文：查询 Query，变更 Mutation以及订阅 Subscription）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphQL</span> <span class=\"hljs-variable\">graphQL</span> <span class=\"hljs-operator\">=</span> setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(ApolloWSHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n想要支持 <code>graphql-ws</code> websocket 子协议，必需在服务器配置中添加：\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpServerOptions</span> <span class=\"hljs-variable\">httpServerOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerOptions</span>()\n  .addWebSocketSubProtocol(<span class=\"hljs-string\">&quot;graphql-ws&quot;</span>);\nvertx.createHttpServer(httpServerOptions)\n  .requestHandler(router)\n  .listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果要在同一路径中支持 WebSocketLink 和 HttpLink ，您可先添加 ApolloWSHandler ，然后再添加 GraphQLHandler 。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphQL</span> <span class=\"hljs-variable\">graphQL</span> <span class=\"hljs-operator\">=</span> setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(ApolloWSHandler.create(graphQL));\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可在此处找到配置 Apollo 订阅客户端（SubscriptionClient）的方法： <a href=\"https://github.com/apollographql/subscriptions-transport-ws\" class=\"bare\">https://github.com/apollographql/subscriptions-transport-ws</a></p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n一个 <code>DataFetcher</code> 订阅必需返回一个 <code>org.reactivestreams.Publisher</code> 实例。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_fetching_data\"><a class=\"anchor\" href=\"#_fetching_data\"></a>获取数据</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>GraphQL-Java API 非常适合异步环境：查询操作默认策略便是异步执行（对于变更，则是串行异步）。</p>\n</div>\n<div class=\"paragraph\">\n<p>为 <a href=\"https://vertx-china.github.io/docs/vertx-core/java/#golden_rule\">避免阻塞 eventloop</a> ，您需要做的是实现 <a href=\"https://www.graphql-java.com/documentation/v17/data-fetching/\">data fetchers</a> 并返回 <code>CompletionStage</code> ，而不是直接返回结果。（译者注： Data Fetcher 下文统一保留原文、不翻译）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DataFetcher&lt;CompletionStage&lt;List&lt;Link&gt;&gt;&gt; dataFetcher = environment -&gt; {\n\n  CompletableFuture&lt;List&lt;Link&gt;&gt; completableFuture = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CompletableFuture</span>&lt;&gt;();\n\n  retrieveLinksFromBackend(environment, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      completableFuture.complete(ar.result());\n    } <span class=\"hljs-keyword\">else</span> {\n      completableFuture.completeExceptionally(ar.cause());\n    }\n  });\n\n  <span class=\"hljs-keyword\">return</span> completableFuture;\n};\n\n<span class=\"hljs-type\">RuntimeWiring</span> <span class=\"hljs-variable\">runtimeWiring</span> <span class=\"hljs-operator\">=</span> RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">&quot;Query&quot;</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_callback_based_apis\"><a class=\"anchor\" href=\"#_working_with_callback_based_apis\"></a>使用基于回调的API</h3>\n<div class=\"paragraph\">\n<p>实现一个返回 <code>CompletionStage</code> 的 DataFetcher 并不复杂。\n但当您使用基于回调的 Vert.x API 时，需要一些八股文代码。</p>\n</div>\n<div class=\"paragraph\">\n<p>这时可以参考 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code> 获取帮助：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((env, promise) -&gt; {\n  retrieveLinksFromBackend(env, promise);\n});\n\n<span class=\"hljs-type\">RuntimeWiring</span> <span class=\"hljs-variable\">runtimeWiring</span> <span class=\"hljs-operator\">=</span> RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">&quot;Query&quot;</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_vert_x_futures\"><a class=\"anchor\" href=\"#_working_with_vert_x_futures\"></a>使用 Vert.x Future</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code> 对于使用 Future 化的 API 也有帮助：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create(environment -&gt; {\n  Future&lt;List&lt;Link&gt;&gt; future = retrieveLinksFromBackend(environment);\n  <span class=\"hljs-keyword\">return</span> future;\n});\n\n<span class=\"hljs-type\">RuntimeWiring</span> <span class=\"hljs-variable\">runtimeWiring</span> <span class=\"hljs-operator\">=</span> RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">&quot;Query&quot;</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_providing_data_fetchers_with_some_context\"><a class=\"anchor\" href=\"#_providing_data_fetchers_with_some_context\"></a>为数据获取器提供上下文</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> 通常是最后一个声明的处理器。\n例如，您可以通过身份验证保护您的应用程序。</p>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，您的 DataFetcher 可能需要知道哪个用户已登录，才能缩小结果范围。\n假设您的身份验证层在 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 中存储了一个 <code>User</code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code>DataFetchingEnvironment</code> 来获取这个 <code>User</code> 对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((environment, promise) -&gt; {\n\n  <span class=\"hljs-type\">RoutingContext</span> <span class=\"hljs-variable\">routingContext</span> <span class=\"hljs-operator\">=</span> GraphQLHandler.getRoutingContext(environment.getGraphQlContext());\n\n  <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> routingContext.get(<span class=\"hljs-string\">&quot;user&quot;</span>);\n\n  retrieveLinksPostedBy(user, promise);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nRoutingContext 可用于任何类型的 DataFetcher ，而不仅仅是 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code> 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_data_results\"><a class=\"anchor\" href=\"#_json_data_results\"></a>JSON 类型数据结果</h3>\n<div class=\"paragraph\">\n<p>默认的GraphQL DataFetcher 是 <code>PropertyDataFetcher</code> 。\n因此，它无需进一步配置即可读取域对象的字段。</p>\n</div>\n<div class=\"paragraph\">\n<p>不过，某些 Vert.x 数据客户端会返回 <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> 类型的结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您不需要（或不想）使用域对象层，则可以将 GraphQL-Java 配置改为使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RuntimeWiring.<span class=\"hljs-type\">Builder</span> <span class=\"hljs-variable\">builder</span> <span class=\"hljs-operator\">=</span> RuntimeWiring.newRuntimeWiring();\n\nbuilder.wiringFactory(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WiringFactory</span>() {\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> DataFetcher&lt;Object&gt; <span class=\"hljs-title function_\">getDefaultDataFetcher</span><span class=\"hljs-params\">(FieldWiringEnvironment environment)</span> {\n\n    <span class=\"hljs-keyword\">return</span> VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName());\n\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> 包装了一个 <code>PropertyDataFetcher</code> ，因此您也可以通过它使用域对象。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batch_loading\"><a class=\"anchor\" href=\"#_batch_loading\"></a>批量加载</h3>\n<div class=\"paragraph\">\n<p>DataLoader 可以批量化请求并缓存结果，助您高效地加载数据。（译者注：与 DataFetcher 对应，DataLoader保留原文不翻译）</p>\n</div>\n<div class=\"paragraph\">\n<p>首先，创建一个批量加载器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">BatchLoaderWithContext&lt;String, Link&gt; linksBatchLoader = (ids, env) -&gt; {\n  <span class=\"hljs-comment\">// retrieveLinksFromBackend takes a list of ids and returns a CompletionStage for a list of links</span>\n  <span class=\"hljs-keyword\">return</span> retrieveLinksFromBackend(ids, env);\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后，配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> ，为每个请求创建一个 <code>DataLoaderRegistry</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphQLHandler</span> <span class=\"hljs-variable\">handler</span> <span class=\"hljs-operator\">=</span> GraphQLHandler.create(graphQL).beforeExecute(builderWithContext -&gt; {\n\n  DataLoader&lt;String, Link&gt; linkDataLoader = DataLoaderFactory.newDataLoader(linksBatchLoader);\n\n  <span class=\"hljs-type\">DataLoaderRegistry</span> <span class=\"hljs-variable\">dataLoaderRegistry</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DataLoaderRegistry</span>().register(<span class=\"hljs-string\">&quot;link&quot;</span>, linkDataLoader);\n\n  builderWithContext.builder().dataLoaderRegistry(dataLoaderRegistry);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用了 Vert.x 的 API，那么您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/dataloader/VertxBatchLoader.html\">VertxBatchLoader</a></code> 或 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/dataloader/VertxMappedBatchLoader.html\">VertxMappedBatchLoader</a></code> 来简化代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">BatchLoaderWithContext&lt;Long, String&gt; commentsBatchLoader = VertxBatchLoader.create((ids, env) -&gt; {\n  <span class=\"hljs-comment\">// findComments takes a list of ids and returns a Future for a list of links</span>\n  <span class=\"hljs-keyword\">return</span> findComments(ids, env);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_file_uploads\"><a class=\"anchor\" href=\"#_file_uploads\"></a>文件上传</h3>\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/jaydenseric/graphql-multipart-request-spec\">GraphQL multipart 请求</a> 是用于 <code>GraphQL</code> 请求的可互操作表单结构。\n通过启用此功能，GraphQL 客户端将能够使用单个变更（Mutation）调用来上传文件。\n所有服务器端文件处理逻辑都抽象到了 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>启用该功能需要创建一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> ，并将 requestMultipartEnabled 配置设置为true，然后添加 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 到路由。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GraphQLHandler</span> <span class=\"hljs-variable\">graphQLHandler</span> <span class=\"hljs-operator\">=</span> GraphQLHandler.create(\n  setupGraphQLJava(),\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GraphQLHandlerOptions</span>().setRequestMultipartEnabled(<span class=\"hljs-literal\">true</span>)\n);\n\n<span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\nrouter.route().handler(BodyHandler.create());\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(graphQLHandler);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n如果路由没有 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> ，则 multipart 请求解析器无法处理 GraphQL 的变更请求。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>最后，创建 <code>Upload</code> scalar 并设置到 <code>RuntimeWiring</code> 中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">RuntimeWiring</span> <span class=\"hljs-variable\">runtimeWiring</span> <span class=\"hljs-operator\">=</span> RuntimeWiring.newRuntimeWiring().scalar(UploadScalar.build()).build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>FileUpload</code> 实例可以通过 <code>DataFetchingEnvironment::getArgument</code> 方法获取。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">FileUpload</span> <span class=\"hljs-variable\">file</span> <span class=\"hljs-operator\">=</span> environment.getArgument(<span class=\"hljs-string\">&quot;myFile&quot;</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_3_api\"><a class=\"anchor\" href=\"#_rxjava_3_api\"></a>RxJava 3 API</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_setting_up_with_an_rxified_router\"><a class=\"anchor\" href=\"#_setting_up_with_an_rxified_router\"></a>配置 Rxified 路由</h3>\n<div class=\"paragraph\">\n<p>若需要在 Rxified <code><a href=\"../../apidocs/io/vertx/rxjava3/ext/web/Route.html\">路由</a></code> 中处理 GraphQL 请求，则请确保已导入了 <code><a href=\"../../apidocs/io/vertx/rxjava3/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> 类。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_vert_x_rxified_apis\"><a class=\"anchor\" href=\"#_working_with_vert_x_rxified_apis\"></a>使用 Vert.x 的 Rxified API</h3>\n<div class=\"paragraph\">\n<p>GraphQL-Java 期望 DataFetcher 和批量加载器使用 <code>CompletionStage</code> 提供异步结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>但是若您使用 Vert.x Rxified API （如 <a href=\"https://vertx.io/docs/vertx-web-client/java/#_rxjava_3_api\">Web 客户端</a> 或 <a href=\"https://vertx.io/docs/vertx-cassandra-client/java/#_rxjava_3_api\">Cassandra 客户端</a>），则需要适配 <code>Single</code> 和 <code>Maybe</code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>RxJavaJdk8Interop</code> 库提供了这些适配工具。\n您可以在 Maven 构建配置文件的 <em>dependencies</em> 部分中增加以下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.github.akarnokd<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>rxjava3-jdk8-interop<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.0.0-RC6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 Gradle，则增加以下依赖配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">implementation <span class=\"hljs-string\">&#x27;com.github.akarnokd:rxjava3-jdk8-interop:3.0.0-RC6&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后可以从 <code>Single</code> 结果中创建 DataFetcher ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; data = loadDataFromBackend();\nDataFetcher&lt;CompletionStage&lt;String&gt;&gt; fetcher = environment -&gt; {\n <span class=\"hljs-keyword\">return</span> data.to(SingleInterop.get());\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同样，可以使用 <code>MaybeInterop</code> 处理 <code>Maybe</code> 结果。</p>\n</div>\n</div>\n</div>\n</div>","version":"4.2.3"},"__N_SSG":true}