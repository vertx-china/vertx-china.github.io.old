{"pageProps":{"slug":"vertx-http-proxy/java","title":"Vert.x Http Proxy","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_http_proxy\">使用 Vert.x Http Proxy</a></li>\n<li><a href=\"#_reverse_proxy_server\">Reverse proxy server</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_websockets\">WebSockets</a></li>\n<li><a href=\"#_proxy_caching\">代理缓存</a></li>\n<li><a href=\"#_proxy_interception\">Proxy interception</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Http Proxy</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Http Proxy 是一个基于 Vert.x 的反向代理服务器，其目的是实现可重用的反向代理逻辑，\n这样，使用者就可以关注更高层面的问题了</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n这个模块处于 <em>Tech Preview</em> 阶段，这意味着在不同版本之间 API 可能会不太一样\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_http_proxy\"><a class=\"anchor\" href=\"#_using_vert_x_http_proxy\"></a>使用 Vert.x Http Proxy</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用 Vert.x Http Proxy 之前，请把以下的依赖放到您的构建描述文件的 <em>依赖</em> 部分中</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-http-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-http-proxy:4.2.5&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reverse_proxy_server\"><a class=\"anchor\" href=\"#_reverse_proxy_server\"></a>Reverse proxy server</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了使用 Vert.x Http Proxy 实现一个反向代理，您需要了解这些名词：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><strong>Proxy Server</strong> that handles user-agent requests and forward them to the <strong>origin server</strong></p>\n</li>\n<li>\n<p><strong>Origin Server</strong> that handles requests from the <strong>proxy server</strong> and respond accordingly</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>You can create a <strong>proxy server</strong> that listens to port <code>8080</code> and implement reverse proxy logic</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient proxyClient = vertx.createHttpClient();\n\nHttpProxy proxy = HttpProxy.reverseProxy(proxyClient);\nproxy.origin(<span class=\"hljs-number\">7070</span>, <span class=\"hljs-string\">&quot;origin&quot;</span>);\n\nHttpServer proxyServer = vertx.createHttpServer();\n\nproxyServer.requestHandler(proxy).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>All user-agent requests are forwarded to the <strong>origin server</strong> conveniently.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websockets\"><a class=\"anchor\" href=\"#_websockets\"></a>WebSockets</h3>\n<div class=\"paragraph\">\n<p>该 HTTP 代理默认支持 WebSocket 协议。</p>\n</div>\n<div class=\"paragraph\">\n<p>WebSocket 的握手请求会被转发到源服务器 (包含 <code>connection</code> 头部) ，并且用户端\n和源服务器间会发生握手。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyOptions.html#setSupportWebSocket-boolean-\">setSupportWebSocket</a></code> 方法来设置其是否支持 WebSocket 协议。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_proxy_caching\"><a class=\"anchor\" href=\"#_proxy_caching\"></a>代理缓存</h3>\n<div class=\"paragraph\">\n<p>大部分情况下，代理不会缓存响应内容，并且会忽视大部分的缓存指令，您也可以使用缓存选项来开启缓存。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpProxy proxy = HttpProxy.reverseProxy(<span class=\"hljs-keyword\">new</span> ProxyOptions().setCacheOptions(<span class=\"hljs-keyword\">new</span> CacheOptions()), proxyClient);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_proxy_interception\"><a class=\"anchor\" href=\"#_proxy_interception\"></a>Proxy interception</h3>\n<div class=\"paragraph\">\n<p>Interception is a powerful way to extend the proxy withg new features.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can implement <code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyInterceptor.html#handleProxyRequest-io.vertx.httpproxy.ProxyContext-\">handleProxyRequest</a></code> to perform any operation on the proxy request</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> ProxyInterceptor() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;ProxyResponse&gt; <span class=\"hljs-title\">handleProxyRequest</span><span class=\"hljs-params\">(ProxyContext context)</span> </span>{\n    ProxyRequest proxyRequest = context.request();\n\n    filter(proxyRequest.headers());\n\n    <span class=\"hljs-comment\">// Continue the interception chain</span>\n    <span class=\"hljs-keyword\">return</span> context.sendRequest();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Likewise with the proxy response</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> ProxyInterceptor() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;Void&gt; <span class=\"hljs-title\">handleProxyResponse</span><span class=\"hljs-params\">(ProxyContext context)</span> </span>{\n    ProxyResponse proxyResponse = context.response();\n\n    filter(proxyResponse.headers());\n\n    <span class=\"hljs-comment\">// Continue the interception chain</span>\n    <span class=\"hljs-keyword\">return</span> context.sendResponse();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_body_filtering\"><a class=\"anchor\" href=\"#_body_filtering\"></a>Body filtering</h4>\n<div class=\"paragraph\">\n<p>You can filter body by simply replacing the original <code><a href=\"../../apidocs/io/vertx/httpproxy/Body.html\">Body</a></code> with a new one</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> ProxyInterceptor() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;Void&gt; <span class=\"hljs-title\">handleProxyResponse</span><span class=\"hljs-params\">(ProxyContext context)</span> </span>{\n    ProxyResponse proxyResponse = context.response();\n\n    <span class=\"hljs-comment\">// Create a filtered body</span>\n    Body filteredBody = filter(proxyResponse.getBody());\n\n    <span class=\"hljs-comment\">// And then let the response use it</span>\n    proxyResponse.setBody(filteredBody);\n\n    <span class=\"hljs-comment\">// Continue the interception chain</span>\n    <span class=\"hljs-keyword\">return</span> context.sendResponse();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_interception_control\"><a class=\"anchor\" href=\"#_interception_control\"></a>Interception control</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyContext.html#sendRequest--\">sendRequest</a></code> and <code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyContext.html#sendResponse--\">sendResponse</a></code> continue the\ncurrent interception chain and then send the result to the origin server or the user-agent.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can change the control, e.g you can send a response immediately to the user-agent without even requesting the origin server</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> ProxyInterceptor() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;ProxyResponse&gt; <span class=\"hljs-title\">handleProxyRequest</span><span class=\"hljs-params\">(ProxyContext context)</span> </span>{\n\n    ProxyRequest proxyRequest = context.request();\n\n    <span class=\"hljs-comment\">// Release the underlying resources</span>\n    proxyRequest.release();\n\n    <span class=\"hljs-comment\">// Create a response and populate it</span>\n    ProxyResponse proxyResponse = proxyRequest.response()\n      .setStatusCode(<span class=\"hljs-number\">200</span>)\n      .putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;text/plain&quot;</span>)\n      .setBody(Body.body(Buffer.buffer(<span class=\"hljs-string\">&quot;Hello World&quot;</span>)));\n\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(proxyResponse);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}