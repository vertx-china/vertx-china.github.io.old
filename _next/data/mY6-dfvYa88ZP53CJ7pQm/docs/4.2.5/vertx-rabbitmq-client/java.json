{"pageProps":{"slug":"4.2.5/vertx-rabbitmq-client/java","title":"RabbitMQ Client for Vert.x","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">入门</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_maven\">Maven</a></li>\n<li><a href=\"#_gradle\">Gradle</a></li>\n<li><a href=\"#_creating_a_client\">创建客户端</a></li>\n<li><a href=\"#_recovery_and_reconnections\">恢复连接和重新连接</a></li>\n<li><a href=\"#_declare_exchange_with_additional_config\">声明交换机并携带额外配置</a></li>\n<li><a href=\"#_declare_queue_with_additional_config\">声明队列并携带额外配置</a></li>\n</ul>\n</li>\n<li><a href=\"#_operations\">各种操作</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_publish\">发布消息</a></li>\n<li><a href=\"#_publish_with_confirm\">发布消息并进行确认</a></li>\n<li><a href=\"#_reliable_message_publishing\">可靠的消息发布</a></li>\n<li><a href=\"#_consume\">消费消息</a></li>\n<li><a href=\"#_get\">获取消息</a></li>\n<li><a href=\"#_consume_messages_without_auto_ack\">手动确认消费的消息</a></li>\n</ul>\n</li>\n<li><a href=\"#_running_the_tests\">运行测试</a></li>\n</ul>\n</div>","contents":"<h1>RabbitMQ Client for Vert.x</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您的 Vert.x 应用可使用 Vert.x RabbitMQ Client（以下简称客户端）与 RabbitMQ 服务实例（基于 AMQP 0.9.1 版协议）互动</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>此服务是实验性的，API可能会在解决之前发生变化。</strong></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>入门</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_maven\"><a class=\"anchor\" href=\"#_maven\"></a>Maven</h3>\n<div class=\"paragraph\">\n<p>在您的 maven 项目中，需要添加下列依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-rabbitmq-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_gradle\"><a class=\"anchor\" href=\"#_gradle\"></a>Gradle</h3>\n<div class=\"paragraph\">\n<p>在您的 gradle 项目中，需要添加下列依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-rabbitmq-client:4.2.5&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_client\"><a class=\"anchor\" href=\"#_creating_a_client\"></a>创建客户端</h3>\n<div class=\"paragraph\">\n<p>您还可以像下面这样，使用完整的 amqp uri 来创建一个客户端实例： （译者注：amqp uri的使用规范可参考官网 <a href=\"https://www.rabbitmq.com/uri-spec.html\" class=\"bare\">https://www.rabbitmq.com/uri-spec.html</a> ）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions config = <span class=\"hljs-keyword\">new</span> RabbitMQOptions();\n<span class=\"hljs-comment\">// full amqp uri</span>\nconfig.setUri(<span class=\"hljs-string\">&quot;amqp://xvjvsrrc:VbuL1atClKt7zVNQha0bnnScbNvGiqgb@moose.rmq.cloudamqp.com/xvjvsrrc&quot;</span>);\nRabbitMQClient client = RabbitMQClient.create(vertx, config);\n\n<span class=\"hljs-comment\">// Connect</span>\nclient.start(asyncResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (asyncResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ successfully connected!&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Fail to connect to RabbitMQ &quot;</span> + asyncResult.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者您也可以手动指定一些特定的参数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions config = <span class=\"hljs-keyword\">new</span> RabbitMQOptions();\n<span class=\"hljs-comment\">// 每个参数都是可选的</span>\n<span class=\"hljs-comment\">// 如果参数没有被设置，将会使用默认的参数值</span>\nconfig.setUser(<span class=\"hljs-string\">&quot;user1&quot;</span>);\nconfig.setPassword(<span class=\"hljs-string\">&quot;password1&quot;</span>);\nconfig.setHost(<span class=\"hljs-string\">&quot;localhost&quot;</span>);\nconfig.setPort(<span class=\"hljs-number\">5672</span>);\nconfig.setVirtualHost(<span class=\"hljs-string\">&quot;vhost1&quot;</span>);\nconfig.setConnectionTimeout(<span class=\"hljs-number\">6000</span>); <span class=\"hljs-comment\">// in milliseconds</span>\nconfig.setRequestedHeartbeat(<span class=\"hljs-number\">60</span>); <span class=\"hljs-comment\">// in seconds</span>\nconfig.setHandshakeTimeout(<span class=\"hljs-number\">6000</span>); <span class=\"hljs-comment\">// in milliseconds</span>\nconfig.setRequestedChannelMax(<span class=\"hljs-number\">5</span>);\nconfig.setNetworkRecoveryInterval(<span class=\"hljs-number\">500</span>); <span class=\"hljs-comment\">// in milliseconds</span>\nconfig.setAutomaticRecoveryEnabled(<span class=\"hljs-keyword\">true</span>);\n\nRabbitMQClient client = RabbitMQClient.create(vertx, config);\n\n<span class=\"hljs-comment\">// Connect</span>\nclient.start(asyncResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (asyncResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ successfully connected!&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Fail to connect to RabbitMQ &quot;</span> + asyncResult.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以设置多个地址以连接到集群；</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions config = <span class=\"hljs-keyword\">new</span> RabbitMQOptions();\nconfig.setUser(<span class=\"hljs-string\">&quot;user1&quot;</span>);\nconfig.setPassword(<span class=\"hljs-string\">&quot;password1&quot;</span>);\nconfig.setVirtualHost(<span class=\"hljs-string\">&quot;vhost1&quot;</span>);\n\nconfig.setAddresses(Arrays.asList(Address.parseAddresses(<span class=\"hljs-string\">&quot;firstHost,secondHost:5672&quot;</span>)));\n\nRabbitMQClient client = RabbitMQClient.create(vertx, config);\n\n<span class=\"hljs-comment\">// Connect</span>\nclient.start(asyncResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (asyncResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ successfully connected!&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Fail to connect to RabbitMQ &quot;</span> + asyncResult.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_recovery_and_reconnections\"><a class=\"anchor\" href=\"#_recovery_and_reconnections\"></a>恢复连接和重新连接</h3>\n<div class=\"paragraph\">\n<p>在 RabbitMQClient 中，存在两种单独且互不兼容的机制来处理重新连接：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Java RabbitMQ 客户端程序库提供的自动恢复连接机制;</p>\n</li>\n<li>\n<p>重新启动 RabbitMQClient.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下均未启用任何一种机制。</p>\n</div>\n<div class=\"paragraph\">\n<p>Java RabbitMQ 客户端库提供的重新连接机制并非会在所有情况下都生效（如果和服务端的连接很好的断连，客户端将会关闭并且不会再恢复连接）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[source, java]\n为了使用 Java RabbitMQ 客户端程序库的自动恢复连接功能，您必须启用它并且同时禁用 `RabbitMQClient` 程序库的重连尝试功能：\nRabbitMQOptions options = new RabbitMQOptions();\noptions.setAutomaticRecoveryEnabled(true);\noptions.setReconnectAttempts(0);</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端程序库同样会如其文档所述，尽可能的尝试拓扑恢复（该功能在客户端程序库里面是默认启用的，并且在 <code>RabbitMQClientOptions</code> 中没有公开）</p>\n</div>\n<div class=\"paragraph\">\n<p>或者 <code>RabbitMQClient</code> 可以配置为，每当存在连接问题就重连 <code>RabbitMQ</code> 服务端。\n这种连接失败可能是由于一个短时间的网络异常（客户端可能会连接回相同的 <code>RabbitMQ</code> 服务端），也可能是因为故障转移方案引起。\n这种方法比客户端程序库采用的方法更直接 —— 当客户端程序库报告了一个问题，不断尝试从头开始重连时， <code>RabbitMQClient</code> 会通过关闭连接重启。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过在配置中设置 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html#setReconnectInterval-long-\">setReconnectInterval</a></code>\n以及 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html#setReconnectAttempts-int-\">setReconnectAttempts</a></code> 属性来配置重连策略。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions options = <span class=\"hljs-keyword\">new</span> RabbitMQOptions();\noptions.setAutomaticRecoveryEnabled(<span class=\"hljs-keyword\">false</span>);\noptions.setReconnectAttempts(Integer.MAX_VALUE);\noptions.setReconnectInterval(<span class=\"hljs-number\">500</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>RabbitMQClient</code> 重连不具有任何形式的拓扑恢复功能。\n当服务端的拓扑结构准备好之前（换句话说，即在创建/绑定交换机和队列之前）发送信息，可能会导致竞争状况。\n为了在连接准备就绪之前提供创建这些对象的机会， <code>RabbitMQClient</code> 提供了 <code>ConnectionEstablishedCallback</code> 方法。\n<code>ConnectionEstablishedCallback</code> 方法可用于在其他使用者（包括 <code>RabbitMQConsumer</code> 和 <code>RabbitMQPublisher</code> ）访问 `RabbitMQClient`前，执行任意操作。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQClient client = RabbitMQClient.create(vertx, config);\nclient.addConnectionEstablishedCallback(promise -&gt; {\n            client.exchangeDeclare(<span class=\"hljs-string\">&quot;exchange&quot;</span>, <span class=\"hljs-string\">&quot;fanout&quot;</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">false</span>)\n                .compose(v -&gt; {\n                  <span class=\"hljs-keyword\">return</span> client.queueDeclare(<span class=\"hljs-string\">&quot;queue&quot;</span>, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>);\n                })\n                .compose(declareOk -&gt; {\n                  <span class=\"hljs-keyword\">return</span> client.queueBind(declareOk.getQueue(), <span class=\"hljs-string\">&quot;exchange&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>);\n                })\n                .onComplete(promise);\n});\n\n<span class=\"hljs-comment\">// At this point the exchange, queue and binding will have been declared even if the client connects to a new server</span>\nclient.basicConsumer(<span class=\"hljs-string\">&quot;queue&quot;</span>, rabbitMQConsumerAsyncResult -&gt; {\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果 <code>RabbitMQConsumer</code> 在一个自动删除且服务端命名的队列上监听消息时，服务端重启了，那么直到客户端重连的时候，该队列将被移除。\n在这种情况下，需要在 <code>RabbitMQConsumer</code> 上重新创建队列并且设置新队列的名称。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQClient client = RabbitMQClient.create(vertx, config);\nAtomicReference&lt;RabbitMQConsumer&gt; consumer = <span class=\"hljs-keyword\">new</span> AtomicReference&lt;&gt;();\nAtomicReference&lt;String&gt; queueName = <span class=\"hljs-keyword\">new</span> AtomicReference&lt;&gt;();\nclient.addConnectionEstablishedCallback(promise -&gt; {\n      client.exchangeDeclare(<span class=\"hljs-string\">&quot;exchange&quot;</span>, <span class=\"hljs-string\">&quot;fanout&quot;</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">false</span>)\n              .compose(v -&gt; client.queueDeclare(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>))\n              .compose(dok -&gt; {\n                  queueName.set(dok.getQueue());\n                  <span class=\"hljs-comment\">// The first time this runs there will be no existing consumer</span>\n                  <span class=\"hljs-comment\">// on subsequent connections the consumer needs to be update with the new queue name</span>\n                  RabbitMQConsumer currentConsumer = consumer.get();\n                  <span class=\"hljs-keyword\">if</span> (currentConsumer != <span class=\"hljs-keyword\">null</span>) {\n                    currentConsumer.setQueueName(queueName.get());\n                  }\n                  <span class=\"hljs-keyword\">return</span> client.queueBind(queueName.get(), <span class=\"hljs-string\">&quot;exchange&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>);\n              })\n              .onComplete(promise);\n});\n\nclient.start()\n        .onSuccess(v -&gt; {\n            <span class=\"hljs-comment\">// At this point the exchange, queue and binding will have been declared even if the client connects to a new server</span>\n            client.basicConsumer(queueName.get(), rabbitMQConsumerAsyncResult -&gt; {\n                <span class=\"hljs-keyword\">if</span> (rabbitMQConsumerAsyncResult.succeeded()) {\n                    consumer.set(rabbitMQConsumerAsyncResult.result());\n                }\n            });\n        })\n        .onFailure(ex -&gt; {\n            System.out.println(<span class=\"hljs-string\">&quot;It went wrong: &quot;</span> + ex.getMessage());\n        });</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_enabling_ssl_tls_on_the_cilent\"><a class=\"anchor\" href=\"#_enabling_ssl_tls_on_the_cilent\"></a>客户端启用SSL/TLS</h4>\n<div class=\"paragraph\">\n<p>您可以很轻松配置 <code>RabbitMQClient</code> 来使用 <code>SSL</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions options = <span class=\"hljs-keyword\">new</span> RabbitMQOptions()\n .setSsl(<span class=\"hljs-keyword\">true</span>);</code></pre>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_client_trust_configuration\"><a class=\"anchor\" href=\"#_client_trust_configuration\"></a>客户端证书认证配置</h5>\n<div class=\"paragraph\">\n<p>如果您将 <code><a href=\"../../apidocs/io/vertx/core/net/ClientOptionsBase.html#setTrustAll-boolean-\">trustAll</a></code> 设置为 <code>true</code> ，那么客户端将信任所有服务端的证书。\n虽然连接仍然会被加密，但是很容易受到 '中间人' 的攻击。\n<strong>后果不堪设想</strong>, 不要在生产环境中使用该选项! 该配置的默认值是 <code>false</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions options = <span class=\"hljs-keyword\">new</span> RabbitMQOptions()\n .setSsl(<span class=\"hljs-keyword\">true</span>)\n .setTrustAll(<span class=\"hljs-keyword\">true</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您将 <code><a href=\"../../apidocs/io/vertx/core/net/ClientOptionsBase.html#setTrustAll-boolean-\">trustAll</a></code> 设置为 <code>false</code> ，客户端将进行妥当的服务端验证。这里有三个主要的可选策略。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果您默认的 <code>truststore</code> 已经信任了服务端，那么在这种情况下一切都没问题<br></p>\n</li>\n<li>\n<p>启动java进程的时候，携带 -Djavax.net.ssl.trustStore=xxx.jks ，自定义客户端信任证书仓库<br></p>\n</li>\n<li>\n<p>通过 <code>RabbitMQOptions</code> 给客户端提供一个自定义的客户端信任证书仓库。</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_jks_trust_store_option\"><a class=\"anchor\" href=\"#_jks_trust_store_option\"></a>配置JKS格式证书信任仓库</h5>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions options = <span class=\"hljs-keyword\">new</span> RabbitMQOptions()\n .setSsl(<span class=\"hljs-keyword\">true</span>)\n .setTrustOptions(<span class=\"hljs-keyword\">new</span> JksOptions()\n   .setPath(<span class=\"hljs-string\">&quot;/path/myKeyStore.jks&quot;</span>)\n   .setPassword(<span class=\"hljs-string\">&quot;myKeyStorePassword&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_p12_pfx_trust_store_option\"><a class=\"anchor\" href=\"#_p12_pfx_trust_store_option\"></a>配置p12/pfx格式证书信任仓库</h5>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions options = <span class=\"hljs-keyword\">new</span> RabbitMQOptions()\n .setSsl(<span class=\"hljs-keyword\">true</span>)\n .setPfxTrustOptions(\n   <span class=\"hljs-keyword\">new</span> PfxOptions().\n     setPath(<span class=\"hljs-string\">&quot;/path/myKeyStore.p12&quot;</span>).\n     setPassword(<span class=\"hljs-string\">&quot;myKeyStorePassword&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_pem_trust_option\"><a class=\"anchor\" href=\"#_pem_trust_option\"></a>配置PEM格式证书</h5>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQOptions options = <span class=\"hljs-keyword\">new</span> RabbitMQOptions()\n .setSsl(<span class=\"hljs-keyword\">true</span>)\n .setPemTrustOptions(\n   <span class=\"hljs-keyword\">new</span> PemTrustOptions().\n     addCertPath(<span class=\"hljs-string\">&quot;/path/ca-cert.pem&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_declare_exchange_with_additional_config\"><a class=\"anchor\" href=\"#_declare_exchange_with_additional_config\"></a>声明交换机并携带额外配置</h3>\n<div class=\"paragraph\">\n<p>您可以向 <code>RabbitMQ</code> 的 <code>exchangeDeclare</code> 方法传入额外的配置参数。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject config = <span class=\"hljs-keyword\">new</span> JsonObject();\n\nconfig.put(<span class=\"hljs-string\">&quot;x-dead-letter-exchange&quot;</span>, <span class=\"hljs-string\">&quot;my.deadletter.exchange&quot;</span>);\nconfig.put(<span class=\"hljs-string\">&quot;alternate-exchange&quot;</span>, <span class=\"hljs-string\">&quot;my.alternate.exchange&quot;</span>);\n<span class=\"hljs-comment\">// ...</span>\nclient.exchangeDeclare(<span class=\"hljs-string\">&quot;my.exchange&quot;</span>, <span class=\"hljs-string\">&quot;fanout&quot;</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">false</span>, config, onResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (onResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Exchange successfully declared with config&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    onResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_declare_queue_with_additional_config\"><a class=\"anchor\" href=\"#_declare_queue_with_additional_config\"></a>声明队列并携带额外配置</h3>\n<div class=\"paragraph\">\n<p>您可以向 <code>RabbitMQ</code> 的 <code>queueDeclare</code> 方法传入额外的配置参数。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject config = <span class=\"hljs-keyword\">new</span> JsonObject();\nconfig.put(<span class=\"hljs-string\">&quot;x-message-ttl&quot;</span>, <span class=\"hljs-number\">10_000L</span>);\n\nclient.queueDeclare(<span class=\"hljs-string\">&quot;my-queue&quot;</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>, config, queueResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (queueResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Queue declared!&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">&quot;Queue failed to be declared!&quot;</span>);\n    queueResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_operations\"><a class=\"anchor\" href=\"#_operations\"></a>各种操作</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>下面是一些 <code>RabbitMQService API</code> 支持的操作示例。\n关于所有 <code>API</code> 方法的详细信息，请参阅 <code>API</code> 文档。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_publish\"><a class=\"anchor\" href=\"#_publish\"></a>发布消息</h3>\n<div class=\"paragraph\">\n<p>将消息发布到队列</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer message = Buffer.buffer(<span class=\"hljs-string\">&quot;body&quot;</span>, <span class=\"hljs-string\">&quot;Hello RabbitMQ, from Vert.x !&quot;</span>);\nclient.basicPublish(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;my.queue&quot;</span>, message, pubResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (pubResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Message published !&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    pubResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_publish_with_confirm\"><a class=\"anchor\" href=\"#_publish_with_confirm\"></a>发布消息并进行确认</h3>\n<div class=\"paragraph\">\n<p>将消息发布到队列，并确认服务端已收到消息。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer message = Buffer.buffer(<span class=\"hljs-string\">&quot;body&quot;</span>, <span class=\"hljs-string\">&quot;Hello RabbitMQ, from Vert.x !&quot;</span>);\n\n<span class=\"hljs-comment\">// Put the channel in confirm mode. This can be done once at init.</span>\nclient.confirmSelect(confirmResult -&gt; {\n  <span class=\"hljs-keyword\">if</span>(confirmResult.succeeded()) {\n    client.basicPublish(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;my.queue&quot;</span>, message, pubResult -&gt; {\n      <span class=\"hljs-keyword\">if</span> (pubResult.succeeded()) {\n        <span class=\"hljs-comment\">// Check the message got confirmed by the broker.</span>\n        client.waitForConfirms(waitResult -&gt; {\n          <span class=\"hljs-keyword\">if</span>(waitResult.succeeded())\n            System.out.println(<span class=\"hljs-string\">&quot;Message published !&quot;</span>);\n          <span class=\"hljs-keyword\">else</span>\n            waitResult.cause().printStackTrace();\n        });\n      } <span class=\"hljs-keyword\">else</span> {\n        pubResult.cause().printStackTrace();\n      }\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    confirmResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_reliable_message_publishing\"><a class=\"anchor\" href=\"#_reliable_message_publishing\"></a>可靠的消息发布</h3>\n<div class=\"paragraph\">\n<p>为了可靠的将消息发布到 <code>RabbitMQ</code>，有必要去确认每条消息是否都已被服务端接受。\n最简单的确认方法是使用上面的 <code>basicPublishWithConfirm</code> 方法，该方法是在发送每条消息的时候，同步进行确认操作 —— 阻塞发布通道，直到确认消息已被接受。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>RabbitMQ</code> 为了达成更大的吞吐量，提供了异步的确认方法。\n异步确认方法可以一次性确认多条消息，因此客户端有必要按照发布的顺序，追踪所有的消息。\n此外，直到服务端确认消息前，可能有必要重新发送它们，因此这些消息必须被客户端继续保留。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>RabbitMQPublisher</code> 类实现了一个处理异步确认的标准方法，这避免了大量的样版代码。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>RabbitMQPublisher</code> 运作的方式如下：\n* 将所有需要发送的消息添加到一个内部的队列中。\n* 从队列发送消息时，追踪这些在单独队列中等待确认的消息。\n* 处理 <code>RabbitMQ</code> 异步确认结果时，一但消息被确认，就将这些消息从等待确认的队列中移除。\n* 每条被确认的消息都会通知调用者（一次通知一条消息，不同于 <code>RabbitMQ</code> 使用的批量消息确认机制）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RabbitMQPublisher publisher = RabbitMQPublisher.create(vertx, client, options);\n\nmessages.forEach((k,v) -&gt; {\n  com.rabbitmq.client.BasicProperties properties = <span class=\"hljs-keyword\">new</span> AMQP.BasicProperties.Builder()\n          .messageId(k)\n          .build();\n  publisher.publish(<span class=\"hljs-string\">&quot;exchange&quot;</span>, <span class=\"hljs-string\">&quot;routingKey&quot;</span>, properties, v.toBuffer());\n});\n\npublisher.getConfirmationStream().handler(conf -&gt; {\n  <span class=\"hljs-keyword\">if</span> (conf.isSucceeded()) {\n    messages.remove(conf.getMessageId());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>投递标签</p>\n</div>\n<div class=\"paragraph\">\n<p>对于任何想实现他们自己的 <code>RabbitMQPublisher</code> 的人来说，本节的实现细节会很有用。</p>\n</div>\n<div class=\"paragraph\">\n<p>要使 <code>RabbitMQPublisher</code> 工作，必须了解投递标签。<code>RabbitMQ</code> 会对每一条已发布的消息使用投递标签。\n<code>RabbitMQ</code> 的确认信息，可在完成 <code>basicPublish</code> 方法的调用前，就到达客户端。因此您在使用异步确认的时候，是不可能通过任何 <code>basicPublish</code> 返回的东西来识别投递标签。\n出于这个原因，<code>RabbitMQClient</code> 有必要通过单独的回调告诉 <code>RabbitMQPublisher</code> 每一条消息的投递标签。而这个回调发生在消息发送之前的 <code>RabbitMQClient::basicPublish</code> 调用过程中。\n另外，单个消息的投递标签也有可能会变化（投递标签使用的是单通道，因此如果一条消息在重新连接之后被重新发送，那么这条消息会有一条新的投递标签）—— 这意味着，我们无法用 <code>Future</code> 把投递标签通知给客户端。\n针对一条给定的消息，进行多次 <code>deliveryTagHandler</code> 方法调用时，忽略旧的投递标签是安全的 —— 因为无论什么时候，一条消息只存在一条有效的投递标签。</p>\n</div>\n<div class=\"paragraph\">\n<p>要想捕获投递标签，可使用下面 <code>RabbitMqClient::basicPublishWithDeliveryTag</code> 方法中的一个。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">basicPublishWithDeliveryTag</span><span class=\"hljs-params\">(String exchange, String routingKey, BasicProperties properties, Buffer body, Handler&lt;Long&gt; deliveryTagHandler, Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler)</span></span>;\n <span class=\"hljs-function\">Future&lt;Void&gt; <span class=\"hljs-title\">basicPublishWithDeliveryTag</span><span class=\"hljs-params\">(String exchange, String routingKey, BasicProperties properties, Buffer body, <span class=\"hljs-meta\">@Nullable</span> Handler&lt;Long&gt; deliveryTagHandler)</span></span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这是 <code>RabbitMqClient::basicPublishWithDeliveryTag</code> 的列表。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_consume\"><a class=\"anchor\" href=\"#_consume\"></a>消费消息</h3>\n<div class=\"paragraph\">\n<p>从队列中消费消息。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// 您可以从队列创建一个消息 stream</span>\nclient.basicConsumer(<span class=\"hljs-string\">&quot;my.queue&quot;</span>, rabbitMQConsumerAsyncResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (rabbitMQConsumerAsyncResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ consumer created !&quot;</span>);\n    RabbitMQConsumer mqConsumer = rabbitMQConsumerAsyncResult.result();\n    mqConsumer.handler(message -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Got message: &quot;</span> + message.body().toString());\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    rabbitMQConsumerAsyncResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>任何时候您都可以暂停、或者继续 <code>stream</code>。当 <code>stream</code> 暂停时，您将不会接收到任何消息。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">consumer.pause();\nconsumer.resume();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您要创建一个消费 <code>stream</code> 时，有一组选项可供选择。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>QueueOptions</code> 允许您进行定制化：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>可以用 <code>setMaxInternalQueueSize</code> 来设置内部队列的长度</p>\n</li>\n<li>\n<p>使用 <code>setKeepMostRecent</code> 可以设置 <code>stream</code> 是否保留更多的最近消息</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">QueueOptions options = <span class=\"hljs-keyword\">new</span> QueueOptions()\n  .setMaxInternalQueueSize(<span class=\"hljs-number\">1000</span>)\n  .setKeepMostRecent(<span class=\"hljs-keyword\">true</span>);\n\nclient.basicConsumer(<span class=\"hljs-string\">&quot;my.queue&quot;</span>, options, rabbitMQConsumerAsyncResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (rabbitMQConsumerAsyncResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ consumer created !&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    rabbitMQConsumerAsyncResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您想要停止从队列中消费消息，那么您可以参照下面的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">rabbitMQConsumer.cancel(cancelResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (cancelResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Consumption successfully stopped&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Tired in attempt to stop consumption&quot;</span>);\n    cancelResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当队列不再处理任何消息时，您会收到结束处理程序的通知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">rabbitMQConsumer.endHandler(v -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;It is the end of the stream&quot;</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以设置专门处理异常的 <code>handler</code>，在程序运行出错时用它收到通知。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">consumer.exceptionHandler(e -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;An exception occurred in the process of message handling&quot;</span>);\n  e.printStackTrace();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>最后，您可能想要查找消费者标签：（译者注：费者标签可以由客户端或者服务器来生成，用于消费者的身份识别。详见官方文档：http://rabbitmq.mr-ping.com/ClientDocumentation/java-api-guide.html）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String consumerTag = consumer.consumerTag();\nSystem.out.println(<span class=\"hljs-string\">&quot;Consumer tag is: &quot;</span> + consumerTag);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_get\"><a class=\"anchor\" href=\"#_get\"></a>获取消息</h3>\n<div class=\"paragraph\">\n<p>从队列中获取消息</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.basicGet(<span class=\"hljs-string\">&quot;my.queue&quot;</span>, <span class=\"hljs-keyword\">true</span>, getResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (getResult.succeeded()) {\n    RabbitMQMessage msg = getResult.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got message: &quot;</span> + msg.body());\n  } <span class=\"hljs-keyword\">else</span> {\n    getResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_consume_messages_without_auto_ack\"><a class=\"anchor\" href=\"#_consume_messages_without_auto_ack\"></a>手动确认消费的消息</h3>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.basicConsumer(<span class=\"hljs-string\">&quot;my.queue&quot;</span>, <span class=\"hljs-keyword\">new</span> QueueOptions().setAutoAck(<span class=\"hljs-keyword\">false</span>), consumeResult -&gt; {<span class=\"hljs-comment\">//（译者注：设置autoAck = false时，需要手动对投递到 `Consumer` 的消息进行确认）</span>\n  <span class=\"hljs-keyword\">if</span> (consumeResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ consumer created !&quot;</span>);\n    RabbitMQConsumer consumer = consumeResult.result();\n\n    <span class=\"hljs-comment\">// Set the handler which messages will be sent to</span>\n    consumer.handler(msg -&gt; {\n      JsonObject json = (JsonObject) msg.body();\n      System.out.println(<span class=\"hljs-string\">&quot;Got message: &quot;</span> + json.getString(<span class=\"hljs-string\">&quot;body&quot;</span>));\n      <span class=\"hljs-comment\">// ack</span>\n      client.basicAck(json.getLong(<span class=\"hljs-string\">&quot;deliveryTag&quot;</span>), <span class=\"hljs-keyword\">false</span>, asyncResult -&gt; {\n      });\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    consumeResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_the_tests\"><a class=\"anchor\" href=\"#_running_the_tests\"></a>运行测试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为此，您需要安装完 <code>RabbitMQ</code>，并且在本地使用默认端口运行它</p>\n</div>\n</div>\n</div>","version":"4.2.5"},"__N_SSG":true}