{"pageProps":{"slug":"4.1.6/vertx-rx/java","title":"Vert.x RxJava","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_vert_x_api_for_rxjava\">用于 RxJava 的 Vert.x API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_api_for_rxjava1\">在 RxJava1 中使用 Vert.x API</a></li>\n<li><a href=\"#_read_stream_support\">可读流支持</a></li>\n<li><a href=\"#_write_stream_support\">可写流支持</a></li>\n<li><a href=\"#_handler_support\">Handler 支持</a></li>\n<li><a href=\"#_async_result_support\">异步结果支持</a></li>\n<li><a href=\"#_scheduler_support\">调度器支持</a></li>\n<li><a href=\"#_json_unmarshalling\">JSON解码</a></li>\n<li><a href=\"#_deploying_a_verticle\">部署Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxified_api\">Rx化的 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_embedding_rxfified_vert.x\">嵌入Rx化的 Vert.x</a></li>\n<li><a href=\"#_as_a_verticle\">作为 Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_api_examples\">API 例子</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_eventBus_message_stream\">EventBus 消息流</a></li>\n<li><a href=\"#_timers\">定时器Timers</a></li>\n<li><a href=\"#_http_client_requests\">HTTP客户端请求</a></li>\n<li><a href=\"#_http_server_requests\">HTTP服务端请求</a></li>\n<li><a href=\"#_websocket_client\">WebSocket客户端</a></li>\n<li><a href=\"#_websocket_server\">WebSocket服务端</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x RxJava</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_vert_x_api_for_rxjava\"><a class=\"anchor\" href=\"#_vert_x_api_for_rxjava\"></a>用于 RxJava 的 Vert.x API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> 是 JVM 上一个流行的库，用于组合异步的、使用可观察序列的、基于事件的程序。\nVert.x 与 RxJava 集成起来很自然：\n它使得无论什么时候，只要我们能使用流和异步结果，就能使用 Observable。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_api_for_rxjava1\"><a class=\"anchor\" href=\"#_using_vert_x_api_for_rxjava1\"></a>在 RxJava1 中使用 Vert.x API</h3>\n<div class=\"paragraph\">\n<p>要在 RxJava1 中使用 Vert.x API，请将以下依赖项添加到构建描述符的 <em>dependencies</em> 部分中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code>）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-rx-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-rx-java:4.1.6&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>要使用 Vert.x 的 RxJava API，有两种方式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>通过原始的 Vert.x API 辅以 <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html\">RxHelper</a></code> 类，\n该辅助类提供了用于 Vert.x Core API 和 RxJava API 之间互相转化的静态方法。</p>\n</li>\n<li>\n<p>通过基于 Vert.x Core API 增强的 <em>Rx化的</em> Vert.x API。</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_read_stream_support\"><a class=\"anchor\" href=\"#_read_stream_support\"></a>可读流支持</h3>\n<div class=\"paragraph\">\n<p>RxJava 中 <code>Observable</code> 的概念和 Vert.x 中 <code>ReadStream</code> 类是一对完美的匹配：都提供了一个对象流。</p>\n</div>\n<div class=\"paragraph\">\n<p>静态方法 <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toObservable-io.vertx.core.streams.ReadStream-\">RxHelper.toObservable</a></code> 用于将\nVert.x 可读流转换为 <code>rx.Observable</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fileSystem = vertx.fileSystem();\nfileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = RxHelper.toObservable(file);\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>而 <em>Rx化的</em> Vert.x API 在 <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/ReadStream.html\">ReadStream</a></code> 类上提供了\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/ReadStream.html#toObservable--\">toObservable</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\nfs.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = file.toObservable();\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这样的 Observable 是所谓 <strong>hot</strong> Observable，即不管是否有订阅，它们都会产生通知。\n<code>ReadStream</code> 是否能自发地发射数据，这取决于它的具体实现：</p>\n</div>\n<div class=\"paragraph\">\n<p>当订阅动作发生时，适配器会调用 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-\">handler</a></code>\n来设置它的 handler 。</p>\n</div>\n<div class=\"paragraph\">\n<p>某些 <code>ReadStream</code> 实现会在这个调用之后开始发射事件，而其他的则与\nhandler 是否设置无关：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>AsyncFile</code> 在 handler 设置后开始产生 buffer 事件</p>\n</li>\n<li>\n<p><code>HttpServerRequest</code> 则不依赖于此（即 如果 handler 未设置，buffer 可能会丢失）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在上述所有情形中，订阅 <code>Observable</code> 都是安全的。原因在于不管 event loop 还是 worker\nverticle 都不会被并发执行，所以订阅一定是在 handler\n开始发射数据之前发生。</p>\n</div>\n<div class=\"paragraph\">\n<p>当你想延迟订阅时，需要先 <code>暂停（pause）</code> <code>ReadStream</code> ，并在之后 <code>恢复（resume）</code> 它，\n这与使用 <code>ReadStream</code> 一样。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.POST) {\n\n    <span class=\"hljs-comment\">// 暂停接收 buffer</span>\n    request.pause();\n\n    checkAuth(res -&gt; {\n\n      <span class=\"hljs-comment\">// 现在可以重新接收 buffer</span>\n      request.resume();\n\n      <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n        Observable&lt;Buffer&gt; observable = request.toObservable();\n        observable.subscribe(buff -&gt; {\n          <span class=\"hljs-comment\">// 获得 buffer</span>\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同样的，将一个 <code>Observable</code> 转变为 Vert.x <code>ReadStream</code> 也是可以的。</p>\n</div>\n<div class=\"paragraph\">\n<p>静态方法 <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toReadStream-rx.Observable-\">RxHelper.toReadStream</a></code>  用于将\n<code>rx.Observable</code> 转换为 Vert.x 可读流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Buffer&gt; observable = getObservable();\nReadStream&lt;Buffer&gt; readStream = RxHelper.toReadStream(observable);\nPump pump = Pump.pump(readStream, response);\npump.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_write_stream_support\"><a class=\"anchor\" href=\"#_write_stream_support\"></a>可写流支持</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 类似于 <code>rx.Subscriber</code> ，它会消费数据，并且在消费速度无法跟上生产速度时与生产者协作，以避免积压的情况不断增加。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 提供了 <code><a href=\"../../apidocs/io/vertx/rx/java/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> 适配器，它可以发送 <code>Observable</code> 对象到任意 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">将 buffer 发送到 HTTP 服务响应</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nWriteStreamSubscriber&lt;io.vertx.core.buffer.Buffer&gt; subscriber = io.vertx.rx.java.RxHelper.toSubscriber(response);\nobservable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 <em>Rx化的</em> Vert.x API 进行编程，<code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> 的实现提供了一个 <code>toSubscriber</code> 方法。\n这样一来，上面的例子可以变得更直接明了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nobservable.subscribe(response.toSubscriber());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n当 <code>Observable</code> 成功结束时，该适配器会调用 <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html#end-io.vertx.core.Handler-\">end</a></code> 方法。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n该适配器会设置 <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> 的 <code>drain</code> 和 <code>exception</code> handler，所以订阅后请不要使用它们。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rx/java/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> 适配器在下述情况下会调用回调方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Observable</code> 错误地结束，或</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> 失败（如 HTTP 连接被关闭，或文件系统已满），或</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> 结束（即，所有写入已完成，且文件已关闭），或</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> 错误地结束（即，所有写入已结束，当关闭文件时发生了错误）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这样不但可以设计更健壮的程序，而且可以在处理完流之后安排其他任务：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\nWriteStreamSubscriber&lt;Buffer&gt; subscriber = response.toSubscriber();\n\nsubscriber.onError(throwable -&gt; {\n  <span class=\"hljs-keyword\">if</span> (!response.headWritten() &amp;&amp; response.closed()) {\n    response.setStatusCode(<span class=\"hljs-number\">500</span>).end(<span class=\"hljs-string\">&quot;oops&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 错误日志</span>\n  }\n});\n\nsubscriber.onWriteStreamError(throwable -&gt; {\n  <span class=\"hljs-comment\">// 错误日志</span>\n});\n\nsubscriber.onWriteStreamEnd(() -&gt; {\n  <span class=\"hljs-comment\">// 将事务结束记录到审计系统</span>\n});\n\nobservable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果 <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> 失败，则该是配置取消订阅 <code>Observable</code> 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handler_support\"><a class=\"anchor\" href=\"#_handler_support\"></a>Handler 支持</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html\">RxHelper</a></code> 类可以创建 <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableHandler.html\">ObservableHandler</a></code> 对象，它是一个 <code>Observable</code> 对象，\n它的 <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableHandler.html#toHandler--\">toHandler</a></code> 方法会返回 <code>Handler&lt;T&gt;</code> 接口的实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ObservableHandler&lt;Long&gt; observable = RxHelper.observableHandler();\nobservable.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// Fired</span>\n});\nvertx.setTimer(<span class=\"hljs-number\">1000</span>, observable.toHandler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化的</em> Vert.x API 未提供针对 <code>Handler</code> 的 API。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_async_result_support\"><a class=\"anchor\" href=\"#_async_result_support\"></a>异步结果支持</h3>\n<div class=\"paragraph\">\n<p>以一个现有的 Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 对象为基础，你可以创建一个 RxJava <code>Subscriber</code>，\n然后将其注册在 <code>Observable</code> 或 <code>Single</code> 上：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">observable.subscribe(RxHelper.toSubscriber(handler1));\n\n<span class=\"hljs-comment\">// 订阅 Single</span>\nsingle.subscribe(RxHelper.toSubscriber(handler2));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在构造(construct)发生时，作为异步方法的最后一个参数的 Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>\n可以被映射为单个元素的 Observable：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当回调成功时，观察者的 <code>onNext</code> 方法将被调用，参数就是这个对象；\n且其后 <code>onComplete</code> 方法会立即被调用。</p>\n</li>\n<li>\n<p>当回调失败时，观察者的 <code>onError</code> 方法将被调用。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#observableFuture--\">RxHelper.observableFuture</a></code> 方法可以创建一个 <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableFuture.html\">ObservableFuture</a></code> 对象。\n这是一个 <code>Observable</code> 对象，它的 <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableFuture.html#toHandler--\">toHandler</a></code> 方法会返回 <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>\n接口的实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ObservableFuture&lt;HttpServer&gt; observable = RxHelper.observableFuture();\nobservable.subscribe(\n    server -&gt; {\n      <span class=\"hljs-comment\">// 服务器在监听</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// 服务器无法启动</span>\n    }\n);\nvertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions().\n    setPort(<span class=\"hljs-number\">1234</span>).\n    setHost(<span class=\"hljs-string\">&quot;localhost&quot;</span>)\n).listen(observable.toHandler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们可以从 <code>ObservableFuture&lt;Server&gt;</code> 中获取单个 <code>HttpServer</code> 对象。如果端口 <code>监听（listen）</code> 失败，\n订阅者将会接收到通知。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toHandler-rx.Observer-\">RxHelper.toHandler</a></code> 方法为观察者（<code>Observer</code>）和事件处理器（<code>Handler</code>）做了适配：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observer&lt;HttpServer&gt; observer = <span class=\"hljs-keyword\">new</span> Observer&lt;HttpServer&gt;() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(HttpServer o)</span> </span>{\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{\n  }\n};\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler = RxHelper.toFuture(observer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>下面的代码也是可以的（译者注：直接基于 <code>Action</code> ）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Action1&lt;HttpServer&gt; onNext = httpServer -&gt; {};\nAction1&lt;Throwable&gt; onError = httpServer -&gt; {};\nAction0 onComplete = () -&gt; {};\n\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler1 = RxHelper.toFuture(onNext);\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler2 = RxHelper.toFuture(onNext, onError);\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler3 = RxHelper.toFuture(onNext, onError, onComplete);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化的</em> Vert.x API 复制了类似的每一个方法，并冠以 <code>rx</code> 的前缀，它们都返回 RxJava 的 <code>Single</code> 对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpServer&gt; single = vertx\n  .createHttpServer()\n  .rxListen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>);\n\n<span class=\"hljs-comment\">// 订阅绑定端口的事件</span>\nsingle.\n    subscribe(\n        server -&gt; {\n          <span class=\"hljs-comment\">// 服务器正在监听</span>\n        },\n        failure -&gt; {\n          <span class=\"hljs-comment\">// 服务器无法启动</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这样的 Single 是 <strong>“冷的”(cold)</strong> ，对应的 API 方法将在注册时被调用。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n类似 <code>rx*</code> 的方法替换了以前版本中 <code>*Observable</code> 的方法，\n这样一个语义上的改变是为了与 RxJava 保持一致。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scheduler_support\"><a class=\"anchor\" href=\"#_scheduler_support\"></a>调度器支持</h3>\n<div class=\"paragraph\">\n<p>有时候 Reactive 扩展库需要执行一些可调度的操作，例如 <code>Observable#timer</code>\n方法将创建一个能周期性发射事件的定时器并返回之。缺省情况下，这些可调度的操作由 RxJava 管理，\n这意味着定时器线程并非 Vert.x 线程，因此（这些操作）并不是在 Vert.x Event Loop 线程上执行的。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 RxJava 中，有些操作通常会有接受一个 <code>rx.Scheduler</code> 参数的重载方法用于设定 <code>Scheduler</code>。\n<code>RxHelper</code> 类提供了一个 <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#scheduler-io.vertx.core.Vertx-\">RxHelper.scheduler</a></code> 方法，其返回的调度器可供 RxJava\n的这些方法使用。比如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.timer(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于阻塞型的可调度操作（blocking scheduled actions），我们可以通过 <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#blockingScheduler-io.vertx.core.Vertx-\">RxHelper.blockingScheduler</a></code>\n方法获得适用的调度器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.blockingScheduler(vertx);\nObservable&lt;Integer&gt; obs = blockingObservable.observeOn(scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava 也能被配置成使用 Vert.x 的调度器，这得益于\n<code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#schedulerHook-io.vertx.core.Vertx-\">RxHelper.schedulerHook</a></code> 方法创建的调度器钩子对象。\n对于 IO 操作这里使用了阻塞型的调度器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaSchedulersHook hook = RxHelper.schedulerHook(vertx);\nRxJavaHooks.setOnIOScheduler(f -&gt; hook.getIOScheduler());\nRxJavaHooks.setOnNewThreadScheduler(f -&gt; hook.getNewThreadScheduler());\nRxJavaHooks.setOnComputationScheduler(f -&gt; hook.getComputationScheduler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化的</em> Vert.x API 在 <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html\">RxHelper</a></code> 类中也提供了相似的方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = io.vertx.rxjava.core.RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaSchedulersHook hook = io.vertx.rxjava.core.RxHelper.schedulerHook(vertx);\n  RxJavaHooks.setOnIOScheduler(f -&gt; hook.getIOScheduler());\n  RxJavaHooks.setOnNewThreadScheduler(f -&gt; hook.getNewThreadScheduler());\n  RxJavaHooks.setOnComputationScheduler(f -&gt; hook.getComputationScheduler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>基于一个命名的工作线程池（named worker pool）创建调度器也是可以的，\n如果你想为了调度阻塞操作复用特定的线程池，这将会很有帮助：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = io.vertx.rxjava.core.RxHelper.scheduler(workerExecutor);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_unmarshalling\"><a class=\"anchor\" href=\"#_json_unmarshalling\"></a>JSON解码</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code> 方法创建了一个 <code>rx.Observable.Operator</code> 对象，\n它可以将 <code>Observable&lt;Buffer&gt;</code> 变换为对象的 Observable：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = RxHelper.toObservable(file);\n  observable.lift(RxHelper.unmarshaller(MyPojo.class)).subscribe(\n      mypojo -&gt; {\n        <span class=\"hljs-comment\">// 处理对象</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化</em> 的辅助类也能做同样的事情：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = file.toObservable();\n  observable.lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo.class)).subscribe(\n      mypojo -&gt; {\n        <span class=\"hljs-comment\">// 处理对象</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_a_verticle\"><a class=\"anchor\" href=\"#_deploying_a_verticle\"></a>部署Verticle</h3>\n<div class=\"paragraph\">\n<p>Rx化的 API 不能部署一个已经存在的 Verticle 实例。<code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#observableFuture--\">RxHelper.observableFuture</a></code>\n方法为此提供了一个解决方案。</p>\n</div>\n<div class=\"paragraph\">\n<p>所有工作都在 <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#deployVerticle-io.vertx.rxjava.core.Vertx-io.vertx.core.Verticle-\">RxHelper.deployVerticle</a></code>\n方法里自动完成，它会部署一个 <code>Verticle</code> 并返回包含部署 ID 的 <code>Observable&lt;String&gt;</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;String&gt; deployment = RxHelper.deployVerticle(vertx, verticle);\n\ndeployment.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// 部署成功</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// 部署失败</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxified_api\"><a class=\"anchor\" href=\"#_rxified_api\"></a>Rx化的 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><em>Rx化的</em> API 是 Vert.x API 的一个代码自动生成版本，就像 Vert.x 的 <em>JavaScript</em> 或 <em>Groovy</em> 版本一样。\n这些 API 以 <code>io.vertx.rxjava</code> 为包名前缀，例如 <code>io.vertx.core.Vertx</code> 类对应为\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html\">Vertx</a></code> 类。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_embedding_rxfified_vert.x\"><a class=\"anchor\" href=\"#_embedding_rxfified_vert.x\"></a>嵌入Rx化的 Vert.x</h3>\n<div class=\"paragraph\">\n<p>只需使用 <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#vertx--\">Vertx.vertx</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = io.vertx.rxjava.core.Vertx.vertx();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_as_a_verticle\"><a class=\"anchor\" href=\"#_as_a_verticle\"></a>作为 Verticle</h3>\n<div class=\"paragraph\">\n<p>通过继承 <code><a href=\"../../apidocs/io/vertx/rxjava/core/AbstractVerticle.html\">AbstractVerticle</a></code> 类，它会做一些包装（您将获得一个 RxJava Verticle）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">rxjava</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// 在此可使用Rx化的Vert.x了</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>部署一个 RxJava Verticle 不需要特别的部署器，使用 Java\n部署器即可。</p>\n</div>\n<div class=\"paragraph\">\n<p>支持异步启动的 Verticle 可以重写 <code>rxStart</code> 方法并返回一个 <code>Completable</code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">rxjava</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Completable <span class=\"hljs-title\">rxStart</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Hello World&quot;</span>))\n      .rxListen()\n      .toCompletable();\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_api_examples\"><a class=\"anchor\" href=\"#_api_examples\"></a>API 例子</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>让我们通过研究一些例子来了解相关 API 吧。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_eventBus_message_stream\"><a class=\"anchor\" href=\"#_eventBus_message_stream\"></a>EventBus 消息流</h3>\n<div class=\"paragraph\">\n<p>很自然地， <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 类提供了相关的 <code>Observable&lt;Message&lt;T&gt;&gt;</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nObservable&lt;Message&lt;String&gt;&gt; observable = consumer.toObservable();\nSubscription sub = observable.subscribe(msg -&gt; {\n  <span class=\"hljs-comment\">// 获得消息</span>\n});\n\n<span class=\"hljs-comment\">// 10秒后注销</span>\nvertx.setTimer(<span class=\"hljs-number\">10000</span>, id -&gt; {\n  sub.unsubscribe();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 类提供了 <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/Message.html\">Message</a></code> 的流。\n如果需要，还可以通过 <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/Message.html#body--\">body</a></code> 方法获得消息体组成的新流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nObservable&lt;String&gt; observable = consumer.bodyStream().toObservable();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava 的 map/reduce 组合风格在这里是相当有用的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Double&gt; observable = vertx.eventBus().\n    &lt;Double&gt;consumer(<span class=\"hljs-string\">&quot;heat-sensor&quot;</span>).\n    bodyStream().\n    toObservable();\n\nobservable.\n    buffer(<span class=\"hljs-number\">1</span>, TimeUnit.SECONDS).\n    map(samples -&gt; samples.\n        stream().\n        collect(Collectors.averagingDouble(d -&gt; d))).\n    subscribe(heat -&gt; {\n      vertx.eventBus().send(<span class=\"hljs-string\">&quot;news-feed&quot;</span>, <span class=\"hljs-string\">&quot;Current heat is &quot;</span> + heat);\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timers\"><a class=\"anchor\" href=\"#_timers\"></a>定时器Timers</h3>\n<div class=\"paragraph\">\n<p>定时器任务可以通过 <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#timerStream-long-\">timerStream</a></code> 方法来创建：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.timerStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback after 1 second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>周期性的任务可以通过 <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#periodicStream-long-\">periodicStream</a></code> 方法来创建：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback every second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过注销操作可以取消对 Observable 的订阅：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(<span class=\"hljs-keyword\">new</span> Subscriber&lt;Long&gt;() {\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(Long aLong)</span> </span>{\n        <span class=\"hljs-comment\">// 回调</span>\n        unsubscribe();\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{}\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{}\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_client_requests\"><a class=\"anchor\" href=\"#_http_client_requests\"></a>HTTP客户端请求</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClient.html#rxRequest-io.vertx.core.http.RequestOptions-\">rxRequest</a></code> 方法返回一个\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientRequest.html\">HttpClientRequest</a></code> 的 Single 对象。 这个 Single 对象可以将请求失败上报。</p>\n</div>\n<div class=\"paragraph\">\n<p>调用 <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientRequest.html#rxSend--\">rxSend</a></code>\n方法可以将请求发送出去，并返回响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nSingle&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.subscribe(\n    response -&gt; {\n      <span class=\"hljs-comment\">// 处理响应</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// 无法连接</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过 <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientResponse.html#toObservable--\">toObservable</a></code>\n方法可以将响应当成 <code>Observable&lt;Buffer&gt;</code> 来处理：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.toObservable().\n    subscribe(\n        response -&gt; {\n          Observable&lt;Buffer&gt; observable = response.toObservable();\n          observable.forEach(\n              buffer -&gt; {\n                <span class=\"hljs-comment\">// 处理 buffer</span>\n              }\n          );\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>flatMap</code> 操作也能获得同样的流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.toObservable().\n    flatMap(HttpClientResponse::toObservable).\n    forEach(\n        buffer -&gt; {\n          <span class=\"hljs-comment\">// 处理 buffer</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过静态方法 <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code> ，我们也能将 <code>Observable&lt;Buffer&gt;</code> 重组为对象。\n这个方法创建了一个 <code>Rx.Observable.Operator</code>（Rx 操作符）供重组操作使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.toObservable().\n    flatMap(HttpClientResponse::toObservable).\n    lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo.class)).\n    forEach(\n        pojo -&gt; {\n          <span class=\"hljs-comment\">// 处理 pojo</span>\n        }\n    );</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_server_requests\"><a class=\"anchor\" href=\"#_http_server_requests\"></a>HTTP服务端请求</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpServer.html#requestStream--\">requestStream</a></code>\n方法对到达的每个请求都提供了回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  <span class=\"hljs-comment\">// 处理请求</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> 可以被适配为 <code>Observable&lt;Buffer&gt;</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;Buffer&gt; observable = request.toObservable();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code> 方法可以用来解析 JSON 格式的请求，\n并将其映射为对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;MyPojo&gt; observable = request.\n      toObservable().\n      lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo.class));\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_client\"><a class=\"anchor\" href=\"#_websocket_client\"></a>WebSocket客户端</h3>\n<div class=\"paragraph\">\n<p>当 WebSocket 连接成功或失败时， <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClient.html#rxWebSocket-int-java.lang.String-java.lang.String-\">rxWebSocket</a></code>\n方法对此提供了一次性的回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nclient.rxWebSocket(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>).subscribe(\n    ws -&gt; {\n      <span class=\"hljs-comment\">// 使用 websocket</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// 连接失败</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/http/WebSocket.html\">WebSocket</a></code> 对象可以轻松地转换为 <code>Observable&lt;Buffer&gt;</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_server\"><a class=\"anchor\" href=\"#_websocket_server\"></a>WebSocket服务端</h3>\n<div class=\"paragraph\">\n<p>每当有新连接到达时， <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpServer.html#webSocketStream--\">webSocketStream</a></code>\n方法都会提供一次回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;ServerWebSocket&gt; socketObservable = server.webSocketStream().toObservable();\nsocketObservable.subscribe(\n    socket -&gt; System.out.println(<span class=\"hljs-string\">&quot;Web socket connect&quot;</span>),\n    failure -&gt; System.out.println(<span class=\"hljs-string\">&quot;Should never be called&quot;</span>),\n    () -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Subscription ended or server closed&quot;</span>);\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> 对象可以轻松地转换为 <code>Observable&lt;Buffer&gt;</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.1.6"},"__N_SSG":true}