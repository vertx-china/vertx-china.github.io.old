{"pageProps":{"slug":"3.9.5/vertx-web-client/java","title":"Vert.x Web Client","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_the_web_client\">Using the Web Client</a></li>\n<li><a href=\"#_re_cap_on_vert_x_core_http_client\">Re-cap on Vert.x core HTTP client</a></li>\n<li><a href=\"#_creating_a_web_client\">Creating a Web Client</a></li>\n<li><a href=\"#_making_requests\">Making requests</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_simple_requests_with_no_body\">Simple requests with no body</a></li>\n<li><a href=\"#_writing_request_bodies\">Writing request bodies</a></li>\n<li><a href=\"#_writing_request_headers\">Writing request headers</a></li>\n<li><a href=\"#_configure_the_request_to_add_authentication\">Configure the request to add authentication.</a></li>\n<li><a href=\"#_reusing_requests\">Reusing requests</a></li>\n<li><a href=\"#_timeouts\">Timeouts</a></li>\n</ul>\n</li>\n<li><a href=\"#_handling_http_responses\">Handling http responses</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_decoding_responses\">Decoding responses</a></li>\n<li><a href=\"#response-predicates\">Response predicates</a></li>\n<li><a href=\"#_handling_30x_redirections\">Handling 30x redirections</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_https\">Using HTTPS</a></li>\n<li><a href=\"#_sessions_management\">Sessions management</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_websession\">Creating a WebSession</a></li>\n<li><a href=\"#_making_requests_2\">Making requests</a></li>\n<li><a href=\"#_setting_session_level_headers\">Setting session level headers</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxjava_2_api\">RxJava 2 API</a></li>\n<li><a href=\"#_domain_sockets\">Domain sockets</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Web Client</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web Client is an asynchronous HTTP and HTTP/2 client.</p>\n</div>\n<div class=\"paragraph\">\n<p>The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced\nfeatures like:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Json body encoding / decoding</p>\n</li>\n<li>\n<p>request/response pumping</p>\n</li>\n<li>\n<p>request parameters</p>\n</li>\n<li>\n<p>unified error handling</p>\n</li>\n<li>\n<p>form submissions</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The Web Client does not deprecate the Vert.x Core <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code>, indeed it is based on\nthis client and inherits its configuration and great features like pooling, HTTP/2 support, pipelining support, etc&#8230;&#8203;\nThe <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> should be used when fine grained control over the HTTP\nrequests/responses is necessary.</p>\n</div>\n<div class=\"paragraph\">\n<p>The Web Client does not provide a WebSocket API, the Vert.x Core <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> should\nbe used. It also does not handle cookies at the moment.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_web_client\"><a class=\"anchor\" href=\"#_using_the_web_client\"></a>Using the Web Client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use Vert.x Web Client, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-client:3.9.5'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_re_cap_on_vert_x_core_http_client\"><a class=\"anchor\" href=\"#_re_cap_on_vert_x_core_http_client\"></a>Re-cap on Vert.x core HTTP client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web Client uses the API from Vert.x core, so it&#8217;s well worth getting familiar with the basic concepts of using\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> using Vert.x core, if you&#8217;re not already.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_web_client\"><a class=\"anchor\" href=\"#_creating_a_web_client\"></a>Creating a Web Client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You create an <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code> instance with default options as follows</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If you want to configure options for the client, you create it as follows</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClientOptions options = <span class=\"hljs-keyword\">new</span> WebClientOptions()\n  .setUserAgent(<span class=\"hljs-string\">\"My-App/1.2.3\"</span>);\noptions.setKeepAlive(<span class=\"hljs-keyword\">false</span>);\nWebClient client = WebClient.create(vertx, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Web Client options inherit Http Client options so you can set any one of them.</p>\n</div>\n<div class=\"paragraph\">\n<p>If your already have an HTTP Client in your application you can also reuse it</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.wrap(httpClient);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\nIn most cases, a Web Client should be created once on application startup and then reused.\nOtherwise you lose a lot of benefits such as connection pooling and may leak resources if instances are not closed properly.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_making_requests\"><a class=\"anchor\" href=\"#_making_requests\"></a>Making requests</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_simple_requests_with_no_body\"><a class=\"anchor\" href=\"#_simple_requests_with_no_body\"></a>Simple requests with no body</h3>\n<div class=\"paragraph\">\n<p>Often, you’ll want to make HTTP requests with no request body. This is usually the case with HTTP GET, OPTIONS\nand HEAD requests</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx);\n\n<span class=\"hljs-comment\">// Send a GET request</span>\nclient\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Obtain response</span>\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });\n\n<span class=\"hljs-comment\">// Send a HEAD request</span>\nclient\n  .head(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Obtain response</span>\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can add query parameters to the request URI in a fluent fashion</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .addQueryParam(<span class=\"hljs-string\">\"param\"</span>, <span class=\"hljs-string\">\"param_value\"</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Obtain response</span>\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Any request URI parameter will pre-populate the request</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri?param1=param1_value&amp;param2=param2_value\"</span>);\n\n<span class=\"hljs-comment\">// Add param3</span>\nrequest.addQueryParam(<span class=\"hljs-string\">\"param3\"</span>, <span class=\"hljs-string\">\"param3_value\"</span>);\n\n<span class=\"hljs-comment\">// Overwrite param2</span>\nrequest.setQueryParam(<span class=\"hljs-string\">\"param2\"</span>, <span class=\"hljs-string\">\"another_param2_value\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Setting a request URI discards existing query parameters</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\n\n<span class=\"hljs-comment\">// Add param1</span>\nrequest.addQueryParam(<span class=\"hljs-string\">\"param1\"</span>, <span class=\"hljs-string\">\"param1_value\"</span>);\n\n<span class=\"hljs-comment\">// Overwrite param1 and add param2</span>\nrequest.uri(<span class=\"hljs-string\">\"/some-uri?param1=param1_value&amp;param2=param2_value\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_request_bodies\"><a class=\"anchor\" href=\"#_writing_request_bodies\"></a>Writing request bodies</h3>\n<div class=\"paragraph\">\n<p>When you need to make a request with a body, you use the same API and call then <code>sendXXX</code> methods\nthat expects a body to send.</p>\n</div>\n<div class=\"paragraph\">\n<p>Use <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendBuffer-io.vertx.core.buffer.Buffer-io.vertx.core.Handler-\">sendBuffer</a></code> to send a buffer body</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendBuffer(buffer, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Sending a single buffer is useful but often you don&#8217;t want to load fully the content in memory because\nit may be too large or you want to handle many concurrent requests and want to use just the minimum\nfor each request. For this purpose the Web Client can send <code>ReadStream&lt;Buffer&gt;</code> (e.g a\n<code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html\">AsyncFile</a></code> is a ReadStream&lt;Buffer&gt;`) with the <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendStream-io.vertx.core.streams.ReadStream-io.vertx.core.Handler-\">sendStream</a></code> method</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendStream(stream, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The Web Client takes care of setting up the transfer pump for you. Since the length of the stream is not know\nthe request will use chunked transfer encoding .</p>\n</div>\n<div class=\"paragraph\">\n<p>When you know the size of the stream, you shall specify before using the <code>content-length</code> header</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fs.open(<span class=\"hljs-string\">\"content.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), fileRes -&gt; {\n  <span class=\"hljs-keyword\">if</span> (fileRes.succeeded()) {\n    ReadStream&lt;Buffer&gt; fileStream = fileRes.result();\n\n    String fileLen = <span class=\"hljs-string\">\"1024\"</span>;\n\n    <span class=\"hljs-comment\">// Send the file to the server using POST</span>\n    client\n      .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n      .putHeader(<span class=\"hljs-string\">\"content-length\"</span>, fileLen)\n      .sendStream(fileStream, ar -&gt; {\n        <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n          <span class=\"hljs-comment\">// Ok</span>\n        }\n      });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The POST will not be chunked.</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_json_bodies\"><a class=\"anchor\" href=\"#_json_bodies\"></a>Json bodies</h4>\n<div class=\"paragraph\">\n<p>Often you’ll want to send Json body requests, to send a <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code>\nuse the <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendJsonObject-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">sendJsonObject</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendJsonObject(<span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">\"firstName\"</span>, <span class=\"hljs-string\">\"Dale\"</span>)\n    .put(<span class=\"hljs-string\">\"lastName\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In Java, Groovy or Kotlin, you can use the <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendJson-java.lang.Object-io.vertx.core.Handler-\">sendJson</a></code> method that maps\na POJO (Plain Old Java Object) to a Json object using <code><a href=\"../../apidocs/io/vertx/core/json/Json.html#encode-java.lang.Object-\">Json.encode</a></code>\nmethod</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendJson(<span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-string\">\"Dale\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nthe <code><a href=\"../../apidocs/io/vertx/core/json/Json.html#encode-java.lang.Object-\">Json.encode</a></code> uses the Jackson mapper to encode the object\nto Json.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_form_submissions\"><a class=\"anchor\" href=\"#_form_submissions\"></a>Form submissions</h4>\n<div class=\"paragraph\">\n<p>You can send http form submissions bodies with the <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendForm-io.vertx.core.MultiMap-io.vertx.core.Handler-\">sendForm</a></code>\nvariant.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultiMap form = MultiMap.caseInsensitiveMultiMap();\nform.set(<span class=\"hljs-string\">\"firstName\"</span>, <span class=\"hljs-string\">\"Dale\"</span>);\nform.set(<span class=\"hljs-string\">\"lastName\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>);\n\n<span class=\"hljs-comment\">// Submit the form as a form URL encoded body</span>\nclient\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendForm(form, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>By default the form is submitted with the <code>application/x-www-form-urlencoded</code> content type header. You can set\nthe <code>content-type</code> header to <code>multipart/form-data</code> instead</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultiMap form = MultiMap.caseInsensitiveMultiMap();\nform.set(<span class=\"hljs-string\">\"firstName\"</span>, <span class=\"hljs-string\">\"Dale\"</span>);\nform.set(<span class=\"hljs-string\">\"lastName\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>);\n\n<span class=\"hljs-comment\">// Submit the form as a multipart form body</span>\nclient\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"multipart/form-data\"</span>)\n  .sendForm(form, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If you want to upload files and send attributes, you can create a <code><a href=\"../../apidocs/io/vertx/ext/web/multipart/MultipartForm.html\">MultipartForm</a></code> and\nuse <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendMultipartForm-io.vertx.ext.web.multipart.MultipartForm-io.vertx.core.Handler-\">sendMultipartForm</a></code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultipartForm form = MultipartForm.create()\n  .attribute(<span class=\"hljs-string\">\"imageDescription\"</span>, <span class=\"hljs-string\">\"a very nice image\"</span>)\n  .binaryFileUpload(<span class=\"hljs-string\">\"imageFile\"</span>, <span class=\"hljs-string\">\"image.jpg\"</span>, <span class=\"hljs-string\">\"/path/to/image\"</span>, <span class=\"hljs-string\">\"image/jpeg\"</span>);\n\n<span class=\"hljs-comment\">// Submit the form as a multipart form body</span>\nclient\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendMultipartForm(form, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_request_headers\"><a class=\"anchor\" href=\"#_writing_request_headers\"></a>Writing request headers</h3>\n<div class=\"paragraph\">\n<p>You can write headers to a request using the headers multi-map as follows:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\nMultiMap headers = request.headers();\nheaders.set(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>);\nheaders.set(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"foo\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The headers are an instance of <code><a href=\"../../apidocs/io/vertx/core/MultiMap.html\">MultiMap</a></code> which provides operations for adding,\nsetting and removing entries. Http headers allow more than one value for a specific key.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also write headers using putHeader</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\nrequest.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>);\nrequest.putHeader(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"foo\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configure_the_request_to_add_authentication\"><a class=\"anchor\" href=\"#_configure_the_request_to_add_authentication\"></a>Configure the request to add authentication.</h3>\n<div class=\"paragraph\">\n<p>Authentication can be performed manually by setting the correct headers, or, using our predefined methods\n(We strongly suggest having HTTPS enabled, especially for authenticated requests):</p>\n</div>\n<div class=\"paragraph\">\n<p>In basic HTTP authentication, a request contains a header field of the form <code>Authorization: Basic &lt;credentials&gt;</code>,\nwhere credentials is the base64 encoding of id and password joined by a colon.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can configure the request to add basic access authentication as follows:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .basicAuthentication(<span class=\"hljs-string\">\"myid\"</span>, <span class=\"hljs-string\">\"mypassword\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In OAuth 2.0, a request contains a header field of the form <code>Authorization: Bearer &lt;bearerToken&gt;</code>,\nwhere bearerToken is the bearer token issued by an authorization server to access protected resources.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can configure the request to add bearer token authentication as follows:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .bearerTokenAuthentication(<span class=\"hljs-string\">\"myBearerToken\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_reusing_requests\"><a class=\"anchor\" href=\"#_reusing_requests\"></a>Reusing requests</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#send-io.vertx.core.Handler-\">send</a></code> method can be called multiple times\nsafely, making it very easy to configure and reuse <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html\">HttpRequest</a></code> objects</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; get = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\nget.send(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Ok</span>\n  }\n});\n\n<span class=\"hljs-comment\">// Same request again</span>\nget.send(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Ok</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Beware though that <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html\">HttpRequest</a></code> instances are mutable.\nTherefore you should call the <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#copy--\">copy</a></code> method before modifying a cached instance.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; get = client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\nget.send(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Ok</span>\n  }\n});\n\n<span class=\"hljs-comment\">// The \"get\" request instance remains unmodified</span>\nget.copy().putHeader(<span class=\"hljs-string\">\"a-header\"</span>, <span class=\"hljs-string\">\"with-some-value\"</span>).send(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Ok</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timeouts\"><a class=\"anchor\" href=\"#_timeouts\"></a>Timeouts</h3>\n<div class=\"paragraph\">\n<p>You can set a timeout for a specific http request using <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#timeout-long-\">timeout</a></code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .timeout(<span class=\"hljs-number\">5000</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Ok</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// Might be a timeout when cause is java.util.concurrent.TimeoutException</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If the request does not return any data within the timeout period an exception will be passed to the response\nhandler.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_http_responses\"><a class=\"anchor\" href=\"#_handling_http_responses\"></a>Handling http responses</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When the Web Client sends a request you always deal with a single async result <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpResponse.html\">HttpResponse</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>On a success result the callback happens after the response has been received</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>By default, a Vert.x Web Client request ends with an error only if something wrong happens at the network level.\nIn other words, a <code>404 Not Found</code> response, or a response with the wrong content type, are <strong>not</strong> considered as failures.\nUse <a href=\"#response-predicates\">response predicates</a> if you want the Web Client to perform sanity checks automatically.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nResponses are fully buffered, use <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#pipe-io.vertx.core.streams.WriteStream-\">BodyCodec.pipe</a></code>\nto pipe the response to a write stream\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_decoding_responses\"><a class=\"anchor\" href=\"#_decoding_responses\"></a>Decoding responses</h3>\n<div class=\"paragraph\">\n<p>By default the Web Client provides an http response body as a <code>Buffer</code> and does not apply\nany decoding.</p>\n</div>\n<div class=\"paragraph\">\n<p>Custom response body decoding can be achieved using <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html\">BodyCodec</a></code>:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Plain String</p>\n</li>\n<li>\n<p>Json object</p>\n</li>\n<li>\n<p>Json mapped POJO</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>A body codec can decode an arbitrary binary data stream into a specific object instance, saving you the decoding\nstep in your response handlers.</p>\n</div>\n<div class=\"paragraph\">\n<p>Use <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#jsonObject--\">BodyCodec.jsonObject</a></code> To decode a Json object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.jsonObject())\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      HttpResponse&lt;JsonObject&gt; response = ar.result();\n\n      JsonObject body = response.body();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode() + <span class=\"hljs-string\">\" with body \"</span> + body);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In Java, Groovy or Kotlin, custom Json mapped POJO can be decoded</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.json(User<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))\n  .<span class=\"hljs-title\">send</span>(<span class=\"hljs-title\">ar</span> -&gt; </span>{\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      HttpResponse&lt;User&gt; response = ar.result();\n\n      User user = response.body();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode() + <span class=\"hljs-string\">\" with body \"</span> +\n        user.getFirstName() + <span class=\"hljs-string\">\" \"</span> + user.getLastName());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When large response are expected, use the <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#pipe-io.vertx.core.streams.WriteStream-\">BodyCodec.pipe</a></code>.\nThis body codec pumps the response body buffers to a <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>\nand signals the success or the failure of the operation in the async result response</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.pipe(writeStream))\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      HttpResponse&lt;Void&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Finally if you are not interested at all by the response content, the <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#none--\">BodyCodec.none</a></code>\nsimply discards the entire response body</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.none())\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      HttpResponse&lt;Void&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you don&#8217;t know in advance the content type of the http response, you can still use the <code>bodyAsXXX()</code> methods\nthat decode the response to a specific type</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      <span class=\"hljs-comment\">// Decode the body as a json object</span>\n      JsonObject body = response.bodyAsJsonObject();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode() + <span class=\"hljs-string\">\" with body \"</span> + body);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nthis is only valid for the response decoded as a buffer.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"response-predicates\"><a class=\"anchor\" href=\"#response-predicates\"></a>Response predicates</h3>\n<div class=\"paragraph\">\n<p>By default, a Vert.x Web Client request ends with an error only if something wrong happens at the network level.</p>\n</div>\n<div class=\"paragraph\">\n<p>In other words, you must perform sanity checks manually after the response is received:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">200</span> &amp;&amp; response.getHeader(<span class=\"hljs-string\">\"content-type\"</span>).equals(<span class=\"hljs-string\">\"application/json\"</span>)) {\n\n        <span class=\"hljs-comment\">// Decode the body as a json object</span>\n        JsonObject body = response.bodyAsJsonObject();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode() + <span class=\"hljs-string\">\" with body \"</span> + body);\n\n      } <span class=\"hljs-keyword\">else</span> {\n        System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + response.statusCode());\n      }\n\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can trade flexibility for clarity and conciseness using <em>response predicates</em>.</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html\">Response predicates</a></code> can fail a request when the response does\nnot match a criteria.</p>\n</div>\n<div class=\"paragraph\">\n<p>The Web Client comes with a set of out of the box predicates ready to use:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .expect(ResponsePredicate.SC_SUCCESS)\n  .expect(ResponsePredicate.JSON)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      <span class=\"hljs-comment\">// Safely decode the body as a json object</span>\n      JsonObject body = response.bodyAsJsonObject();\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode() + <span class=\"hljs-string\">\" with body \"</span> + body);\n\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also create custom predicates when existing predicates don&#8217;t fit your needs:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Function&lt;HttpResponse&lt;Void&gt;, ResponsePredicateResult&gt; methodsPredicate = resp -&gt; {\n  String methods = resp.getHeader(<span class=\"hljs-string\">\"Access-Control-Allow-Methods\"</span>);\n  <span class=\"hljs-keyword\">if</span> (methods != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-keyword\">if</span> (methods.contains(<span class=\"hljs-string\">\"POST\"</span>)) {\n      <span class=\"hljs-keyword\">return</span> ResponsePredicateResult.success();\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> ResponsePredicateResult.failure(<span class=\"hljs-string\">\"Does not work\"</span>);\n};\n\n<span class=\"hljs-comment\">// Send pre-flight CORS request</span>\nclient\n  .request(HttpMethod.OPTIONS, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"Origin\"</span>, <span class=\"hljs-string\">\"Server-b.com\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"Access-Control-Request-Method\"</span>, <span class=\"hljs-string\">\"POST\"</span>)\n  .expect(methodsPredicate)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Process the POST request now</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\nResponse predicates are evaluated <em>before</em> the response body is received. Therefore you can&#8217;t inspect the response body\nin a predicate test function.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_predefined_predicates\"><a class=\"anchor\" href=\"#_predefined_predicates\"></a>Predefined predicates</h4>\n<div class=\"paragraph\">\n<p>As a convenience, the Web Client ships a few predicates for common uses cases .</p>\n</div>\n<div class=\"paragraph\">\n<p>For status codes, e.g <code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html#SC_SUCCESS\">ResponsePredicate.SC_SUCCESS</a></code> to verify that the\nresponse has a <code>2xx</code> code, you can also create a custom one:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .expect(ResponsePredicate.status(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">202</span>))\n  .send(ar -&gt; {\n    <span class=\"hljs-comment\">// ....</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For content types, e.g <code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html#JSON\">ResponsePredicate.JSON</a></code> to verify that the\nresponse body contains JSON data, you can also create a custom one:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .expect(ResponsePredicate.contentType(<span class=\"hljs-string\">\"some/content-type\"</span>))\n  .send(ar -&gt; {\n    <span class=\"hljs-comment\">// ....</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Please refer to the <code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html\">ResponsePredicate</a></code> documentation for a full list of predefined predicates.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_creating_custom_failures\"><a class=\"anchor\" href=\"#_creating_custom_failures\"></a>Creating custom failures</h4>\n<div class=\"paragraph\">\n<p>By default, response predicates (including the predefined ones) use a default error converter which discards\nthe body and conveys a simple message. You can customize the exception class by changing the error converter:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ResponsePredicate predicate = ResponsePredicate.create(ResponsePredicate.SC_SUCCESS, result -&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyCustomException(result.message());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Many web APIs provide details in error responses.\nFor example, the <a href=\"https://developer.marvel.com/docs\">Marvel API</a> uses this JSON object format:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\">{\n <span class=\"hljs-string\">\"code\"</span>: <span class=\"hljs-string\">\"InvalidCredentials\"</span>,\n <span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"The passed API key is invalid.\"</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>To avoid losing this information, it is possible to wait for the response body to be fully received before the error\nconverter is called:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ErrorConverter converter = ErrorConverter.createFullBody(result -&gt; {\n\n  <span class=\"hljs-comment\">// Invoked after the response body is fully received</span>\n  HttpResponse&lt;Buffer&gt; response = result.response();\n\n  <span class=\"hljs-keyword\">if</span> (response.getHeader(<span class=\"hljs-string\">\"content-type\"</span>).equals(<span class=\"hljs-string\">\"application/json\"</span>)) {\n    <span class=\"hljs-comment\">// Error body is JSON data</span>\n    JsonObject body = response.bodyAsJsonObject();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyCustomException(body.getString(<span class=\"hljs-string\">\"code\"</span>), body.getString(<span class=\"hljs-string\">\"message\"</span>));\n  }\n\n  <span class=\"hljs-comment\">// Fallback to defaut message</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyCustomException(result.message());\n});\n\nResponsePredicate predicate = ResponsePredicate.create(ResponsePredicate.SC_SUCCESS, converter);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\ncreating exception in Java can have a performance cost when it captures a stack trace, so you might want\n        to create exceptions that do not capture the stack trace. By default exceptions are reported using the\n        an exception that does not capture the stack trace.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_30x_redirections\"><a class=\"anchor\" href=\"#_handling_30x_redirections\"></a>Handling 30x redirections</h3>\n<div class=\"paragraph\">\n<p>By default the client follows redirections, you can configure the default behavior in the <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientOptions.html\">WebClientOptions</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx, <span class=\"hljs-keyword\">new</span> WebClientOptions().setFollowRedirects(<span class=\"hljs-keyword\">false</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The client will follow at most <code>16</code> requests redirections, it can be changed in the same options:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx, <span class=\"hljs-keyword\">new</span> WebClientOptions().setMaxRedirects(<span class=\"hljs-number\">5</span>));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nFor security reason, client won&#8217;t follow redirects for request with methods different from GET or HEAD\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_https\"><a class=\"anchor\" href=\"#_using_https\"></a>Using HTTPS</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web Client can be configured to use HTTPS in exactly the same way as the Vert.x <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can specify the behavior per request</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">443</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .ssl(<span class=\"hljs-keyword\">true</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Obtain response</span>\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or using create methods with absolute URI argument</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .getAbs(<span class=\"hljs-string\">\"https://myserver.mycompany.com:4043/some-uri\"</span>)\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Obtain response</span>\n      HttpResponse&lt;Buffer&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sessions_management\"><a class=\"anchor\" href=\"#_sessions_management\"></a>Sessions management</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x web offers a web session management facility; to use it, you create a\n<code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code> for every user (session) and use it instead of the\n<code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code>.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_websession\"><a class=\"anchor\" href=\"#_creating_a_websession\"></a>Creating a WebSession</h3>\n<div class=\"paragraph\">\n<p>You create a <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code> instance as follows</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx);\nWebClientSession session = WebClientSession.create(client);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_making_requests_2\"><a class=\"anchor\" href=\"#_making_requests_2\"></a>Making requests</h3>\n<div class=\"paragraph\">\n<p>Once created, a <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code> can be used instead of a\n<code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code> to do HTTP(s) requests and automatically manage any cookies received from the server(s)\nyou are calling.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_setting_session_level_headers\"><a class=\"anchor\" href=\"#_setting_session_level_headers\"></a>Setting session level headers</h3>\n<div class=\"paragraph\">\n<p>You can set any session level headers to be added to every request as follows:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClientSession session = WebClientSession.create(client);\nsession.addHeader(<span class=\"hljs-string\">\"my-jwt-token\"</span>, jwtToken);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The headers will then be added to every request; notice that these headers will be sent to all hosts; if you need\nto send different headers to different hosts, you have to add them manually to every single request and not to the\n<code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code>.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_2_api\"><a class=\"anchor\" href=\"#_rxjava_2_api\"></a>RxJava 2 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The RxJava <code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/client/HttpRequest.html\">HttpRequest</a></code> provides an rx-ified version of the original API,\nthe <code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/client/HttpRequest.html#rxSend--\">rxSend</a></code> method returns a <code>Single&lt;HttpResponse&lt;Buffer&gt;&gt;</code> that\nmakes the HTTP request upon subscription, as consequence, the <code>Single</code> can be subscribed many times.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpResponse&lt;Buffer&gt;&gt; single = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .rxSend();\n\n<span class=\"hljs-comment\">// Send a request upon subscription of the Single</span>\nsingle.subscribe(response -&gt; System.out.println(<span class=\"hljs-string\">\"Received 1st response with status code\"</span> + response.statusCode()), error -&gt; System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + error.getMessage()));\n\n<span class=\"hljs-comment\">// Send another request</span>\nsingle.subscribe(response -&gt; System.out.println(<span class=\"hljs-string\">\"Received 2nd response with status code\"</span> + response.statusCode()), error -&gt; System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + error.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The obtained <code>Single</code> can be composed and chained naturally with the RxJava API</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; url = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .rxSend()\n  .map(HttpResponse::bodyAsString);\n\n<span class=\"hljs-comment\">// Use the flatMap operator to make a request on the URL Single</span>\nurl\n  .flatMap(u -&gt; client.getAbs(u).rxSend())\n  .subscribe(response -&gt; System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode()), error -&gt; System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + error.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same APIs is available</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpResponse&lt;JsonObject&gt;&gt; single = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"some-header\"</span>, <span class=\"hljs-string\">\"header-value\"</span>)\n  .addQueryParam(<span class=\"hljs-string\">\"some-param\"</span>, <span class=\"hljs-string\">\"param value\"</span>)\n  .as(BodyCodec.jsonObject())\n  .rxSend();\nsingle.subscribe(resp -&gt; {\n  System.out.println(resp.statusCode());\n  System.out.println(resp.body());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/client/HttpRequest.html#sendStream-io.reactivex.Flowable-io.vertx.core.Handler-\">sendStream</a></code> shall\nbe preferred for sending bodies <code>Flowable&lt;Buffer&gt;</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Buffer&gt; body = getPayload();\n\nSingle&lt;HttpResponse&lt;Buffer&gt;&gt; single = client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .rxSendStream(body);\nsingle.subscribe(resp -&gt; {\n  System.out.println(resp.statusCode());\n  System.out.println(resp.body());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Upon subscription, the <code>body</code> will be subscribed and its content used for the request.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_domain_sockets\"><a class=\"anchor\" href=\"#_domain_sockets\"></a>Domain sockets</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Since 3.7.1 the Web Client supports domain sockets, e.g you can interact with the <a href=\"https://docs.docker.com/engine/reference/commandline/dockerd/\">local Docker daemon</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To achieve this, the <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> instance must be created using a native transport, you can read\nthe Vert.x core documentation that explains it clearly.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SocketAddress serverAddress = SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/run/docker.sock\"</span>);\n\n<span class=\"hljs-comment\">// We still need to specify host and port so the request HTTP header will be localhost:8080</span>\n<span class=\"hljs-comment\">// otherwise it will be a malformed HTTP request</span>\n<span class=\"hljs-comment\">// the actual value does not matter much for this example</span>\nclient\n  .request(HttpMethod.GET, serverAddress, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/images/json\"</span>)\n  .expect(ResponsePredicate.SC_ACCEPTED)\n  .as(BodyCodec.jsonObject())\n  .send(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Obtain response</span>\n      HttpResponse&lt;JsonObject&gt; response = ar.result();\n\n      System.out.println(<span class=\"hljs-string\">\"Current Docker images\"</span> + response.body());\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"3.9.5"},"__N_SSG":true}