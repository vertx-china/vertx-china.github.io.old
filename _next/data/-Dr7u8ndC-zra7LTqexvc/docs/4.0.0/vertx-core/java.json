{"pageProps":{"slug":"4.0.0/vertx-core/java","title":"Vert.x Core 文档手册","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_in_the_beginning_there_was_vert_x\">故事从 Vert.x 开始</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_specifying_options_when_creating_a_vertx_object\">创建 Vertx 对象时指定配置项</a></li>\n<li><a href=\"#_creating_a_clustered_vert_x_object\">创建集群模式的 Vert.x 对象</a></li>\n</ul>\n</li>\n<li><a href=\"#_are_you_fluent\">是流式的吗？</a></li>\n<li><a href=\"#_dont_call_us_well_call_you\">Don&#8217;t call us, we&#8217;ll call you.</a></li>\n<li><a href=\"#_dont_block_me\">不要阻塞我！</a></li>\n<li><a href=\"#_reactor_and_multi_reactor\">Reactor 模式和 Multi-Reactor 模式</a></li>\n<li><a href=\"#golden_rule\">黄金法则：不要阻塞Event Loop</a></li>\n<li><a href=\"#_future_results\">Future的异步结果</a></li>\n<li><a href=\"#_future_composition\">Future组合</a></li>\n<li><a href=\"#_future_coordination\">Future协作</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_completionstage_interoperability\">兼容CompletionStage</a></li>\n</ul>\n</li>\n<li><a href=\"#_verticles\">Verticles</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_writing_verticles\">编写 Verticle</a></li>\n<li><a href=\"#_asynchronous_verticle_start_and_stop\">Verticle 异步启动和停止</a></li>\n<li><a href=\"#_verticle_types\">Verticle 种类</a></li>\n<li><a href=\"#_standard_verticles\">Standard verticles</a></li>\n<li><a href=\"#worker_verticles\">Worker verticles</a></li>\n<li><a href=\"#_deploying_verticles_programmatically\">编程方式部署Verticle</a></li>\n<li><a href=\"#_rules_for_mapping_a_verticle_name_to_a_verticle_factory\">Verticle名称到Factory的映射规则</a></li>\n<li><a href=\"#_how_are_verticle_factories_located\">如何定位Verticle Factory？</a></li>\n<li><a href=\"#_waiting_for_deployment_to_complete\">等待部署完成</a></li>\n<li><a href=\"#_undeploying_verticle_deployments\">撤销Verticle</a></li>\n<li><a href=\"#_specifying_number_of_verticle_instances\">设置 Verticle 实例数量</a></li>\n<li><a href=\"#_passing_configuration_to_a_verticle\">向 Verticle 传入配置</a></li>\n<li><a href=\"#_accessing_environment_variables_in_a_verticle\">在 Verticle 中访问环境变量</a></li>\n<li><a href=\"#_high_availability\">高可用性</a></li>\n<li><a href=\"#_running_verticles_from_the_command_line\">从命令行运行Verticle</a></li>\n<li><a href=\"#_causing_vert_x_to_exit\">退出 Vert.x 环境</a></li>\n<li><a href=\"#_the_context_object\">Context 对象</a></li>\n<li><a href=\"#_executing_periodic_and_delayed_actions\">执行周期性/延迟性操作</a></li>\n<li><a href=\"#_verticle_worker_pool\">Verticle worker pool</a></li>\n</ul>\n</li>\n<li><a href=\"#event_bus\">Event Bus</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_the_theory\">基本概念</a></li>\n<li><a href=\"#_the_event_bus_api\">Event Bus API</a></li>\n<li><a href=\"#_automatic_clean_up_in_verticles_2\">Verticle 中的自动清理</a></li>\n</ul>\n</li>\n<li><a href=\"#_configuring_the_event_bus\">配置 Event Bus</a></li>\n<li><a href=\"#_json\">JSON</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_json_objects\">JSON objects</a></li>\n<li><a href=\"#_json_arrays\">JSON 数组</a></li>\n</ul>\n</li>\n<li><a href=\"#_json_pointers\">Json 指针（Json Pointers）</a></li>\n<li><a href=\"#_buffers\">Buffers</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_buffers\">创建 Buffer</a></li>\n<li><a href=\"#_writing_to_a_buffer\">向Buffer写入数据</a></li>\n<li><a href=\"#_reading_from_a_buffer\">从Buffer中读取</a></li>\n<li><a href=\"#_working_with_unsigned_numbers\">使用无符号数</a></li>\n<li><a href=\"#_buffer_length\">Buffer长度</a></li>\n<li><a href=\"#_copying_buffers\">拷贝Buffer</a></li>\n<li><a href=\"#_slicing_buffers\">裁剪Buffer</a></li>\n<li><a href=\"#_buffer_re_use\">Buffer 重用</a></li>\n</ul>\n</li>\n<li><a href=\"#_writing_tcp_servers_and_clients\">编写 TCP 服务端和客户端</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_tcp_server\">创建 TCP 服务端</a></li>\n<li><a href=\"#_configuring_a_tcp_server\">配置 TCP 服务端</a></li>\n<li><a href=\"#_start_the_server_listening\">启动服务端监听</a></li>\n<li><a href=\"#_listening_on_a_random_port\">监听随机端口</a></li>\n<li><a href=\"#_getting_notified_of_incoming_connections\">接收传入连接的通知</a></li>\n<li><a href=\"#_reading_data_from_the_socket\">从Socket读取数据</a></li>\n<li><a href=\"#_writing_data_to_a_socket\">向Socket中写入数据</a></li>\n<li><a href=\"#_closed_handler\">关闭处理器</a></li>\n<li><a href=\"#_handling_exceptions\">处理异常</a></li>\n<li><a href=\"#_event_bus_write_handler\">Event Bus 写处理器</a></li>\n<li><a href=\"#_local_and_remote_addresses\">本地和远程地址</a></li>\n<li><a href=\"#_sending_files_or_resources_from_the_classpath\">发送文件或 Classpath 中的资源</a></li>\n<li><a href=\"#_streaming_sockets\">流式的Socket</a></li>\n<li><a href=\"#_upgrading_connections_to_ssltls\">升级到 SSL/TLS 连接</a></li>\n<li><a href=\"#_closing_a_tcp_server\">关闭 TCP 服务端</a></li>\n<li><a href=\"#_automatic_clean_up_in_verticles_3\">Verticle中的自动清理</a></li>\n<li><a href=\"#_scaling_sharing_tcp_servers\">扩展 - 共享 TCP 服务端</a></li>\n<li><a href=\"#_creating_a_tcp_client\">创建 TCP 客户端</a></li>\n<li><a href=\"#_configuring_a_tcp_client\">配置 TCP 客户端</a></li>\n<li><a href=\"#_making_connections\">创建连接</a></li>\n<li><a href=\"#_configuring_connection_attempts\">配置连接重试</a></li>\n<li><a href=\"#logging_network_activity\">记录网络活动</a></li>\n<li><a href=\"#ssl\">配置服务端和客户端以使用SSL/TLS</a></li>\n<li><a href=\"#_using_a_proxy_for_client_connections\">客户端连接使用代理</a></li>\n<li><a href=\"#_using_ha_proxy_protocol\">使用HA PROXY协议</a></li>\n</ul>\n</li>\n<li><a href=\"#_writing_http_servers_and_clients\">编写 HTTP 服务端和客户端</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_an_http_server\">创建 HTTP 服务端</a></li>\n<li><a href=\"#_configuring_an_http_server\">配置 HTTP 服务端</a></li>\n<li><a href=\"#_configuring_an_http2_server\">配置 HTTP/2 服务端</a></li>\n<li><a href=\"#_logging_network_server_activity\">服务端网络活动日志</a></li>\n<li><a href=\"#_start_the_server_listening_2\">开启服务端监听</a></li>\n<li><a href=\"#_getting_notified_of_incoming_requests\">收到传入请求的通知</a></li>\n<li><a href=\"#_handling_requests\">处理请求</a></li>\n<li><a href=\"#_sending_back_responses\">返回响应</a></li>\n<li><a href=\"#_http_compression\">HTTP 压缩</a></li>\n<li><a href=\"#_creating_an_http_client\">创建 HTTP 客户端</a></li>\n<li><a href=\"#_logging_network_client_activity\">客户端网络活动日志</a></li>\n<li><a href=\"#_making_requests\">发送请求</a></li>\n<li><a href=\"#_handling_http_responses\">处理 HTTP 响应</a></li>\n<li><a href=\"#_enabling_compression_on_the_client\">客户端启用压缩</a></li>\n<li><a href=\"#_http1_x_pooling_and_keep_alive\">HTTP/1.x pooling 和 keep alive</a></li>\n<li><a href=\"#_http1_1_pipe_lining\">HTTP/1.1 pipe-lining</a></li>\n<li><a href=\"#_http2_multiplexing\">HTTP/2 多路复用</a></li>\n<li><a href=\"#_http_connections\">HTTP 连接</a></li>\n<li><a href=\"#_httpclient_usage\">HttpClient 使用说明</a></li>\n<li><a href=\"#_server_sharing\">水平扩展 - 服务端共享</a></li>\n<li><a href=\"#_using_https_with_vert_x\">使用 HTTPS</a></li>\n<li><a href=\"#_websockets\">WebSockets</a></li>\n<li><a href=\"#_using_a_proxy_for_httphttps_connections\">使用 HTTP/HTTPS 连接代理</a></li>\n<li><a href=\"#_using_ha_proxy_protocol_2\">使用HA代理协议</a></li>\n<li><a href=\"#_automatic_clean_up_in_verticles_4\">Verticle 中自动清理</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_shareddata_api\">使用共享数据的API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_local_maps\">Local maps</a></li>\n<li><a href=\"#_asynchronous_shared_maps\">异步共享的 maps</a></li>\n<li><a href=\"#_asynchronous_locks\">异步锁</a></li>\n<li><a href=\"#_asynchronous_counters\">异步计数器</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_file_system_with_vert_x\">使用 Vert.x 访问文件系统</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_asynchronous_files\">异步文件访问</a></li>\n</ul>\n</li>\n<li><a href=\"#_datagram_sockets_udp\">数据报套接字（UDP）</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_datagramsocket\">创建 DatagramSocket</a></li>\n<li><a href=\"#_sending_datagram_packets\">发送数据报包</a></li>\n<li><a href=\"#_receiving_datagram_packets\">接收数据报包</a></li>\n<li><a href=\"#_multicast\">多播</a></li>\n</ul>\n</li>\n<li><a href=\"#_dns_client\">DNS 客户端</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_lookup\">lookup</a></li>\n<li><a href=\"#_lookup4\">lookup4</a></li>\n<li><a href=\"#_lookup6\">lookup6</a></li>\n<li><a href=\"#_resolvea\">resolveA</a></li>\n<li><a href=\"#_resolveaaaa\">resolveAAAA</a></li>\n<li><a href=\"#_resolvecname\">resolveCNAME</a></li>\n<li><a href=\"#_resolvemx\">resolveMX</a></li>\n<li><a href=\"#_resolvetxt\">resolveTXT</a></li>\n<li><a href=\"#_resolvens\">resolveNS</a></li>\n<li><a href=\"#_resolvesrv\">resolveSRV</a></li>\n<li><a href=\"#_resolveptr\">resolvePTR</a></li>\n<li><a href=\"#_reverselookup\">reverseLookup</a></li>\n<li><a href=\"#_error_handling\">错误处理</a></li>\n</ul>\n</li>\n<li><a href=\"#streams\">流</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_readstream\">ReadStream</a></li>\n<li><a href=\"#_writestream\">WriteStream</a></li>\n</ul>\n</li>\n<li><a href=\"#_record_parser\">记录解析器（Record Parser）</a></li>\n<li><a href=\"#_json_parser\">Json 解析器</a></li>\n<li><a href=\"#_thread_safety\">线程安全</a></li>\n<li><a href=\"#blocking_code\">运行阻塞式代码</a></li>\n<li><a href=\"#_metrics_spi\">Metrics SPI</a></li>\n<li><a href=\"#_the_vertx_command_line\">\"vertx\" 命令行</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_run_verticles\">运行 Verticles</a></li>\n<li><a href=\"#_executing_a_vert_x_application_packaged_as_a_fat_jar\">执行打包成 fat-jar 的Vert.x 应用</a></li>\n<li><a href=\"#_displaying_version_of_vert_x\">显示Vert.x的版本</a></li>\n<li><a href=\"#_other_commands\">其他命令</a></li>\n<li><a href=\"#_live_redeploy\">实时重部署</a></li>\n</ul>\n</li>\n<li><a href=\"#_cluster_managers\">集群管理器</a></li>\n<li><a href=\"#_logging\">日志记录</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_configuring_with_the_system_property\">通过系统属性配置</a></li>\n<li><a href=\"#_automatic_configuration\">自动配置</a></li>\n<li><a href=\"#_configuring_jul_logging\">配置JUL日志记录</a></li>\n<li><a href=\"#netty-logging\">Netty 日志记录</a></li>\n<li><a href=\"#_troubleshooting\">故障排除</a></li>\n</ul>\n</li>\n<li><a href=\"#_host_name_resolution\">主机名解析</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_failover\">故障转移</a></li>\n<li><a href=\"#_server_list_rotation\">服务器列表轮询</a></li>\n<li><a href=\"#_hosts_mapping\">主机映射</a></li>\n<li><a href=\"#_search_domains\">DNS搜索域</a></li>\n</ul>\n</li>\n<li><a href=\"#_high_availability_and_fail_over\">高可用与故障转移</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_automatic_failover\">自动故障转移</a></li>\n<li><a href=\"#_ha_groups\">高可用组</a></li>\n<li><a href=\"#_dealing_with_network_partitions_quora\">处理网络分区 - Quora</a></li>\n</ul>\n</li>\n<li><a href=\"#_native_transports\">本地传输</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_native_linux_transport\">Linux 下的本地传输</a></li>\n<li><a href=\"#_native_bsd_transport\">BSD 下的本地传输</a></li>\n<li><a href=\"#_domain_sockets\">域套接字</a></li>\n</ul>\n</li>\n<li><a href=\"#_security_notes\">安全提示</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_web_applications\">Web 应用</a></li>\n<li><a href=\"#_clustered_event_bus_traffic\">集群模式事件总线流量</a></li>\n<li><a href=\"#_standard_security_best_practices\">安全方面的标准最佳实践</a></li>\n</ul>\n</li>\n<li><a href=\"#_vert_x_command_line_interface_api\">Vert.x 命令行界面（CLI）API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_definition_stage\">定义阶段</a></li>\n<li><a href=\"#_parsing_stage\">解析阶段</a></li>\n<li><a href=\"#query_interrogation_stage\">查询/问答交互阶段</a></li>\n<li><a href=\"#_typed_options_and_arguments\">类型化的选项和参数</a></li>\n<li><a href=\"#_using_annotations\">注解的使用</a></li>\n</ul>\n</li>\n<li><a href=\"#_the_vert_x_launcher\">Vert.x 启动器（Launcher）</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_extending_the_vert_x_launcher\">扩展 Vert.x 启动器（Launcher）</a></li>\n<li><a href=\"#_using_the_launcher_in_fat_jars\">在 fat-jar 中使用启动器（Launcher）</a></li>\n<li><a href=\"#_sub_classing_the_launcher\">启动器（Launcher）子类</a></li>\n<li><a href=\"#_launcher_and_exit_code\">启动器（Launcher）和退出代码</a></li>\n</ul>\n</li>\n<li><a href=\"#_configuring_vert_x_cache\">配置 Vert.x 缓存</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Core 文档手册</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 的核心 Java API 被我们称为 <strong>Vert.x Core</strong></p>\n</div>\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/eclipse/vert.x\">Github仓库</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Core 提供了下列功能：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>编写 TCP 客户端和服务端</p>\n</li>\n<li>\n<p>编写支持 WebSocket 的 HTTP 客户端和服务端</p>\n</li>\n<li>\n<p>事件总线</p>\n</li>\n<li>\n<p>共享数据 —— 本地的Map和分布式集群Map</p>\n</li>\n<li>\n<p>周期性、延迟性动作</p>\n</li>\n<li>\n<p>部署和撤销 Verticle 实例</p>\n</li>\n<li>\n<p>数据报套接字</p>\n</li>\n<li>\n<p>DNS客户端</p>\n</li>\n<li>\n<p>文件系统访问</p>\n</li>\n<li>\n<p>高可用性</p>\n</li>\n<li>\n<p>本地传输</p>\n</li>\n<li>\n<p>集群</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Core中的功能相当底层，不包含诸如数据库访问、授权或高层Web应用的功能。\n您可以在 <strong>Vert.x ext</strong> （扩展包）（译者注：Vert.x的扩展包是Vert.x的子项目集合，类似 <a href=\"../../vertx-web/java/\">Web</a>、 <a href=\"../../vertx-web-client/java/\">Web Client</a>、 <a href=\"../../#databases\">Databases</a>等）中找到这些功能。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Vert.x Core</strong> 小巧而轻便，您可以只使用您需要的部分，\n它可整体嵌入现存应用中。\nVert.x没有强制要求使用特定的方式构造应用。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x也支持在其他语言中使用Vert.x Core，\n而且在使用诸如 JavaScript 或 Ruby 等语言编写Vert.x代码时，无需直接调用 Java的API；毕竟不同的语言有不同的代码风格，\n若强行让 Ruby 开发人员遵循 Java 的代码风格会很怪异，\n所以我们根据 Java API 自动生成了适应不同语言代码风格的 API。</p>\n</div>\n<div class=\"paragraph\">\n<p>从现在开始，我们将仅使用 <strong>core</strong> 以指代 Vert.x core 。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您在使用 Maven 或 Gradle（译者注：两种常用的项目构建工具），\n将以下依赖项添加到项目描述文件的 <em>dependencies</em> 节点即可使用 <strong>Vert.x Core</strong> 的API：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （您的 <code>pom.xml</code> 中）</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-core<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （您的 <code>build.gradle</code> 中）</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-core:4.0.0'</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>接下来讨论 Vert.x Core 的概念和特性。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_in_the_beginning_there_was_vert_x\"><a class=\"anchor\" href=\"#_in_the_beginning_there_was_vert_x\"></a>故事从 Vert.x 开始</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用Vert.x进行开发离不开 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>它是 Vert.x 的控制中心，也是您做几乎一切事情的基础，包括创建客户端和服务器、\n获取事件总线的引用、设置定时器等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>那么如何获取它的实例呢？</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您用嵌入方式使用Vert.x，可通过以下代码创建实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = Vertx.vertx();</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n大部分应用将只会需要一个Vert.x实例，但如果您有需要也可创建多个Vert.x实例，\n如：隔离的事件总线或不同组的客户端和服务器。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_specifying_options_when_creating_a_vertx_object\"><a class=\"anchor\" href=\"#_specifying_options_when_creating_a_vertx_object\"></a>创建 Vertx 对象时指定配置项</h3>\n<div class=\"paragraph\">\n<p>如果缺省的配置不适合您，可在创建 <code>Vertx</code> 对象的同时指定配置项：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = Vertx.vertx(<span class=\"hljs-keyword\">new</span> VertxOptions().setWorkerPoolSize(<span class=\"hljs-number\">40</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html\">VertxOptions</a></code> 对象有很多配置，包括集群、高可用、池大小等。在Javadoc中描述了所有配置的细节。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_clustered_vert_x_object\"><a class=\"anchor\" href=\"#_creating_a_clustered_vert_x_object\"></a>创建集群模式的 Vert.x 对象</h3>\n<div class=\"paragraph\">\n<p>如果您想创建一个 <strong>集群模式的 Vert.x</strong> 对象（参考 <a href=\"#event_bus\">event bus</a> 章节了解更多事件总线集群细节），\n那么通常情况下您将需要使用另一种异步的方式来创建 <code>Vertx</code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是因为让不同的 Vert.x 实例组成一个集群需要一些时间（也许是几秒钟）。\n在这段时间内，我们不想去阻塞调用线程，所以我们将结果异步返回给您。</p>\n</div>\n<div class=\"quoteblock\">\n<blockquote>\n<div class=\"paragraph\">\n<p>译者注：这里给个示例：</p>\n</div>\n</blockquote>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// 注意要添加对应的集群管理器依赖，详情见集群管理器章节</span>\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions();\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result(); <span class=\"hljs-comment\">// 获取到了集群模式下的 Vertx 对象</span>\n    <span class=\"hljs-comment\">// 做一些其他的事情</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 获取失败，可能是集群管理器出现了问题</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_are_you_fluent\"><a class=\"anchor\" href=\"#_are_you_fluent\"></a>是流式的吗？</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您也许注意到前边的例子里使用了一个 <strong>流式（Fluent）</strong> 的API。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个流式的API表示将多个方法的调用链在一起。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.response().putHeader(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>).end(<span class=\"hljs-string\">\"some text\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这是贯穿 Vert.x API 中的一个通用模式，所以请适应这种代码风格。</p>\n</div>\n<div class=\"paragraph\">\n<p>流式调用可以让代码更为简洁。\n当然，Vert.x并 <strong>不强制</strong> 您用这种方式书写代码，如果您更倾向于用以下非流式编码，\n您可以忽略它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.putHeader(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>);\nresponse.write(<span class=\"hljs-string\">\"some text\"</span>);\nresponse.end();</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_dont_call_us_well_call_you\"><a class=\"anchor\" href=\"#_dont_call_us_well_call_you\"></a>Don&#8217;t call us, we&#8217;ll call you.</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 的 API 大部分都是 <em>事件驱动</em> 的。这意味着当您感兴趣的事情发生时，\n会以事件的形式发送给您。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一些事件的例子：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>触发一个计时器</p>\n</li>\n<li>\n<p>Socket 收到了一些数据</p>\n</li>\n<li>\n<p>从磁盘中读取了一些数据</p>\n</li>\n<li>\n<p>发生了一个异常</p>\n</li>\n<li>\n<p>HTTP 服务器收到了一个请求</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x API调用您提供的 <em>处理器</em> 来处理事件。\n例如每隔一秒发送一个事件的计时器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.setPeriodic(<span class=\"hljs-number\">1000</span>, id -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器将会每隔一秒被调用一次</span>\n  System.out.println(<span class=\"hljs-string\">\"timer fired!\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>又比如收到一个HTTP请求：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-comment\">// 服务器每次收到一个HTTP请求时这个处理器将被调用</span>\n  request.response().end(<span class=\"hljs-string\">\"hello world!\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>稍后当Vert.x有事件要传给您的处理器时，它会 <strong>异步地</strong> 调用这个处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>由此，下面会引入Vert.x中一些重要的概念。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_dont_block_me\"><a class=\"anchor\" href=\"#_dont_block_me\"></a>不要阻塞我！</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x中的几乎所有API都不会阻塞调用线程，除了个别特例（如以 \"Sync\" 结尾的某些文件系统操作）。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以立即提供结果的API会立即返回，否则您需要提供一个处理器（<code>Handler</code>）\n来接收稍后回调的事件。</p>\n</div>\n<div class=\"paragraph\">\n<p>因为Vert.x API不会阻塞线程，\n所以通过Vert.x您可以只使用少量的线程来处理大量的并发。</p>\n</div>\n<div class=\"paragraph\">\n<p>当使用传统的阻塞式API做以下操作时，调用线程可能会被阻塞：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>从 Socket 中读取数据</p>\n</li>\n<li>\n<p>写数据到磁盘</p>\n</li>\n<li>\n<p>发送消息给接收者并等待回复</p>\n</li>\n<li>\n<p>其他很多情况</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在上述情况下，线程在等待处理结果时它不能做任何事，此时这些线程并无实际用处。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着如果使用阻塞式API处理大量并发，\n需要大量线程来防止应用程序停止运转。</p>\n</div>\n<div class=\"paragraph\">\n<p>而这些线程使用的内存（例如它们的栈）和线程上下文切换开销很可观。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着，阻塞式的方式对于现代应用程序所需要的并发级别来说是难于扩展的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reactor_and_multi_reactor\"><a class=\"anchor\" href=\"#_reactor_and_multi_reactor\"></a>Reactor 模式和 Multi-Reactor 模式</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>我们前边提过 Vert.x 的 API 都是事件驱动的，当有事件时 Vert.x 会将事件传给处理器来处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>在多数情况下，Vert.x使用被称为 <strong>Event Loop</strong> 的线程来调用您的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于Vert.x或应用程序的代码块中没有阻塞，<strong>Event Loop</strong>\n可以在事件到达时快速地分发到不同的处理器中。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于没有阻塞，Event Loop 可在短时间内分发大量的事件。\n例如，一个单独的 <strong>Event Loop</strong> 可以非常迅速地处理数千个 HTTP 请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们称之为 <a href=\"https://en.wikipedia.org/wiki/Reactor_pattern\">Reactor 模式</a>（译者注：Reactor Pattern 翻译成了 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F\">反应器模式</a>）。</p>\n</div>\n<div class=\"paragraph\">\n<p>您之前也许听说过它，例如 Node.js 实现了这种模式。</p>\n</div>\n<div class=\"paragraph\">\n<p>在一个标准的Reactor实现中，有 <strong>一个独立的 Event Loop</strong> 会循环执行，\n处理所有到达的事件并传递给处理器处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>单一线程的问题在于它在任意时刻只能运行在一个核上，\n如果您希望单线程反应器应用（如您的 Node.js 应用）扩展到多核服务器上，\n则需要启动并且管理多个不同的进程。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x的工作方式有所不同。每个 <code>Vertx</code> 实例维护的是 <strong>多个Event Loop 线程</strong>。\n默认情况下，我们会根据机器上可用的核数量来设置 Event Loop 的数量，您亦可自行设置。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着 Vertx 进程能够在您的服务器上扩展，与 Node.js 不同。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们将这种模式称为 <strong>Multi-Reactor 模式</strong>（多反应器模式），区别于单线程的 Reactor 模式（反应器模式）。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n即使一个 <code>Vertx</code> 实例维护了多个 Event Loop，任何一个特定的处理器永远不会被并发执行。\n大部分情况下（除了 <a href=\"#worker_verticles\">Worker Verticle</a> 以外）\n它们总是在同一个 Event Loop 线程中被调用。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"golden_rule\"><a class=\"anchor\" href=\"#golden_rule\"></a>黄金法则：不要阻塞Event Loop</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>尽管Vert.x 的 API 都是非阻塞式的，且不会阻塞 Event Loop，\n但是用户编写的处理器中可能会阻塞 Event Loop。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果这样做，该 Event Loop 在被阻塞时就不能做任何事情；如果您阻塞了 <code>Vertx</code>\n实例中的所有Event Loop，那么您的应用就会完全停止！</p>\n</div>\n<div class=\"paragraph\">\n<p>所以不要这样做！<strong>这是一个警告!</strong></p>\n</div>\n<div class=\"paragraph\">\n<p>这些阻塞做法包括：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Thead.sleep()</p>\n</li>\n<li>\n<p>等待一个锁</p>\n</li>\n<li>\n<p>等待一个互斥信号或监视器（例如同步的代码块）</p>\n</li>\n<li>\n<p>执行一个长时间数据库操作并等待其结果</p>\n</li>\n<li>\n<p>执行一个复杂的计算，占用了可感知的时长</p>\n</li>\n<li>\n<p>在循环语句中长时间逗留</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>如果上述任何一种情况停止了 Event Loop 并占用了 <strong>显著执行时间</strong> ，\n那您应该去面壁（译者注：原文此处为 Naughy Step，英国父母会在家里选择一个角落作为小孩罚站或静坐的地方，被称为 naughty corner 或 naughty step），等待下一步的指示。</p>\n</div>\n<div class=\"paragraph\">\n<p>所以，什么是 <strong>显著执行时间</strong> ？</p>\n</div>\n<div class=\"paragraph\">\n<p>您要等多久？它取决于您的应用程序和所需的并发数量。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您只有单个 Event Loop，而且您希望每秒处理10000个 HTTP 请求，\n很明显的是每一个请求处理时间不可以超过0.1毫秒，所以您不能阻塞任何过多（大于0.1毫秒）的时间。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>这个数学题并不难，将留给读者作为练习。</strong></p>\n</div>\n<div class=\"paragraph\">\n<p>如果您的应用程序没有响应，可能这是一个迹象，表明您在某个地方阻塞了Event Loop。\n为了帮助您诊断类似问题，若 Vert.x 检测到 Event Loop 有一段时间没有响应，将会自动记录这种警告。\n若您在日志中看到类似警告，那么您需要检查您的代码。比如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 还将提供堆栈跟踪，以精确定位发生阻塞的位置。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果想关闭这些警告或更改设置，您可以在创建 <code>Vertx</code> 对象之前在\n<code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html\">VertxOptions</a></code> 中完成此操作。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_future_results\"><a class=\"anchor\" href=\"#_future_results\"></a>Future的异步结果</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 4使用future承载异步结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>异步的方法会返回一个 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code> 对象，其包含\n<em>成功</em> 或 <em>失败</em> 的异步结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们不能直接操作future的异步结果，而应该设置future的handler；\n当future执行完毕，结果可用时，会调用handler进行处理。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\n\nFuture&lt;FileProps&gt; future = fs.props(<span class=\"hljs-string\">\"/my_file.txt\"</span>);\n\nfuture.onComplete((AsyncResult&lt;FileProps&gt; ar) -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    FileProps props = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"File size = \"</span> + props.size());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nVert.x 3的API只提供了回调模式；为了减少从Vert.x 3迁移到Vert.x 4的工作量，Vert.x 4为每个异步方法都保留了回调版本。\n如上面样例代码的 <code>props</code> 方法，提供了带回调参数的版本\n<code><a href=\"../../apidocs/io/vertx/core/file/FileSystem.html#props-java.lang.String-io.vertx.core.Handler-\">props</a></code>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_future_composition\"><a class=\"anchor\" href=\"#_future_composition\"></a>Future组合</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/Future.html#compose-java.util.function.Function-\">compose</a></code> 方法作用于顺序组合 future：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>若当前future成功，执行 <code>compose</code> 方法指定的方法，该方法返回新的future；当返回的新future完成时，future组合成功；</p>\n</li>\n<li>\n<p>若当前future失败，则future组合失败。</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\n\nFuture&lt;Void&gt; future = fs\n  .createFile(<span class=\"hljs-string\">\"/foo\"</span>)\n  .compose(v -&gt; {\n    <span class=\"hljs-comment\">// createFile文件创建完成后执行</span>\n    <span class=\"hljs-keyword\">return</span> fs.writeFile(<span class=\"hljs-string\">\"/foo\"</span>, Buffer.buffer());\n  })\n  .compose(v -&gt; {\n    <span class=\"hljs-comment\">// writeFile文件写入完成后执行</span>\n    <span class=\"hljs-keyword\">return</span> fs.move(<span class=\"hljs-string\">\"/foo\"</span>, <span class=\"hljs-string\">\"/bar\"</span>);\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这里例子中，有三个操作被串起来了：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>一个文件被创建（<code>createFile</code>）</p>\n</li>\n<li>\n<p>一些东西被写入到文件（<code>writeFile</code>）</p>\n</li>\n<li>\n<p>文件被移走（<code>move</code>）</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>如果这三个步骤全部成功，则最终的 <code>Future</code>（<code>future</code>）会是成功的；\n其中任何一步失败，则最终 <code>Future</code> 就是失败的。</p>\n</div>\n<div class=\"paragraph\">\n<p>除了上述方法， <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code> 还提供了更多方法：<code>map</code>，<code>recover</code>，<code>otherwise</code>，以及 <code>flatMap</code> （等同 <code>compose</code> 方法）。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_future_coordination\"><a class=\"anchor\" href=\"#_future_coordination\"></a>Future协作</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 中的 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">futures</a></code> 支持协调多个Future，\n支持并发组合（并行执行多个异步调用）和顺序组合\n（依次执行异步调用）。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/CompositeFuture.html#all-io.vertx.core.Future-io.vertx.core.Future-\">CompositeFuture.all</a></code> 方法接受多个 <code>Future</code> 对象作为参数（最多6个，或者传入 <code>List</code>）。\n当所有的 <code>Future</code> 都成功完成，该方法将返回一个 <em>成功的</em> <code>Future</code>；当任一个 <code>Future</code> 执行失败，则返回一个 <em>失败的</em> <code>Future</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;HttpServer&gt; httpServerFuture = httpServer.listen();\n\nFuture&lt;NetServer&gt; netServerFuture = netServer.listen();\n\nCompositeFuture.all(httpServerFuture, netServerFuture).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 所有服务器启动完成</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 有一个服务器启动失败</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>所有被合并的 <code>Future</code> 中的操作同时运行。当组合的处理操作完成时，该方法返回的 <code>Future</code> 上绑定的处理器（<code><a href=\"../../apidocs/io/vertx/core/Handler.html\">Handler</a></code>）会被调用。\n只要有一个操作失败（其中的某一个 <code>Future</code> 的状态被标记成失败），\n则返回的 <code>Future</code> 会被标记为失败。如果所有的操作都成功，\n则返回的 <code>Future</code> 将会成功完成。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以传入一个 <code>Future</code> 列表（可能为空）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CompositeFuture.all(Arrays.asList(future1, future2, future3));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>all</code> 方法的合并会 <em>等待</em> 所有的 Future 成功执行（或任一失败），\n而 <code>any</code> 方法的合并会 <em>等待</em> 第一个成功执行的Future。<code><a href=\"../../apidocs/io/vertx/core/CompositeFuture.html#any-io.vertx.core.Future-io.vertx.core.Future-\">CompositeFuture.any</a></code> 方法接受多个 <code>Future</code>\n作为参数（最多6个，或传入 <code>List</code>）。当任意一个 <code>Future</code> 成功得到结果，则该 <code>Future</code> 成功；\n当所有的 <code>Future</code> 都执行失败，则该 <code>Future</code> 失败。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CompositeFuture.any(future1, future2).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 至少一个成功</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 所有的都失败</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它也可使用 <code>Future</code> 列表传参：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CompositeFuture.any(Arrays.asList(f1, f2, f3));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>join</code> 方法的合并会 <em>等待</em> 所有的 <code>Future</code> 完成，无论成败。\n<code><a href=\"../../apidocs/io/vertx/core/CompositeFuture.html#join-io.vertx.core.Future-io.vertx.core.Future-\">CompositeFuture.join</a></code> 方法接受多个 <code>Future</code> 作为参数（最多6个），并将结果归并成一个 <code>Future</code> 。\n当全部 <code>Future</code> 成功执行完成，得到的 <code>Future</code> 是成功状态的；当至少一个 <code>Future</code> 执行失败时，\n得到的 <code>Future</code> 是失败状态的。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CompositeFuture.join(future1, future2, future3).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 所有都成功</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 全部完成（无论成功还是失败），且至少一个失败</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它也可使用 <code>Future</code> 列表传参：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CompositeFuture.join(Arrays.asList(future1, future2, future3));</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_completionstage_interoperability\"><a class=\"anchor\" href=\"#_completionstage_interoperability\"></a>兼容CompletionStage</h3>\n<div class=\"paragraph\">\n<p>JDK的 <code>CompletionStage</code> 接口用于组合异步操作，\nVert.x的 <code>Future</code> API可兼容 <code>CompletionStage</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们可以用 <code><a href=\"../../apidocs/io/vertx/core/Future.html#toCompletionStage--\">toCompletionStage</a></code> 方法将Vert.x的 <code>Future</code> 对象转为 <code>CompletionStage</code> 对象，如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;String&gt; future = vertx.createDnsClient().lookup(<span class=\"hljs-string\">\"vertx.io\"</span>);\nfuture.toCompletionStage().whenComplete((ip, err) -&gt; {\n  <span class=\"hljs-keyword\">if</span> (err != <span class=\"hljs-keyword\">null</span>) {\n    System.err.println(<span class=\"hljs-string\">\"Could not resolve vertx.io\"</span>);\n    err.printStackTrace();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"vertx.io =&gt; \"</span> + ip);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>相应地，可使用 <code><a href=\"../../apidocs/io/vertx/core/Future.html#fromCompletionStage-java.util.concurrent.CompletionStage-\">Future.fromCompletionStage</a></code> 方法将 <code>CompletionStage</code> 对象转为Vert.x的 <code>Future</code> 对象。\n<code>Future.fromCompletionStage</code> 有两个重载方法：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>第一个重载方法只接收一个 <code>CompletionStage</code> 参数，会在执行 <code>CompletionStage</code> 实例的线程中调用 <code>Future</code> 的方法；</p>\n</li>\n<li>\n<p>第二个重载方法额外多接收一个 <code><a href=\"../../apidocs/io/vertx/core/Context.html\">Context</a></code> 参数，会在Vert.x的Context中调用 <code>Future</code> 的方法。</p>\n</li>\n</ol>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n由于Vert.x的 <code>Future</code> 通常会与Vert.x的代码、库以及客户端等一起使用，为了与Vert.x的线程模型更好地配合，\n大部分场景下应使用 <code>Future.fromCompletionStage(CompletionStage, Context)</code> 方法。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>下面的例子展示了如何将 <code>CompletionStage</code> 对象转为Vert.x的 <code>Future</code> 对象，这里选择使用Vert.x的Context执行:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future.fromCompletionStage(completionStage, vertx.getOrCreateContext())\n  .flatMap(str -&gt; {\n    String key = UUID.randomUUID().toString();\n    <span class=\"hljs-keyword\">return</span> storeInDb(key, str);\n  })\n  .onSuccess(str -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"We have a result: \"</span> + str);\n  })\n  .onFailure(err -&gt; {\n    System.err.println(<span class=\"hljs-string\">\"We have a problem\"</span>);\n    err.printStackTrace();\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_verticles\"><a class=\"anchor\" href=\"#_verticles\"></a>Verticles</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 通过开箱即用的方式提供了一个简单便捷的、可扩展的、类似 <a href=\"https://en.wikipedia.org/wiki/Actor_model\">Actor Model</a> 的部署和并发模型机制。\n您可以用此模型机制来保管您自己的代码组件。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>这个模型是可选的，Vert.x\n并不强制使用这种方式创建应用程序。</strong></p>\n</div>\n<div class=\"paragraph\">\n<p>这个模型并不是严格的 Actor 模式实现，但它确实有相似之处，\n特别是在并发、扩展性和部署等方面。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用该模型，需要将应用代码编写成多个 <strong>Verticle</strong>。</p>\n</div>\n<div class=\"paragraph\">\n<p>Verticle 是由 Vert.x 部署和运行的代码块。默认情况一个 Vert.x 实例维护了N个 Event Loop\n线程（默认情况下N = CPU核数 x 2）。Verticle 实例可使用任意 Vert.x 支持的编程语言编写，\n而且一个简单的应用程序也可以包含多种语言编写的 Verticle。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以将 Verticle 想成 <a href=\"http://en.wikipedia.org/wiki/Actor_model\">Actor Model</a> 中的 Actor。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个应用程序通常是由在同一个 Vert.x 实例中同时运行的许多 Verticle 实例组合而成。\n不同的 Verticle 实例通过向 <a href=\"#event_bus\">Event Bus</a> 上发送消息来相互通信。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_verticles\"><a class=\"anchor\" href=\"#_writing_verticles\"></a>编写 Verticle</h3>\n<div class=\"paragraph\">\n<p>Verticle 的实现类必须实现 <code><a href=\"../../apidocs/io/vertx/core/Verticle.html\">Verticle</a></code> 接口。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您喜欢的话，可以直接实现该接口，但是通常直接从抽象类\n<code><a href=\"../../apidocs/io/vertx/core/AbstractVerticle.html\">AbstractVerticle</a></code> 继承更简单。</p>\n</div>\n<div class=\"paragraph\">\n<p>这儿有一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>public class MyVerticle extends AbstractVerticle {\n\n // Verticle部署时调用\n public void start() {\n }\n\n // 可选 - Verticle撤销时调用\n public void stop() {\n }\n\n}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通常您需要像上边例子一样重写 <code>start</code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>当 Vert.x 部署 Verticle 时，它的 <code>start</code> 方法将被调用，这个方法执行完成后 Verticle\n就变成已启动状态。</p>\n</div>\n<div class=\"paragraph\">\n<p>您同样可以重写 <code>stop</code> 方法，当Vert.x 撤销一个 Verticle 时它会被调用，\n这个方法执行完成后 Verticle 就变成已停止状态了。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_asynchronous_verticle_start_and_stop\"><a class=\"anchor\" href=\"#_asynchronous_verticle_start_and_stop\"></a>Verticle 异步启动和停止</h3>\n<div class=\"paragraph\">\n<p>有些时候您的 Verticle 启动会耗费一些时间，您想要在这个过程做一些事，\n并且您做的这些事并不想等到Verticle部署完成过后再发生。如：您想在 <code>start</code> 方法中部署其他的 Verticle。</p>\n</div>\n<div class=\"paragraph\">\n<p>您不能在您的 <code>start</code> 方法中阻塞等待其他的 Verticle 部署完成，这样做会破坏 <a href=\"#golden_rule\">Golden Rule</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>所以您要怎么做？</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以实现 <strong>异步版本</strong> 的 <code>start</code> 方法来实现，它接收一个 <code>Promise</code> 参数。\n方法执行完时，Verticle 实例<strong>并没有</strong>部署好（状态不是 deployed）。</p>\n</div>\n<div class=\"paragraph\">\n<p>当所有您需要做的事（如：启动HTTP服务）完成后，就可以调用 <code>Future</code> 的 <code>complete</code>（或 <code>fail</code> ）\n方法来标记启动完成或失败了。</p>\n</div>\n<div class=\"paragraph\">\n<p>这儿有一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>public class MyVerticle extends AbstractVerticle {\n\n private HttpServer server;\n\n public void start(Future&lt;Void&gt; startFuture) {\n   server = vertx.createHttpServer().requestHandler(req -&gt; {\n     req.response()\n       .putHeader(\"content-type\", \"text/plain\")\n       .end(\"Hello from Vert.x!\");\n     });\n\n   // Now bind the server:\n   server.listen(8080, res -&gt; {\n     if (res.succeeded()) {\n       startFuture.complete();\n     } else {\n       startFuture.fail(res.cause());\n     }\n   });\n }\n}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同样的，这儿也有一个异步版本的 <code>stop</code> 方法，如果您想做一些耗时的 Verticle清理工作，\n您可以使用它。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>public class MyVerticle extends AbstractVerticle {\n\n public void start() {\n   // 做一些事\n }\n\n public void stop(Future&lt;Void&gt; stopFuture) {\n   obj.doSomethingThatTakesTime(res -&gt; {\n     if (res.succeeded()) {\n       stopFuture.complete();\n     } else {\n       stopFuture.fail();\n     }\n   });\n }\n}</pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n在Verticle中启动的HTTP服务，无需在 <code>stop</code> 方法中手动停止；\nVert.x在撤销Verticle时会自动停止运行中的服务。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verticle_types\"><a class=\"anchor\" href=\"#_verticle_types\"></a>Verticle 种类</h3>\n<div class=\"paragraph\">\n<p>这儿有两种 Verticle：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">Standard Verticles</dt>\n<dd>\n<p>这是最常用的一类 Verticle —— 它们永远运行在 Event Loop 线程上。\n更多讨论详见稍后的章节。</p>\n</dd>\n<dt class=\"hdlist1\">Worker Verticles</dt>\n<dd>\n<p>这类 Verticle 会运行在 Worker Pool 中的线程上。\n一个实例绝对不会被多个线程同时执行。</p>\n</dd>\n</dl>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_standard_verticles\"><a class=\"anchor\" href=\"#_standard_verticles\"></a>Standard verticles</h3>\n<div class=\"paragraph\">\n<p>当 Standard Verticle 被创建时，它会被分派给一个 Event Loop 线程，并在这个 Event Loop 中执行它的 <code>start</code> 方法。\n当您在一个 Event Loop 上调用了 Core API 中的方法并传入了处理器时，Vert.x\n将保证用与调用该方法时相同的 Event Loop 来执行这些处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着我们可以保证您的 Verticle 实例中 <strong>所有的代码都是在相同Event Loop中执行</strong>\n（只要您不创建自己的线程来调用它！）</p>\n</div>\n<div class=\"paragraph\">\n<p>同样意味着您可以将您的应用中的所有代码用单线程方式编写，让 Vert.x\n去考虑线程和扩展问题。您不用再考虑 synchronized 和 volatile 的问题，\n也可以避免传统的多线程应用经常会遇到的竞态条件和死锁的问题。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"worker_verticles\"><a class=\"anchor\" href=\"#worker_verticles\"></a>Worker verticles</h3>\n<div class=\"paragraph\">\n<p>Worker Verticle 和 Standard Verticle 很像，但它并不是由一个 Event Loop 来执行，\n而是由Vert.x中的 Worker Pool 中的线程执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>Worker Verticle 设计用于调用阻塞式代码，它不会阻塞任何 Event Loop。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您不想使用 Worker Verticle 来运行阻塞式代码，\n您还可以在一个Event Loop中直接使用 <a href=\"#blocking_code\">内联阻塞式代码</a></p>\n</div>\n<div class=\"paragraph\">\n<p>您需要通过 <code><a href=\"../../apidocs/io/vertx/core/DeploymentOptions.html#setWorker-boolean-\">setWorker</a></code> 方法来将 Verticle 部署成一个 Worker Verticle：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DeploymentOptions options = <span class=\"hljs-keyword\">new</span> DeploymentOptions().setWorker(<span class=\"hljs-keyword\">true</span>);\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在 Vert.x 中，Worker Verticle 实例绝对不会同时被多个线程执行，\n但它可以在不同时间由不同线程执行。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_verticles_programmatically\"><a class=\"anchor\" href=\"#_deploying_verticles_programmatically\"></a>编程方式部署Verticle</h3>\n<div class=\"paragraph\">\n<p>部署Verticle可以使用任意一个 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#deployVerticle-io.vertx.core.Verticle-\">deployVerticle</a></code> 方法，\n并传入一个 Verticle名称或Verticle 实例。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n通过 Verticle <strong>实例</strong> 来部署 Verticle 仅限Java语言。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Verticle myVerticle = <span class=\"hljs-keyword\">new</span> MyVerticle();\nvertx.deployVerticle(myVerticle);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您同样可以指定 Verticle 的 <strong>名称</strong> 来部署它。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个 Verticle 的名称会用于查找实例化 Verticle的特定\n<code><a href=\"../../apidocs/io/vertx/core/spi/VerticleFactory.html\">VerticleFactory</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>不同的 Verticle Factory 可用于实例化不同语言的 Verticle，也可用于其他目的，\n例如加载服务、运行时从Maven中获取Verticle实例等。</p>\n</div>\n<div class=\"paragraph\">\n<p>因此可以部署任何使用Vert.x支持的语言编写的Verticle。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面的例子展示了如何部署多个不同语言编写的 Verticle ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>);\n\n<span class=\"hljs-comment\">// 部署JavaScript的Verticle</span>\nvertx.deployVerticle(<span class=\"hljs-string\">\"verticles/myverticle.js\"</span>);\n\n<span class=\"hljs-comment\">// 部署Ruby的Verticle</span>\nvertx.deployVerticle(<span class=\"hljs-string\">\"verticles/my_verticle.rb\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rules_for_mapping_a_verticle_name_to_a_verticle_factory\"><a class=\"anchor\" href=\"#_rules_for_mapping_a_verticle_name_to_a_verticle_factory\"></a>Verticle名称到Factory的映射规则</h3>\n<div class=\"paragraph\">\n<p>使用名称部署Verticle时，会通过名称来选择一个用于实例化 Verticle\n的 Verticle Factory。</p>\n</div>\n<div class=\"paragraph\">\n<p>Verticle 名称可以增加一个以冒号结尾的前缀，这个前缀用于查找Factory，如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>js:foo.js // 使用JavaScript的Factory\ngroovy:com.mycompany.SomeGroovyCompiledVerticle // 用Groovy的Factory\nservice:com.mycompany:myorderservice // 用Service的Factory</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果不指定前缀，Vert.x将根据Verticle名称的后缀来查找对应Factory，如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>foo.js // 将使用JavaScript的Factory\nSomeScript.groovy // 将使用Groovy的Factory</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若前缀后缀都没指定，Vert.x将假定Verticle名称是一个Java 全限定类名（FQCN），\n并尝试实例化它。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_how_are_verticle_factories_located\"><a class=\"anchor\" href=\"#_how_are_verticle_factories_located\"></a>如何定位Verticle Factory？</h3>\n<div class=\"paragraph\">\n<p>大部分Verticle Factory会从 classpath 中加载，并在 Vert.x 启动时注册。</p>\n</div>\n<div class=\"paragraph\">\n<p>您同样可以使用编程的方式去注册或注销Verticle Factory：通过 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#registerVerticleFactory-io.vertx.core.spi.VerticleFactory-\">registerVerticleFactory</a></code> 方法和\n<code><a href=\"../../apidocs/io/vertx/core/Vertx.html#unregisterVerticleFactory-io.vertx.core.spi.VerticleFactory-\">unregisterVerticleFactory</a></code> 方法。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_waiting_for_deployment_to_complete\"><a class=\"anchor\" href=\"#_waiting_for_deployment_to_complete\"></a>等待部署完成</h3>\n<div class=\"paragraph\">\n<p>Verticle是异步部署的，换而言之，可能在 <code>deploy</code> 方法调用返回后一段时间才会完成部署。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您想要在部署完成时收到通知，则可以指定一个完成处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Deployment id is: \"</span> + res.result());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Deployment failed!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果部署成功，这个完成处理器的结果中将会包含部署ID的字符串。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个部署ID可以用于撤销部署。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_undeploying_verticle_deployments\"><a class=\"anchor\" href=\"#_undeploying_verticle_deployments\"></a>撤销Verticle</h3>\n<div class=\"paragraph\">\n<p>我们可以通过 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#undeploy-java.lang.String-\">undeploy</a></code> 方法来撤销部署好的 Verticle。</p>\n</div>\n<div class=\"paragraph\">\n<p>撤销操作也是异步的，因此若您想要在撤销完成后收到通知，则可以指定另一个完成处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.undeploy(deploymentID, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Undeployed ok\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Undeploy failed!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_specifying_number_of_verticle_instances\"><a class=\"anchor\" href=\"#_specifying_number_of_verticle_instances\"></a>设置 Verticle 实例数量</h3>\n<div class=\"paragraph\">\n<p>使用名称部署 Verticle 时，可以指定需要部署的 Verticle\n实例的数量。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DeploymentOptions options = <span class=\"hljs-keyword\">new</span> DeploymentOptions().setInstances(<span class=\"hljs-number\">16</span>);\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个功能对于跨多核扩展时很有用。例如，您有一个带Web服务的Verticle需要部署在多核的机器上，\n您可以部署多个实例来利用所有的核。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_passing_configuration_to_a_verticle\"><a class=\"anchor\" href=\"#_passing_configuration_to_a_verticle\"></a>向 Verticle 传入配置</h3>\n<div class=\"paragraph\">\n<p>可在部署时传给 Verticle 一个 JSON 格式的配置</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject config = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"tim\"</span>).put(<span class=\"hljs-string\">\"directory\"</span>, <span class=\"hljs-string\">\"/blah\"</span>);\nDeploymentOptions options = <span class=\"hljs-keyword\">new</span> DeploymentOptions().setConfig(config);\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>传入之后，这个配置可以通过 <code><a href=\"../../apidocs/io/vertx/core/Context.html\">Context</a></code> 对象或使用\n<code><a href=\"../../apidocs/io/vertx/core/AbstractVerticle.html#config--\">config</a></code> 方法访问。这个配置会以 JSON 对象（<code>JsonObject</code>）的形式返回，\n因此您可以用下边代码读取数据：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"Configuration: \"</span> + config().getString(<span class=\"hljs-string\">\"name\"</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_accessing_environment_variables_in_a_verticle\"><a class=\"anchor\" href=\"#_accessing_environment_variables_in_a_verticle\"></a>在 Verticle 中访问环境变量</h3>\n<div class=\"paragraph\">\n<p>环境变量和系统属性可以直接通过 Java API 访问：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.getProperty(<span class=\"hljs-string\">\"prop\"</span>);\nSystem.getenv(<span class=\"hljs-string\">\"HOME\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_high_availability\"><a class=\"anchor\" href=\"#_high_availability\"></a>高可用性</h3>\n<div class=\"paragraph\">\n<p>Verticle可以启用高可用方式（HA）部署。在这种方式下，当其中一个部署在\nVert.x 实例中的 Verticle 突然挂掉，这个 Verticle 可以在集群环境中的另一个 Vert.x 实例中重新部署。</p>\n</div>\n<div class=\"paragraph\">\n<p>若要启用高可用方式运行一个 Verticle，仅需要追加 <code>-ha</code> 参数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当启用高可用方式时，不需要追加 <code>-cluster</code> 参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>关于高可用的功能和配置的更多细节可参考\n<a href=\"#_high_availability_and_fail_over\">高可用和故障转移</a></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_running_verticles_from_the_command_line\"><a class=\"anchor\" href=\"#_running_verticles_from_the_command_line\"></a>从命令行运行Verticle</h3>\n<div class=\"paragraph\">\n<p>您可以在 Maven 或 Gradle 项目中以正常方式添加 Vert.x\nCore 为依赖，在项目中直接使用 Vert.x。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以从命令行直接运行 Vert.x 的 Verticle。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，您需要下载并安装 Vert.x 的发行版，并且将安装的 <code>bin</code> 目录添加到您的\n<code>PATH</code> 环境变量中，并确保您的 <code>PATH</code> 中设置了Java 8的JDK环境。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n在 <code>PATH</code> 设置JDK是为了支持Java代码的运行时编译（on the fly compilation）。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>现在您可以使用 <code>vertx run</code> 命令运行Verticle了，下面是一些例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre># 运行JavaScript的Verticle\nvertx run my_verticle.js\n\n# 运行Ruby的Verticle\nvertx run a_n_other_verticle.rb\n\n# 使用集群模式运行Groovy的Verticle\nvertx run FooVerticle.groovy -cluster</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您甚至可以不必编译 Java 源代码，直接运行它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>vertx run SomeJavaSourceFile.java</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 在运行Java 源代码文件之前将执行运行时编译，\n这对于快速原型制作和演示很有用，而且不需要配置 Maven 或 Gradle 就能跑起来！</p>\n</div>\n<div class=\"paragraph\">\n<p>欲了解有关在命令行执行 <code>vertx</code> 可用的各种选项完整信息，\n可以直接在命令行键入 <code>vertx</code> 查看帮助。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_causing_vert_x_to_exit\"><a class=\"anchor\" href=\"#_causing_vert_x_to_exit\"></a>退出 Vert.x 环境</h3>\n<div class=\"paragraph\">\n<p>Vert.x 实例维护的线程不是守护线程，因此它们会阻止JVM退出。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您通过嵌入式的方式使用 Vert.x 并且完成了操作，您可以调用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#close--\">close</a></code>\n方法关闭它。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将关闭所有内部线程池并关闭其他资源，允许JVM退出。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_context_object\"><a class=\"anchor\" href=\"#_the_context_object\"></a>Context 对象</h3>\n<div class=\"paragraph\">\n<p>当 Vert.x 传递一个事件给处理器或者调用 <code><a href=\"../../apidocs/io/vertx/core/Verticle.html\">Verticle</a></code> 的 start 或 stop 方法时，\n它会关联一个 <code>Context</code> 对象来执行。通常来说这个context会是一个\n<strong>event-loop context</strong>，它绑定到了一个特定的 Event Loop 线程上。所以在该context上执行的操作总是\n在同一个 Event Loop 线程中。对于运行内联的阻塞代码的 Worker Verticle 来说，会关联一个\nWorker Context，并且所有的操作运都会运行在 Worker 线程池的线程上。（译者注：每个 <code>Verticle</code> 在部署的时候都会被分配一个 <code>Context</code>（根据配置不同，可以是Event Loop Context 或者 Worker Context），之后此 <code>Verticle</code> 上所有的普通代码都会在此 <code>Context</code> 上执行（即对应的 Event Loop 或Worker 线程）。一个 <code>Context</code> 对应一个 Event Loop 线程（或 Worker 线程），但一个 Event Loop 可能对应多个 <code>Context</code>。）</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--\">getOrCreateContext</a></code> 方法获取 <code>Context</code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Context context = vertx.getOrCreateContext();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若已经有一个context和当前线程关联，那么它直接重用这个context对象，\n如果没有则创建一个新的。您可以检查获取的context的 <em>类型</em> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Context context = vertx.getOrCreateContext();\n<span class=\"hljs-keyword\">if</span> (context.isEventLoopContext()) {\n  System.out.println(<span class=\"hljs-string\">\"Context attached to Event Loop\"</span>);\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (context.isWorkerContext()) {\n  System.out.println(<span class=\"hljs-string\">\"Context attached to Worker Thread\"</span>);\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (! Context.isOnVertxThread()) {\n  System.out.println(<span class=\"hljs-string\">\"Context not attached to a thread managed by vert.x\"</span>);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您获取了这个context对象，您就可以在context中异步执行代码了。换句话说，\n您提交的任务将会在同一个context中运行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.getOrCreateContext().runOnContext( (v) -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"This will be executed asynchronously in the same context\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当在同一个context中运行了多个处理函数时，可能需要在它们之间共享数据。\ncontext对象提供了存储和读取共享数据的方法。举例来说，它允许您将数据传递到\n <code><a href=\"../../apidocs/io/vertx/core/Context.html#runOnContext-io.vertx.core.Handler-\">runOnContext</a></code> 方法运行的某些操作中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">final</span> Context context = vertx.getOrCreateContext();\ncontext.put(<span class=\"hljs-string\">\"data\"</span>, <span class=\"hljs-string\">\"hello\"</span>);\ncontext.runOnContext((v) -&gt; {\n  String hello = context.get(<span class=\"hljs-string\">\"data\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还可以通过 <code><a href=\"../../apidocs/io/vertx/core/Context.html#config--\">config</a></code>\n方法访问 Verticle 的配置信息。查看 <a href=\"#_passing_configuration_to_a_verticle\">向 Verticle 传入配置</a> 章节了解更多配置信息。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_executing_periodic_and_delayed_actions\"><a class=\"anchor\" href=\"#_executing_periodic_and_delayed_actions\"></a>执行周期性/延迟性操作</h3>\n<div class=\"paragraph\">\n<p>在 Vert.x 中，延迟执行或定期执行操作很常见。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Standard Verticle 中您不能直接让线程休眠以引入延迟，因为它会阻塞 Event Loop 线程。</p>\n</div>\n<div class=\"paragraph\">\n<p>取而代之是使用 Vert.x 定时器。定时器可以是 <strong>一次性</strong> 或 <strong>周期性</strong> 的，两者我们都会讨论到。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_one_shot_timers\"><a class=\"anchor\" href=\"#_one_shot_timers\"></a>一次性计时器</h4>\n<div class=\"paragraph\">\n<p>一次性计时器会在一定延迟后调用一个 Event Handler，以毫秒为单位计时。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-\">setTimer</a></code> 方法传递延迟时间和一个处理器来设置计时器的触发。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">long</span> timerID = vertx.setTimer(<span class=\"hljs-number\">1000</span>, id -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"And one second later this is printed\"</span>);\n});\n\nSystem.out.println(<span class=\"hljs-string\">\"First this is printed\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>返回值是一个唯一的计时器id，该id可用于之后取消该计时器，这个计时器id会传入给处理器。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_periodic_timers\"><a class=\"anchor\" href=\"#_periodic_timers\"></a>周期性计时器</h4>\n<div class=\"paragraph\">\n<p>您同样可以使用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#setPeriodic-long-io.vertx.core.Handler-\">setPeriodic</a></code> 方法设置一个周期性触发的计时器。</p>\n</div>\n<div class=\"paragraph\">\n<p>第一次触发之前同样会有一段设置的延时时间。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>setPeriodic</code> 方法的返回值也是一个唯一的计时器id，若之后该计时器需要取消则使用该id。</p>\n</div>\n<div class=\"paragraph\">\n<p>传给处理器的参数也是这个唯一的计时器id。</p>\n</div>\n<div class=\"paragraph\">\n<p>请记住这个计时器将会定期触发。如果您的定时任务会花费大量的时间，则您的计时器事件可能会连续执行,\n甚至发生更坏的情况：重叠。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种情况，您应考虑使用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-\">setTimer</a></code> 方法，\n当任务执行完成时设置下一个计时器。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">long</span> timerID = vertx.setPeriodic(<span class=\"hljs-number\">1000</span>, id -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"And every second this is printed\"</span>);\n});\n\nSystem.out.println(<span class=\"hljs-string\">\"First this is printed\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_cancelling_timers\"><a class=\"anchor\" href=\"#_cancelling_timers\"></a>取消计时器</h4>\n<div class=\"paragraph\">\n<p>指定一个计时器id并调用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#cancelTimer-long-\">cancelTimer</a></code> 方法来取消一个周期性计时器。如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.cancelTimer(timerID);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_automatic_clean_up_in_verticles\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles\"></a>Verticle 中自动清除定时器</h4>\n<div class=\"paragraph\">\n<p>如果您在 Verticle 中创建了计时器，\n当这个 Verticle 被撤销时这个计时器会被自动关闭。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verticle_worker_pool\"><a class=\"anchor\" href=\"#_verticle_worker_pool\"></a>Verticle worker pool</h3>\n<div class=\"paragraph\">\n<p>Verticle 使用 Vert.x 中的 Worker Pool 来执行阻塞式行为，例如 <code><a href=\"../../apidocs/io/vertx/core/Context.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\">executeBlocking</a></code> 或\nWorker Verticle。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以在部署配置项中指定不同的 Worker 线程池：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.deployVerticle(<span class=\"hljs-string\">\"the-verticle\"</span>, <span class=\"hljs-keyword\">new</span> DeploymentOptions().setWorkerPoolName(<span class=\"hljs-string\">\"the-specific-pool\"</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"event_bus\"><a class=\"anchor\" href=\"#event_bus\"></a>Event Bus</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBus.html\">event bus</a></code> 是 Vert.x 的 <strong>神经系统</strong> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>每一个 Vert.x 实例都有一个单独的 Event Bus 实例。您可以通过 <code>Vertx</code> 实例的 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#eventBus--\">eventBus</a></code> 方法来获得对应的 <code>EventBus</code> 实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>应用中的不同组成部分可以通过 Event Bus 相互通信，您无需关心它们由哪一种语言实现，\n也无需关心它们是否在同一个 Vert.x 实例中。</p>\n</div>\n<div class=\"paragraph\">\n<p>您甚至可以通过桥接的方式让浏览器中运行的多个JavaScript客户端在同一个 Event Bus 上相互通信。</p>\n</div>\n<div class=\"paragraph\">\n<p>Event Bus构建了一个跨越多个服务器节点和多个浏览器的分布式点对点消息系统。</p>\n</div>\n<div class=\"paragraph\">\n<p>Event Bus支持发布/订阅、点对点、请求-响应的消息传递方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>Event Bus的API很简单。基本上只涉及注册处理器、\n注销处理器以及发送和发布(publish)消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>先来看一些基本概念和理论。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_theory\"><a class=\"anchor\" href=\"#_the_theory\"></a>基本概念</h3>\n<div class=\"sect3\">\n<h4 id=\"_addressing\"><a class=\"anchor\" href=\"#_addressing\"></a>寻址</h4>\n<div class=\"paragraph\">\n<p>消息的发送目标被称作 <strong>地址(address)</strong> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x的地址格式并不花哨。Vert.x中的地址就是一个简单的字符串，任何字符串都合法。\n不过还是建议使用某种规范来进行地址的命名。 <em>例如</em> 使用点号(<code>.</code>)来划分命名空间。</p>\n</div>\n<div class=\"paragraph\">\n<p>一些合法的地址形如：europe.news.feed1、acme.games.pacman、sausages 以及 X 。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_handlers\"><a class=\"anchor\" href=\"#_handlers\"></a>处理器</h4>\n<div class=\"paragraph\">\n<p>消息需由处理器（<code>Handler</code>）来接收。您需要将处理器注册在某个地址上。</p>\n</div>\n<div class=\"paragraph\">\n<p>同一个地址可以注册许多不同的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个处理器也可以注册在多个不同的地址上。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publish_subscribe_messaging\"><a class=\"anchor\" href=\"#_publish_subscribe_messaging\"></a>发布/订阅消息</h4>\n<div class=\"paragraph\">\n<p>Event Bus支持 <strong>发布(publish)消息</strong> 功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>消息将被发布到一个地址上。\n发布意味着信息会被传递给所有注册在该地址上的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>即我们熟悉的 <strong>发布/订阅</strong> 消息传递模式。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_point_to_point_and_request_response_messaging\"><a class=\"anchor\" href=\"#_point_to_point_and_request_response_messaging\"></a>点对点消息传递 与 请求-响应消息传递</h4>\n<div class=\"paragraph\">\n<p>Event Bus也支持 <strong>点对点</strong> 消息模式。</p>\n</div>\n<div class=\"paragraph\">\n<p>消息将被发送到一个地址上，Vert.x仅会把消息发给注册在该地址上的处理器中的其中一个。</p>\n</div>\n<div class=\"paragraph\">\n<p>若这个地址上注册有不止一个处理器，那么Vert.x将使用 <strong>不严格的轮询算法</strong> 选择其中一个。</p>\n</div>\n<div class=\"paragraph\">\n<p>点对点消息传递模式下，可在消息发送的时候指定一个应答处理器（可选）。</p>\n</div>\n<div class=\"paragraph\">\n<p>当接收者收到消息并且处理完成时，它可以选择性地回复该消息。\n若回复，则关联的应答处理器将会被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>当发送者收到应答消息时，发送者还可以继续回复这个“应答”，这个过程可以 <em>不断</em> 重复。\n通过这种方式可以在两个不同的 Verticle 之间建立一个对话窗口。</p>\n</div>\n<div class=\"paragraph\">\n<p>这也是一个常见的消息传递模式：<strong>请求-响应</strong> 模式。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_best_effort_delivery\"><a class=\"anchor\" href=\"#_best_effort_delivery\"></a>尽力传输</h4>\n<div class=\"paragraph\">\n<p>Vert.x会尽它最大努力去传递消息，并且不会主动丢弃消息。这种方式称为 <strong>尽力传输(Best-effort delivery)</strong>。</p>\n</div>\n<div class=\"paragraph\">\n<p>但是，当 Event Bus 发生故障时，消息可能会丢失。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您的应用关心消息丢失，那么您应当编写具有幂等性的处理器，\n并且您的发送者应当在故障恢复后重试。（译者注：RPC通信通常情况下有三种语义：<strong>at least once</strong>、<strong>at most once</strong> 和 <strong>exactly once</strong>。不同语义情况下要考虑的情况不同。本小节中文档建议开发者通过重试来实现at least once语义，并通过幂等设计来规避重复接收消息的影响。）</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_types_of_messages\"><a class=\"anchor\" href=\"#_types_of_messages\"></a>消息类型</h4>\n<div class=\"paragraph\">\n<p>Vert.x 默认允许任何基本/简单类型、<code>String</code> 类型、 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">buffers</a></code> 类型的值\n作为消息发送。</p>\n</div>\n<div class=\"paragraph\">\n<p>不过在 Vert.x 中更规范且更通用的做法是使用 <a href=\"http://json.org/\">JSON</a> 格式来发送消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 Vert.x 支持的所有语言来说，JSON都是非常容易创建、读取和解析的，因此JSON已经成为了Vert.x中的\n<em>通用语(lingua franca)</em> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>但是若您不想用 JSON，我们也不强制您使用它。</p>\n</div>\n<div class=\"paragraph\">\n<p>Event Bus 非常灵活，\n您可以通过自定义 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageCodec.html\">codec</a></code> 来实现任何类型对象在 Event Bus 上的传输。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_event_bus_api\"><a class=\"anchor\" href=\"#_the_event_bus_api\"></a>Event Bus API</h3>\n<div class=\"paragraph\">\n<p>下面我们来看一下 API。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_getting_the_event_bus\"><a class=\"anchor\" href=\"#_getting_the_event_bus\"></a>获取Event Bus</h4>\n<div class=\"paragraph\">\n<p>您可以通过下面的代码获取 Event Bus 的引用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>每一个 Vertx.x 实例仅有一个 Event Bus 实例。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_registering_handlers\"><a class=\"anchor\" href=\"#_registering_handlers\"></a>注册处理器</h4>\n<div class=\"paragraph\">\n<p>最简单的注册处理器的方式是使用 <code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBus.html#consumer-java.lang.String-io.vertx.core.Handler-\">consumer</a></code> 方法，\n这儿有个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\n\neb.consumer(<span class=\"hljs-string\">\"news.uk.sport\"</span>, message -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"I have received a message: \"</span> + message.body());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当消息达到您的处理器时，该消息会被放入 <code><a href=\"../../apidocs/io/vertx/core/eventbus/Message.html\">message</a></code> 参数进行处理器的调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>调用 consumer() 方法会返回一个 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>该对象后续可用于注销处理器，或者流式地处理该对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBus.html#consumer-java.lang.String-io.vertx.core.Handler-\">consumer</a></code> 方法直接返回一个不带处理器的 MessageConsumer，\n之后再在这个返回的对象上设置处理器。如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\n\nMessageConsumer&lt;String&gt; consumer = eb.consumer(<span class=\"hljs-string\">\"news.uk.sport\"</span>);\nconsumer.handler(message -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"I have received a message: \"</span> + message.body());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在向集群模式下的 Event Bus 注册处理器时，\n注册信息会花费一些时间才能传播到集群中的所有节点。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您希望在完成注册后收到通知，您可以在 <code>MessageConsumer</code> 对象上注册\n一个 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html#completionHandler-io.vertx.core.Handler-\">completion handler</a></code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">consumer.completionHandler(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"The handler registration has reached all nodes\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Registration failed!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_un_registering_handlers\"><a class=\"anchor\" href=\"#_un_registering_handlers\"></a>注销处理器</h4>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html#unregister--\">unregister</a></code> 方法来注销处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您在使用集群模式的 Event Bus，注销处理器的动作会花费一些时间在节点中传播。若您想\n在完成后收到通知，可以使用 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html#unregister-io.vertx.core.Handler-\">unregister</a></code> 方法注册回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">consumer.unregister(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"The handler un-registration has reached all nodes\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Un-registration failed!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publishing_messages\"><a class=\"anchor\" href=\"#_publishing_messages\"></a>发布消息</h4>\n<div class=\"paragraph\">\n<p>发布消息很简单，只需使用 <code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBus.html#publish-java.lang.String-java.lang.Object-\">publish</a></code>\n方法指定一个地址去发布即可。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">eventBus.publish(<span class=\"hljs-string\">\"news.uk.sport\"</span>, <span class=\"hljs-string\">\"Yay! Someone kicked a ball\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个消息将会传递给所有在地址 news.uk.sport 上注册过的处理器。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_sending_messages\"><a class=\"anchor\" href=\"#_sending_messages\"></a>发送消息</h4>\n<div class=\"paragraph\">\n<p>在对应地址上注册过的所有处理器中，仅一个处理器能够接收到发送的消息。\n这是一种点对点消息传递模式。Vert.x 使用不严格的轮询算法来选择绑定的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBus.html#send-java.lang.String-java.lang.Object-\">send</a></code> 方法来发送消息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">eventBus.send(<span class=\"hljs-string\">\"news.uk.sport\"</span>, <span class=\"hljs-string\">\"Yay! Someone kicked a ball\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_setting_headers_on_messages\"><a class=\"anchor\" href=\"#_setting_headers_on_messages\"></a>设置消息头</h4>\n<div class=\"paragraph\">\n<p>在 Event Bus 上发送的消息可包含头信息。您可以在发送或发布(publish)时提供一个\n <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html\">DeliveryOptions</a></code> 来指定头信息。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DeliveryOptions options = <span class=\"hljs-keyword\">new</span> DeliveryOptions();\noptions.addHeader(<span class=\"hljs-string\">\"some-header\"</span>, <span class=\"hljs-string\">\"some-value\"</span>);\neventBus.send(<span class=\"hljs-string\">\"news.uk.sport\"</span>, <span class=\"hljs-string\">\"Yay! Someone kicked a ball\"</span>, options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_message_ordering\"><a class=\"anchor\" href=\"#_message_ordering\"></a>消息顺序</h4>\n<div class=\"paragraph\">\n<p>Vert.x会按照发送者发送消息的顺序，将消息以同样的顺序传递给处理器。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_the_message_object\"><a class=\"anchor\" href=\"#_the_message_object\"></a>消息对象</h4>\n<div class=\"paragraph\">\n<p>您在消息处理器中接收到的对象的类型是 <code><a href=\"../../apidocs/io/vertx/core/eventbus/Message.html\">Message</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>消息的 <code><a href=\"../../apidocs/io/vertx/core/eventbus/Message.html#body--\">body</a></code> 对应发送或发布(publish)的对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>消息的头信息可以通过 <code><a href=\"../../apidocs/io/vertx/core/eventbus/Message.html#headers--\">headers</a></code> 方法获取。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_acknowledging_messages_sending_replies\"><a class=\"anchor\" href=\"#_acknowledging_messages_sending_replies\"></a>应答消息/发送回复</h4>\n<div class=\"paragraph\">\n<p>当使用 <code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBus.html#send-java.lang.String-java.lang.Object-\">send</a></code> 方法发送消息时，\nEvent Bus会尝试将消息传递到注册在Event Bus上的 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 中。</p>\n</div>\n<div class=\"paragraph\">\n<p>某些情况下，发送者可以通过 <strong>请求/响应+</strong>\n模式来得知消费者已经收到并\"处理\"了该消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>消费者可以通过调用\n<code><a href=\"../../apidocs/io/vertx/core/eventbus/Message.html#reply-java.lang.Object-\">reply</a></code> 方法来应答这个消息，确认该消息已被处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>此时，它会将一个应答消息返回给发送者并调用发送者的应答处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>看这个例子会更清楚：</p>\n</div>\n<div class=\"paragraph\">\n<p>接收者：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MessageConsumer&lt;String&gt; consumer = eventBus.consumer(<span class=\"hljs-string\">\"news.uk.sport\"</span>);\nconsumer.handler(message -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"I have received a message: \"</span> + message.body());\n  message.reply(<span class=\"hljs-string\">\"how interesting!\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>发送者：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">eventBus.request(<span class=\"hljs-string\">\"news.uk.sport\"</span>, <span class=\"hljs-string\">\"Yay! Someone kicked a ball across a patch of grass\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Received reply: \"</span> + ar.result().body());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在应答的消息体中可以包含一些有用的信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>“处理中”的实际含义应当由应用程序来定义。\n这完全取决于消费者如何执行，Event Bus 对此并不关心。</p>\n</div>\n<div class=\"paragraph\">\n<p>一些例子：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>一个简单地实现了返回当天时间的服务，\n在应答的消息里会包含当天时间信息。</p>\n</li>\n<li>\n<p>一个实现了持久化队列的消息消费者，可以回复 <code>true</code>\n来表示消息已成功持久化到存储设备中，或回复 <code>false</code> 表示失败。</p>\n</li>\n<li>\n<p>一个处理订单的消息消费者可以使用 <code>true</code> 确认这个订单已经成功处理，\n并且可以从数据库中删除。</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_sending_with_timeouts\"><a class=\"anchor\" href=\"#_sending_with_timeouts\"></a>带超时的发送</h4>\n<div class=\"paragraph\">\n<p>当发送带有应答处理器的消息时，可以在 <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html\">DeliveryOptions</a></code> 中指定一个超时时间。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果在这个时间之内没有收到应答，则会以“失败的结果”为参数调用应答处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认超时是 <strong>30 秒</strong>。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_send_failures\"><a class=\"anchor\" href=\"#_send_failures\"></a>发送失败</h4>\n<div class=\"paragraph\">\n<p>消息发送可能会因为其他原因失败，包括：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>没有可用的处理器来接收消息</p>\n</li>\n<li>\n<p>接收者调用了 <code><a href=\"../../apidocs/io/vertx/core/eventbus/Message.html#fail-int-java.lang.String-\">fail</a></code> 方法显式声明失败</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>发生这些情况时，应答处理器将会以这些异常失败结果为参数进行调用。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_message_codecs\"><a class=\"anchor\" href=\"#_message_codecs\"></a>消息编解码器</h4>\n<div class=\"paragraph\">\n<p>您可以在 Event Bus 中发送任何对象，只需为这个对象类型注册一个编解码器 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageCodec.html\">message codec</a></code> 即可。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个消息编解码器都有一个名称，您需要在发送或发布消息时通过 <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html\">DeliveryOptions</a></code>\n来指定：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">eventBus.registerCodec(myCodec);\n\nDeliveryOptions options = <span class=\"hljs-keyword\">new</span> DeliveryOptions().setCodecName(myCodec.name());\n\neventBus.send(<span class=\"hljs-string\">\"orders\"</span>, <span class=\"hljs-keyword\">new</span> MyPOJO(), options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若您希望某个类总是使用特定的编解码器，那么您可以为这个类注册默认编解码器。\n这样您就不需要在每次发送的时候指定了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">eventBus.registerDefaultCodec(MyPOJO<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">myCodec</span>)</span>;\n\neventBus.send(<span class=\"hljs-string\">\"orders\"</span>, <span class=\"hljs-keyword\">new</span> MyPOJO());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBus.html#unregisterCodec-java.lang.String-\">unregisterCodec</a></code> 方法注销某个消息编解码器。</p>\n</div>\n<div class=\"paragraph\">\n<p>消息编解码器的编码输入和解码输出不一定使用同一个类型。\n例如您可以编写一个编解码器来发送 MyPOJO 类的对象，但是当消息发送给处理器后解码成 MyOtherPOJO 对象。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_clustered_event_bus\"><a class=\"anchor\" href=\"#_clustered_event_bus\"></a>集群模式的 Event Bus</h4>\n<div class=\"paragraph\">\n<p>Event Bus 不仅仅只存在于单个 Vert.x 实例中。将网络上不同的 Vert.x 实例组合成集群，\n就可以在这些实例间形成一个单一的、分布式的Event Bus。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_clustering_programmatically\"><a class=\"anchor\" href=\"#_clustering_programmatically\"></a>通过编写代码启用集群模式</h4>\n<div class=\"paragraph\">\n<p>若您用编程的方式创建 Vert.x 实例（Vertx），则可以通过将 Vert.x\n实例配置成集群模式来获取集群模式的Event Bus：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions();\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n    EventBus eventBus = vertx.eventBus();\n    System.out.println(<span class=\"hljs-string\">\"We now have a clustered event bus: \"</span> + eventBus);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed: \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您需要确保在您的 classpath 中（或构建工具的依赖中）包含 <code><a href=\"../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html\">ClusterManager</a></code> 的实现类，如默认的 <code>HazelcastClusterManager</code>。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_clustering_on_the_command_line\"><a class=\"anchor\" href=\"#_clustering_on_the_command_line\"></a>通过命令行启用集群模式</h4>\n<div class=\"paragraph\">\n<p>您可以通过以下命令以集群模式运行 Vert.x 应用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>vertx run my-verticle.js -cluster</pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_clean_up_in_verticles_2\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles_2\"></a>Verticle 中的自动清理</h3>\n<div class=\"paragraph\">\n<p>若您在 Verticle 中注册了 Event Bus 的处理器，那么这些处理器在 Verticle\n被撤销（undeploy）的时候会自动被注销。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_the_event_bus\"><a class=\"anchor\" href=\"#_configuring_the_event_bus\"></a>配置 Event Bus</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Event Bus 是可配置的，这对于以集群模式运行的 Event Bus 来说非常有用。\nEvent Bus 使用 TCP 连接发送和接收消息，因此可以通过 <code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBusOptions.html\">EventBusOptions</a></code> 对TCP连接进行全面的配置。\n由于 Event Bus 既可以用作客户端又可以用作服务端，因此这些配置近似于 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html\">NetClientOptions</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html\">NetServerOptions</a></code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions()\n    .setEventBusOptions(<span class=\"hljs-keyword\">new</span> EventBusOptions()\n        .setSsl(<span class=\"hljs-keyword\">true</span>)\n        .setKeyStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions().setPath(<span class=\"hljs-string\">\"keystore.jks\"</span>).setPassword(<span class=\"hljs-string\">\"wibble\"</span>))\n        .setTrustStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions().setPath(<span class=\"hljs-string\">\"keystore.jks\"</span>).setPassword(<span class=\"hljs-string\">\"wibble\"</span>))\n        .setClientAuth(ClientAuth.REQUIRED)\n    );\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n    EventBus eventBus = vertx.eventBus();\n    System.out.println(<span class=\"hljs-string\">\"We now have a clustered event bus: \"</span> + eventBus);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed: \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上边代码段描述了如何在Event Bus中使用SSL连接替换明文的TCP连接。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>警告</strong> ：若要在集群模式下保证安全性，您 <strong>必须</strong> 将集群管理器配置成加密的或者加强安全规则。\n参考集群管理器的文档获取更多细节。</p>\n</div>\n<div class=\"paragraph\">\n<p>Event Bus 的配置需要在集群的所有节点中保持一致。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/eventbus/EventBusOptions.html\">EventBusOptions</a></code> 还允许您指定 Event Bus 是否运行在集群模式下，以及它的端口和主机信息（译者注：host，这里指网络socket绑定的地址）。</p>\n</div>\n<div class=\"paragraph\">\n<p>在容器中使用时，您还可以配置公共主机和端口号：（译者注：setClusterPublicHost 和 setClusterPublicPort 的功能在原文档上描述得不清晰，但是API文档上有详细描述。 在某些容器、云环境等场景下，本节点监听的地址，和其他节点连接本节点时使用的地址，是不同的。这种情况下则可以利用上面两个配置区分监听地址和公开暴露的地址。  ）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions()\n    .setEventBusOptions(<span class=\"hljs-keyword\">new</span> EventBusOptions()\n        .setClusterPublicHost(<span class=\"hljs-string\">\"whatever\"</span>)\n        .setClusterPublicPort(<span class=\"hljs-number\">1234</span>)\n    );\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n    EventBus eventBus = vertx.eventBus();\n    System.out.println(<span class=\"hljs-string\">\"We now have a clustered event bus: \"</span> + eventBus);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed: \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_json\"><a class=\"anchor\" href=\"#_json\"></a>JSON</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>和其他一些语言不同，Java 没有对 <a href=\"http://json.org/\">JSON</a> 做原生支持（first class support），\n因此我们提供了两个类，以便在 Vert.x 应用中更方便地处理 JSON。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_objects\"><a class=\"anchor\" href=\"#_json_objects\"></a>JSON objects</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> 类用来描述JSON对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个JSON 对象基本上只是一个 Map 结构。它具有字符串的键，值可以是任意一种JSON 支持的类型\n（如 string, number, boolean）。</p>\n</div>\n<div class=\"paragraph\">\n<p>JSON 对象也支持 null 值。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_creating_json_objects\"><a class=\"anchor\" href=\"#_creating_json_objects\"></a>创建 JSON 对象</h4>\n<div class=\"paragraph\">\n<p>可以使用默认构造函数创建空的JSON对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过一个 JSON 格式的字符串创建JSON对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String jsonString = <span class=\"hljs-string\">\"{\\\"foo\\\":\\\"bar\\\"}\"</span>;\nJsonObject object = <span class=\"hljs-keyword\">new</span> JsonObject(jsonString);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以根据Map创建JSON对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\nmap.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>);\nmap.put(<span class=\"hljs-string\">\"xyz\"</span>, <span class=\"hljs-number\">3</span>);\nJsonObject object = <span class=\"hljs-keyword\">new</span> JsonObject(map);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_putting_entries_into_a_json_object\"><a class=\"anchor\" href=\"#_putting_entries_into_a_json_object\"></a>将键值对放入 JSON 对象</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html#put-java.lang.String-java.lang.Object-\">put</a></code> 方法可以将值放入到JSON对象里。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个API是流式的，因此这个方法可以被链式地调用。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject object = <span class=\"hljs-keyword\">new</span> JsonObject();\nobject.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>).put(<span class=\"hljs-string\">\"num\"</span>, <span class=\"hljs-number\">123</span>).put(<span class=\"hljs-string\">\"mybool\"</span>, <span class=\"hljs-keyword\">true</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_getting_values_from_a_json_object\"><a class=\"anchor\" href=\"#_getting_values_from_a_json_object\"></a>从 JSON 对象获取值</h4>\n<div class=\"paragraph\">\n<p>您可使用 <code>getXXX</code> 方法从JSON对象中获取值。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String val = jsonObject.getString(<span class=\"hljs-string\">\"some-key\"</span>);\n<span class=\"hljs-keyword\">int</span> intVal = jsonObject.getInteger(<span class=\"hljs-string\">\"some-other-key\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_mapping_between_json_objects_and_java_objects\"><a class=\"anchor\" href=\"#_mapping_between_json_objects_and_java_objects\"></a>JSON 对象和 Java 对象间的映射</h4>\n<div class=\"paragraph\">\n<p>您可以根据 Java 对象的字段创建一个JSON 对象，如下所示：</p>\n</div>\n<div class=\"paragraph\">\n<p>你可以根据一个 JSON 对象来实例化一个Java 对象并填充字段值。如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.bodyHandler(buff -&gt; {\n  JsonObject jsonObject = buff.toJsonObject();\n  User javaObject = jsonObject.mapTo(User<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意上述代码直接使用了 Jackson 的 <code>ObjectMapper#convertValue()</code> 来执行映射。\n关于字段和构造函数的可见性的影响、对象引用的序列化和反序列化等等的问题，\n可参考 Jackson 的文档获取更多信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>在最简单的情况下，如果 Java 类中所有的字段都是\n<code>public</code>（或者有 <code>public</code> 的 getter/setter）时，并且有一个 <code>public</code> 的默认构造函数（或不定义构造函数），<code>mapFrom</code> 和 <code>mapTo</code> 都应该成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>只要不存在对象的循环引用，嵌套的 Java 对象就可以和嵌套的 JSON\n对象相互序列化/反序列化。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_encoding_a_json_object_to_a_string\"><a class=\"anchor\" href=\"#_encoding_a_json_object_to_a_string\"></a>将 JSON 对象编码成字符串</h4>\n<div class=\"paragraph\">\n<p>您可使用 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html#encode--\">encode</a></code> 方法将一个对象编码成字符串格式。（译者注：如要得到更优美、格式化的字符串，可以使用 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html#encodePrettily--\">encodePrettily</a></code> 方法。）</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_arrays\"><a class=\"anchor\" href=\"#_json_arrays\"></a>JSON 数组</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> 类用来描述 JSON数组。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个JSON 数组是一个值的序列（值的类型可以是 string、number、boolean 等）。</p>\n</div>\n<div class=\"paragraph\">\n<p>JSON 数组同样可以包含 <code>null</code> 值。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_creating_json_arrays\"><a class=\"anchor\" href=\"#_creating_json_arrays\"></a>创建 JSON 数组</h4>\n<div class=\"paragraph\">\n<p>可以使用默认构造函数创建空的JSON数组。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以根据JSON格式的字符串创建一个JSON数组：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String jsonString = <span class=\"hljs-string\">\"[\\\"foo\\\",\\\"bar\\\"]\"</span>;\nJsonArray array = <span class=\"hljs-keyword\">new</span> JsonArray(jsonString);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_adding_entries_into_a_json_array\"><a class=\"anchor\" href=\"#_adding_entries_into_a_json_array\"></a>将数组项添加到JSON数组</h4>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html#add-java.lang.Object-\">add</a></code> 方法添加数组项到JSON数组中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonArray array = <span class=\"hljs-keyword\">new</span> JsonArray();\narray.add(<span class=\"hljs-string\">\"foo\"</span>).add(<span class=\"hljs-number\">123</span>).add(<span class=\"hljs-keyword\">false</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_getting_values_from_a_json_array\"><a class=\"anchor\" href=\"#_getting_values_from_a_json_array\"></a>从 JSON 数组中获取值</h4>\n<div class=\"paragraph\">\n<p>您可使用 <code>getXXX</code> 方法从JSON 数组中获取值。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String val = array.getString(<span class=\"hljs-number\">0</span>);\nInteger intVal = array.getInteger(<span class=\"hljs-number\">1</span>);\nBoolean boolVal = array.getBoolean(<span class=\"hljs-number\">2</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_encoding_a_json_array_to_a_string\"><a class=\"anchor\" href=\"#_encoding_a_json_array_to_a_string\"></a>将 JSON 数组编码成字符串</h4>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html#encode--\">encode</a></code> 编码成字符串格式。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_creating_arbitrary_json\"><a class=\"anchor\" href=\"#_creating_arbitrary_json\"></a>创建任意类型的 JSON</h4>\n<div class=\"paragraph\">\n<p>创建 JSON 对象或数组的前提是，你需要事先已知其输入是合法的字符串。（译者注：这里说的“合法”指的是，你在使用 <code>JsonObject</code> 时，需要事先知道构造函数输入的字符串是一个json object <code>{&#8230;&#8203;}</code>，同理，使用 <code>JsonArray</code> 时，字符串需要是一个json array <code>[&#8230;&#8203;]</code>，否则即使输入了一个规范的Json字符串，也没有办法成功解析。）</p>\n</div>\n<div class=\"paragraph\">\n<p>当你不确定字符串是否合法时，你应当转而使用 <code><a href=\"../../apidocs/io/vertx/core/json/Json.html#decodeValue-java.lang.String-\">Json.decodeValue</a></code> 方法。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Object object = Json.decodeValue(arbitraryJson);\n<span class=\"hljs-keyword\">if</span> (object <span class=\"hljs-keyword\">instanceof</span> JsonObject) {\n  <span class=\"hljs-comment\">// That's a valid json object</span>\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (object <span class=\"hljs-keyword\">instanceof</span> JsonArray) {\n  <span class=\"hljs-comment\">// That's a valid json array</span>\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (object <span class=\"hljs-keyword\">instanceof</span> String) {\n  <span class=\"hljs-comment\">// That's valid string</span>\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">// etc...</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_json_pointers\"><a class=\"anchor\" href=\"#_json_pointers\"></a>Json 指针（Json Pointers）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 提供了一个 <a href=\"https://tools.ietf.org/html/rfc6901\">Json指针 RFC6901</a> 的实现。\n无论是查询还是写入，你都可以使用Json指针来完成。你可以基于字符串、URI，或者通过手动追加路径(path)的方式，\n来构建 <code><a href=\"../../apidocs/io/vertx/core/json/pointer/JsonPointer.html\">JsonPointer</a></code> 对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonPointer pointer1 = JsonPointer.from(<span class=\"hljs-string\">\"/hello/world\"</span>);\n<span class=\"hljs-comment\">// Build a pointer manually</span>\nJsonPointer pointer2 = JsonPointer.create()\n  .append(<span class=\"hljs-string\">\"hello\"</span>)\n  .append(<span class=\"hljs-string\">\"world\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在初始化Json指针后，你可以使用 <code><a href=\"../../apidocs/io/vertx/core/json/pointer/JsonPointer.html#queryJson-java.lang.Object-\">queryJson</a></code> 方法做查询，\n也可以使用 <code><a href=\"../../apidocs/io/vertx/core/json/pointer/JsonPointer.html#writeJson-java.lang.Object-java.lang.Object-\">writeJson</a></code> 方法修改JSON的值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Object result1 = objectPointer.queryJson(jsonObject);\n<span class=\"hljs-comment\">// Query a JsonArray</span>\nObject result2 = arrayPointer.queryJson(jsonArray);\n<span class=\"hljs-comment\">// Write starting from a JsonObject</span>\nobjectPointer.writeJson(jsonObject, <span class=\"hljs-string\">\"new element\"</span>);\n<span class=\"hljs-comment\">// Write starting from a JsonObject</span>\narrayPointer.writeJson(jsonArray, <span class=\"hljs-string\">\"new element\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你可以将Vert.x的Json指针功能应用在任何类型的对象上，只需实现一个自定义的 <code><a href=\"../../apidocs/io/vertx/core/json/pointer/JsonPointerIterator.html\">JsonPointerIterator</a></code> 即可。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_buffers\"><a class=\"anchor\" href=\"#_buffers\"></a>Buffers</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在 Vert.x 内部，大部分数据被重新组织（shuffle，表意为洗牌）成 <code>Buffer</code> 格式。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>Buffer</code> 是一个可以被读取或写入的，包含0个或多个字节的序列，并且能够根据写入的字节自动扩容。\n您也可以将 <code>Buffer</code> 想象成一个智能的字节数组。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_buffers\"><a class=\"anchor\" href=\"#_creating_buffers\"></a>创建 Buffer</h3>\n<div class=\"paragraph\">\n<p>可以使用静态方法 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html#buffer--\">Buffer.buffer</a></code> 来创建 Buffer。</p>\n</div>\n<div class=\"paragraph\">\n<p>Buffer可以从字符串或字节数组初始化，或者直接创建空的Buffer。</p>\n</div>\n<div class=\"paragraph\">\n<p>这儿有一些创建Buffer的例子。</p>\n</div>\n<div class=\"paragraph\">\n<p>创建一个空的Buffer：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>从字符串创建一个Buffer，这个Buffer中的字符会以 UTF-8 格式编码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer(<span class=\"hljs-string\">\"some string\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>从字符串创建一个Buffer，这个字符串会以指定的编码方式编码，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer(<span class=\"hljs-string\">\"some string\"</span>, <span class=\"hljs-string\">\"UTF-16\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>从字节数组 <code>byte[]</code> 创建Buffer：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">byte</span>[] bytes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">byte</span>[] {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>};\nBuffer buff = Buffer.buffer(bytes);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>创建一个指定初始大小的Buffer。若您知道您的 Buffer会写入一定量的数据，\n您可以在创建Buffer时指定它的大小，使这个Buffer在初始化时就分配了更多的内存，\n比数据写入时重新调整大小效率更高。</p>\n</div>\n<div class=\"paragraph\">\n<p>注意以这种方式创建的Buffer是 <strong>空的</strong>。它不会创建一个填满了0的Buffer。代码如下：（译者注：这里说的“空的”、“不会填满0”，指的是buffer内部的游标会从头开始，并不是在说内存布局。这种实现方式和使用直觉是一致的，只不过明确通过文档进行描述有点奇怪。）</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer(<span class=\"hljs-number\">10000</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_to_a_buffer\"><a class=\"anchor\" href=\"#_writing_to_a_buffer\"></a>向Buffer写入数据</h3>\n<div class=\"paragraph\">\n<p>向Buffer写入数据的方式有两种：追加和随机访问。\n任何一种情况下 Buffer都会自动进行扩容，\n所以你不会在使用Buffer时遇到 <code>IndexOutOfBoundsException</code>。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_appending_to_a_buffer\"><a class=\"anchor\" href=\"#_appending_to_a_buffer\"></a>追加到Buffer</h4>\n<div class=\"paragraph\">\n<p>您可以使用 <code>appendXXX</code> 方法追加数据到Buffer。\nBuffer类提供了追加各种不同类型数据的追加写入方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>因为 <code>appendXXX</code> 方法的返回值就是 Buffer 自身，所以它可以链式地调用:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer();\n\nbuff.appendInt(<span class=\"hljs-number\">123</span>).appendString(<span class=\"hljs-string\">\"hello\\n\"</span>);\n\nsocket.write(buff);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_random_access_buffer_writes\"><a class=\"anchor\" href=\"#_random_access_buffer_writes\"></a>随机访问写Buffer</h4>\n<div class=\"paragraph\">\n<p>您还可以指定一个索引值，通过 <code>setXXX</code> 方法写入数据到 <code>Buffer</code>。\n<code>setXXX</code> 也为各种不同数据类型提供了对应的方法。所有的 set 方法都会将索引值作为第一个参数\n—— 这表示Buffer中开始写入数据的位置。</p>\n</div>\n<div class=\"paragraph\">\n<p>Buffer始终根据需要进行自动扩容。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer();\n\nbuff.setInt(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-number\">123</span>);\nbuff.setString(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"hello\"</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_reading_from_a_buffer\"><a class=\"anchor\" href=\"#_reading_from_a_buffer\"></a>从Buffer中读取</h3>\n<div class=\"paragraph\">\n<p>可使用 <code>getXXX</code> 方法从 Buffer 中读取数据，<code>getXXX</code> 为各种不同数据类型提供了对应的方法，\n这些方法的第一个参数是Buffer中待获取的数据的索引位置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer();\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; buff.length(); i += <span class=\"hljs-number\">4</span>) {\n  System.out.println(<span class=\"hljs-string\">\"int value at \"</span> + i + <span class=\"hljs-string\">\" is \"</span> + buff.getInt(i));\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_unsigned_numbers\"><a class=\"anchor\" href=\"#_working_with_unsigned_numbers\"></a>使用无符号数</h3>\n<div class=\"paragraph\">\n<p>可使用 <code>getUnsignedXXX</code>、\n<code>appendUnsignedXXX</code> 和 <code>setUnsignedXXX</code> 方法将无符号数从Buffer中读取或追加/设置到Buffer里。\n这对于实现一个致力于优化带宽占用的网络协议的编解码器是非常有用的。</p>\n</div>\n<div class=\"paragraph\">\n<p>下边例子中，值 200 被设置到了仅占用一个字节的特定位置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buff = Buffer.buffer(<span class=\"hljs-number\">128</span>);\n<span class=\"hljs-keyword\">int</span> pos = <span class=\"hljs-number\">15</span>;\nbuff.setUnsignedByte(pos, (<span class=\"hljs-keyword\">short</span>) <span class=\"hljs-number\">200</span>);\nSystem.out.println(buff.getUnsignedByte(pos));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>控制台中显示 \"200\"。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_buffer_length\"><a class=\"anchor\" href=\"#_buffer_length\"></a>Buffer长度</h3>\n<div class=\"paragraph\">\n<p>可使用 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html#length--\">length</a></code> 方法获取Buffer长度，\nBuffer的长度值是Buffer中包含的字节的最大索引 + 1。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_copying_buffers\"><a class=\"anchor\" href=\"#_copying_buffers\"></a>拷贝Buffer</h3>\n<div class=\"paragraph\">\n<p>可使用 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html#copy--\">copy</a></code> 方法创建一个Buffer的副本。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_slicing_buffers\"><a class=\"anchor\" href=\"#_slicing_buffers\"></a>裁剪Buffer</h3>\n<div class=\"paragraph\">\n<p>裁剪得到的Buffer是完全依赖于原始Buffer的一个新的Buffer，换句话说，它不会对Buffer中的数据做拷贝。\n使用 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html#slice--\">slice</a></code> 方法裁剪一个Buffer。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_buffer_re_use\"><a class=\"anchor\" href=\"#_buffer_re_use\"></a>Buffer 重用</h3>\n<div class=\"paragraph\">\n<p>将Buffer写入到一个Socket或其他类似位置后，Buffer就不可被重用了。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_writing_tcp_servers_and_clients\"><a class=\"anchor\" href=\"#_writing_tcp_servers_and_clients\"></a>编写 TCP 服务端和客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x让您轻松编写非阻塞的TCP客户端和服务器。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_tcp_server\"><a class=\"anchor\" href=\"#_creating_a_tcp_server\"></a>创建 TCP 服务端</h3>\n<div class=\"paragraph\">\n<p>最简单地使用所有默认配置项创建 TCP 服务端的方式如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_a_tcp_server\"><a class=\"anchor\" href=\"#_configuring_a_tcp_server\"></a>配置 TCP 服务端</h3>\n<div class=\"paragraph\">\n<p>若您不想使用默认配置，可以在创建时通过传入一个 <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html\">NetServerOptions</a></code>\n实例来配置服务器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().setPort(<span class=\"hljs-number\">4321</span>);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_start_the_server_listening\"><a class=\"anchor\" href=\"#_start_the_server_listening\"></a>启动服务端监听</h3>\n<div class=\"paragraph\">\n<p>要告诉服务端监听传入的请求，您可以使用其中一个 <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html#listen--\">listen</a></code>\n方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>让服务器监听配置项指定的主机和端口：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer();\nserver.listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或在调用 <code>listen</code> 方法时指定主机和端口号，忽略配置项中的配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer();\nserver.listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认主机名是 <code>0.0.0.0</code>，它表示：监听所有可用地址。默认端口号是 <code>0</code>，\n这也是一个特殊值，它告诉服务器随机选择并监听一个本地没有被占用的端口。</p>\n</div>\n<div class=\"paragraph\">\n<p>实际的绑定也是异步的，因此服务器在调用了 <code>listen</code> 方法的一段时间 <strong>之后</strong>\n才会实际开始监听。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您希望在服务器实际监听时收到通知，您可以在调用 <code>listen</code> 方法时提供一个处理器。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer();\nserver.listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Server is now listening!\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to bind!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_listening_on_a_random_port\"><a class=\"anchor\" href=\"#_listening_on_a_random_port\"></a>监听随机端口</h3>\n<div class=\"paragraph\">\n<p>若设置监听端口为 <code>0</code>，服务器将随机寻找一个没有使用的端口来监听。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以调用 <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html#actualPort--\">actualPort</a></code> 方法来获得服务器实际监听的端口：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer();\nserver.listen(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"localhost\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Server is now listening on actual port: \"</span> + server.actualPort());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to bind!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_getting_notified_of_incoming_connections\"><a class=\"anchor\" href=\"#_getting_notified_of_incoming_connections\"></a>接收传入连接的通知</h3>\n<div class=\"paragraph\">\n<p>若您想要在连接创建完时收到通知，则需要设置一个 <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html#connectHandler-io.vertx.core.Handler-\">connectHandler</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer();\nserver.connectHandler(socket -&gt; {\n  <span class=\"hljs-comment\">// Handle the connection in here</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当连接成功时，您可以在回调函数中处理得到的 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个代表了实际连接的套接字接口，它允许您读取和写入数据、以及执行各种其他操作，\n如关闭 Socket。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_reading_data_from_the_socket\"><a class=\"anchor\" href=\"#_reading_data_from_the_socket\"></a>从Socket读取数据</h3>\n<div class=\"paragraph\">\n<p>您可以在Socket上调用 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#handler-io.vertx.core.Handler-\">handler</a></code>\n方法来设置用于读取数据的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>每次 Socket 接收到数据时，会以 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code>\n对象为参数调用处理器。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer();\nserver.connectHandler(socket -&gt; {\n  socket.handler(buffer -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"I received some bytes: \"</span> + buffer.length());\n  });\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_data_to_a_socket\"><a class=\"anchor\" href=\"#_writing_data_to_a_socket\"></a>向Socket中写入数据</h3>\n<div class=\"paragraph\">\n<p>您可使用 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-\">write</a></code> 方法写入数据到Socket：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buffer = Buffer.buffer().appendFloat(<span class=\"hljs-number\">12.34f</span>).appendInt(<span class=\"hljs-number\">123</span>);\nsocket.write(buffer);\n\n<span class=\"hljs-comment\">// 以UTF-8的编码方式写入一个字符串</span>\nsocket.write(<span class=\"hljs-string\">\"some data\"</span>);\n\n<span class=\"hljs-comment\">// 以指定的编码方式写入一个字符串</span>\nsocket.write(<span class=\"hljs-string\">\"some data\"</span>, <span class=\"hljs-string\">\"UTF-16\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>写入操作是异步的，可能调用 <code>write</code> 方法返回过后一段时间才会执行。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_closed_handler\"><a class=\"anchor\" href=\"#_closed_handler\"></a>关闭处理器</h3>\n<div class=\"paragraph\">\n<p>若您想要在 Socket 关闭时收到通知，可以设置一个 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#closeHandler-io.vertx.core.Handler-\">closeHandler</a></code>\n处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socket.closeHandler(v -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"The socket has been closed\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_exceptions\"><a class=\"anchor\" href=\"#_handling_exceptions\"></a>处理异常</h3>\n<div class=\"paragraph\">\n<p>您可以设置一个 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#exceptionHandler-io.vertx.core.Handler-\">exceptionHandler</a></code>\n来接收所有socket上发生的异常。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html#exceptionHandler-io.vertx.core.Handler-\">exceptionHandler</a></code> 所设置的异常处理器还可以接收在\n<code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html#connectHandler-io.vertx.core.Handler-\">connectHandler</a></code> 接受到连接对象前发生的所有异常，\n比如在TLS握手期间。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_event_bus_write_handler\"><a class=\"anchor\" href=\"#_event_bus_write_handler\"></a>Event Bus 写处理器</h3>\n<div class=\"paragraph\">\n<p>每个 Socket 会自动在Event Bus中注册一个处理器，当这个处理器中收到任意Buffer时，\n它会将数据写入到 Socket。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着您可以通过向这个地址发送Buffer的方式，从不同的 Verticle 甚至是不同的 Vert.x 实例中向指定的 Socket 发送数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>处理器的地址由 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#writeHandlerID--\">writeHandlerID</a></code> 方法提供。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_local_and_remote_addresses\"><a class=\"anchor\" href=\"#_local_and_remote_addresses\"></a>本地和远程地址</h3>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#localAddress--\">localAddress</a></code> 方法获取 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 的本地地址。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#remoteAddress--\">remoteAddress</a></code> 方法获取\n<code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 的远程地址（即连接的另一端的地址）。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sending_files_or_resources_from_the_classpath\"><a class=\"anchor\" href=\"#_sending_files_or_resources_from_the_classpath\"></a>发送文件或 Classpath 中的资源</h3>\n<div class=\"paragraph\">\n<p>您可以直接通过 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#sendFile-java.lang.String-\">sendFile</a></code> 方法将文件和 classpath 中的资源写入Socket。\n这种做法是非常高效的，它可以被操作系统内核直接处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>请阅读 <a href=\"#classpath\">从 Classpath 访问文件</a>\n章节了解类路径的限制或禁用它。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socket.sendFile(<span class=\"hljs-string\">\"myfile.dat\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_streaming_sockets\"><a class=\"anchor\" href=\"#_streaming_sockets\"></a>流式的Socket</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 接口继承了 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 接口，因此您可以将它套用（pipe）到其他的\n读写流上。</p>\n</div>\n<div class=\"paragraph\">\n<p>有关更多信息，请参阅  <a href=\"#streams\">流 </a> 章节。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_upgrading_connections_to_ssltls\"><a class=\"anchor\" href=\"#_upgrading_connections_to_ssltls\"></a>升级到 SSL/TLS 连接</h3>\n<div class=\"paragraph\">\n<p>一个非SSL/TLS连接可以通过 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html#upgradeToSsl-io.vertx.core.Handler-\">upgradeToSsl</a></code> 方法升级到SSL/TLS连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>必须为服务器或客户端配置SSL/TLS才能正常工作。请参阅 <a href=\"#ssl\">chapter on SSL/TLS</a>\n章节获取详细信息。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_closing_a_tcp_server\"><a class=\"anchor\" href=\"#_closing_a_tcp_server\"></a>关闭 TCP 服务端</h3>\n<div class=\"paragraph\">\n<p>您可以调用 <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html#close--\">close</a></code> 方法关闭服务端。\n关闭操作将关闭所有打开的连接并释放所有服务端资源。</p>\n</div>\n<div class=\"paragraph\">\n<p>关闭操作也是异步的，可能直到方法调用返回过后一段时间才会实际关闭。\n若您想在实际关闭完成时收到通知，那么您可以传递一个处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>当关闭操作完成后，绑定的处理器将被调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.close(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Server is now closed\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"close failed\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_clean_up_in_verticles_3\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles_3\"></a>Verticle中的自动清理</h3>\n<div class=\"paragraph\">\n<p>若您在Verticle内创建了 TCP 服务端和客户端，\n它们将会在Verticle撤销时自动被关闭。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scaling_sharing_tcp_servers\"><a class=\"anchor\" href=\"#_scaling_sharing_tcp_servers\"></a>扩展 - 共享 TCP 服务端</h3>\n<div class=\"paragraph\">\n<p>任意一个TCP服务端中的处理器总是在相同的Event-Loop线程上执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着如果您在多核的服务器上运行，并且只部署了一个实例，\n那么您的服务器上最多只能使用一个核。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了利用更多的服务器核，您将需要部署更多的服务器实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以在代码中以编程方式实例化更多（Server的）实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n  NetServer server = vertx.createNetServer();\n  server.connectHandler(socket -&gt; {\n    socket.handler(buffer -&gt; {\n      <span class=\"hljs-comment\">// Just echo back the data</span>\n      socket.write(buffer);\n    });\n  });\n  server.listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用的是 Verticle，您可以通过在命令行上使用 <code>-instances</code>\n选项来简单部署更多的服务器实例：</p>\n</div>\n<div class=\"paragraph\">\n<p>vertx run com.mycompany.MyVerticle -instances 10</p>\n</div>\n<div class=\"paragraph\">\n<p>或者使用编程方式部署您的 Verticle 时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DeploymentOptions options = <span class=\"hljs-keyword\">new</span> DeploymentOptions().setInstances(<span class=\"hljs-number\">10</span>);\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyVerticle\"</span>, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦您这样做，您将发现echo服务器在功能上与之前相同，\n但是服务器上的所有核都可以被利用，并且可以处理更多的工作。</p>\n</div>\n<div class=\"paragraph\">\n<p>在这一点上，您可能会问自己：<strong>”如何让多台服务器在同一主机和端口上侦听？\n尝试部署一个以上的实例时真的不会遇到端口冲突吗？“</strong></p>\n</div>\n<div class=\"paragraph\">\n<p><em>Vert.x施加了一点魔法。</em></p>\n</div>\n<div class=\"paragraph\">\n<p>当您在与现有服务器相同的主机和端口上部署另一个服务器实例时，\n实际上它并不会尝试创建在同一主机/端口上侦听的新服务器实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>相反，它内部仅仅维护一个服务器实例。当传入新的连接时，\n它以轮询的方式将其分发给任意一个连接处理器处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>因此，Vert.x TCP 服务端可以水平扩展到多个核，并且每个实例保持单线程环境不变。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_tcp_client\"><a class=\"anchor\" href=\"#_creating_a_tcp_client\"></a>创建 TCP 客户端</h3>\n<div class=\"paragraph\">\n<p>使用所有默认选项创建 TCP 客户端的最简单方法如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClient client = vertx.createNetClient();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_a_tcp_client\"><a class=\"anchor\" href=\"#_configuring_a_tcp_client\"></a>配置 TCP 客户端</h3>\n<div class=\"paragraph\">\n<p>如果您不想使用默认值，则可以在创建实例时传入 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html\">NetClientOptions</a></code>\n给客户端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().setConnectTimeout(<span class=\"hljs-number\">10000</span>);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_making_connections\"><a class=\"anchor\" href=\"#_making_connections\"></a>创建连接</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/core/net/NetClient.html#connect-int-java.lang.String-io.vertx.core.Handler-\">connect</a></code> 方法创建到服务器的连接。\n请指定服务器的端口和主机，以及用于处理\n<code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 的处理器。当连接成功或失败时处理器会被调用。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().setConnectTimeout(<span class=\"hljs-number\">10000</span>);\nNetClient client = vertx.createNetClient(options);\nclient.connect(<span class=\"hljs-number\">4321</span>, <span class=\"hljs-string\">\"localhost\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Connected!\"</span>);\n    NetSocket socket = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to connect: \"</span> + res.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_connection_attempts\"><a class=\"anchor\" href=\"#_configuring_connection_attempts\"></a>配置连接重试</h3>\n<div class=\"paragraph\">\n<p>可以将客户端配置为在无法连接的情况下自动重试。\n这是通过 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html#setReconnectInterval-long-\">setReconnectInterval</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html#setReconnectAttempts-int-\">setReconnectAttempts</a></code> 方法配置的。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n目前如果连接失效，Vert.x将不尝试重新连接。\n重新连接尝试和时间间隔仅适用于创建初始连接。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setReconnectAttempts(<span class=\"hljs-number\">10</span>).\n  setReconnectInterval(<span class=\"hljs-number\">500</span>);\n\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，多个连接尝试是被禁用的。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"logging_network_activity\"><a class=\"anchor\" href=\"#logging_network_activity\"></a>记录网络活动</h3>\n<div class=\"paragraph\">\n<p>网络活动可以被记录下来，用于调试：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().setLogActivity(<span class=\"hljs-keyword\">true</span>);\n\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于客户端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().setLogActivity(<span class=\"hljs-keyword\">true</span>);\n\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Netty 使用 <code>DEBUG</code> 级别和 <code>io.netty.handler.logging.LoggingHandler</code> 名称来记录网络活动。\n使用网络活动记录时，需要注意以下几点：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>日志的记录是由Netty而不是Vert.x的日志来执行</p>\n</li>\n<li>\n<p>这个功能 <strong>不能</strong> 用于生产环境</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您应该阅读 <a href=\"#netty-logging\">Netty 日志记录</a> 章节来了解详细信息。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"ssl\"><a class=\"anchor\" href=\"#ssl\"></a>配置服务端和客户端以使用SSL/TLS</h3>\n<div class=\"paragraph\">\n<p>TCP 客户端和服务端可以通过配置来使用 [TLS（传输层安全性协议）]<a href=\"http://en.wikipedia.org/wiki/Transport_Layer_Security\">Transport Layer Security</a>\n——早期版本的TLS被称为SSL。</p>\n</div>\n<div class=\"paragraph\">\n<p>无论是否使用SSL/TLS，服务器和客户端的API都是相同的。通过创建客户端/服务器时使用的\n<code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html\">NetClientOptions</a></code> 或 / <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html\">NetServerOptions</a></code>\n来启用TLS/SSL。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_enabling_ssltls_on_the_server\"><a class=\"anchor\" href=\"#_enabling_ssltls_on_the_server\"></a>在服务端启用SSL/TLS</h4>\n<div class=\"paragraph\">\n<p>您需要设置 <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html#setSsl-boolean-\">ssl</a></code> 配置项来启用 SSL/TLS。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认是禁用的。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_specifying_keycertificate_for_the_server\"><a class=\"anchor\" href=\"#_specifying_keycertificate_for_the_server\"></a>指定服务端的密钥/证书</h4>\n<div class=\"paragraph\">\n<p>SSL/TLS 服务端通常向客户端提供证书，以便验证服务端的身份。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以通过以下几种方式为服务端配置证书/密钥：</p>\n</div>\n<div class=\"paragraph\">\n<p>第一种方法是指定包含证书和私钥的Java密钥库位置。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以使用 JDK 附带的 <a href=\"http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html\">keytool</a>\n实用程序来管理Java密钥存储。</p>\n</div>\n<div class=\"paragraph\">\n<p>还应提供密钥存储的密码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().setSsl(<span class=\"hljs-keyword\">true</span>).setKeyStoreOptions(\n  <span class=\"hljs-keyword\">new</span> JksOptions().\n    setPath(<span class=\"hljs-string\">\"/path/to/your/server-keystore.jks\"</span>).\n    setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>)\n);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者，您可以自己读取密钥库到一个Buffer，并将它直接提供给 <code>JksOptions</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/server-keystore.jks\"</span>);\nJksOptions jksOptions = <span class=\"hljs-keyword\">new</span> JksOptions().\n  setValue(myKeyStoreAsABuffer).\n  setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>);\nNetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setKeyStoreOptions(jksOptions);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>PKCS＃12格式的密钥/证书（ <a href=\"http://en.wikipedia.org/wiki/PKCS_12\" class=\"bare\">http://en.wikipedia.org/wiki/PKCS_12</a> ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名），\n也可以用与JKS密钥存储相似的方式加载：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().setSsl(<span class=\"hljs-keyword\">true</span>).setPfxKeyCertOptions(\n  <span class=\"hljs-keyword\">new</span> PfxOptions().\n    setPath(<span class=\"hljs-string\">\"/path/to/your/server-keystore.pfx\"</span>).\n    setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>)\n);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过Buffer来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/server-keystore.pfx\"</span>);\nPfxOptions pfxOptions = <span class=\"hljs-keyword\">new</span> PfxOptions().\n  setValue(myKeyStoreAsABuffer).\n  setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>);\nNetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPfxKeyCertOptions(pfxOptions);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>另外一种分别提供服务器私钥和证书的方法是使用 <code>.pem</code> 文件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().setSsl(<span class=\"hljs-keyword\">true</span>).setPemKeyCertOptions(\n  <span class=\"hljs-keyword\">new</span> PemKeyCertOptions().\n    setKeyPath(<span class=\"hljs-string\">\"/path/to/your/server-key.pem\"</span>).\n    setCertPath(<span class=\"hljs-string\">\"/path/to/your/server-cert.pem\"</span>)\n);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过 <code>Buffer</code> 来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myKeyAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/server-key.pem\"</span>);\nBuffer myCertAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/server-cert.pem\"</span>);\nPemKeyCertOptions pemOptions = <span class=\"hljs-keyword\">new</span> PemKeyCertOptions().\n  setKeyValue(myKeyAsABuffer).\n  setCertValue(myCertAsABuffer);\nNetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPemKeyCertOptions(pemOptions);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x支持从PKCS8 PEM文件中读取未加密的基于RSA和/或ECC的私钥。\n也可以从PKCS1 PEM文件中读取基于RSA的私钥。\n若PEM文件包含由 <a href=\"https://tools.ietf.org/html/rfc7468#section-5\">RFC 7468, Section 5</a> 定义的文本编码证书，\n可以从该PEM文件中读取X.509证书。</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n请记住，未加密的PKCS8或PKCS1 PEM文件中包含的密钥，\n可以被有这些文件读取权限的人提取出来。因此，请确保对此类PEM文件设置适当的访问限制，\n以防止滥用。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>最后，您还可以加载通用Java密钥库，使用其他密钥库实现时非常有用，\n比如使用Bouncy Castle时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().setSsl(<span class=\"hljs-keyword\">true</span>).setKeyCertOptions(\n  <span class=\"hljs-keyword\">new</span> KeyStoreOptions().\n    setType(<span class=\"hljs-string\">\"BKS\"</span>).\n    setPath(<span class=\"hljs-string\">\"/path/to/your/server-keystore.bks\"</span>).\n    setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>)\n);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_specifying_trust_for_the_server\"><a class=\"anchor\" href=\"#_specifying_trust_for_the_server\"></a>指定服务器信任</h4>\n<div class=\"paragraph\">\n<p>SSL/TLS 服务端可以使用证书颁发机构来验证客户端的身份。</p>\n</div>\n<div class=\"paragraph\">\n<p>证书颁发机构可通过多种方式为服务端配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>可使用JDK随附的 <a href=\"http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html\">keytool</a>\n实用程序来管理Java 受信存储。</p>\n</div>\n<div class=\"paragraph\">\n<p>还应提供受信存储的密码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setClientAuth(ClientAuth.REQUIRED).\n  setTrustStoreOptions(\n    <span class=\"hljs-keyword\">new</span> JksOptions().\n      setPath(<span class=\"hljs-string\">\"/path/to/your/truststore.jks\"</span>).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者您可以自己读取受信存储到Buffer，并将它直接提供：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/truststore.jks\"</span>);\nNetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setClientAuth(ClientAuth.REQUIRED).\n  setTrustStoreOptions(\n    <span class=\"hljs-keyword\">new</span> JksOptions().\n      setValue(myTrustStoreAsABuffer).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>PKCS＃12格式的密钥/证书（ <a href=\"http://en.wikipedia.org/wiki/PKCS_12\" class=\"bare\">http://en.wikipedia.org/wiki/PKCS_12</a> ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名），\n也可以用与JKS密钥存储相似的方式加载：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setClientAuth(ClientAuth.REQUIRED).\n  setPfxTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PfxOptions().\n      setPath(<span class=\"hljs-string\">\"/path/to/your/truststore.pfx\"</span>).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过 <code>Buffer</code> 来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/truststore.pfx\"</span>);\nNetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setClientAuth(ClientAuth.REQUIRED).\n  setPfxTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PfxOptions().\n      setValue(myTrustStoreAsABuffer).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>另一种提供服务器证书颁发机构的方法是使用一个 <code>.pem</code> 文件列表。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setClientAuth(ClientAuth.REQUIRED).\n  setPemTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PemTrustOptions().\n      addCertPath(<span class=\"hljs-string\">\"/path/to/your/server-ca.pem\"</span>)\n  );\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过 <code>Buffer</code> 来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myCaAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/server-ca.pfx\"</span>);\nNetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setClientAuth(ClientAuth.REQUIRED).\n  setPemTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PemTrustOptions().\n      addCertValue(myCaAsABuffer)\n  );\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_enabling_ssltls_on_the_client\"><a class=\"anchor\" href=\"#_enabling_ssltls_on_the_client\"></a>客户端启用SSL/TLS</h4>\n<div class=\"paragraph\">\n<p>客户端也可以轻松地配置为SSL。使用SSL和使用标准套接字具有完全相同的API。</p>\n</div>\n<div class=\"paragraph\">\n<p>若要启用 <code>NetClient</code> 上的SSL，可调用函数 <code>setSSL(true)</code>。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_client_trust_configuration\"><a class=\"anchor\" href=\"#_client_trust_configuration\"></a>客户端受信配置</h4>\n<div class=\"paragraph\">\n<p>若客户端将 <code><a href=\"../../apidocs/io/vertx/core/net/ClientOptionsBase.html#setTrustAll-boolean-\">trustALl</a></code>  设置为 <code>true</code>，\n则客户端将信任所有服务端证书。连接仍然会被加密，但这种模式很容易受到中间人攻击。\n即您无法确定您正连接到谁，请谨慎使用。默认值为 <code>false</code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setTrustAll(<span class=\"hljs-keyword\">true</span>);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若客户端没有设置 <code><a href=\"../../apidocs/io/vertx/core/net/ClientOptionsBase.html#setTrustAll-boolean-\">trustAll</a></code> ，则必须配置客户端受信存储，\n并且受信客户端应该包含服务器的证书。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，客户端禁用主机验证。\n要启用主机验证，请在客户端上设置使用的算法（目前仅支持HTTPS和LDAPS）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setHostnameVerificationAlgorithm(<span class=\"hljs-string\">\"HTTPS\"</span>);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>和服务器配置相同，也可通过以下几种方式配置受信客户端：</p>\n</div>\n<div class=\"paragraph\">\n<p>第一种方法是指定包含证书颁发机构的Java受信库的位置。</p>\n</div>\n<div class=\"paragraph\">\n<p>它只是一个标准的Java密钥存储，与服务器端的密钥存储相同。\n通过在 <code><a href=\"../../apidocs/io/vertx/core/net/JksOptions.html\">jks options</a></code> 上使用 <code><a href=\"../../apidocs/io/vertx/core/net/JksOptions.html#setPath-java.lang.String-\">path</a></code>\n设置客户端受信存储位置。\n如果服务器在连接期间提供不在客户端受信存储中的证书，则尝试连接将不会成功。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setTrustStoreOptions(\n    <span class=\"hljs-keyword\">new</span> JksOptions().\n      setPath(<span class=\"hljs-string\">\"/path/to/your/truststore.jks\"</span>).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它也支持 <code>Buffer</code> 的配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/truststore.jks\"</span>);\nNetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setTrustStoreOptions(\n    <span class=\"hljs-keyword\">new</span> JksOptions().\n      setValue(myTrustStoreAsABuffer).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>PKCS＃12格式的密钥/证书（ <a href=\"http://en.wikipedia.org/wiki/PKCS_12\" class=\"bare\">http://en.wikipedia.org/wiki/PKCS_12</a> ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名），\n也可以用与JKS密钥存储相似的方式加载：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPfxTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PfxOptions().\n      setPath(<span class=\"hljs-string\">\"/path/to/your/truststore.pfx\"</span>).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它也支持 <code>Buffer</code> 的配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/truststore.pfx\"</span>);\nNetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPfxTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PfxOptions().\n      setValue(myTrustStoreAsABuffer).\n      setPassword(<span class=\"hljs-string\">\"password-of-your-truststore\"</span>)\n  );\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>另一种提供服务器证书颁发机构的方法是使用一个 <code>.pem</code> 文件列表。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPemTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PemTrustOptions().\n      addCertPath(<span class=\"hljs-string\">\"/path/to/your/ca-cert.pem\"</span>)\n  );\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它也支持 <code>Buffer</code> 的配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/ca-cert.pem\"</span>);\nNetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPemTrustOptions(\n    <span class=\"hljs-keyword\">new</span> PemTrustOptions().\n      addCertValue(myTrustStoreAsABuffer)\n  );\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_specifying_keycertificate_for_the_client\"><a class=\"anchor\" href=\"#_specifying_keycertificate_for_the_client\"></a>指定客户端的密钥/证书</h4>\n<div class=\"paragraph\">\n<p>如果服务器需要客户端认证，那么当连接时，客户端必须向服务器提供自己的证书。\n可通过以下几种方式配置客户端：</p>\n</div>\n<div class=\"paragraph\">\n<p>第一种方法是指定包含密钥和证书的Java密钥库的位置，它只是一个常规的Java密钥存储。\n使用 <code><a href=\"../../apidocs/io/vertx/core/net/JksOptions.html\">jks options</a></code> 上的\n<code><a href=\"../../apidocs/io/vertx/core/net/JksOptions.html#setPath-java.lang.String-\">path</a></code>\n方法设置客户端密钥库位置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().setSsl(<span class=\"hljs-keyword\">true</span>).setKeyStoreOptions(\n  <span class=\"hljs-keyword\">new</span> JksOptions().\n    setPath(<span class=\"hljs-string\">\"/path/to/your/client-keystore.jks\"</span>).\n    setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>)\n);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过 <code>Buffer</code> 来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/client-keystore.jks\"</span>);\nJksOptions jksOptions = <span class=\"hljs-keyword\">new</span> JksOptions().\n  setValue(myKeyStoreAsABuffer).\n  setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>);\nNetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setKeyStoreOptions(jksOptions);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>PKCS#12格式的密钥/证书（ <a href=\"http://en.wikipedia.org/wiki/PKCS_12\" class=\"bare\">http://en.wikipedia.org/wiki/PKCS_12</a> ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名），\n也可以用与JKS密钥存储相似的方式加载：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().setSsl(<span class=\"hljs-keyword\">true</span>).setPfxKeyCertOptions(\n  <span class=\"hljs-keyword\">new</span> PfxOptions().\n    setPath(<span class=\"hljs-string\">\"/path/to/your/client-keystore.pfx\"</span>).\n    setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>)\n);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过 <code>Buffer</code> 来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/client-keystore.pfx\"</span>);\nPfxOptions pfxOptions = <span class=\"hljs-keyword\">new</span> PfxOptions().\n  setValue(myKeyStoreAsABuffer).\n  setPassword(<span class=\"hljs-string\">\"password-of-your-keystore\"</span>);\nNetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPfxKeyCertOptions(pfxOptions);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>另一种单独提供服务器私钥和证书的方法是使用 <code>.pem</code> 文件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().setSsl(<span class=\"hljs-keyword\">true</span>).setPemKeyCertOptions(\n  <span class=\"hljs-keyword\">new</span> PemKeyCertOptions().\n    setKeyPath(<span class=\"hljs-string\">\"/path/to/your/client-key.pem\"</span>).\n    setCertPath(<span class=\"hljs-string\">\"/path/to/your/client-cert.pem\"</span>)\n);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过 <code>Buffer</code> 来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myKeyAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/client-key.pem\"</span>);\nBuffer myCertAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/client-cert.pem\"</span>);\nPemKeyCertOptions pemOptions = <span class=\"hljs-keyword\">new</span> PemKeyCertOptions().\n  setKeyValue(myKeyAsABuffer).\n  setCertValue(myCertAsABuffer);\nNetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setPemKeyCertOptions(pemOptions);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请记住 <code>pem</code> 的配置中，私钥是不加密的。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_self_signed_certificates_for_testing_and_development_purposes\"><a class=\"anchor\" href=\"#_self_signed_certificates_for_testing_and_development_purposes\"></a>用于测试和开发目的的自签名证书</h4>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n不要在生产设置中使用，这里生成的密钥非常不安全。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>在运行单元/集成测试或是运行开发版的应用程序时，\n都经常需要自签名证书。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/net/SelfSignedCertificate.html\">SelfSignedCertificate</a></code> 可用于提供自签名PEM证书，并可以提供\n<code><a href=\"../../apidocs/io/vertx/core/net/KeyCertOptions.html\">KeyCertOptions</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/net/TrustOptions.html\">TrustOptions</a></code> 配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SelfSignedCertificate certificate = SelfSignedCertificate.create();\n\nNetServerOptions serverOptions = <span class=\"hljs-keyword\">new</span> NetServerOptions()\n  .setSsl(<span class=\"hljs-keyword\">true</span>)\n  .setKeyCertOptions(certificate.keyCertOptions())\n  .setTrustOptions(certificate.trustOptions());\n\nvertx.createNetServer(serverOptions)\n  .connectHandler(socket -&gt; socket.end(Buffer.buffer(<span class=\"hljs-string\">\"Hello!\"</span>)))\n  .listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>);\n\nNetClientOptions clientOptions = <span class=\"hljs-keyword\">new</span> NetClientOptions()\n  .setSsl(<span class=\"hljs-keyword\">true</span>)\n  .setKeyCertOptions(certificate.keyCertOptions())\n  .setTrustOptions(certificate.trustOptions());\n\nNetClient client = vertx.createNetClient(clientOptions);\nclient.connect(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    ar.result().handler(buffer -&gt; System.out.println(buffer));\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Woops: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端也可配置为信任所有证书：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions clientOptions = <span class=\"hljs-keyword\">new</span> NetClientOptions()\n  .setSsl(<span class=\"hljs-keyword\">true</span>)\n  .setTrustAll(<span class=\"hljs-keyword\">true</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>自签名证书也适用于其他基于TCP的协议，如HTTPS：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SelfSignedCertificate certificate = SelfSignedCertificate.create();\n\nvertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions()\n  .setSsl(<span class=\"hljs-keyword\">true</span>)\n  .setKeyCertOptions(certificate.keyCertOptions())\n  .setTrustOptions(certificate.trustOptions()))\n  .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">\"Hello!\"</span>))\n  .listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_revoking_certificate_authorities\"><a class=\"anchor\" href=\"#_revoking_certificate_authorities\"></a>待撤销证书颁发机构</h4>\n<div class=\"paragraph\">\n<p>可以通过配置证书吊销列表（CRL）来吊销不再被信任的证书机构。\n<code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html#addCrlPath-java.lang.String-\">crlPath</a></code>\n配置了使用的CRL：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setTrustStoreOptions(trustOptions).\n  addCrlPath(<span class=\"hljs-string\">\"/path/to/your/crl.pem\"</span>);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也支持通过 <code>Buffer</code> 来配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer myCrlAsABuffer = vertx.fileSystem().readFileBlocking(<span class=\"hljs-string\">\"/path/to/your/crl.pem\"</span>);\nNetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setTrustStoreOptions(trustOptions).\n  addCrlValue(myCrlAsABuffer);\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_configuring_the_cipher_suite\"><a class=\"anchor\" href=\"#_configuring_the_cipher_suite\"></a>配置密码套件</h4>\n<div class=\"paragraph\">\n<p>默认情况下，TLS配置将使用运行Vert.x的JVM 密码套件，该密码套件可以\n配置一套启用的密码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setKeyStoreOptions(keyStoreOptions).\n  addEnabledCipherSuite(<span class=\"hljs-string\">\"ECDHE-RSA-AES128-GCM-SHA256\"</span>).\n  addEnabledCipherSuite(<span class=\"hljs-string\">\"ECDHE-ECDSA-AES128-GCM-SHA256\"</span>).\n  addEnabledCipherSuite(<span class=\"hljs-string\">\"ECDHE-RSA-AES256-GCM-SHA384\"</span>).\n  addEnabledCipherSuite(<span class=\"hljs-string\">\"CDHE-ECDSA-AES256-GCM-SHA384\"</span>);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>密码套件可在 <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html\">NetServerOptions</a></code> 或 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html\">NetClientOptions</a></code> 配置项中指定。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_configuring_tls_protocol_versions\"><a class=\"anchor\" href=\"#_configuring_tls_protocol_versions\"></a>配置TLS协议版本</h4>\n<div class=\"paragraph\">\n<p>默认情况下，TLS配置将使用以下协议版本：SSLv2Hello、TLSv1、TLSv1.1 和 TLSv1.2。\n协议版本可以通过显式添加启用协议进行配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setKeyStoreOptions(keyStoreOptions).\n  removeEnabledSecureTransportProtocol(<span class=\"hljs-string\">\"TLSv1\"</span>).\n  addEnabledSecureTransportProtocol(<span class=\"hljs-string\">\"TLSv1.3\"</span>);\nNetServer server = vertx.createNetServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>协议版本可在 <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html\">NetServerOptions</a></code> 或 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html\">NetClientOptions</a></code> 配置项中指定。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_ssl_engine\"><a class=\"anchor\" href=\"#_ssl_engine\"></a>SSL引擎</h4>\n<div class=\"paragraph\">\n<p>引擎实现可以配置为使用 <a href=\"https://www.openssl.org\">OpenSSL</a> 而不是JDK实现（来支持SSL）。\nOpenSSL提供比JDK引擎更好的性能和CPU使用率、以及JDK版本独立性。</p>\n</div>\n<div class=\"paragraph\">\n<p>引擎选项可使用：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>设置了 <code><a href=\"../../apidocs/io/vertx/core/net/TCPSSLOptions.html#getSslEngineOptions--\">getSslEngineOptions</a></code> 时，使用该选项</p>\n</li>\n<li>\n<p>否则使用 <code><a href=\"../../apidocs/io/vertx/core/net/JdkSSLEngineOptions.html\">JdkSSLEngineOptions</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setKeyStoreOptions(keyStoreOptions);\n\n<span class=\"hljs-comment\">// Use JDK SSL engine explicitly</span>\noptions = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setKeyStoreOptions(keyStoreOptions).\n  setJdkSslEngineOptions(<span class=\"hljs-keyword\">new</span> JdkSSLEngineOptions());\n\n<span class=\"hljs-comment\">// Use OpenSSL engine</span>\noptions = <span class=\"hljs-keyword\">new</span> NetServerOptions().\n  setSsl(<span class=\"hljs-keyword\">true</span>).\n  setKeyStoreOptions(keyStoreOptions).\n  setOpenSslEngineOptions(<span class=\"hljs-keyword\">new</span> OpenSSLEngineOptions());</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_name_indication_sni\"><a class=\"anchor\" href=\"#_server_name_indication_sni\"></a>服务器名称指示（SNI）</h4>\n<div class=\"paragraph\">\n<p>服务器名称指示（英語：Server Name Indication，缩写：SNI）是TLS的一个扩展协议，需要指定尝试连接的主机名：\nTLS握手开始时客户端提供要连接的服务器名称，服务端根据该服务器名称，返回主机名对应的证书，\n而非默认部署的证书。\n如果服务器要求客户端身份验证，则服务器可以根据指定的服务器名称，\n使用特定的受信任CA证书。</p>\n</div>\n<div class=\"paragraph\">\n<p>当SNI可用时，服务器使用以下规则匹配证书：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>服务器名称完全匹配的证书CN（Common Name，通用名称）或SAN DNS（带有DNS的主题备用名称），例如 <code>www.example.com</code></p>\n</li>\n<li>\n<p>带匹配通配符的服务器名称匹配的证书CN或SAN DNS证书，例如 <code>* .example.com</code></p>\n</li>\n<li>\n<p>否则，当客户端不提供服务器名称或提供的服务器名称无法匹配时，返回第一个证书</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>当服务器另外要求客户端身份验证时：</p>\n</div>\n<div class=\"paragraph\">\n<p>*如果使用 <code><a href=\"../../apidocs/io/vertx/core/net/JksOptions.html\">JksOptions</a></code> 设置信任选项\n（ <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html#setTrustOptions-io.vertx.core.net.TrustOptions-\">options</a></code> ），\n则将与信任库别名完全匹配\n*否则，将使用无SNI的方式处理可用的CA证书</p>\n</div>\n<div class=\"paragraph\">\n<p>通过设置 <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html#setSni-boolean-\">setSni</a></code> 为 <code>true</code>，可以在服务器上启用SNI，\n并为服务器配置多个密钥/证书对。</p>\n</div>\n<div class=\"paragraph\">\n<p>Java KeyStore文件，或PKCS12文件可以开箱即用地存储多个密钥/证书对。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JksOptions keyCertOptions = <span class=\"hljs-keyword\">new</span> JksOptions().setPath(<span class=\"hljs-string\">\"keystore.jks\"</span>).setPassword(<span class=\"hljs-string\">\"wibble\"</span>);\n\nNetServer netServer = vertx.createNetServer(<span class=\"hljs-keyword\">new</span> NetServerOptions()\n    .setKeyStoreOptions(keyCertOptions)\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n    .setSni(<span class=\"hljs-keyword\">true</span>)\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/net/PemKeyCertOptions.html\">PemKeyCertOptions</a></code> can be configured to hold multiple entries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PemKeyCertOptions keyCertOptions = <span class=\"hljs-keyword\">new</span> PemKeyCertOptions()\n    .setKeyPaths(Arrays.asList(<span class=\"hljs-string\">\"default-key.pem\"</span>, <span class=\"hljs-string\">\"host1-key.pem\"</span>, <span class=\"hljs-string\">\"etc...\"</span>))\n    .setCertPaths(Arrays.asList(<span class=\"hljs-string\">\"default-cert.pem\"</span>, <span class=\"hljs-string\">\"host2-key.pem\"</span>, <span class=\"hljs-string\">\"etc...\"</span>)\n    );\n\nNetServer netServer = vertx.createNetServer(<span class=\"hljs-keyword\">new</span> NetServerOptions()\n    .setPemKeyCertOptions(keyCertOptions)\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n    .setSni(<span class=\"hljs-keyword\">true</span>)\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端默认使用连接的主机名的完全限定域名（Fully Qualified Domain Name，缩写：FQDN）作为SNI服务器名称。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以在连接socket时，提供明确的服务器名称。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClient client = vertx.createNetClient(<span class=\"hljs-keyword\">new</span> NetClientOptions()\n    .setTrustStoreOptions(trustOptions)\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n);\n\n<span class=\"hljs-comment\">// 连接到 'localhost'，并以 'server.name'为服务器名</span>\nclient.connect(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"server.name\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Connected!\"</span>);\n    NetSocket socket = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to connect: \"</span> + res.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以用于以下目的：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>指定与服务器主机不一样的服务器名称</p>\n</li>\n<li>\n<p>使用IP进行连接时，指定服务器名称</p>\n</li>\n<li>\n<p>使用短名称进行连接时，强制指定服务器名称</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_application_layer_protocol_negotiation_alpn\"><a class=\"anchor\" href=\"#_application_layer_protocol_negotiation_alpn\"></a>应用层协议协商</h4>\n<div class=\"paragraph\">\n<p>ALPN(Application-Layer Protocol Negotiation)是应用层协议协商的TLS扩展，它被HTTP/2使用：\n在TLS握手期时，客户端给出其接受的应用协议列表，\n之后服务器使用它所支持的协议响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>Java 9 支持HTTP/2，可以开箱即用，无需其他步骤。</p>\n</div>\n<div class=\"paragraph\">\n<p>标准的Java 8不支持ALPN，所以ALPN应该通过其他方式启用：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><em>OpenSSL</em> 支持</p>\n</li>\n<li>\n<p><em>Jetty-ALPN</em> 支持</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>引擎选项可使用:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>设置了 <code><a href=\"../../apidocs/io/vertx/core/net/TCPSSLOptions.html#getSslEngineOptions--\">getSslEngineOptions</a></code> 时，使用该选项</p>\n</li>\n<li>\n<p>JDK中ALPN可用时，使用 <code><a href=\"../../apidocs/io/vertx/core/net/JdkSSLEngineOptions.html\">JdkSSLEngineOptions</a></code></p>\n</li>\n<li>\n<p>OpenSSL中ALPN可用时，使用 <code><a href=\"../../apidocs/io/vertx/core/net/OpenSSLEngineOptions.html\">OpenSSLEngineOptions</a></code></p>\n</li>\n<li>\n<p>否则失败</p>\n</li>\n</ul>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_openssl_alpn_support\"><a class=\"anchor\" href=\"#_openssl_alpn_support\"></a>OpenSSL ALPN支持</h5>\n<div class=\"paragraph\">\n<p>OpenSSL提供了原生的ALPN支持。</p>\n</div>\n<div class=\"paragraph\">\n<p>OpenSSL需要配置 <code><a href=\"../../apidocs/io/vertx/core/net/TCPSSLOptions.html#setOpenSslEngineOptions-io.vertx.core.net.OpenSSLEngineOptions-\">setOpenSslEngineOptions</a></code>\n并在类路径上使用 <a href=\"http://netty.io/wiki/forked-tomcat-native.html\">netty-tcnative</a> 的jar库。\n依赖于tcnative的实现，需要OpenSSL安装在您的操作系统中。</p>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_jetty_alpn_support\"><a class=\"anchor\" href=\"#_jetty_alpn_support\"></a>Jetty-ALPN支持</h5>\n<div class=\"paragraph\">\n<p>Jetty-ALPN是一个小型的jar，它覆盖了几种Java 8发行版用以支持ALPN。</p>\n</div>\n<div class=\"paragraph\">\n<p>JVM必须将 <em>alpn-boot-${version}.jar</em> 放在它的 <code>bootclasspath</code> 中启动：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Xbootclasspath/p:/path/to/alpn-boot${version}.jar</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>其中 ${version} 取决于JVM的版本，如 <em>OpenJDK 1.8.0u74</em> 中的 <em>8.1.7.v20160121</em>。\n这个完整列表可以在 <a href=\"http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html\">Jetty-ALPN page</a> 页面上找到。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种方法主要缺点是ALPN的实现版本依赖于JVM的版本。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了解决这个问题，可以使用 <em><a href=\"https://github.com/jetty-project/jetty-alpn-agent\">Jetty ALPN agent</a></em> 。agent是一个JVM代理，\n它会为运行它的JVM选择正确的ALPN版本：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-javaagent:/path/to/alpn/agent</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_a_proxy_for_client_connections\"><a class=\"anchor\" href=\"#_using_a_proxy_for_client_connections\"></a>客户端连接使用代理</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/net/NetClient.html\">NetClient</a></code> 支持HTTP/1.x <em>CONNECT</em>、<em>SOCKS4a</em> 或 <em>SOCKS5</em> 代理。</p>\n</div>\n<div class=\"paragraph\">\n<p>代理可以在 <code><a href=\"../../apidocs/io/vertx/core/net/NetClientOptions.html\">NetClientOptions</a></code> 内设置\n<code><a href=\"../../apidocs/io/vertx/core/net/ProxyOptions.html\">ProxyOptions</a></code> 来配置代理类型、主机名、端口、可选的用户名和密码。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClientOptions options = <span class=\"hljs-keyword\">new</span> NetClientOptions()\n  .setProxyOptions(<span class=\"hljs-keyword\">new</span> ProxyOptions().setType(ProxyType.SOCKS5)\n    .setHost(<span class=\"hljs-string\">\"localhost\"</span>).setPort(<span class=\"hljs-number\">1080</span>)\n    .setUsername(<span class=\"hljs-string\">\"username\"</span>).setPassword(<span class=\"hljs-string\">\"secret\"</span>));\nNetClient client = vertx.createNetClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>DNS 解析总是在代理服务器上完成解析，为了实现 SOCKS4 客户端的功能，\n需要先在本地解析 DNS 地址。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_ha_proxy_protocol\"><a class=\"anchor\" href=\"#_using_ha_proxy_protocol\"></a>使用HA PROXY协议</h3>\n<div class=\"paragraph\">\n<p><a href=\"https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">HA PROXY 协议</a> 提供了一种便捷的安全传输连接信息\n（例如客户端的地址）的方式，\n可以跨多层NAT或TCP代理传输。</p>\n</div>\n<div class=\"paragraph\">\n<p>HA PROXY 协议通过 <code><a href=\"../../apidocs/io/vertx/core/net/NetServerOptions.html#setUseProxyProtocol-boolean-\">setUseProxyProtocol</a></code> 方法设置启用，\n同时需要在classpath中增加以下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.netty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>netty-codec-haproxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-comment\">&lt;!--&lt;version&gt;该版本号需要和Vert.x使用的netty版本对齐&lt;/version&gt;--&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServerOptions options = <span class=\"hljs-keyword\">new</span> NetServerOptions().setUseProxyProtocol(<span class=\"hljs-keyword\">true</span>);\nNetServer server = vertx.createNetServer(options);\nserver.connectHandler(so -&gt; {\n  <span class=\"hljs-comment\">// 打印HA Proxy协议提供的真实客户端地址，而非代理的地址</span>\n  System.out.println(so.remoteAddress());\n\n  <span class=\"hljs-comment\">// 打印代理的地址</span>\n  System.out.println(so.localAddress());\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_writing_http_servers_and_clients\"><a class=\"anchor\" href=\"#_writing_http_servers_and_clients\"></a>编写 HTTP 服务端和客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 允许您轻松编写非阻塞的 HTTP 客户端和服务端。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 支持 HTTP/1.0、HTTP/1.1 和 HTTP/2 协议。</p>\n</div>\n<div class=\"paragraph\">\n<p>用于 HTTP 的基本 API 对 HTTP/1.x 和 HTTP/2 是相同的，特定的API功能也可用于处理\nHTTP/2 协议。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_an_http_server\"><a class=\"anchor\" href=\"#_creating_an_http_server\"></a>创建 HTTP 服务端</h3>\n<div class=\"paragraph\">\n<p>使用所有默认选项创建 HTTP 服务端的最简单方法如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_an_http_server\"><a class=\"anchor\" href=\"#_configuring_an_http_server\"></a>配置 HTTP 服务端</h3>\n<div class=\"paragraph\">\n<p>若您不想用默认值，可以在创建服务器时传递一个  <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html\">HttpServerOptions</a></code>\n实例给它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerOptions options = <span class=\"hljs-keyword\">new</span> HttpServerOptions().setMaxWebSocketFrameSize(<span class=\"hljs-number\">1000000</span>);\n\nHttpServer server = vertx.createHttpServer(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_an_http2_server\"><a class=\"anchor\" href=\"#_configuring_an_http2_server\"></a>配置 HTTP/2 服务端</h3>\n<div class=\"paragraph\">\n<p>Vert.x 通过 TLS 之上的 <code>h2</code> 和 TCP 之上的 <code>h2c</code> 来支持 HTTP/2 协议。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>h2</code> 表示使用了TLS的 <a href=\"https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation\">应用层协议协商</a> (ALPN)协议来协商的 HTTP/2 协议</p>\n</li>\n<li>\n<p><code>h2c</code> 表示在TCP层上使用明文形式的 HTTP/2 协议，\n这样的连接可以使用 HTTP/1.1 升级请求建立，也可以直接建立。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>要处理 <code>h2</code> 请求，你必须调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setUseAlpn-boolean-\">setUseAlpn</a></code> 方法来启用TLS：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerOptions options = <span class=\"hljs-keyword\">new</span> HttpServerOptions()\n    .setUseAlpn(<span class=\"hljs-keyword\">true</span>)\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n    .setKeyStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions().setPath(<span class=\"hljs-string\">\"/path/to/my/keystore\"</span>));\n\nHttpServer server = vertx.createHttpServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>ALPN是一个TLS的扩展，它在客户端和服务器开始交换数据之前协商协议。</p>\n</div>\n<div class=\"paragraph\">\n<p>不支持ALPN的客户端仍然可以执行 <em>经典的</em> SSL握手。</p>\n</div>\n<div class=\"paragraph\">\n<p>通常情况，ALPN会对 <code>h2</code> 协议达成一致，不过服务器或客户端仍然可以决定使用\n<code>HTTP/1.1</code> 协议。</p>\n</div>\n<div class=\"paragraph\">\n<p>要处理 <code>h2c</code> 请求，TLS必须被禁用，服务器将升级到 HTTP/2 以满足任何希望升级到 HTTP/2 的 HTTP/1.1 请求。\n它还将接受以 <code>PRI * HTTP/2.0\\r\\nSM\\r\\n</code> 开始的 <code>h2c</code> 直接连接。</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n大多数浏览器不支持 <code>h2c</code>，所以在建站时，您应该使用 <code>h2</code> 而不是 <code>h2c</code>。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>当服务器接受 HTTP/2 连接时，它会向客户端发送其 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#getInitialSettings--\">初始设置</a></code> 。\n定义客户端如何使用连接，服务器的默认初始设置为：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/http/Http2Settings.html#getMaxConcurrentStreams--\">getMaxConcurrentStreams</a></code> ：按照 HTTP/2 RFC建议推荐值为 <code>100</code></p>\n</li>\n<li>\n<p>其他默认的 HTTP/2 的设置</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_logging_network_server_activity\"><a class=\"anchor\" href=\"#_logging_network_server_activity\"></a>服务端网络活动日志</h3>\n<div class=\"paragraph\">\n<p>网络活动可以被记录下来，用于调试。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerOptions options = <span class=\"hljs-keyword\">new</span> HttpServerOptions().setLogActivity(<span class=\"hljs-keyword\">true</span>);\n\nHttpServer server = vertx.createHttpServer(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>详细说明请参阅 <a href=\"#logging_network_activity\">网络活动日志</a> 章节。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_start_the_server_listening_2\"><a class=\"anchor\" href=\"#_start_the_server_listening_2\"></a>开启服务端监听</h3>\n<div class=\"paragraph\">\n<p>要告诉服务器监听传入的请求，您可以使用其中一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServer.html#listen--\">listen</a></code>\n方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>在配置项中让服务器监听指定的主机和端口：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer(); <span class=\"hljs-comment\">// 译者注：配置服务器监听指定的主机和端口的例子：vertx.createHttpServer(new HttpServerOptions().setPort(8080).setHost(\"0.0.0.0\"))</span>\nserver.listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或在调用listen方法时指定主机和端口号，这样就忽略了配置项（中的主机和端口）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer();\nserver.listen(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myhost.com\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认主机名是 <code>0.0.0.0</code> ，它表示：监听所有可用地址；默认端口号是 <code>80</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>实际的绑定也是异步的，因此服务器也许并没有在调用listen方法返回时监听，而是在一段时间 <strong>过后</strong>\n才监听。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您希望在服务器实际监听时收到通知，您可以向 <code>listen</code> 提供一个处理器。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer();\nserver.listen(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myhost.com\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Server is now listening!\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to bind!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_getting_notified_of_incoming_requests\"><a class=\"anchor\" href=\"#_getting_notified_of_incoming_requests\"></a>收到传入请求的通知</h3>\n<div class=\"paragraph\">\n<p>若您需要在收到请求时收到通知，则需要设置一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServer.html#requestHandler-io.vertx.core.Handler-\">requestHandler</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer();\nserver.requestHandler(request -&gt; {\n  <span class=\"hljs-comment\">// Handle the request in here</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_requests\"><a class=\"anchor\" href=\"#_handling_requests\"></a>处理请求</h3>\n<div class=\"paragraph\">\n<p>当请求到达时，Vert.x 会像对应的处理函数传入一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> 实例并调用请求处理函数。\n此对象表示服务端 HTTP 请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>当请求的头信息被完全读取时会调用该请求处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果请求包含请求体，那么该请求体将在请求处理器被调用后的某个时间到达服务器。</p>\n</div>\n<div class=\"paragraph\">\n<p>服务请求对象允许您读取 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#uri--\">uri</a></code>，\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#path--\">path</a></code>， <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#params--\">params</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#headers--\">headers</a></code> 等其他信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>每一个服务请求对象和一个服务响应对象绑定，您可以用\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#response--\">response</a></code> 方法获取一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html\">HttpServerResponse</a></code>\n对象的引用。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是服务器处理请求并回复 “hello world” 的简单示例。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(request -&gt; {\n  request.response().end(<span class=\"hljs-string\">\"Hello world\"</span>);\n}).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_version\"><a class=\"anchor\" href=\"#_request_version\"></a>请求版本</h4>\n<div class=\"paragraph\">\n<p>在请求中指定的 HTTP 版本可通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#version--\">version</a></code> 方法获取。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_method\"><a class=\"anchor\" href=\"#_request_method\"></a>请求方法</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#method--\">method</a></code> 方法读取请求中的 HTTP 方法。\n（即GET、POST、PUT、DELETE、HEAD、OPTIONS等）。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_uri\"><a class=\"anchor\" href=\"#_request_uri\"></a>请求URI</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#uri--\">uri</a></code> 方法读取请求中的URI路径。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意，这是在HTTP请求中传递的实际URI，它总是一个相对的URI。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个URI是在 <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html\">Section 5.1.2 of the HTTP specification - Request-URI</a> 中定义的。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_path\"><a class=\"anchor\" href=\"#_request_path\"></a>请求路径</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#path--\">path</a></code> 方法读取URI中的路径部分。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，请求的URI为：</p>\n</div>\n<div class=\"paragraph\">\n<p>a/b/c/page.html?param1=abc&amp;param2=xyz</p>\n</div>\n<div class=\"paragraph\">\n<p>请求路径是：</p>\n</div>\n<div class=\"paragraph\">\n<p>/a/b/c/page.html</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_query\"><a class=\"anchor\" href=\"#_request_query\"></a>请求查询</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#query--\">query</a></code> 读取URI中的查询部分。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，请求的URI为：</p>\n</div>\n<div class=\"paragraph\">\n<p>a/b/c/page.html?param1=abc&amp;param2=xyz</p>\n</div>\n<div class=\"paragraph\">\n<p>请求查询是：</p>\n</div>\n<div class=\"paragraph\">\n<p>param1=abc&amp;param2=xyz</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_headers\"><a class=\"anchor\" href=\"#_request_headers\"></a>请求头部</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#headers--\">headers</a></code> 方法获取HTTP请求中的请求头部信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个方法返回一个 <code><a href=\"../../apidocs/io/vertx/core/MultiMap.html\">MultiMap</a></code> 实例。它像一个普通的Map或哈希表，并且它还允许同个键对应多个值\n—— 因为HTTP允许同一个键对应多个请求头的值。</p>\n</div>\n<div class=\"paragraph\">\n<p>它的键不区分大小写，这意味着您可以执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultiMap headers = request.headers();\n\n<span class=\"hljs-comment\">// 读取User-Agent</span>\nSystem.out.println(<span class=\"hljs-string\">\"User agent is \"</span> + headers.get(<span class=\"hljs-string\">\"user-agent\"</span>));\n\n<span class=\"hljs-comment\">// 这样做可以得到和上边相同的结果</span>\nSystem.out.println(<span class=\"hljs-string\">\"User agent is \"</span> + headers.get(<span class=\"hljs-string\">\"User-Agent\"</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_host\"><a class=\"anchor\" href=\"#_request_host\"></a>请求主机</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#host--\">host</a></code> 方法返回HTTP请求中的主机名。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 HTTP/1.x 请求返回请求头中的 <code>host</code> 值，对于 HTTP/2 请求则返回伪头中的 <code>:authority</code> 的值。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_parameters\"><a class=\"anchor\" href=\"#_request_parameters\"></a>请求参数</h4>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#params--\">params</a></code> 方法返回HTTP请求中的参数信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>像 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#headers--\">headers</a></code> 方法一样，它也会返回一个 <code><a href=\"../../apidocs/io/vertx/core/MultiMap.html\">MultiMap</a></code>\n实例，因为可以有多个具有相同名称的参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>请求参数在请求URI的 path 部分之后，例如URI是：</p>\n</div>\n<div class=\"paragraph\">\n<p>/page.html?param1=abc&amp;param2=xyz</p>\n</div>\n<div class=\"paragraph\">\n<p>那么参数将包含以下内容：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>param1: 'abc'\nparam2: 'xyz</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意，这些请求参数是从请求的 URI 中解析读取的，\n若您已经将表单属性存放在请求体中发送出去，并且该请求为 <code>multi-part/form-data</code>\n类型请求，那么它们将不会显示在此处的参数中。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_remote_address\"><a class=\"anchor\" href=\"#_remote_address\"></a>远程地址</h4>\n<div class=\"paragraph\">\n<p>可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#remoteAddress--\">remoteAddress</a></code> 方法读取请求发送者的地址。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_absolute_uri\"><a class=\"anchor\" href=\"#_absolute_uri\"></a>绝对URI</h4>\n<div class=\"paragraph\">\n<p>HTTP 请求中传递的URI通常是相对的，若您想要读取请求中和相对URI对应的绝对URI，\n可调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#absoluteURI--\">absoluteURI</a></code> 方法。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_end_handler\"><a class=\"anchor\" href=\"#_end_handler\"></a>结束处理器</h4>\n<div class=\"paragraph\">\n<p>当整个请求（包括所有请求体）已经被完全读取时，请求中的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#endHandler-io.vertx.core.Handler-\">endHandler</a></code>\n方法会被调用。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_reading_data_from_the_request_body\"><a class=\"anchor\" href=\"#_reading_data_from_the_request_body\"></a>从请求体中读取数据</h4>\n<div class=\"paragraph\">\n<p>HTTP请求通常包含我们需要读取的请求体。如前所述，当请求头部达到时，\n请求处理器会被调用，因此请求对象在此时没有请求体。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是因为请求体可能非常大（如文件上传），并且我们不会在内容发送给您之前将其全部缓冲存储在内存中，\n这可能会导致服务器耗尽可用内存。</p>\n</div>\n<div class=\"paragraph\">\n<p>要接收请求体，您可在请求中调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#handler-io.vertx.core.Handler-\">handler</a></code> 方法设置一个处理器，\n每次请求体的一小块数据收到时，该处理器都会被调用。以下是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.handler(buffer -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"I have received a chunk of the body of length \"</span> + buffer.length());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>传递给处理器的对象是一个 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code>，\n当数据从网络到达时，处理器可以多次被调用，这取决于请求体的大小。</p>\n</div>\n<div class=\"paragraph\">\n<p>在某些情况下（例：若请求体很小），您将需要将这个请求体聚合到内存中，\n您可以按照下边的方式进行聚合：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer totalBuffer = Buffer.buffer();\n\nrequest.handler(buffer -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"I have received a chunk of the body of length \"</span> + buffer.length());\n  totalBuffer.appendBuffer(buffer);\n});\n\nrequest.endHandler(v -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Full body received, length = \"</span> + totalBuffer.length());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这是一个常见的情况，Vert.x为您提供了一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#bodyHandler-io.vertx.core.Handler-\">bodyHandler</a></code> 方法来执行此操作。\n当所有请求体被收到时，<code>bodyHandler</code> 绑定的处理器会被调用一次：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.bodyHandler(totalBuffer -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Full body received, length = \"</span> + totalBuffer.length());\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_requests\"><a class=\"anchor\" href=\"#_streaming_requests\"></a>流式请求</h4>\n<div class=\"paragraph\">\n<p>请求对象实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 接口，因此您可以将请求体读取到任何\n<code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 实例中。</p>\n</div>\n<div class=\"paragraph\">\n<p>详细请参阅 <a href=\"#streams\">流</a> 章节。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_handling_html_forms\"><a class=\"anchor\" href=\"#_handling_html_forms\"></a>处理 HTML 表单</h4>\n<div class=\"paragraph\">\n<p>您可使用 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 这两种 content-type 来提交 HTML 表单。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于使用 URL 编码过的表单，表单属性会被编码在URL中，如同普通查询参数一样。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 multipart 类型的表单，它会被编码在请求体中，而且在整个请求体被\n完全读取之前它是不可用的。</p>\n</div>\n<div class=\"paragraph\">\n<p>Multipart 表单还可以包含文件上传。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您想要读取 multipart 表单的属性，您应该告诉 Vert.x 您会在读取任何请求体\n<strong>之前</strong> 调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#setExpectMultipart-boolean-\">setExpectMultipart</a></code> 方法，\n然后在整个请求体都被读取后，您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#formAttributes--\">formAttributes</a></code>\n方法来读取实际的表单属性。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  request.setExpectMultipart(<span class=\"hljs-keyword\">true</span>);\n  request.endHandler(v -&gt; {\n    <span class=\"hljs-comment\">// The body has now been fully read, so retrieve the form attributes</span>\n    MultiMap formAttributes = request.formAttributes();\n  });\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_handling_form_file_uploads\"><a class=\"anchor\" href=\"#_handling_form_file_uploads\"></a>处理文件上传</h4>\n<div class=\"paragraph\">\n<p>Vert.x 可以处理以 multipart 编码形式上传的的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>要接收文件，您可以告诉 Vert.x 使用 multipart 表单，并对请求设置\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#uploadHandler-io.vertx.core.Handler-\">uploadHandler</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>当服务器每次接收到上传请求时，\n该处理器将被调用一次。</p>\n</div>\n<div class=\"paragraph\">\n<p>传递给处理器的对象是一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerFileUpload.html\">HttpServerFileUpload</a></code> 实例。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  request.setExpectMultipart(<span class=\"hljs-keyword\">true</span>);\n  request.uploadHandler(upload -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"Got a file upload \"</span> + upload.name());\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上传的文件可能很大，我们不会在单个缓冲区中包含整个上传的数据，因为这样会导致内存耗尽。\n相反，上传数据是以块的形式被接收的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.uploadHandler(upload -&gt; {\n  upload.handler(chunk -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"Received a chunk of the upload of length \"</span> + chunk.length());\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上传对象实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 接口，因此您可以将请求体读取到任何\n<code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 实例中。详细说明请参阅 <a href=\"#streams\">流</a>\n章节。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您只是想将文件上传到服务器磁盘的某个地方，可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerFileUpload.html#streamToFileSystem-java.lang.String-io.vertx.core.Handler-\">streamToFileSystem</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.uploadHandler(upload -&gt; {\n  upload.streamToFileSystem(<span class=\"hljs-string\">\"myuploads_directory/\"</span> + upload.filename());\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n确保您检查了生产系统的文件名，以避免恶意客户将文件上传到文件系统中的任意位置。\n有关详细信息，参阅  <a href=\"#_security_notes\">安全说明</a>。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_handling_cookies\"><a class=\"anchor\" href=\"#_handling_cookies\"></a>处理cookies</h4>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#getCookie-java.lang.String-\">getCookie</a></code> 可以按Cookie名读取Cookie，\n或使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#cookieMap--\">cookieMap</a></code> 获取所有Cookie。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#removeCookie-java.lang.String-\">removeCookie</a></code> 删除Cookie。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#addCookie-io.vertx.core.http.Cookie-\">addCookie</a></code> 增加Cookie。</p>\n</div>\n<div class=\"paragraph\">\n<p>增加的Cookie会在响应的时候自动写到响应头，随后浏览器可以获取到设置的 Cookie\n并存储起来。</p>\n</div>\n<div class=\"paragraph\">\n<p>（Vert.x的）cookie是 <code><a href=\"../../apidocs/io/vertx/core/http/Cookie.html\">Cookie</a></code> 的实例。\n可以从中获取cookie的名字、取值、域名、路径以及其他cookie的常规属性。</p>\n</div>\n<div class=\"paragraph\">\n<p>设置了SameSite的Cookie禁止服务器在发送跨域请求时带上发送\n（站点是否跨域，取决于可注册域），从而为伪造跨域请求攻击提供了一些保护。\n这种Cookie可以通过 <code><a href=\"../../apidocs/io/vertx/core/http/Cookie.html#setSameSite-io.vertx.core.http.CookieSameSite-\">setSameSite</a></code> 设置。</p>\n</div>\n<div class=\"paragraph\">\n<p>Cookie的SameSite属性接受三个取值:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>None - 允许在跨域请求和非跨域请求中发送</p>\n</li>\n<li>\n<p>Strict - 只能在同站点的请求中发送（请求到设置该Cookie的站点）。\n如果设置Cookie的站点与当前请求的站点不一致，\n则不会发送SameSite设置为Strict的Cookie</p>\n</li>\n<li>\n<p>Lax - 在跨域的子请求（例如调用加载图像或iframe）不发送这种SameSite（设为Lax的）Cookie，\n但当用户从外部站点导航到URL时将发送该Cookie, 例如通过链接打开。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>下面是一个查询并增加Cookie的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Cookie someCookie = request.getCookie(<span class=\"hljs-string\">\"mycookie\"</span>);\nString cookieValue = someCookie.getValue();\n\n<span class=\"hljs-comment\">// 处理Cookie的逻辑</span>\n\n<span class=\"hljs-comment\">// 增加Cookie - 会自动写入响应头</span>\nrequest.response().addCookie(Cookie.cookie(<span class=\"hljs-string\">\"othercookie\"</span>, <span class=\"hljs-string\">\"somevalue\"</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_handling_compressed_body\"><a class=\"anchor\" href=\"#_handling_compressed_body\"></a>处理压缩体</h4>\n<div class=\"paragraph\">\n<p>Vert.x 可以处理在客户端通过 <em>deflate</em> 或 <em>gzip</em>\n算法压缩过的请求体信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>若要启用解压缩功能则您要在创建服务器时调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setDecompressionSupported-boolean-\">setDecompressionSupported</a></code>\n方法设置配置项。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下解压缩是并未被启用的。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_receiving_custom_http2_frames\"><a class=\"anchor\" href=\"#_receiving_custom_http2_frames\"></a>接收自定义 HTTP/2 帧</h4>\n<div class=\"paragraph\">\n<p>HTTP/2 是用于 HTTP 请求/响应模型的包含各种帧的一种帧协议，\n该协议允许发送和接收其他类型的帧。</p>\n</div>\n<div class=\"paragraph\">\n<p>若要接收自定义帧(frame)，您可以在请求中使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#customFrameHandler-io.vertx.core.Handler-\">customFrameHandler</a></code> ，\n每次当自定义的帧数据到达时，这个处理器会被调用。这而是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.customFrameHandler(frame -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"Received a frame type=\"</span> + frame.type() +\n      <span class=\"hljs-string\">\" payload\"</span> + frame.payload().toString());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2 帧不受流量控制限制 —— 当接收到自定义帧时，不论请求是否暂停，\n自定义帧处理器都将立即被调用。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sending_back_responses\"><a class=\"anchor\" href=\"#_sending_back_responses\"></a>返回响应</h3>\n<div class=\"paragraph\">\n<p>服务器响应对象是一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html\">HttpServerResponse</a></code> 实例，\n它可以从request对应的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#response--\">response</a></code> 方法中读取。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用响应对象回写一个响应到 HTTP客户端。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_setting_status_code_and_message\"><a class=\"anchor\" href=\"#_setting_status_code_and_message\"></a>设置状态码和消息</h4>\n<div class=\"paragraph\">\n<p>默认的 HTTP 状态响应码为 <code>200</code>，表示 <code>OK</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#setStatusCode-int-\">setStatusCode</a></code> 方法设置不同状态代码。</p>\n</div>\n<div class=\"paragraph\">\n<p>您还可用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#setStatusMessage-java.lang.String-\">setStatusMessage</a></code> 方法指定自定义状态消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您不指定状态信息，将会使用默认的状态码响应。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n在 HTTP/2 中，状态码的描述信息不会在响应中出现\n—— 因为协议不传递该信息。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_writing_http_responses\"><a class=\"anchor\" href=\"#_writing_http_responses\"></a>向 HTTP 响应写入数据</h4>\n<div class=\"paragraph\">\n<p>想要将数据写入 HTTP Response，您可使用任意一个 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-\">write</a></code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>它们可以在响应结束之前被多次调用，它们可以通过以下几种方式调用：</p>\n</div>\n<div class=\"paragraph\">\n<p>对用单个缓冲区：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.write(buffer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>写入字符串，这种请求字符串将使用 UTF-8 进行编码，并将结果写入到报文中。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.write(<span class=\"hljs-string\">\"hello world!\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>写入带编码方式的字符串，这种情况字符串将使用指定的编码方式编码，\n并将结果写入到报文中。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.write(<span class=\"hljs-string\">\"hello world!\"</span>, <span class=\"hljs-string\">\"UTF-16\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>响应写入是异步的，并且在写操作进入队列之后会立即返回。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您只需要将单个字符串或Buffer写入到HTTP 响应，则可使用\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#end-java.lang.String-\">end</a></code> 方法将其直接写入响应中并发回到客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>第一次写入操作会触发响应头的写入，因此，\n若您不使用 HTTP 分块，那么必须在写入响应之前设置 <code>Content-Length</code> 头，\n否则不会生效。若您使用 HTTP 分块则不需要担心这点。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_ending_http_responses\"><a class=\"anchor\" href=\"#_ending_http_responses\"></a>完成 HTTP 响应</h4>\n<div class=\"paragraph\">\n<p>一旦您完成了 HTTP 响应，可调用 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#end-io.vertx.core.Handler-\">end</a></code> 将其发回客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>这可以通过几种方式完成：</p>\n</div>\n<div class=\"paragraph\">\n<p>没有参数，直接结束响应，发回客户端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.write(<span class=\"hljs-string\">\"hello world!\"</span>);\nresponse.end();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以和调用 <code>write</code> 方法一样传String或Buffer给 <code>end</code> 方法。\n这种方式类似于先调用带String或Buffer参数的 <code>write</code> 方法，再调用无参 <code>end</code> 方法。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.end(<span class=\"hljs-string\">\"hello world!\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_the_underlying_connection\"><a class=\"anchor\" href=\"#_closing_the_underlying_connection\"></a>关闭底层连接</h4>\n<div class=\"paragraph\">\n<p>您可以调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#close--\">close</a></code> 方法关闭底层的TCP 连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>当响应结束时，Vert.x 将自动关闭非 keep-alive 的连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，Vert.x 不会自动关闭 keep-alive 的连接，\n若您想要在一段空闲时间之后让 Vert.x 自动关闭 keep-alive 的连接，则使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setIdleTimeout-int-\">setIdleTimeout</a></code>  方法进行配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2 连接在关闭响应之前会发送 {@literal GOAWAY} 帧。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_setting_response_headers\"><a class=\"anchor\" href=\"#_setting_response_headers\"></a>设置响应头</h4>\n<div class=\"paragraph\">\n<p>HTTP 响应头可直接添加到 HTTP 响应中，通常直接操作\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#headers--\">headers</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nMultiMap headers = response.headers();\nheaders.set(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/html\"</span>);\nheaders.set(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"wibble\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或您可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#putHeader-java.lang.String-java.lang.String-\">putHeader</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/html\"</span>).putHeader(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"wibble\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>响应头必须在写入响应体之前进行设置。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_chunked_http_responses_and_trailers\"><a class=\"anchor\" href=\"#_chunked_http_responses_and_trailers\"></a>分块 HTTP 响应和附加尾部</h4>\n<div class=\"paragraph\">\n<p>Vert.x 支持 <a href=\"http://en.wikipedia.org/wiki/Chunked_transfer_encoding\">分块传输编码(HTTP Chunked Transfer Encoding)</a> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>这允许HTTP 响应体以块的形式写入，通常在响应体预先不知道尺寸、\n需要将很大响应正文以流式传输到客户端时使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过如下方式开启分块模式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.setChunked(<span class=\"hljs-keyword\">true</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认是不分块的，当处于分块模式时，每次调用任意一个 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-\">write</a></code>\n方法将导致新的 HTTP 块被写出。</p>\n</div>\n<div class=\"paragraph\">\n<p>在分块模式下，您还可以将响应的 HTTP 响应附加尾部(trailers)写入响应，\n这种方式实际上是在写入响应的最后一块。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n分块响应在 HTTP/2 流中无效。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>若要向响应添加尾部，则直接添加到 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#trailers--\">trailers</a></code> 里。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.setChunked(<span class=\"hljs-keyword\">true</span>);\nMultiMap trailers = response.trailers();\ntrailers.set(<span class=\"hljs-string\">\"X-wibble\"</span>, <span class=\"hljs-string\">\"woobble\"</span>).set(<span class=\"hljs-string\">\"X-quux\"</span>, <span class=\"hljs-string\">\"flooble\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#putTrailer-java.lang.String-java.lang.String-\">putTrailer</a></code> 方法。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\nresponse.setChunked(<span class=\"hljs-keyword\">true</span>);\nresponse.putTrailer(<span class=\"hljs-string\">\"X-wibble\"</span>, <span class=\"hljs-string\">\"woobble\"</span>).putTrailer(<span class=\"hljs-string\">\"X-quux\"</span>, <span class=\"hljs-string\">\"flooble\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_serving_files_directly_from_disk_or_the_classpath\"><a class=\"anchor\" href=\"#_serving_files_directly_from_disk_or_the_classpath\"></a>直接从磁盘或 Classpath 读文件</h4>\n<div class=\"paragraph\">\n<p>若您正在编写一个Web 服务端，一种从磁盘中读取并提供文件的方法是将文件作为 <code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html\">AsyncFile</a></code>\n打开并将其传送到HTTP 响应中。</p>\n</div>\n<div class=\"paragraph\">\n<p>或您可以使用 <code><a href=\"../../apidocs/io/vertx/core/file/FileSystem.html#readFile-java.lang.String-io.vertx.core.Handler-\">readFile</a></code> 方法一次性加载它，并直接将其写入响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>此外，Vert.x 提供了一种方法，允许您只执行一次操作，\n即可直接将文件从磁盘或文件系统写入 HTTP 响应。\n若底层操作系统支持，操作系统可以不拷贝到用户态，\n而直接把数据从文件传输到Socket。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#sendFile-java.lang.String-\">sendFile</a></code> 方法完成的，对于大文件处理通常更有效，\n而这个方法对于小文件可能很慢。</p>\n</div>\n<div class=\"paragraph\">\n<p>这儿是一个非常简单的 Web 服务器，它使用 <code>sendFile</code> 方法从文件系统中读取并提供文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(request -&gt; {\n  String file = <span class=\"hljs-string\">\"\"</span>;\n  <span class=\"hljs-keyword\">if</span> (request.path().equals(<span class=\"hljs-string\">\"/\"</span>)) {\n    file = <span class=\"hljs-string\">\"index.html\"</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!request.path().contains(<span class=\"hljs-string\">\"..\"</span>)) {\n    file = request.path();\n  }\n  request.response().sendFile(<span class=\"hljs-string\">\"web/\"</span> + file);\n}).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>发送文件是异步的，可能在调用返回一段时间后才能完成。如果要在\n文件写入时收到通知，可以在 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#sendFile-java.lang.String-io.vertx.core.Handler-\">sendFile</a></code> 方法中设置一个处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>请阅读 <a href=\"#classpath\">从 Classpath 访问文件</a> 章节了解类路径的限制或禁用它。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n若在 HTTPS 协议中使用 <code>sendFile</code> 方法，它将会通过用户空间进行复制，因为若内核将数据\n直接从磁盘复制到 Socket，则不会给我们任何加密的机会。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n若您要直接使用 Vert.x 编写 Web 服务器，请注意，不要允许用户滥用请求路径，\n以此访问服务目录之外的、或者 classpath 之外的路径。\n更安全的做法是使用Vert.x Web替代。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>当需要提供文件的一部分，从给定的字节开始，您可以像下边这样做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">long</span> offset = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">try</span> {\n    offset = Long.parseLong(request.getParam(<span class=\"hljs-string\">\"start\"</span>));\n  } <span class=\"hljs-keyword\">catch</span> (NumberFormatException e) {\n    <span class=\"hljs-comment\">// error handling...</span>\n  }\n\n  <span class=\"hljs-keyword\">long</span> end = Long.MAX_VALUE;\n  <span class=\"hljs-keyword\">try</span> {\n    end = Long.parseLong(request.getParam(<span class=\"hljs-string\">\"end\"</span>));\n  } <span class=\"hljs-keyword\">catch</span> (NumberFormatException e) {\n    <span class=\"hljs-comment\">// error handling...</span>\n  }\n\n  request.response().sendFile(<span class=\"hljs-string\">\"web/mybigfile.txt\"</span>, offset, end);\n}).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若您想要从偏移量开始发送文件直到尾部，则不需要提供长度信息，\n这种情况下，您可以执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">long</span> offset = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">try</span> {\n    offset = Long.parseLong(request.getParam(<span class=\"hljs-string\">\"start\"</span>));\n  } <span class=\"hljs-keyword\">catch</span> (NumberFormatException e) {\n    <span class=\"hljs-comment\">// error handling...</span>\n  }\n\n  request.response().sendFile(<span class=\"hljs-string\">\"web/mybigfile.txt\"</span>, offset);\n}).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_piping_responses\"><a class=\"anchor\" href=\"#_piping_responses\"></a>管道式响应</h4>\n<div class=\"paragraph\">\n<p>服务端响应 <code>HttpServerResponse</code> 也是一个 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 实例，因此您可以从任何\n<code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 向其传送数据，如 <code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html\">AsyncFile</a></code>， <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code>，\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html\">WebSocket</a></code> 或者 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>这儿有一个例子，它回应了任何 PUT 方法的响应中的请求体。\n它为请求体使用了管道，所以即使 HTTP 请求体远远超过内存容量，\n它依旧可以正常工作。：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(request -&gt; {\n  HttpServerResponse response = request.response();\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.PUT) {\n    response.setChunked(<span class=\"hljs-keyword\">true</span>);\n    request.pipeTo(response);\n  } <span class=\"hljs-keyword\">else</span> {\n    response.setStatusCode(<span class=\"hljs-number\">400</span>).end();\n  }\n}).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>还可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#send-io.vertx.core.streams.ReadStream-\">send</a></code> 方法发送  <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>发送流是一个管道操作，但由于这方法是 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html\">HttpServerResponse</a></code> 的，\n当 <code>content-length</code> 响应头未设置时，此方法可以处理分块响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(request -&gt; {\n  HttpServerResponse response = request.response();\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.PUT) {\n    response.send(request);\n  } <span class=\"hljs-keyword\">else</span> {\n    response.setStatusCode(<span class=\"hljs-number\">400</span>).end();\n  }\n}).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_writing_http2_frames\"><a class=\"anchor\" href=\"#_writing_http2_frames\"></a>写入 HTTP/2 帧</h4>\n<div class=\"paragraph\">\n<p>HTTP/2 是用于 HTTP 请求/响应模型的包含各种帧的一种帧协议，\n该协议允许发送和接收其他类型的帧。</p>\n</div>\n<div class=\"paragraph\">\n<p>要发送这样的帧，您可以在响应中使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#writeCustomFrame-int-int-io.vertx.core.buffer.Buffer-\">writeCustomFrame</a></code> 方法。\n以下是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">int</span> frameType = <span class=\"hljs-number\">40</span>;\n<span class=\"hljs-keyword\">int</span> frameStatus = <span class=\"hljs-number\">10</span>;\nBuffer payload = Buffer.buffer(<span class=\"hljs-string\">\"some data\"</span>);\n\n<span class=\"hljs-comment\">// 向客户端发送一帧</span>\nresponse.writeCustomFrame(frameType, frameStatus, payload);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这些帧被立即发送，并且不受流控的影响 —— 当这样的帧被发送到对端时，\n可以在其他的 {@literal DATA} 帧之前完成。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_stream_reset\"><a class=\"anchor\" href=\"#_stream_reset\"></a>流重置</h4>\n<div class=\"paragraph\">\n<p>HTTP/1.x 不允许请求或响应流执行清除重置，\n如当客户端上传的资源已经存在于服务器上，服务器就需要接受整个响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2 在请求/响应期间随时支持流重置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.response().reset();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认会发送 <code>NO_ERROR</code> (0)错误代码，您也可以发送另外一个错误代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.response().reset(<span class=\"hljs-number\">8</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2 规范中定义了可用的  <a href=\"http://httpwg.org/specs/rfc7540.html#ErrorCodes\">错误码</a>  列表：</p>\n</div>\n<div class=\"paragraph\">\n<p>若使用了 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#exceptionHandler-io.vertx.core.Handler-\">request handler</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#exceptionHandler-io.vertx.core.Handler-\">response handler</a></code> 两个处理器过后，在流重置完成时您将会收到通知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.response().exceptionHandler(err -&gt; {\n  <span class=\"hljs-keyword\">if</span> (err <span class=\"hljs-keyword\">instanceof</span> StreamResetException) {\n    StreamResetException reset = (StreamResetException) err;\n    System.out.println(<span class=\"hljs-string\">\"Stream reset \"</span> + reset.getCode());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_push\"><a class=\"anchor\" href=\"#_server_push\"></a>服务器推送</h4>\n<div class=\"paragraph\">\n<p>服务器推送(Server Push)是 HTTP/2 支持的一个新功能，可以为单个客户端请求并行发送多个响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>当服务器处理请求时，它可以向客户端推送一次请求/响应（译者注：server push会先推送一条“请求”，然后再推送对应的“响应”）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerResponse response = request.response();\n\n<span class=\"hljs-comment\">// 推送main.js到客户端</span>\nresponse.push(HttpMethod.GET, <span class=\"hljs-string\">\"/main.js\"</span>, ar -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    <span class=\"hljs-comment\">// 服务器准备推送响应</span>\n    HttpServerResponse pushedResponse = ar.result();\n\n    <span class=\"hljs-comment\">// 发送main.js响应</span>\n    pushedResponse.\n        putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>).\n        end(<span class=\"hljs-string\">\"alert(\\\"Push response hello\\\")\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Could not push client resource \"</span> + ar.cause());\n  }\n});\n\n<span class=\"hljs-comment\">// 发送请求的资源内容</span>\nresponse.sendFile(<span class=\"hljs-string\">\"&lt;html&gt;&lt;head&gt;&lt;script src=\\\"/main.js\\\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当服务器准备推送响应时，推送响应处理器会被调用，并会发送响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>推送响应处理器可能会接收到失败，如：客户端可能取消推送，因为在缓存中已经包含了 <code>main.js</code>，\n不再需要它。</p>\n</div>\n<div class=\"paragraph\">\n<p>您必须在响应结束之前调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#push-io.vertx.core.http.HttpMethod-java.lang.String-java.lang.String-io.vertx.core.Handler-\">push</a></code>\n方法，但是在推送响应过后依然可以写响应。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_handling_exceptions_2\"><a class=\"anchor\" href=\"#_handling_exceptions_2\"></a>处理异常</h4>\n<div class=\"paragraph\">\n<p>调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServer.html#exceptionHandler-io.vertx.core.Handler-\">exceptionHandler</a></code> 可以设置一个处理器，用于接收\n连接传递给 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServer.html#requestHandler-io.vertx.core.Handler-\">requestHandler</a></code> 之前发生的异常，\n或者是传递给 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServer.html#webSocketHandler-io.vertx.core.Handler-\">webSocketHandler</a></code> 之前发生的异常，如TLS握手期间发生的异常。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_compression\"><a class=\"anchor\" href=\"#_http_compression\"></a>HTTP 压缩</h3>\n<div class=\"paragraph\">\n<p>Vert.x 支持开箱即用的HTTP压缩。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着在响应发送回客户端之前，您可以将响应体自动压缩。</p>\n</div>\n<div class=\"paragraph\">\n<p>若客户端不支持HTTP 压缩，则它可以发回没有压缩过的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>这允许它同时处理支持HTTP 压缩的客户端和不支持的客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>要启用压缩，可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setCompressionSupported-boolean-\">setCompressionSupported</a></code> 方法进行配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，未启用压缩。</p>\n</div>\n<div class=\"paragraph\">\n<p>当启用HTTP 压缩时，服务器将检查客户端请求头中是否包含了 <code>Accept-Encoding</code> 并支持常用的 deflate 和 gzip 压缩算法。\nVert.x 两者都支持。</p>\n</div>\n<div class=\"paragraph\">\n<p>若找到这样的请求头，服务器将使用所支持的压缩算法之一自动压缩响应正文，\n并发送回客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以通过将响应头 <code>content-encoding</code> 设置为 <code>identity</code> ，来关闭响应内容的压缩:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.response()\n  .putHeader(HttpHeaders.CONTENT_ENCODING, HttpHeaders.IDENTITY)\n  .sendFile(<span class=\"hljs-string\">\"/path/to/image.jpg\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意：压缩可以减少网络流量，但是CPU密集度会更高。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了解决后边一个问题，Vert.x也允许您调整原始的 gzip/deflate 压缩算法的 “压缩级别” 参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>压缩级别允许根据所得数据的压缩比和压缩/解压的计算成本来配置 gzip/deflate 算法。</p>\n</div>\n<div class=\"paragraph\">\n<p>压缩级别是从 “1” 到 “9” 的整数值，其中 “1” 表示更低的压缩比但是最快的算法，“9” 表示可用的最大压缩比但比较慢的算法。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用高于 1-2 的压缩级别通常允许仅仅节约一些字节大小 —— 它的增益不是线性的，并取决于要压缩的特定数据\n—— 但它可以满足服务器所要求的CPU周期的不可控的成本\n（注意现在Vert.x不支持任何缓存形式的响应数据，如静态文件，\n因此压缩是在每个请求体生成时进行的）,它可生成压缩过的响应数据、并对接收的响应解码（inflating）—— 和客户端使用的方式一致，\n这种操作随着压缩级别的增长会变得更加倾向于CPU密集型。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下 —— 如果通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setCompressionSupported-boolean-\">setCompressionSupported</a></code> 方法启用压缩，Vert.x 将使用 “6” 作为压缩级别，\n但是该参数可通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setCompressionLevel-int-\">setCompressionLevel</a></code> 方法来更改。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_an_http_client\"><a class=\"anchor\" href=\"#_creating_an_http_client\"></a>创建 HTTP 客户端</h3>\n<div class=\"paragraph\">\n<p>您可通过以下方式创建一个具有默认配置的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若您想要配置客户端选项，可按以下方式创建：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions().setKeepAlive(<span class=\"hljs-keyword\">false</span>);\nHttpClient client = vertx.createHttpClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 支持基于 TLS <code>h2</code> 和 TCP <code>h2c</code> 的 HTTP/2 协议。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，HTTP 客户端会发送 HTTP/1.1 请求。若要执行 HTTP/2 请求，则必须调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setProtocolVersion-io.vertx.core.http.HttpVersion-\">setProtocolVersion</a></code>\n方法将版本设置成 <code><a href=\"../../apidocs/io/vertx/core/http/HttpVersion.html#HTTP_2\">HTTP_2</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 <code>h2</code> 请求，必须使用 <em>应用层协议协商(ALPN)</em> 启用TLS：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions().\n    setProtocolVersion(HttpVersion.HTTP_2).\n    setSsl(<span class=\"hljs-keyword\">true</span>).\n    setUseAlpn(<span class=\"hljs-keyword\">true</span>).\n    setTrustAll(<span class=\"hljs-keyword\">true</span>);\n\nHttpClient client = vertx.createHttpClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于 <code>h2c</code> 请求，TLS必须禁用，客户端将执行 HTTP/1.1 请求并尝试升级到 HTTP/2：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions().setProtocolVersion(HttpVersion.HTTP_2);\n\nHttpClient client = vertx.createHttpClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>h2c</code> 连接也可以直接建立，如连接可以使用前文提到的方式创建，当\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setHttp2ClearTextUpgrade-boolean-\">setHttp2ClearTextUpgrade</a></code> 选项设置为 <code>false</code> 时：\n建立连接后，客户端将发送 HTTP/2 连接前缀，\n并期望从服务端接收相同的连接偏好。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP 服务端可能不支持 HTTP/2，当响应到达时，可以使用\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#version--\">version</a></code> 方法检查实际HTTP版本。。</p>\n</div>\n<div class=\"paragraph\">\n<p>当客户端连接到 HTTP/2 服务端时，它将向服务端发送其 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#getInitialSettings--\">初始设置</a></code> 。\n设置定义服务器如何使用连接、\n客户端的默认初始设置是由 HTTP/2 RFC定义的。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_logging_network_client_activity\"><a class=\"anchor\" href=\"#_logging_network_client_activity\"></a>客户端网络活动日志</h3>\n<div class=\"paragraph\">\n<p>网络活动可以被记录下来，用于调试。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions().setLogActivity(<span class=\"hljs-keyword\">true</span>);\nHttpClient client = vertx.createHttpClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>详情请参阅 <a href=\"#logging_network_activity\">网络活动日志</a> 章节。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_making_requests\"><a class=\"anchor\" href=\"#_making_requests\"></a>发送请求</h3>\n<div class=\"paragraph\">\n<p>HTTP 客户端是很灵活的，您可以通过各种方式发出请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>发送请求的第一步是获取远程服务器的HTTP连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.GET,<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    <span class=\"hljs-comment\">// 已连接到服务器</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>HTTP客户端会连接到远程服务器，也可能复用连接池里可用的连接。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_default_host_and_port\"><a class=\"anchor\" href=\"#_default_host_and_port\"></a>默认主机和端口</h4>\n<div class=\"paragraph\">\n<p>通常您希望使用 HTTP 客户端向同一个主机/端口发送很多请求。为避免每次发送请求时重复设主机/端口，\n您可以为客户端配置默认主机/端口：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions().setDefaultHost(<span class=\"hljs-string\">\"wibble.com\"</span>);\n\n<span class=\"hljs-comment\">// 若您需要，可设置默认端口</span>\nHttpClient client = vertx.createHttpClient(options);\nclient.request(HttpMethod.GET, <span class=\"hljs-string\">\"/some-uri\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    HttpClientRequest request = ar1.result();\n    request.send(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        HttpClientResponse response = ar2.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_writing_request_headers\"><a class=\"anchor\" href=\"#_writing_request_headers\"></a>设置请求头</h4>\n<div class=\"paragraph\">\n<p>可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpHeaders.html\">HttpHeaders</a></code> 设置请求头，比如:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient();\n\n<span class=\"hljs-comment\">// 使用MultiMap设置请求头</span>\nMultiMap headers = HttpHeaders.set(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>).set(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"foo\"</span>);\n\nclient.request(HttpMethod.GET, <span class=\"hljs-string\">\"some-uri\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n      HttpClientRequest request = ar1.result();\n      request.headers().addAll(headers);\n      request.send(ar2 -&gt; {\n        HttpClientResponse response = ar2.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      });\n    }\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个headers是 <code><a href=\"../../apidocs/io/vertx/core/MultiMap.html\">MultiMap</a></code> 的实例，它提供了添加、设置、删除条目的操作。\nHTTP请求头允许一个特定的键包含多个值。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#putHeader-java.lang.String-java.lang.String-\">putHeader</a></code> 方法设置请求头：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>)\n       .putHeader(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"foo\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若您想写入请求头，则您必须在写入任何请求体之前这样做来设置请求头。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_writing_request_and_processing_response\"><a class=\"anchor\" href=\"#_writing_request_and_processing_response\"></a>写请求并处理响应</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html\">HttpClientRequest</a></code> 的 <code>request</code> 方法会连接到远程服务器，\n或复用一个已有连接。获得的请求实例已预先填充了一些数据，\n例如主机或请求URI，但您需要将此请求发送到服务器。</p>\n</div>\n<div class=\"paragraph\">\n<p>调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#send--\">send</a></code> 方法可以发送HTTP请求，\n如 <code>GET</code> 请求，并异步处理 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html\">HttpClientResponse</a></code> 响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.GET,<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    HttpClientRequest request = ar1.result();\n\n    <span class=\"hljs-comment\">// 发送请求并处理响应</span>\n    request.send(ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n        HttpClientResponse response = ar.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      } <span class=\"hljs-keyword\">else</span> {\n        System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你也可以发送带请求体的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#send-java.lang.String-\">send</a></code> 方法可以发送String类型的请求体，\n如果 <code>Content-Length</code> 请求头没有预先设置，则会自动设置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.GET,<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    HttpClientRequest request = ar1.result();\n\n    <span class=\"hljs-comment\">// 发送请求并处理响应</span>\n    request.send(<span class=\"hljs-string\">\"Hello World\"</span>, ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n        HttpClientResponse response = ar.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      } <span class=\"hljs-keyword\">else</span> {\n        System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#send-io.vertx.core.buffer.Buffer-\">send</a></code> 方法可以发送Buffer类型的请求体，\n如果 <code>Content-Length</code> 请求头没有预先设置，则会自动设置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.send(Buffer.buffer(<span class=\"hljs-string\">\"Hello World\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    HttpClientResponse response = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#send-io.vertx.core.streams.ReadStream-\">send</a></code> 方法可以发送Stream类型的请求体，\n如果 <code>Content-Length</code> 请求头没有预先设置，则会设置分块传输的 <code>Content-Encoding</code> 请求头。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request\n  .putHeader(HttpHeaders.CONTENT_LENGTH, <span class=\"hljs-string\">\"1000\"</span>)\n  .send(stream, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    HttpClientResponse response = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_request_body\"><a class=\"anchor\" href=\"#_streaming_request_body\"></a>发送流的请求体</h4>\n<div class=\"paragraph\">\n<p>HttpClient的 <code>send</code> 方法在调用后马上发起请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>但有时候需要对请求体的写入做底层控制。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html\">HttpClientRequest</a></code> 可用于写请求体.</p>\n</div>\n<div class=\"paragraph\">\n<p>下面是发起带请求体的POST请求的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient();\n\nclient.request(HttpMethod.POST, <span class=\"hljs-string\">\"some-uri\"</span>)\n  .onSuccess(request -&gt; {\n    request.response().onSuccess(response -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n    });\n\n    <span class=\"hljs-comment\">// 现在可以对请求做各种配置</span>\n    request.putHeader(<span class=\"hljs-string\">\"content-length\"</span>, <span class=\"hljs-string\">\"1000\"</span>);\n    request.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>);\n    request.write(body);\n\n    <span class=\"hljs-comment\">// 确认请求可以结束</span>\n    request.end();\n});\n\n<span class=\"hljs-comment\">// 或使用链式调用风格:</span>\n\nclient.request(HttpMethod.POST, <span class=\"hljs-string\">\"some-uri\"</span>)\n  .onSuccess(request -&gt; {\n    request\n      .response(ar -&gt; {\n        <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n          HttpClientResponse response = ar.result();\n          System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n        }\n      })\n      .putHeader(<span class=\"hljs-string\">\"content-length\"</span>, <span class=\"hljs-string\">\"1000\"</span>)\n      .putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>)\n      .end(body);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也有一些方法可用于写入UTF-8编码的字符串，或以其他特定编码写入buffer：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.write(<span class=\"hljs-string\">\"some data\"</span>);\n\n<span class=\"hljs-comment\">// 指定字符串编码</span>\nrequest.write(<span class=\"hljs-string\">\"some other data\"</span>, <span class=\"hljs-string\">\"UTF-16\"</span>);\n\n<span class=\"hljs-comment\">// 通过buffer写入</span>\nBuffer buffer = Buffer.buffer();\nbuffer.appendInt(<span class=\"hljs-number\">123</span>).appendLong(<span class=\"hljs-number\">245l</span>);\nrequest.write(buffer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果你的http请求只需要写入一个字符串或buffer，\n可以直接调用 <code>end</code> 方法。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.end(<span class=\"hljs-string\">\"some simple data\"</span>);\n\n<span class=\"hljs-comment\">// 通过调用一次end方法，写入一个buffer并结束请求</span>\nBuffer buffer = Buffer.buffer().appendDouble(<span class=\"hljs-number\">12.34</span>d).appendLong(<span class=\"hljs-number\">432l</span>);\nrequest.end(buffer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您写入请求时，第一次调用 <code>write</code>\n方法将先将请求头写入到请求报文中。</p>\n</div>\n<div class=\"paragraph\">\n<p>实际写入操作是异步的，它可能在调用返回一段时间后才发生。</p>\n</div>\n<div class=\"paragraph\">\n<p>带请求体的非分块 HTTP 请求需要提供 <code>Content-Length</code> 头。</p>\n</div>\n<div class=\"paragraph\">\n<p>因此，若您不使用 HTTP 分块，则必须在写入请求之前设置 <code>Content-Length</code> 头，\n否则会出错。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您在调用其中一个 <code>end</code> 方法处理 String 或 Buffer，在写入请求体之前，Vert.x 将自动计算并设置\n<code>Content-Length</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您在使用 HTTP 分块模式，则不需要 <code>Content-Length</code> 头，\n因此您不必先计算大小。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_ending_streamed_http_requests\"><a class=\"anchor\" href=\"#_ending_streamed_http_requests\"></a>结束HTTP请求流</h4>\n<div class=\"paragraph\">\n<p>一旦完成了 HTTP 请求的准备工作，您必须调用其中一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#end-java.lang.String-\">end</a></code> 方法来\n发送该请求（结束请求）。</p>\n</div>\n<div class=\"paragraph\">\n<p>结束一个请求时，若请求头尚未被写入，会导致它们被写入，并且请求被标记\n成完成的。</p>\n</div>\n<div class=\"paragraph\">\n<p>请求可以通过多种方式结束。无参简单结束请求的方式如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.end();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或可以在调用 <code>end</code> 方法时提供 String 或 Buffer，这个和先调用带 String/Buffer 参数的 <code>write</code>\n方法之后再调用无参 <code>end</code> 方法一样：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.end(<span class=\"hljs-string\">\"some-data\"</span>);\n\n<span class=\"hljs-comment\">// 使用buffer结束</span>\nBuffer buffer = Buffer.buffer().appendFloat(<span class=\"hljs-number\">12.3f</span>).appendInt(<span class=\"hljs-number\">321</span>);\nrequest.end(buffer);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_the_request_as_a_stream\"><a class=\"anchor\" href=\"#_using_the_request_as_a_stream\"></a>使用流式请求</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html\">HttpClientRequest</a></code> 实例实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 接口。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着您可以从任何 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 实例将数据pipe到请求中。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您可以将磁盘上的文件直接管送到HTTP 请求体中，如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.setChunked(<span class=\"hljs-keyword\">true</span>);\nfile.pipeTo(request);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_chunked_http_requests\"><a class=\"anchor\" href=\"#_chunked_http_requests\"></a>分块 HTTP 请求</h4>\n<div class=\"paragraph\">\n<p>Vert.x 支持 <a href=\"http://en.wikipedia.org/wiki/Chunked_transfer_encoding\">HTTP Chunked Transfer Encoding</a> 请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>这允许使用块方式写入HTTP 请求体，这个在请求体比较大需要流式发送到服务器，\n或预先不知道大小时很常用。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#setChunked-boolean-\">setChunked</a></code> 将 HTTP 请求设置成分块模式。</p>\n</div>\n<div class=\"paragraph\">\n<p>在分块模式下，每次调用 <code>write</code> 方法将导致新的块被写入到报文。\n这种模式中，无需先设置请求头中的 <code>Content-Length</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.setChunked(<span class=\"hljs-keyword\">true</span>);\n\n<span class=\"hljs-comment\">// 写一些块</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n  request.write(<span class=\"hljs-string\">\"this-is-chunk-\"</span> + i);\n}\n\nrequest.end();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_timeouts\"><a class=\"anchor\" href=\"#_request_timeouts\"></a>请求超时</h4>\n<div class=\"paragraph\">\n<p>您可使用 <code><a href=\"../../apidocs/io/vertx/core/http/RequestOptions.html#setTimeout-long-\">setTimeout</a></code> 或\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#setTimeout-long-\">setTimeout</a></code> 设置一个特定 HTTP 请求的超时时间。</p>\n</div>\n<div class=\"paragraph\">\n<p>若请求在超时期限内未返回任何数据，则异常将会被传给异常处理器\n（若已提供），并且请求将会被关闭。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_writing_http2_frames_2\"><a class=\"anchor\" href=\"#_writing_http2_frames_2\"></a>写 HTTP/2 帧</h4>\n<div class=\"paragraph\">\n<p>HTTP/2 是用于 HTTP 请求/响应模型的具有各种帧的一个帧协议，\n该协议允许发送和接收其他类型的帧。</p>\n</div>\n<div class=\"paragraph\">\n<p>要发送这样的帧，您可以使用 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-\">write</a></code> 方法写入请求，以下是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">int</span> frameType = <span class=\"hljs-number\">40</span>;\n<span class=\"hljs-keyword\">int</span> frameStatus = <span class=\"hljs-number\">10</span>;\nBuffer payload = Buffer.buffer(<span class=\"hljs-string\">\"some data\"</span>);\n\n<span class=\"hljs-comment\">// 发送一帧到服务器</span>\nrequest.writeCustomFrame(frameType, frameStatus, payload);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_stream_reset_2\"><a class=\"anchor\" href=\"#_stream_reset_2\"></a>流重置</h4>\n<div class=\"paragraph\">\n<p>HTTP/1.x 不允许请求或响应流进行重置，如当客户端上传了服务器上存在的资源时，\n服务器依然要接收整个响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2 在请求/响应期间随时支持流重置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.reset();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况，发送 <code>NO_ERROR(0)</code> 错误代码，可发送其他错误代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.reset(<span class=\"hljs-number\">8</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2规范定义了可使用的 <a href=\"http://httpwg.org/specs/rfc7540.html#ErrorCodes\">错误码</a> 列表。</p>\n</div>\n<div class=\"paragraph\">\n<p>若使用了 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#exceptionHandler-io.vertx.core.Handler-\">request handler</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#exceptionHandler-io.vertx.core.Handler-\">response handler</a></code> 两个处理器过后，在流重置完成时您将会收到通知。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.exceptionHandler(err -&gt; {\n  <span class=\"hljs-keyword\">if</span> (err <span class=\"hljs-keyword\">instanceof</span> StreamResetException) {\n    StreamResetException reset = (StreamResetException) err;\n    System.out.println(<span class=\"hljs-string\">\"Stream reset \"</span> + reset.getCode());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_http_responses\"><a class=\"anchor\" href=\"#_handling_http_responses\"></a>处理 HTTP 响应</h3>\n<div class=\"paragraph\">\n<p>您可以在请求方法中指定处理器或通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html\">HttpClientRequest</a></code>\n对象直接设置处理器来接收 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html\">HttpClientResponse</a></code> 的实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#statusCode--\">statusCode</a></code>\n和 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#statusMessage--\">statusMessage</a></code> 方法从响应中查询响应的状态码和状态消息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.send(ar2 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n\n    HttpClientResponse response = ar2.result();\n\n    <span class=\"hljs-comment\">// 状态代码,如:200、404</span>\n    System.out.println(<span class=\"hljs-string\">\"Status code is \"</span> + response.statusCode());\n\n    <span class=\"hljs-comment\">// 状态消息,如:OK、Not Found</span>\n    System.out.println(<span class=\"hljs-string\">\"Status message is \"</span> + response.statusMessage());\n  }\n});\n\n<span class=\"hljs-comment\">// 与上面类似，设置一个请求发送完成的handler并结束请求</span>\nrequest\n  .response(ar2 -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n\n      HttpClientResponse response = ar2.result();\n\n      <span class=\"hljs-comment\">// 状态代码,如:200、404</span>\n      System.out.println(<span class=\"hljs-string\">\"Status code is \"</span> + response.statusCode());\n\n      <span class=\"hljs-comment\">// 状态消息,如:OK、Not Found</span>\n      System.out.println(<span class=\"hljs-string\">\"Status message is \"</span> + response.statusMessage());\n    }\n  })\n  .end();</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_the_response_as_a_stream\"><a class=\"anchor\" href=\"#_using_the_response_as_a_stream\"></a>使用流式响应</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html\">HttpClientResponse</a></code> 实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> ，\n这意味着您可以pipe数据到任何 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 实例。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_response_headers_and_trailers\"><a class=\"anchor\" href=\"#_response_headers_and_trailers\"></a>响应头和尾</h4>\n<div class=\"paragraph\">\n<p>HTTP 响应可包含头信息。您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#headers--\">headers</a></code> 方法来读取响应头。</p>\n</div>\n<div class=\"paragraph\">\n<p>该方法返回的对象是一个 <code><a href=\"../../apidocs/io/vertx/core/MultiMap.html\">MultiMap</a></code> 实例，因为 HTTP 响应头中单个键可以关联多个值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String contentType = response.headers().get(<span class=\"hljs-string\">\"content-type\"</span>);\nString contentLength = response.headers().get(<span class=\"hljs-string\">\"content-lengh\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>分块 HTTP 响应还可以包含响应尾(trailer) —— 这实际上是在发送响应体的最后一个（数据）块。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#trailers--\">trailers</a></code> 方法读取响应尾，尾数据也是一个 <code><a href=\"../../apidocs/io/vertx/core/MultiMap.html\">MultiMap</a></code> 。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_reading_the_request_body\"><a class=\"anchor\" href=\"#_reading_the_request_body\"></a>读取请求体</h4>\n<div class=\"paragraph\">\n<p>当从报文中读取到响应头时，响应处理器就会被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果响应中包含响应体，那么响应体可能会在读取完header后，以多个分片的形式到达。\n我们不会等待所有响应到达才调用响应处理器，因为响应可能会非常大，\n我们可能会等待很长一段时间，或者因为巨大的响应体而耗尽内存。</p>\n</div>\n<div class=\"paragraph\">\n<p>当响应体的某部分（数据）到达时，<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#handler-io.vertx.core.Handler-\">handler</a></code> 方法绑定的回调函数将会被调用，\n其中传入的 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code> 中包含了响应体的这一分片内容：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.GET, <span class=\"hljs-string\">\"some-uri\"</span>, ar1 -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    HttpClientRequest request = ar1.result();\n    request.send(ar2 -&gt; {\n      HttpClientResponse response = ar2.result();\n      response.handler(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"Received a part of the response body: \"</span> + buffer);\n      });\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若您知道响应体不是很大，并想在处理之前在内存中聚合所有响应体数据，\n那么您可以自行聚合：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.send(ar2 -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n\n    HttpClientResponse response = ar2.result();\n\n    <span class=\"hljs-comment\">// 创建空的缓冲区</span>\n    Buffer totalBuffer = Buffer.buffer();\n\n    response.handler(buffer -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"Received a part of the response body: \"</span> + buffer.length());\n\n      totalBuffer.appendBuffer(buffer);\n    });\n\n    response.endHandler(v -&gt; {\n      <span class=\"hljs-comment\">// 现在所有的响应体都读取了</span>\n      System.out.println(<span class=\"hljs-string\">\"Total response body length is \"</span> + totalBuffer.length());\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者当响应已被完全读取时，您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#body-io.vertx.core.Handler-\">body</a></code>\n方法以便读取整个响应体：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.send(ar1 -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    HttpClientResponse response = ar1.result();\n    response.body(ar2 -&gt; {\n\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        Buffer body = ar2.result();\n        <span class=\"hljs-comment\">// 现在所有的响应体都读取了</span>\n        System.out.println(<span class=\"hljs-string\">\"Total response body length is \"</span> + body.length());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_response_end_handler\"><a class=\"anchor\" href=\"#_response_end_handler\"></a>响应完成处理器</h4>\n<div class=\"paragraph\">\n<p>当整个响应体被完全读取或者无响应体的响应头被完全读取时，响应的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#endHandler-io.vertx.core.Handler-\">endHandler</a></code>\n就会被调用。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_request_and_response_composition\"><a class=\"anchor\" href=\"#_request_and_response_composition\"></a>请求和响应组合使用</h4>\n<div class=\"paragraph\">\n<p>http客户端接口可以按下面的模式使用，非常简单：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>调用 <code>request</code> 打开连接</p>\n</li>\n<li>\n<p>调用 <code>send</code> 或 <code>write</code>/<code>end</code> 发送请求到服务器</p>\n</li>\n<li>\n<p>处理 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html\">HttpClientResponse</a></code> 响应的开始</p>\n</li>\n<li>\n<p>处理响应事件</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用Vert.x的Future组合的方式来简化代码，但是API是事件驱动的，\n因此您需要充分了解它的工作过程，否则可能会遇到数据争夺\n（即丢失事件导致数据损坏）的情况。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<a href=\"https://vertx.io/docs/vertx-web-client/java/\">Vert.x Web Client</a> 是比HttpClient更高级别的替代品\n（实际上它也是基于HttpClient构建的），如果HttpClient对于你的使用场景来说太底层，可以考虑WebClient。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>HttpClient客户端有意地避免返回 <code>Future&lt;HttpClientResponse&gt;</code> ，\n因为如果在event-loop之外设置Future的完成处理器可能会导致线程竞争。。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;HttpClientResponse&gt; get = client.get(<span class=\"hljs-string\">\"some-uri\"</span>);\n\n<span class=\"hljs-comment\">// 假设客户端返回的响应是Future</span>\n<span class=\"hljs-comment\">//（假设此事件 *不* 在event-loop中）</span>\n<span class=\"hljs-comment\">// 在这个例子里，会引入潜在的数据竞争</span>\nThread.sleep(<span class=\"hljs-number\">100</span>);\n\nget.onSuccess(response -&gt; {\n\n  <span class=\"hljs-comment\">// 响应事件此时可能已经发生</span>\n  response.body(ar -&gt; {\n\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>将 <code>HttpClientRequest</code> 的使用限制在一个verticle的范围内是最简单的解决方案，\n因为Verticle为避免数据竞争，会确保按顺序处理事件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.deployVerticle(() -&gt; <span class=\"hljs-keyword\">new</span> AbstractVerticle() {\n <span class=\"hljs-meta\">@Override</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n\n   HttpClient client = vertx.createHttpClient();\n\n   Future&lt;HttpClientRequest&gt; future = client.request(HttpMethod.GET, <span class=\"hljs-string\">\"some-uri\"</span>);\n }\n}, <span class=\"hljs-keyword\">new</span> DeploymentOptions());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在verticle外使用HttpClient进行交互时，可以安全地使用“组合”(compose)，\n只要不延迟响应事件即可。例如，直接在event-loop上处理响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;JsonObject&gt; future = client\n  .request(HttpMethod.GET, <span class=\"hljs-string\">\"some-uri\"</span>)\n  .compose(request -&gt; request\n    .send()\n    .compose(response -&gt; {\n      <span class=\"hljs-comment\">// Process the response on the event-loop which guarantees no races</span>\n      <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">200</span> &amp;&amp;\n          response.getHeader(HttpHeaders.CONTENT_TYPE).equals(<span class=\"hljs-string\">\"application/json\"</span>)) {\n        <span class=\"hljs-keyword\">return</span> response\n          .body()\n          .map(buffer -&gt; buffer.toJsonObject());\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"Incorrect HTTP response\"</span>);\n      }\n    }));\n\n<span class=\"hljs-comment\">// Listen to the composed final json result</span>\nfuture.onSuccess(json -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Received json result \"</span> + json);\n}).onFailure(err -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果需要延迟响应处理，则需要 <code>pause</code> （暂停）响应或使用 <code>pipe</code>，\n当涉及另一个异步操作时，这可能是必需的。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;Void&gt; future = client\n  .request(HttpMethod.GET, <span class=\"hljs-string\">\"some-uri\"</span>)\n  .compose(request -&gt; request\n    .send()\n    .compose(response -&gt; {\n      <span class=\"hljs-comment\">// 在event-loop上处理响应，从而确保没有数据竞争</span>\n      <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">200</span>) {\n\n        <span class=\"hljs-comment\">// 创建一个管道，会暂停响应</span>\n        Pipe&lt;Buffer&gt; pipe = response.pipe();\n\n        <span class=\"hljs-comment\">// 把文件写入磁盘</span>\n        <span class=\"hljs-keyword\">return</span> fileSystem\n          .open(<span class=\"hljs-string\">\"/some/large/file\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions().setWrite(<span class=\"hljs-keyword\">true</span>))\n          .onFailure(err -&gt; pipe.close())\n          .compose(file -&gt; pipe.to(file));\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"Incorrect HTTP response\"</span>);\n      }\n    }));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_reading_cookies_from_the_response\"><a class=\"anchor\" href=\"#_reading_cookies_from_the_response\"></a>从响应中读取Cookie</h4>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html#cookies--\">cookies</a></code> 方法从响应中获取 Cookie 列表。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者您可以在响应中自己解析 <code>Set-Cookie</code> 头。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_30x_redirection_handling\"><a class=\"anchor\" href=\"#_30x_redirection_handling\"></a>30x 重定向处理器</h4>\n<div class=\"paragraph\">\n<p>客户端可配置成根据 <code>Location</code> 响应头遵循HTTP 重定向规则：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>GET或HEAD请求的HTTP响应码：<code>301</code>、<code>302</code>、<code>307</code> 或 <code>308</code></p>\n</li>\n<li>\n<p>GET请求的HTTP响应码 <code>303</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这有个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.GET, <span class=\"hljs-string\">\"some-uri\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n\n    HttpClientRequest request = ar1.result();\n    request.setFollowRedirects(<span class=\"hljs-keyword\">true</span>);\n    request.send(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n\n        HttpClientResponse response = ar2.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况最大的重定向数为 <code>16</code>，您可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setMaxRedirects-int-\">setMaxRedirects</a></code> 方法设置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(\n    <span class=\"hljs-keyword\">new</span> HttpClientOptions()\n        .setMaxRedirects(<span class=\"hljs-number\">32</span>));\n\nclient.request(HttpMethod.GET, <span class=\"hljs-string\">\"some-uri\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n\n    HttpClientRequest request = ar1.result();\n    request.setFollowRedirects(<span class=\"hljs-keyword\">true</span>);\n    request.send(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n\n        HttpClientResponse response = ar2.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>没有放之四海而皆准的策略，缺省的重定向策略可能不能满足您的需要。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认重定向策略可使用自定义实现更改：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.redirectHandler(response -&gt; {\n\n  <span class=\"hljs-comment\">// 仅仅遵循301状态代码</span>\n  <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">301</span> &amp;&amp; response.getHeader(<span class=\"hljs-string\">\"Location\"</span>) != <span class=\"hljs-keyword\">null</span>) {\n\n    <span class=\"hljs-comment\">// 计算重定向URI</span>\n    String absoluteURI = resolveURI(response.request().absoluteURI(), response.getHeader(<span class=\"hljs-string\">\"Location\"</span>));\n\n    <span class=\"hljs-comment\">// 创建客户端将使用的新的可用请求</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(<span class=\"hljs-keyword\">new</span> RequestOptions().setAbsoluteURI(absoluteURI));\n  }\n\n  <span class=\"hljs-comment\">// （其他情况）不需要重定向</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个策略将会处理接收到的原始 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html\">HttpClientResponse</a></code> ，并返回 <code>null</code>\n或 <code>Future&lt;HttpClientRequest&gt;</code> 。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当返回的是 <code>null</code> 时，处理原始响应</p>\n</li>\n<li>\n<p>当返回的是 <code>Future</code> 时，请求将在它成功完成后发送</p>\n</li>\n<li>\n<p>当返回的是 <code>Future</code> 时，请求失败时将调用设置的异常处理器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>返回的请求必须是未发送的，这样原始请求处理器才会被发送而且客户端之后才能发送请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>大多数原始请求设置将会传播（拷贝）到新请求中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>请求头，除非您已经设置了一些头</p>\n</li>\n<li>\n<p>请求体，除非返回的请求使用了 <code>GET</code> 方法</p>\n</li>\n<li>\n<p>响应处理器</p>\n</li>\n<li>\n<p>请求异常处理器</p>\n</li>\n<li>\n<p>请求超时</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_100_continue_handling\"><a class=\"anchor\" href=\"#_100_continue_handling\"></a>100-Continue 处理</h4>\n<div class=\"paragraph\">\n<p>根据 <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html\">HTTP/1.1 规范</a> ，\n客户端可以设置请求头 <code>Expect: 100-Continue</code>，并且在发送剩余请求体之前先发送请求头。</p>\n</div>\n<div class=\"paragraph\">\n<p>然后服务器可以通过回复临时响应状态 <code>Status: 100 (Continue)</code>\n来告诉客户端可以发送请求的剩余部分。</p>\n</div>\n<div class=\"paragraph\">\n<p>这里的想法是在发送大量数据之前允许服务器授权、接受/拒绝请求，\n若请求不能被接收，则发送大量数据信息会浪费带宽，\n并且会让服务器持续读取即将被丢弃的无用数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 允许您在客户端请求对象中设置一个 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#continueHandler-io.vertx.core.Handler-\">continueHandler</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>它将在服务器发回一个状态 <code>Status: 100 (Continue)</code> 时被调用, 同时也表示（客户端）可以\n发送请求的剩余部分。</p>\n</div>\n<div class=\"paragraph\">\n<p>通常将其与 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#sendHead--\">sendHead</a></code>\n结合起来发送请求的头信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.PUT, <span class=\"hljs-string\">\"some-uri\"</span>)\n  .onSuccess(request -&gt; {\n    request.response().onSuccess(response -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n    });\n\n    request.putHeader(<span class=\"hljs-string\">\"Expect\"</span>, <span class=\"hljs-string\">\"100-Continue\"</span>);\n\n    request.continueHandler(v -&gt; {\n      <span class=\"hljs-comment\">// 可发送请求体剩余部分</span>\n      request.write(<span class=\"hljs-string\">\"Some data\"</span>);\n      request.write(<span class=\"hljs-string\">\"Some more data\"</span>);\n      request.end();\n    });\n\n    request.sendHead();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在服务端，Vert.x HTTP Server可配置成接收到 <code>Expect: 100-Continue</code> 头时\n自动发回 <code>100 Continue</code> 临时响应信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个可通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setHandle100ContinueAutomatically-boolean-\">setHandle100ContinueAutomatically</a></code> 方法来设置。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您想要决定是否手动发送持续响应，那么此属性可设置成\n<code>false</code> （默认值），然后您可以通过检查头信息并且调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html#writeContinue--\">writeContinue</a></code>\n方法让客户端持续发送请求体：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">httpServer.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.getHeader(<span class=\"hljs-string\">\"Expect\"</span>).equalsIgnoreCase(<span class=\"hljs-string\">\"100-Continue\"</span>)) {\n\n    <span class=\"hljs-comment\">// 发送100 Continue持续响应</span>\n    request.response().writeContinue();\n\n    <span class=\"hljs-comment\">// 当客户端收到100响应代码则可以发送剩余请求体</span>\n    request.bodyHandler(body -&gt; {\n      <span class=\"hljs-comment\">// 处理请求体</span>\n    });\n\n    request.endHandler(v -&gt; {\n      request.response().end();\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以通过直接发送故障状态代码来拒绝该请求：这种情况下，\n请求体应该被忽略或连接应该被关闭（ <code>100-Continue</code> 是一个性能提示，\n并不是逻辑协议约束）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">httpServer.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.getHeader(<span class=\"hljs-string\">\"Expect\"</span>).equalsIgnoreCase(<span class=\"hljs-string\">\"100-Continue\"</span>)) {\n\n    <span class=\"hljs-comment\">//</span>\n    <span class=\"hljs-keyword\">boolean</span> rejectAndClose = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-keyword\">if</span> (rejectAndClose) {\n\n      <span class=\"hljs-comment\">// 使用失败码拒绝并关闭这个连接，</span>\n      <span class=\"hljs-comment\">// 长连接情况下最好加上（指的是Connection: close）</span>\n      request.response()\n          .setStatusCode(<span class=\"hljs-number\">405</span>)\n          .putHeader(<span class=\"hljs-string\">\"Connection\"</span>, <span class=\"hljs-string\">\"close\"</span>)\n          .end();\n    } <span class=\"hljs-keyword\">else</span> {\n\n      <span class=\"hljs-comment\">// 使用失败码拒绝忽略请求体，</span>\n      <span class=\"hljs-comment\">// 若体积很小，这是适用的</span>\n      request.response()\n          .setStatusCode(<span class=\"hljs-number\">405</span>)\n          .end();\n    }\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_creating_http_tunnels\"><a class=\"anchor\" href=\"#_creating_http_tunnels\"></a>创建HTTP隧道</h4>\n<div class=\"paragraph\">\n<p>可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#connect-io.vertx.core.Handler-\">connect</a></code> 创建HTTP隧道：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.CONNECT, <span class=\"hljs-string\">\"some-uri\"</span>)\n  .onSuccess(request -&gt; {\n\n    <span class=\"hljs-comment\">// 连接到服务器</span>\n    request.connect(ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n        HttpClientResponse response = ar.result();\n\n        <span class=\"hljs-keyword\">if</span> (response.statusCode() != <span class=\"hljs-number\">200</span>) {\n          <span class=\"hljs-comment\">// 某些原因连接失败</span>\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// HTTP隧道创建成功，原始数据将传输到缓冲区</span>\n          NetSocket socket = response.netSocket();\n        }\n      }\n    });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>收到HTTP响应头时，会调用上面传入的handler，socket也会准备好隧道传输，\n并将会发送、接收数据到缓冲区。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>connect</code> 方法的作用类似 <code>send</code> 方法，\n区别在于前者重新配置传输交换原始数据缓冲区。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_client_push\"><a class=\"anchor\" href=\"#_client_push\"></a>客户端推送</h4>\n<div class=\"paragraph\">\n<p>服务器推送(Server Push)是 HTTP/2 的一个新功能，它可以为单个客户端并行发送多个响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以在接收服务器推送的请求/响应的请求上设置一个推送处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(HttpMethod.GET, <span class=\"hljs-string\">\"/index.html\"</span>)\n  .onSuccess(request -&gt; {\n\n    request\n      .response().onComplete(response -&gt; {\n        <span class=\"hljs-comment\">// 处理index.html响应</span>\n      });\n\n    <span class=\"hljs-comment\">// 设置一个推送处理器来感知服务器推送的任何资源</span>\n    request.pushHandler(pushedRequest -&gt; {\n\n      <span class=\"hljs-comment\">// 为当前请求推送资源</span>\n      System.out.println(<span class=\"hljs-string\">\"Server pushed \"</span> + pushedRequest.path());\n\n      <span class=\"hljs-comment\">// 为响应设置处理器</span>\n      pushedRequest.response().onComplete(pushedResponse -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"The response for the pushed request\"</span>);\n      });\n    });\n\n    <span class=\"hljs-comment\">// 结束请求</span>\n    request.end();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若客户端不想收到推送请求，它可重置流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.pushHandler(pushedRequest -&gt; {\n  <span class=\"hljs-keyword\">if</span> (pushedRequest.path().equals(<span class=\"hljs-string\">\"/main.js\"</span>)) {\n    pushedRequest.reset();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 处理逻辑</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若没有设置任何处理器时，任何被推送的流将被客户端自动重置\n（错误代码 <code>8</code> ）。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_receiving_custom_http2_frames_2\"><a class=\"anchor\" href=\"#_receiving_custom_http2_frames_2\"></a>接收自定义 HTTP/2 帧</h4>\n<div class=\"paragraph\">\n<p>HTTP/2 是一个基于帧的协议，它包含多种类型的帧，\n适用于 HTTP 请求/响应模型。</p>\n</div>\n<div class=\"paragraph\">\n<p>要接收自定义帧，您可以在请求中使用 <code>customFrameHandler</code>，\n每次自定义帧到达时就会调用它。以下是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.customFrameHandler(frame -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"Received a frame type=\"</span> + frame.type() +\n      <span class=\"hljs-string\">\" payload\"</span> + frame.payload().toString());\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_enabling_compression_on_the_client\"><a class=\"anchor\" href=\"#_enabling_compression_on_the_client\"></a>客户端启用压缩</h3>\n<div class=\"paragraph\">\n<p>HTTP 客户端支持开箱即用的 HTTP 压缩功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着客户端可以让远程服务器知道它支持压缩，并且能处理\n压缩过的响应体（数据）。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP 服务端可以自由地使用自己支持的压缩算法之一进行压缩，也可以在\n不压缩的情况下将响应体发回。所以这仅仅是 HTTP 服务端的一个可能被随意忽略的提示。</p>\n</div>\n<div class=\"paragraph\">\n<p>要告诉服务器当前客户端支持哪种压缩，请求头将包含一个 <code>Accept-Encoding</code> 头，\n其值为可支持的压缩算法，（该值可）支持多种压缩算法。\nVert.x 会添加以下头：</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept-Encoding: gzip, deflate</p>\n</div>\n<div class=\"paragraph\">\n<p>服务器将从其中选择一个算法，您可以通过服务器返回的响应中的响应头\n<code>Content-Encoding</code> 来检测服务器是否适应这个正文。</p>\n</div>\n<div class=\"paragraph\">\n<p>若响应体通过 <code>gzip</code> 压缩，它将包含例如下边的头：</p>\n</div>\n<div class=\"paragraph\">\n<p>Content-Encoding: gzip</p>\n</div>\n<div class=\"paragraph\">\n<p>创建客户端时可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setTryUseCompression-boolean-\">setTryUseCompression</a></code>\n设置配置项启用压缩。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况压缩被禁用。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http1_x_pooling_and_keep_alive\"><a class=\"anchor\" href=\"#_http1_x_pooling_and_keep_alive\"></a>HTTP/1.x pooling 和 keep alive</h3>\n<div class=\"paragraph\">\n<p>HTTP 的 Keep Alive 允许单个 HTTP 连接用于多个请求。当您向同一台服务器发送多个请求时，\n可以更加有效使用连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 HTTP/1.x 版本，HTTP 客户端支持连接池，它允许您重用请求之间的连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了连接池（能）工作，配置客户端时，keep alive 必须通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setKeepAlive-boolean-\">setKeepAlive</a></code>\n方法设置成 <code>true</code> 。默认值为 <code>true</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>当 keep alive 启用时，Vert.x 将为每一个发送的 HTTP/1.0 请求添加一个 <code>Connection: Keep-Alive</code> 头。\n当 keep alive 禁用时，Vert.x 将为每一个 HTTP/1.1 请求添加一个 <code>Connection: Close</code> 头 ——\n表示在响应完成后连接将被关闭。</p>\n</div>\n<div class=\"paragraph\">\n<p>可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setMaxPoolSize-int-\">setMaxPoolSize</a></code> 方法 <strong>为每个服务器</strong> 配置连接池的最大连接数。</p>\n</div>\n<div class=\"paragraph\">\n<p>当启用连接池创建请求时，若存在少于已经为服务器创建的最大连接数，Vert.x 将创建一个新连接，\n否则直接将请求添加到队列中。</p>\n</div>\n<div class=\"paragraph\">\n<p>Keep Alive的连接将在闲置一段时间后被客户端自动关闭。这个超时时间可以在服务端通过\n<code>keep-alive</code> 请求头设置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>keep-alive: timeout=30</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者，您可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setKeepAliveTimeout-int-\">setKeepAliveTimeout</a></code> 设置空闲时间——在设置的时间内然后没使用的连接将被关闭。\n请注意空闲超时值以秒为单位而不是毫秒。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http1_1_pipe_lining\"><a class=\"anchor\" href=\"#_http1_1_pipe_lining\"></a>HTTP/1.1 pipe-lining</h3>\n<div class=\"paragraph\">\n<p>客户端还支持同一条连接上的管道(pipeline)。</p>\n</div>\n<div class=\"paragraph\">\n<p>管道意味着在返回一个响应之前，在同一个连接上发送另一个请求。\n管道不是对所有请求都适用的。</p>\n</div>\n<div class=\"paragraph\">\n<p>若要启用管道，必须调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setPipelining-boolean-\">setPipelining</a></code> 方法。\n默认是禁用管道的。</p>\n</div>\n<div class=\"paragraph\">\n<p>当启用管道时，请求可以不等待以前的响应返回而写入到连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>单个连接的管道请求限制数由 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setPipeliningLimit-int-\">setPipeliningLimit</a></code> 方法设置。\n此选项定义了发送到服务器的等待响应的最大请求数。\n这个限制可以保证客户端请求数量在同一服务端的多条连接之间保持平衡。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http2_multiplexing\"><a class=\"anchor\" href=\"#_http2_multiplexing\"></a>HTTP/2 多路复用</h3>\n<div class=\"paragraph\">\n<p>HTTP/2 提倡使用服务器的单一连接，默认情况下，HTTP 客户端针对每个服务器都使用单一连接，\n同样服务器上的所有流都会复用到对应连接中。</p>\n</div>\n<div class=\"paragraph\">\n<p>当客户端需要使用连接池并使用超过一个连接时，则可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setHttp2MaxPoolSize-int-\">setHttp2MaxPoolSize</a></code>\n设置。</p>\n</div>\n<div class=\"paragraph\">\n<p>当您使用连接池（而不是单个连接），并希望限制每个连接的多路复用流数量时，\n可使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setHttp2MultiplexingLimit-int-\">setHttp2MultiplexingLimit</a></code>\n设置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions clientOptions = <span class=\"hljs-keyword\">new</span> HttpClientOptions().\n    setHttp2MultiplexingLimit(<span class=\"hljs-number\">10</span>).\n    setHttp2MaxPoolSize(<span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-comment\">// Uses up to 3 connections and up to 10 streams per connection</span>\nHttpClient client = vertx.createHttpClient(clientOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>连接的多路复用数量限制是在客户端上设置的流数量限制。\n如果服务器使用 <code><a href=\"../../apidocs/io/vertx/core/http/Http2Settings.html#setMaxConcurrentStreams-long-\">SETTINGS_MAX_CONCURRENT_STREAMS</a></code>\n设置的值比该值更低，则有效值会更低。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2 连接不会被客户端自动关闭，若要关闭它们，可以调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#close--\">close</a></code>\n来关闭客户端实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者，您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setIdleTimeout-int-\">setIdleTimeout</a></code> 设置空闲时间\n——这个时间内没有被使用过的连接将被关闭，注意，空闲时间以秒为单位，不是毫秒。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_connections\"><a class=\"anchor\" href=\"#_http_connections\"></a>HTTP 连接</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html\">HttpConnection</a></code> 接口提供了处理 HTTP 连接事件、生命周期、\n设置（settings）的API。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/2 实现了完整的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html\">HttpConnection</a></code> API。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTP/1.x 实现了 <code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html\">HttpConnection</a></code> 中的部分API：\n仅实现了关闭操作、关闭处理器和异常处理器。\n该协议并不提供其他操作的语义。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_connections\"><a class=\"anchor\" href=\"#_server_connections\"></a>服务端连接</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#connection--\">connection</a></code> 方法会返回服务器上的请求连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpConnection connection = request.connection();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以在服务器上设置连接处理器，任意连接传入时可得到通知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer(http2Options);\n\nserver.connectionHandler(connection -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"A client connected\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_client_connections\"><a class=\"anchor\" href=\"#_client_connections\"></a>客户端连接</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html#connection--\">connection</a></code> 方法会返回客户端上的连接请求：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpConnection connection = request.connection();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以在请求上设置连接处理器在连接发生时通知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.connectionHandler(connection -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Connected to the server\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_connection_settings\"><a class=\"anchor\" href=\"#_connection_settings\"></a>连接配置</h4>\n<div class=\"paragraph\">\n<p>HTTP/2 由 <code><a href=\"../../apidocs/io/vertx/core/http/Http2Settings.html\">Http2Settings</a></code> 数据对象来配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个 Endpoint 都必须遵守连接另一端的发送设置。</p>\n</div>\n<div class=\"paragraph\">\n<p>当建立连接时，客户端和服务器交换初始配置，初始设置由客户端上的\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setInitialSettings-io.vertx.core.http.Http2Settings-\">setInitialSettings</a></code> 和\n服务器上的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setInitialSettings-io.vertx.core.http.Http2Settings-\">setInitialSettings</a></code> 方法配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>连接建立后可随时更改设置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.updateSettings(<span class=\"hljs-keyword\">new</span> Http2Settings().setMaxConcurrentStreams(<span class=\"hljs-number\">100</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>由于远端可能会发送配置更新的确认，\n所以可能会在回调中收到通知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.updateSettings(<span class=\"hljs-keyword\">new</span> Http2Settings().setMaxConcurrentStreams(<span class=\"hljs-number\">100</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"The settings update has been acknowledged \"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>相反，在收到新的远程设置时会通知\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#remoteSettingsHandler-io.vertx.core.Handler-\">remoteSettingsHandler</a></code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.remoteSettingsHandler(settings -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Received new settings\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n此功能仅适用于 HTTP/2 协议。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_connection_ping\"><a class=\"anchor\" href=\"#_connection_ping\"></a>连接 Ping</h4>\n<div class=\"paragraph\">\n<p>HTTP/2 连接 ping 对于确定连接往返时间或检查连接有效性很有用：\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#ping-io.vertx.core.buffer.Buffer-io.vertx.core.Handler-\">ping</a></code> 发送 {@literal PING}\n帧到远端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer data = Buffer.buffer();\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">byte</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">8</span>;i++) {\n  data.appendByte(i);\n}\nconnection.ping(data, pong -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Remote side replied\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当接收到 {@literal PING} 帧时，Vert.x 将自动发送确认，\n可设置处理器当收到 ping 帧时发送通知调用处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.pingHandler(ping -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Got pinged by remote side\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>处理器只是接到通知，确认无论如何都会自动发送。\n这个功能是为基于 HTTP/2 实现的其他协议提供的。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n此功能仅适用于 HTTP/2 协议。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_connection_shutdown_and_go_away\"><a class=\"anchor\" href=\"#_connection_shutdown_and_go_away\"></a>连接关闭/GOAWAY</h4>\n<div class=\"paragraph\">\n<p>调用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#shutdown--\">shutdown</a></code> 方法将发送 {@literal GOAWAY} 帧到\n远程的连接，要求其停止创建流：客户端将停止发送新请求，\n并且服务器将停止推送响应。发送 {@literal GOAWAY} 帧后，连接\n将等待一段时间（默认为30秒），直到当前所有流关闭，然后关闭连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.shutdown();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#shutdownHandler-io.vertx.core.Handler-\">shutdownHandler</a></code> 通知何时关闭所有流，\n并且连接尚未关闭。</p>\n</div>\n<div class=\"paragraph\">\n<p>有可能只需发送 {@literal GOAWAY} 帧，和关闭主要的区别在于\n它将只是告诉远程连接停止创建新流，而没有计划\n关闭连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.goAway(<span class=\"hljs-number\">0</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>相反，也可以在收到 <code>{@literal GOAWAY}</code> 时收到通知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.goAwayHandler(goAway -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Received a go away frame\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当所有当前流已经关闭并且可关闭连接时，<code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#shutdownHandler-io.vertx.core.Handler-\">shutdownHandler</a></code>\n将被调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.goAway(<span class=\"hljs-number\">0</span>);\nconnection.shutdownHandler(v -&gt; {\n\n  <span class=\"hljs-comment\">// 所有流被关闭时，关闭连接</span>\n  connection.close();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当接收到 {@literal GOAWAY} 时也适用。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n此功能仅适用于HTTP/2协议。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_connection_close\"><a class=\"anchor\" href=\"#_connection_close\"></a>连接关闭</h4>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#close--\">close</a></code> 方法关闭连接：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>对于 HTTP/1.x 来说，它会关闭底层的 Socket</p>\n</li>\n<li>\n<p>对于 HTTP/2 来说，它将执行无延迟关闭， {@literal GOAWAY} 帧将会在连接关闭之前被发送</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>连接关闭时 <code><a href=\"../../apidocs/io/vertx/core/http/HttpConnection.html#closeHandler-io.vertx.core.Handler-\">closeHandler</a></code> 将发出通知。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_httpclient_usage\"><a class=\"anchor\" href=\"#_httpclient_usage\"></a>HttpClient 使用说明</h3>\n<div class=\"paragraph\">\n<p>HttpClient可以在一个 Verticle 中使用或者嵌入使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Verticle 中使用时，Verticle <strong>应该使用自己的客户端实例</strong> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>一般来说，不应该在不同的 Vert.x 上下文环境之间共享客户端，因为它可能导致不可预知的意外。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：keep-alive的连接将在打开连接的请求上下文环境调用客户端处理器，后续请求将使用\n相同上下文环境。</p>\n</div>\n<div class=\"paragraph\">\n<p>当这种情况发生时，Vert.x会检测到并记录以下警告：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>Reusing a connection with a different context: an HttpClient is probably shared between different Verticles</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>HttpClient可以嵌套在非 Vert.x 线程中，如单元测试或纯Java的 <code>main</code> 线程中：\n客户端处理器将被不同的 Vert.x 线程和上下文调用，这样的上下文会根据需要创建。\n对于生产环境，不推荐这样使用。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_server_sharing\"><a class=\"anchor\" href=\"#_server_sharing\"></a>水平扩展 - 服务端共享</h3>\n<div class=\"paragraph\">\n<p>当多个 HTTP 服务端在同一个端口上监听时，Vert.x\n会使用轮询策略来管理请求处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们用 Verticle 来创建 HTTP 服务端，如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">io.vertx.examples.http.sharing.HttpServerVerticle</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(request -&gt; {\n  request.response().end(<span class=\"hljs-string\">\"Hello from server \"</span> + <span class=\"hljs-keyword\">this</span>);\n}).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个服务监听8080端口。那么当verticle被实例化多次，如：\n<code>vertx run io.vertx.examples.http.sharing.HttpServerVerticle -instances 2</code> ，将会发生什么？\n如果两个Verticle 都绑定到同一个端口，您将收到一个 Socket 异常。\n幸运的是，Vert.x 可以为您处理这种情况。在与现有服务端相同的主机和端口上部署另一个服务器时，\n实际上并不会尝试创建在同一主机/端口上监听的新服务端，它只绑定一次到Socket，\n当接收到请求时，会按照轮询策略调用服务端的请求处理函数。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们现在想象一个客户端，如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.setPeriodic(<span class=\"hljs-number\">100</span>, (l) -&gt; {\n  vertx.createHttpClient().request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/\"</span>, ar1 -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n      HttpClientRequest request = ar1.result();\n      request.send(ar2 -&gt; {\n        <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n          HttpClientResponse resp = ar2.result();\n          resp.bodyHandler(body -&gt; {\n            System.out.println(body.toString(<span class=\"hljs-string\">\"ISO-8859-1\"</span>));\n          });\n        }\n      });\n    }\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 将请求顺序委托给其中一个服务器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>Hello from i.v.e.h.s.HttpServerVerticle@1\nHello from i.v.e.h.s.HttpServerVerticle@2\nHello from i.v.e.h.s.HttpServerVerticle@1\nHello from i.v.e.h.s.HttpServerVerticle@2\n...</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>因此，服务器可直接扩展可用的核，而每个 Vert.x 中的 Verticle 实例仍然严格使用单线程，\n您不需要像编写负载均衡器那样使用任何特殊技巧去编写，\n就可以在多核机器上扩展服务器。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_https_with_vert_x\"><a class=\"anchor\" href=\"#_using_https_with_vert_x\"></a>使用 HTTPS</h3>\n<div class=\"paragraph\">\n<p>Vert.x 的 HTTP 服务端和客户端可以配置成和网络服务器完全相同的方式使用 HTTPS。</p>\n</div>\n<div class=\"paragraph\">\n<p>有关详细信息，请参阅 <a href=\"#ssl\">配置网络服务器以使用 SSL</a> 章节。</p>\n</div>\n<div class=\"paragraph\">\n<p>SSL可以通过每个请求的 <code><a href=\"../../apidocs/io/vertx/core/http/RequestOptions.html\">RequestOptions</a></code> 来启用/禁用，\n或在指定模式时调用 <code><a href=\"../../apidocs/io/vertx/core/http/RequestOptions.html#setAbsoluteURI-java.lang.String-\">setAbsoluteURI</a></code>\n方法。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.request(<span class=\"hljs-keyword\">new</span> RequestOptions()\n    .setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n    .setPort(<span class=\"hljs-number\">8080</span>)\n    .setURI(<span class=\"hljs-string\">\"/\"</span>)\n    .setSsl(<span class=\"hljs-keyword\">true</span>), ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    HttpClientRequest request = ar1.result();\n    request.send(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        HttpClientResponse response = ar2.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setSsl-boolean-\">setSsl</a></code> 设置将用作客户端默认配置。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/RequestOptions.html#setSsl-java.lang.Boolean-\">setSsl</a></code> 将覆盖默认客户端设置。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>即使客户端配置成使用 SSL/TLS，该值设置成 <code>false</code> 将禁用SSL/TLS。</p>\n</li>\n<li>\n<p>即使客户端配置成不使用 SSL/TLS，该值设置成 <code>true</code> 将启用SSL/TLS，\n实际的客户端SSL/TLS（如受信、密钥/证书、密码、ALPN 等）将被重用。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>同样， <code><a href=\"../../apidocs/io/vertx/core/http/RequestOptions.html#setAbsoluteURI-java.lang.String-\">setAbsoluteURI</a></code> 方法也会\n（在调用时）覆盖默认客户端设置。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_name_indication_sni_2\"><a class=\"anchor\" href=\"#_server_name_indication_sni_2\"></a>服务器名称指示（SNI）</h4>\n<div class=\"paragraph\">\n<p>vert.x的Http服务器可以设置为使用SNI，与 {@linkplain io.vertx.core.net net servers} 的方法一样。</p>\n</div>\n<div class=\"paragraph\">\n<p>vert.x的HttpClient在TLS握手过程中会将实际的主机名作为 <em>服务名（server name）</em> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websockets\"><a class=\"anchor\" href=\"#_websockets\"></a>WebSockets</h3>\n<div class=\"paragraph\">\n<p><a href=\"http://en.wikipedia.org/wiki/WebSocket\">WebSockets</a> 是一种Web技术，\n可以在 HTTP 服务端和 HTTP 客户端（通常是浏览器）之间实现全双工 Socket 连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x HTTP 客户端和服务端都支持 WebSocket。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_websockets_on_the_server\"><a class=\"anchor\" href=\"#_websockets_on_the_server\"></a>服务端 WebSocket</h4>\n<div class=\"paragraph\">\n<p>在服务端处理 WebSocket 有两种方法。</p>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_websocket_handler\"><a class=\"anchor\" href=\"#_websocket_handler\"></a>WebSocket handler</h5>\n<div class=\"paragraph\">\n<p>第一种方法需要在服务端实例上提供一个\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServer.html#webSocketHandler-io.vertx.core.Handler-\">webSocketHandler</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>当对服务端创建 WebSocket 连接时，Vert.x 将向 <code>Handler</code> 传入一个\n<code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> 实例，在其中去处理它。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.webSocketHandler(webSocket -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Connected!\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以调用 <code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html#reject--\">reject</a></code> 方法来拒绝一个 WebSocket。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.webSocketHandler(webSocket -&gt; {\n  <span class=\"hljs-keyword\">if</span> (webSocket.path().equals(<span class=\"hljs-string\">\"/myapi\"</span>)) {\n    webSocket.reject();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 处理逻辑</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>调用 <code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html#setHandshake-io.vertx.core.Future-io.vertx.core.Handler-\">setHandshake</a></code> 并传入 <code>Future</code>， 可以实现异步处理WebSocket握手:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.webSocketHandler(webSocket -&gt; {\n  Promise&lt;Integer&gt; promise = Promise.promise();\n  webSocket.setHandshake(promise.future());\n  authenticate(webSocket.headers(), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// 用101状态码（协议切换）结束握手</span>\n      <span class=\"hljs-comment\">// 或用401状态码（未鉴权）拒绝握手</span>\n      promise.complete(ar.succeeded() ? <span class=\"hljs-number\">101</span> : <span class=\"hljs-number\">401</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 发送500错误状态码</span>\n      promise.fail(ar.cause());\n    }\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n除非手动设置了WebSocket握手处理器，否则调用（webSocketHandler传入的）处理器后，将自动接受WebSocket握手。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_upgrading_to_websocket\"><a class=\"anchor\" href=\"#_upgrading_to_websocket\"></a>协议切换为 WebSocket</h5>\n<div class=\"paragraph\">\n<p>处理 WebSocket 的第二种方法是处理从客户端发送的HTTP升级请求，调用服务器请求对象的\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html#toWebSocket--\">toWebSocket</a></code> 方法。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.path().equals(<span class=\"hljs-string\">\"/myapi\"</span>)) {\n\n    Future&lt;ServerWebSocket&gt; fut = request.toWebSocket();\n    fut.onSuccess(ws -&gt; {\n      <span class=\"hljs-comment\">// 处理逻辑</span>\n    });\n\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 拒绝切换WebSocket</span>\n    request.response().setStatusCode(<span class=\"hljs-number\">400</span>).end();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_the_server_websocket\"><a class=\"anchor\" href=\"#_the_server_websocket\"></a>服务端 WebSocket</h5>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> 实例读取在 WebSocket 握手中HTTP请求的 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#headers--\">headers</a></code>，\n<code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html#path--\">path</a></code>， <code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html#query--\">query</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html#uri--\">URI</a></code> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_websockets_on_the_client\"><a class=\"anchor\" href=\"#_websockets_on_the_client\"></a>客户端 WebSocket</h4>\n<div class=\"paragraph\">\n<p>Vert.x的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> 支持 WebSocket。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以调用其中任意一个  <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html#webSocket-int-java.lang.String-java.lang.String-io.vertx.core.Handler-\">webSocket</a></code> 方法创建 WebSocket 连接到服务端，\n并提供回调函数。</p>\n</div>\n<div class=\"paragraph\">\n<p>当连接建立时，处理器将被调用并且传入 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html\">WebSocket</a></code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.webSocket(<span class=\"hljs-string\">\"/some-uri\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    WebSocket ws = res.result();\n    System.out.println(<span class=\"hljs-string\">\"Connected!\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_writing_messages_to_websockets\"><a class=\"anchor\" href=\"#_writing_messages_to_websockets\"></a>向 WebSocket 写入消息</h4>\n<div class=\"paragraph\">\n<p>若您想将一个 WebSocket 消息写入 WebSocket，可使用\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#writeBinaryMessage-io.vertx.core.buffer.Buffer-\">writeBinaryMessage</a></code> 方法或\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#writeTextMessage-java.lang.String-\">writeTextMessage</a></code> 方法来执行该操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Buffer buffer = Buffer.buffer().appendInt(<span class=\"hljs-number\">123</span>).appendFloat(<span class=\"hljs-number\">1.23f</span>);\nwebSocket.writeBinaryMessage(buffer);\n\n<span class=\"hljs-comment\">// 写一个简单文本消息</span>\nString message = <span class=\"hljs-string\">\"hello\"</span>;\nwebSocket.writeTextMessage(message);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若WebSocket 消息大于使用\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setMaxWebSocketFrameSize-int-\">setMaxWebSocketFrameSize</a></code>\n设置的 WebSocket 的帧的最大值，则Vert.x在将其发送到报文之前将其拆分为多个 WebSocket 帧。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_writing_frames_to_websockets\"><a class=\"anchor\" href=\"#_writing_frames_to_websockets\"></a>向 WebSocket 写入帧</h4>\n<div class=\"paragraph\">\n<p>WebSocket 消息可以由多个帧组成，在这种情况下，第一帧要么是 <em>二进制（binary）</em> 帧，要么是 <em>文本（text）</em> 帧帧，\n后边跟着零个或多个 <em>continuation</em> 帧。</p>\n</div>\n<div class=\"paragraph\">\n<p>消息中的最后一帧标记成 <em>final</em> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>要发送多个帧组成的消息，请使用\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocketFrame.html#binaryFrame-io.vertx.core.buffer.Buffer-boolean-\">WebSocketFrame.binaryFrame</a></code>\n， <code><a href=\"../../apidocs/io/vertx/core/http/WebSocketFrame.html#textFrame-java.lang.String-boolean-\">WebSocketFrame.textFrame</a></code> 或\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocketFrame.html#continuationFrame-io.vertx.core.buffer.Buffer-boolean-\">WebSocketFrame.continuationFrame</a></code> 方法创建帧，\n并使用 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#writeFrame-io.vertx.core.http.WebSocketFrame-\">writeFrame</a></code> 方法将其写入WebSocket。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是二进制帧的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebSocketFrame frame1 = WebSocketFrame.binaryFrame(buffer1, <span class=\"hljs-keyword\">false</span>);\nwebSocket.writeFrame(frame1);\n\nWebSocketFrame frame2 = WebSocketFrame.continuationFrame(buffer2, <span class=\"hljs-keyword\">false</span>);\nwebSocket.writeFrame(frame2);\n\n<span class=\"hljs-comment\">// 写最终帧</span>\nWebSocketFrame frame3 = WebSocketFrame.continuationFrame(buffer2, <span class=\"hljs-keyword\">true</span>);\nwebSocket.writeFrame(frame3);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>许多情况下，您只需要发送一个包含了单个最终帧的 WebSocket 消息，因此我们提供了\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#writeFinalBinaryFrame-io.vertx.core.buffer.Buffer-\">writeFinalBinaryFrame</a></code>\n和 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#writeFinalTextFrame-java.lang.String-\">writeFinalTextFrame</a></code> 这两个快捷方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>下边是示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">webSocket.writeFinalTextFrame(<span class=\"hljs-string\">\"Geronimo!\"</span>);\n\n<span class=\"hljs-comment\">// 发送由单个最终二进制帧组成的websocket消息：</span>\n\nBuffer buff = Buffer.buffer().appendInt(<span class=\"hljs-number\">12</span>).appendString(<span class=\"hljs-string\">\"foo\"</span>);\n\nwebSocket.writeFinalBinaryFrame(buff);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_reading_frames_from_websockets\"><a class=\"anchor\" href=\"#_reading_frames_from_websockets\"></a>从 WebSocket 读取帧</h4>\n<div class=\"paragraph\">\n<p>要 从WebSocket 读取帧，您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html#frameHandler-io.vertx.core.Handler-\">frameHandler</a></code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>当帧到达时，会传入一个 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocketFrame.html\">WebSocketFrame</a></code> 实例给帧处理器，并调用它，\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">webSocket.frameHandler(frame -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Received a frame of size!\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_websockets\"><a class=\"anchor\" href=\"#_closing_websockets\"></a>关闭 WebSocket</h4>\n<div class=\"paragraph\">\n<p>处理完成之后，请使用 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#close--\">close</a></code> 方法关闭 WebSocket 连接。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_piping_websockets\"><a class=\"anchor\" href=\"#_piping_websockets\"></a>管道式 WebSocket</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html\">WebSocket</a></code> 也是 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 的实现类，因此可以和管道一起使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>当使用 WebSocket 作为可写流或可读流时，\n它只能用于 WebSocket 连接上连续传输的一组二进制帧（译者注：即二进制帧之间不能被其他帧分割）。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_event_bus_handlers\"><a class=\"anchor\" href=\"#_event_bus_handlers\"></a>Event bus 处理器</h4>\n<div class=\"paragraph\">\n<p>每个WebSocket都会在事件总线上自动注册两个处理器，当此处理器中接收到任何数据时，\n它会将数据写入WebSocket。这两个处理器是本地订阅，不会路由到集群上。</p>\n</div>\n<div class=\"paragraph\">\n<p>基于这个特性，你可以将数据写入WebSocket（可能在完全不同的verticle中），\n只要将数据发送到这两个处理器监听的地址即可。</p>\n</div>\n<div class=\"paragraph\">\n<p>这两个处理器的监听地址由 <code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#binaryHandlerID--\">binaryHandlerID</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocketBase.html#textHandlerID--\">textHandlerID</a></code> 给出。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_a_proxy_for_httphttps_connections\"><a class=\"anchor\" href=\"#_using_a_proxy_for_httphttps_connections\"></a>使用 HTTP/HTTPS 连接代理</h3>\n<div class=\"paragraph\">\n<p>HTTP 客户端支持通过 HTTP 代理（如Squid）或 <em>SOCKS4a</em> 或 <em>SOCKS5</em> 代理访问 HTTP/HTTPS 的 URL。\nCONNECT 协议使用 HTTP/1.x，但可以连接到 HTTP/1.x 和 HTTP/2 服务器。</p>\n</div>\n<div class=\"paragraph\">\n<p>到 <code>h2c</code>（未加密HTTP/2服务器）的连接可能不受 HTTP 代理支持，\n因为代理仅支持 HTTP/1.1。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html\">HttpClientOptions</a></code> 中的\n<code><a href=\"../../apidocs/io/vertx/core/net/ProxyOptions.html\">ProxyOptions</a></code> 对象配置来配置代理（包括代理类型、主机名、端口和可选用户名和密码）。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是使用 HTTP 代理的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions()\n    .setProxyOptions(<span class=\"hljs-keyword\">new</span> ProxyOptions().setType(ProxyType.HTTP)\n        .setHost(<span class=\"hljs-string\">\"localhost\"</span>).setPort(<span class=\"hljs-number\">3128</span>)\n        .setUsername(<span class=\"hljs-string\">\"username\"</span>).setPassword(<span class=\"hljs-string\">\"secret\"</span>));\nHttpClient client = vertx.createHttpClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当客户端连接到HTTP URL时，它会连接到代理服务器，并在HTTP请求中提供完整URL\n（ \"GET <a href=\"http://www.somehost.com/path/file.html\" class=\"bare\">http://www.somehost.com/path/file.html</a> HTTP/1.1\" ）。</p>\n</div>\n<div class=\"paragraph\">\n<p>当客户端连接到HTTPS URL时，它要求代理使用 CONNECT\n方法创建到远程主机的通道。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 SOCKS5 代理：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions()\n    .setProxyOptions(<span class=\"hljs-keyword\">new</span> ProxyOptions().setType(ProxyType.SOCKS5)\n        .setHost(<span class=\"hljs-string\">\"localhost\"</span>).setPort(<span class=\"hljs-number\">1080</span>)\n        .setUsername(<span class=\"hljs-string\">\"username\"</span>).setPassword(<span class=\"hljs-string\">\"secret\"</span>));\nHttpClient client = vertx.createHttpClient(options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>DNS 解析会一直在代理服务器上执行。为了实现 SOCKS4 客户端的功能，\n需要先在本地解析 DNS 地址。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_handling_of_other_protocols\"><a class=\"anchor\" href=\"#_handling_of_other_protocols\"></a>处理其他协议</h4>\n<div class=\"paragraph\">\n<p>如果代理支持，HTTP代理的实现支持获取 ftp://\n协议的url。</p>\n</div>\n<div class=\"paragraph\">\n<p>当HTTP请求URI包含完整URL时，HttpClient不会计算完整的HTTP URL，\n而是直接使用请求URI中指定的完整URL：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClientOptions options = <span class=\"hljs-keyword\">new</span> HttpClientOptions()\n    .setProxyOptions(<span class=\"hljs-keyword\">new</span> ProxyOptions().setType(ProxyType.HTTP));\nHttpClient client = vertx.createHttpClient(options);\nclient.request(HttpMethod.GET, <span class=\"hljs-string\">\"ftp://ftp.gnu.org/gnu/\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    HttpClientRequest request = ar.result();\n    request.send(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        HttpClientResponse response = ar2.result();\n        System.out.println(<span class=\"hljs-string\">\"Received response with status code \"</span> + response.statusCode());\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_ha_proxy_protocol_2\"><a class=\"anchor\" href=\"#_using_ha_proxy_protocol_2\"></a>使用HA代理协议</h3>\n<div class=\"paragraph\">\n<p><a href=\"https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">HA PROXY 协议</a> 提供了一种便捷的安全传输连接信息（例如客户端的地址）的方式，\n可以跨多层 NAT 或 TCP\n代理传输。</p>\n</div>\n<div class=\"paragraph\">\n<p>HA PROXY 协议通过 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setUseProxyProtocol-boolean-\">setUseProxyProtocol</a></code> 方法设置启用，\n同时需要在classpath中增加以下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.netty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>netty-codec-haproxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-comment\">&lt;!--&lt;version&gt;必须和 Vert.x 所使用的 netty 的版本一致&lt;/version&gt;--&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerOptions options = <span class=\"hljs-keyword\">new</span> HttpServerOptions()\n  .setUseProxyProtocol(<span class=\"hljs-keyword\">true</span>);\n\nHttpServer server = vertx.createHttpServer(options);\nserver.requestHandler(request -&gt; {\n  <span class=\"hljs-comment\">// 打印HA代理协议提供的真实地址，而不是代理的地址</span>\n  System.out.println(request.remoteAddress());\n\n  <span class=\"hljs-comment\">// 打印代理的地址</span>\n  System.out.println(request.localAddress());\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_clean_up_in_verticles_4\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles_4\"></a>Verticle 中自动清理</h3>\n<div class=\"paragraph\">\n<p>如果您是在 Verticle 内部创建的 HTTP 服务端和客户端，\n则在撤销该Verticle时，它们将自动关闭。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_shareddata_api\"><a class=\"anchor\" href=\"#_using_the_shareddata_api\"></a>使用共享数据的API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>顾名思义，<code><a href=\"../../apidocs/io/vertx/core/shareddata/SharedData.html\">共享数据（SharedData）</a></code> API允许您在如下组件中安全地共享数据：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>应用程序的不同部分之间，或者</p>\n</li>\n<li>\n<p>同一 Vert.x 实例中的不同应用程序之间，或者</p>\n</li>\n<li>\n<p>Vert.x 集群中的不同实例之间</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在实践中, 它提供了:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>synchronous maps (local-only)</p>\n</li>\n<li>\n<p>asynchronous maps</p>\n</li>\n<li>\n<p>asynchronous locks</p>\n</li>\n<li>\n<p>asynchronous counters</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n分布式数据结构的行为取决于您使用的集群管理器。\n网络分区面临的备份（复制）以及当出现网络分区时的行为，由集群管理器和其配置来决定。\n请参阅集群管理器文档以及底层框架手册。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_local_maps\"><a class=\"anchor\" href=\"#_local_maps\"></a>Local maps</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/shareddata/LocalMap.html\">Local maps</a></code> 允许您在同一个 Vert.x 实例中的不同事件循环（如不同的 verticle）之间安全地共享数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>仅允许将某些数据类型作为键值和值：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>不可变的类型 （如 String、boolean，等等），或</p>\n</li>\n<li>\n<p>实现了 <code><a href=\"../../apidocs/io/vertx/core/shareddata/Shareable.html\">Shareable</a></code> 接口的类型 （比如Buffer，JSON数组，JSON对象，或您编写的Shareable实现类）。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在后一种情况中，键/值将被复制，然后再放到Map中。</p>\n</div>\n<div class=\"paragraph\">\n<p>这样，我们可以确保在Vert.x应用程序不同线程之间没有 <em>共享访问可变状态</em> 。\n因此您不必担心需要通过同步访问来保护该状态。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是使用一个共享的 local map 的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nLocalMap&lt;String, String&gt; map1 = sharedData.getLocalMap(<span class=\"hljs-string\">\"mymap1\"</span>);\n\nmap1.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>); <span class=\"hljs-comment\">// String是不可变的，所以不需要复制</span>\n\nLocalMap&lt;String, Buffer&gt; map2 = sharedData.getLocalMap(<span class=\"hljs-string\">\"mymap2\"</span>);\n\nmap2.put(<span class=\"hljs-string\">\"eek\"</span>, Buffer.buffer().appendInt(<span class=\"hljs-number\">123</span>)); <span class=\"hljs-comment\">// Buffer将会在添加到Map之前拷贝</span>\n\n<span class=\"hljs-comment\">// 之后... 在您应用的另外一部分</span>\n\nmap1 = sharedData.getLocalMap(<span class=\"hljs-string\">\"mymap1\"</span>);\n\nString val = map1.get(<span class=\"hljs-string\">\"foo\"</span>);\n\nmap2 = sharedData.getLocalMap(<span class=\"hljs-string\">\"mymap2\"</span>);\n\nBuffer buff = map2.get(<span class=\"hljs-string\">\"eek\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_asynchronous_shared_maps\"><a class=\"anchor\" href=\"#_asynchronous_shared_maps\"></a>异步共享的 maps</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/shareddata/AsyncMap.html\">异步共享的 maps</a></code> 允许数据被放到 map 中，并从本地或任何其他节点读取。</p>\n</div>\n<div class=\"paragraph\">\n<p>这使得它们对于托管Vert.x Web应用程序的服务器场中的会话状态存储非常有用。</p>\n</div>\n<div class=\"paragraph\">\n<p>获取Map的过程是异步的，返回结果可以传递给您指定的处理器。。以下是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nsharedData.&lt;String, String&gt;getAsyncMap(<span class=\"hljs-string\">\"mymap\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    AsyncMap&lt;String, String&gt; map = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当 Vert.x 是集群模式时, 你放进map的数据，从本地以及从集群中的其他成员那里都可以访问到。</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n在集群模式中, 异步共享的 maps 依靠于集群管理器提供的分布式数据结构。\n请注意，异步共享map操作的延迟，在集群模式下可能比在本地模式下高很多。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果你的应用不需要和其它任何节点共享数据，那么你可以获取一个仅限本地的 map：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nsharedData.&lt;String, String&gt;getLocalAsyncMap(<span class=\"hljs-string\">\"mymap\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 仅限本地的异步map</span>\n    AsyncMap&lt;String, String&gt; map = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_putting_data_in_a_map\"><a class=\"anchor\" href=\"#_putting_data_in_a_map\"></a>将数据放入map</h4>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/core/shareddata/AsyncMap.html#put-java.lang.Object-java.lang.Object-io.vertx.core.Handler-\">put</a></code> 方法将数据放入map。</p>\n</div>\n<div class=\"paragraph\">\n<p>put 方法是异步的，一旦完成它会通知处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">map.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>, resPut -&gt; {\n  <span class=\"hljs-keyword\">if</span> (resPut.succeeded()) {\n    <span class=\"hljs-comment\">// 成功放入值</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_getting_data_from_a_map\"><a class=\"anchor\" href=\"#_getting_data_from_a_map\"></a>从map中读取数据</h4>\n<div class=\"paragraph\">\n<p>您可以使用  <code><a href=\"../../apidocs/io/vertx/core/shareddata/AsyncMap.html#get-java.lang.Object-io.vertx.core.Handler-\">get</a></code> 方法从Map读取数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>get 方法是异步的，一段时间过后它会通知处理器并传入结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">map.get(<span class=\"hljs-string\">\"foo\"</span>, resGet -&gt; {\n  <span class=\"hljs-keyword\">if</span> (resGet.succeeded()) {\n    <span class=\"hljs-comment\">// 成功读取值</span>\n    Object val = resGet.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_other_map_operations\"><a class=\"anchor\" href=\"#_other_map_operations\"></a>其他map操作</h5>\n<div class=\"paragraph\">\n<p>您还可以从异步Map中删除条目、清除Map、读取它的大小。</p>\n</div>\n<div class=\"paragraph\">\n<p>有关更多信息，请参阅  <code><a href=\"../../apidocs/io/vertx/core/shareddata/AsyncMap.html\">API docs</a></code> 。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_asynchronous_locks\"><a class=\"anchor\" href=\"#_asynchronous_locks\"></a>异步锁</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/shareddata/Lock.html\">异步锁</a></code> 允许您在集群中获取独占锁。\n异步锁适用于：同一时刻仅在一个节点上执行某些操作或访问某个资源。</p>\n</div>\n<div class=\"paragraph\">\n<p>集群范围锁具有异步API，它和大多数等待锁释放的阻塞调用线程的API锁不相同。</p>\n</div>\n<div class=\"paragraph\">\n<p>可使用 <code><a href=\"../../apidocs/io/vertx/core/shareddata/SharedData.html#getLock-java.lang.String-io.vertx.core.Handler-\">getLock</a></code> 方法获取锁。\n它不会阻塞，但当锁可用时， <code><a href=\"../../apidocs/io/vertx/core/shareddata/Lock.html\">Lock</a></code> 的实例会被传入处理器，表示您现在拥有该锁。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您拥有的锁没有其他调用者，集群上的任何地方都可以获得该锁。</p>\n</div>\n<div class=\"paragraph\">\n<p>当您用完锁后，您可以调用 <code><a href=\"../../apidocs/io/vertx/core/shareddata/Lock.html#release--\">release</a></code> 方法来释放它，以便另一个调用者可获得它。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nsharedData.getLock(<span class=\"hljs-string\">\"mylock\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 获得锁</span>\n    Lock lock = res.result();\n\n    <span class=\"hljs-comment\">// 5秒后我们释放该锁以便其他人可以得到它</span>\n\n    vertx.setTimer(<span class=\"hljs-number\">5000</span>, tid -&gt; lock.release());\n\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以为锁设置一个超时时间，若获取锁超时，则会通知处理器获取锁失败：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nsharedData.getLockWithTimeout(<span class=\"hljs-string\">\"mylock\"</span>, <span class=\"hljs-number\">10000</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 获得锁</span>\n    Lock lock = res.result();\n\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 获取锁失败</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有更多信息，请参阅  <code><a href=\"../../apidocs/io/vertx/core/shareddata/Lock.html\">API文档</a></code> 。</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n在集群模式中, 异步锁依靠于集群管理器提供的分布式数据结构。\n请注意，异步共享锁的操作的延迟，在集群模式下可能比在本地模式下高很多。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果你的应用不需要和其它任何节点共享锁，你可以获取一个仅限本地的锁：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nsharedData.getLocalLock(<span class=\"hljs-string\">\"mylock\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 仅限本地的计数器</span>\n    Lock lock = res.result();\n\n    <span class=\"hljs-comment\">// 5秒后我们释放该锁以便其他人可以得到它</span>\n\n    vertx.setTimer(<span class=\"hljs-number\">5000</span>, tid -&gt; lock.release());\n\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_asynchronous_counters\"><a class=\"anchor\" href=\"#_asynchronous_counters\"></a>异步计数器</h3>\n<div class=\"paragraph\">\n<p>有时你会需要在本地或者在应用节点之间维护一个原子计数器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/core/shareddata/Counter.html\">Counter</a></code> 来做到这一点。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/core/shareddata/SharedData.html#getCounter-java.lang.String-io.vertx.core.Handler-\">getCounter</a></code> 方法获取一个实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nsharedData.getCounter(<span class=\"hljs-string\">\"mycounter\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Counter counter = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在获取了一个实例后，您可以用多种方式获取当前的计数、原子地+1、-1、\n加某个特定值。</p>\n</div>\n<div class=\"paragraph\">\n<p>有更多信息，请参阅 <code><a href=\"../../apidocs/io/vertx/core/shareddata/Counter.html\">API文档</a></code> 。</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n在集群模式中, 异步计数器依靠于集群管理器提供的分布式数据结构。\n请注意，异步共享计数器操作的延迟，在集群模式下可能比在本地模式下高很多。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果你的应用不需要和其它任何节点共享计数器, 你可以获取一个仅限本地的计数器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SharedData sharedData = vertx.sharedData();\n\nsharedData.getLocalCounter(<span class=\"hljs-string\">\"mycounter\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 仅限本地的计数器</span>\n    Counter counter = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_file_system_with_vert_x\"><a class=\"anchor\" href=\"#_using_the_file_system_with_vert_x\"></a>使用 Vert.x 访问文件系统</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x的 <code><a href=\"../../apidocs/io/vertx/core/file/FileSystem.html\">FileSystem</a></code> 对象提供了许多操作文件系统的方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个Vert.x 实例有一个文件系统对象，您可以使用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#fileSystem--\">fileSystem</a></code> 方法获取它。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个操作都提供了阻塞和非阻塞版本，其中非阻塞版本接受一个处理器（Handler），\n当操作完成或发生错误时调用该处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是文件异步拷贝的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\n\n<span class=\"hljs-comment\">// 从foo.txt拷贝到bar.txt</span>\nfs.copy(<span class=\"hljs-string\">\"foo.txt\"</span>, <span class=\"hljs-string\">\"bar.txt\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 拷贝完成</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>阻塞版本的方法名为 <code>xxxBlocking</code>，它要么返回结果，要么直接抛出异常。\n很多情况下，一些潜在的阻塞操作可以快速返回（这取决于操作系统和文件系统），\n这就是我们为什么提供它。但是强烈建议您在event-loop中使用它之前测试使用它们究竟需要耗费多长时间，\n以避免打破黄金法则。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是使用阻塞 API的拷贝示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\n\n<span class=\"hljs-comment\">// 同步拷贝从foo.txt到bar.txt</span>\nfs.copyBlocking(<span class=\"hljs-string\">\"foo.txt\"</span>, <span class=\"hljs-string\">\"bar.txt\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 文件系统支持 copy、move、truncate、chmod 等等许多其他文件操作。\n我们不会在这里列出所有内容，请参考 <code><a href=\"../../apidocs/io/vertx/core/file/FileSystem.html\">API文档</a></code> 获取完整列表。</p>\n</div>\n<div class=\"paragraph\">\n<p>让我们看看使用异步方法的几个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.fileSystem().readFile(<span class=\"hljs-string\">\"target/classes/readme.txt\"</span>, result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    System.out.println(result.result());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Oh oh ...\"</span> + result.cause());\n  }\n});\n\n<span class=\"hljs-comment\">// 拷贝文件</span>\nvertx.fileSystem().copy(<span class=\"hljs-string\">\"target/classes/readme.txt\"</span>, <span class=\"hljs-string\">\"target/classes/readme2.txt\"</span>, result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"File copied\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Oh oh ...\"</span> + result.cause());\n  }\n});\n\n<span class=\"hljs-comment\">// 写文件</span>\nvertx.fileSystem().writeFile(<span class=\"hljs-string\">\"target/classes/hello.txt\"</span>, Buffer.buffer(<span class=\"hljs-string\">\"Hello\"</span>), result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"File written\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Oh oh ...\"</span> + result.cause());\n  }\n});\n\n<span class=\"hljs-comment\">// 检测是否已经存在以及删除</span>\nvertx.fileSystem().exists(<span class=\"hljs-string\">\"target/classes/junk.txt\"</span>, result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded() &amp;&amp; result.result()) {\n    vertx.fileSystem().delete(<span class=\"hljs-string\">\"target/classes/junk.txt\"</span>, r -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"File deleted\"</span>);\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Oh oh ... - cannot delete the file: \"</span> + result.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_asynchronous_files\"><a class=\"anchor\" href=\"#_asynchronous_files\"></a>异步文件访问</h3>\n<div class=\"paragraph\">\n<p>Vert.x提供了异步文件访问的抽象，允许您操作文件系统上的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以像下边代码打开一个 <code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html\">AsyncFile</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OpenOptions options = <span class=\"hljs-keyword\">new</span> OpenOptions();\nfileSystem.open(<span class=\"hljs-string\">\"myfile.txt\"</span>, options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    AsyncFile file = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发生错误</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>AsyncFile</code> 实现了 <code>ReadStream</code> 和 <code>WriteStream</code> 接口，因此您可以将文件和其他流对象配合 <em>管道</em> 工作，\n如NetSocket、HTTP请求和响应和WebSocket等。</p>\n</div>\n<div class=\"paragraph\">\n<p>它们还允许您直接读写。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_random_access_writes\"><a class=\"anchor\" href=\"#_random_access_writes\"></a>随机访问写</h4>\n<div class=\"paragraph\">\n<p>要使用 <code>AsyncFile</code> 进行随机访问写，请使用\n<code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html#write-io.vertx.core.buffer.Buffer-long-io.vertx.core.Handler-\">write</a></code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个方法的参数有：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>buffer</code> ：要写入的缓冲</p>\n</li>\n<li>\n<p><code>position</code> ：一个整数，指定在文件中写入缓冲的位置，若位置大于或等于文件大小，\n文件将被扩展以适应偏移的位置。</p>\n</li>\n<li>\n<p><code>handler</code> ：结果处理器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这是随机访问写的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.fileSystem().open(<span class=\"hljs-string\">\"target/classes/hello.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    AsyncFile file = result.result();\n    Buffer buff = Buffer.buffer(<span class=\"hljs-string\">\"foo\"</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++) {\n      file.write(buff, buff.length() * i, ar -&gt; {\n        <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n          System.out.println(<span class=\"hljs-string\">\"Written ok!\"</span>);\n          <span class=\"hljs-comment\">// 等等</span>\n        } <span class=\"hljs-keyword\">else</span> {\n          System.err.println(<span class=\"hljs-string\">\"Failed to write: \"</span> + ar.cause());\n        }\n      });\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Cannot open file \"</span> + result.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_random_access_reads\"><a class=\"anchor\" href=\"#_random_access_reads\"></a>随机访问读</h4>\n<div class=\"paragraph\">\n<p>要使用 <code>AsyncFile</code> 进行随机访问读，请使用\n<code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html#read-io.vertx.core.buffer.Buffer-int-long-int-io.vertx.core.Handler-\">read</a></code>\n方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>该方法的参数有：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>buffer</code> ：读取数据的 Buffer</p>\n</li>\n<li>\n<p><code>offset</code> ：读取数据将被放到 Buffer 中的偏移量</p>\n</li>\n<li>\n<p><code>position</code> ：从文件中读取数据的位置</p>\n</li>\n<li>\n<p><code>length</code> ：要读取的数据的字节数</p>\n</li>\n<li>\n<p><code>handler</code> ：结果处理器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>以下是随机访问读的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.fileSystem().open(<span class=\"hljs-string\">\"target/classes/les_miserables.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    AsyncFile file = result.result();\n    Buffer buff = Buffer.buffer(<span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n      file.read(buff, i * <span class=\"hljs-number\">100</span>, i * <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, ar -&gt; {\n        <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n          System.out.println(<span class=\"hljs-string\">\"Read ok!\"</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          System.err.println(<span class=\"hljs-string\">\"Failed to write: \"</span> + ar.cause());\n        }\n      });\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Cannot open file \"</span> + result.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_opening_options\"><a class=\"anchor\" href=\"#_opening_options\"></a>打开选项</h4>\n<div class=\"paragraph\">\n<p>打开 <code>AsyncFile</code> 时，您可以传递一个 <code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html\">OpenOptions</a></code> 实例，\n这些选项描述了访问文件的行为。例如：您可使用\n<code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html#setRead-boolean-\">setRead</a></code>，<code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html#setWrite-boolean-\">setWrite</a></code>\n和 <code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html#setPerms-java.lang.String-\">setPerms</a></code> 方法配置文件访问权限。</p>\n</div>\n<div class=\"paragraph\">\n<p>若打开的文件已经存在，则可以使用\n<code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html#setCreateNew-boolean-\">setCreateNew</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html#setTruncateExisting-boolean-\">setTruncateExisting</a></code> 配置对应行为。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用\n<code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html#setDeleteOnClose-boolean-\">setDeleteOnClose</a></code> 标记在关闭时或JVM停止时要删除的文件。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_flushing_data_to_underlying_storage\"><a class=\"anchor\" href=\"#_flushing_data_to_underlying_storage\"></a>将数据刷新到底层存储</h4>\n<div class=\"paragraph\">\n<p>在 <code>OpenOptions</code> 中，您可以使用\n<code><a href=\"../../apidocs/io/vertx/core/file/OpenOptions.html#setDsync-boolean-\">setDsync</a></code> 方法在每次写入时启用/禁用内容的自动同步。这种情况下，您可以使用\n <code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html#flush--\">flush</a></code> 方法手动将OS缓存中的数据写入存储设备。</p>\n</div>\n<div class=\"paragraph\">\n<p>该方法也可附带一个处理器来调用，这个处理器在 <code>flush</code> 完成时被调用。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_asyncfile_as_readstream_and_writestream\"><a class=\"anchor\" href=\"#_using_asyncfile_as_readstream_and_writestream\"></a>将 AsyncFile 作为 ReadStream 和 WriteStream</h4>\n<div class=\"paragraph\">\n<p><code>AsyncFile</code> 实现了 <code>ReadStream</code> 和 <code>WriteStream</code> 接口。\n您可以使用 <em>管道</em> 将数据与其他读取和写入流进行数据管送。\n例如，下面的例子会将内容复制到另外一个 <code>AsyncFile</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">final</span> AsyncFile output = vertx.fileSystem().openBlocking(<span class=\"hljs-string\">\"target/classes/plagiary.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions());\n\nvertx.fileSystem().open(<span class=\"hljs-string\">\"target/classes/les_miserables.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    AsyncFile file = result.result();\n    file.pipeTo(output)\n      .onComplete(v -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"Copy done\"</span>);\n      });\n  } <span class=\"hljs-keyword\">else</span> {\n    System.err.println(<span class=\"hljs-string\">\"Cannot open file \"</span> + result.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还可以使用 <em>管道</em> 将文件内容写入到HTTP 响应中，或者写入任意\n<code>WriteStream</code>。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"classpath\"><a class=\"anchor\" href=\"#classpath\"></a>从 Classpath 访问文件</h4>\n<div class=\"paragraph\">\n<p>当Vert.x找不到文件系统上的文件时，它尝试从类路径中解析该文件。\n请注意，类路径的资源路径不以\n<code>/</code> 开头。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于Java不提供对类路径资源的异步方法，\n所以当类路径资源第一次被访问时，\n该文件将复制到工作线程中的文件系统。\n当第二次访问相同资源时，访问的文件直接从\n（工作线程的）文件系统提供。\n即使类路径资源发生变化（例如开发系统中），\n也会提供之前的内容。</p>\n</div>\n<div class=\"paragraph\">\n<p>此（文件）缓存行为可以通过 <code><a href=\"../../apidocs/io/vertx/core/file/FileSystemOptions.html#setFileCachingEnabled-boolean-\">setFileCachingEnabled</a></code>\n方法进行设定。如果系统属性中没有预先设置 <code>vertx.disableFileCaching</code>\n，则其默认值为 <code>true</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>文件缓存的路径默认为 <code>.vertx</code>，它可以通过设置系统属性\n<code>vertx.cacheDirBase</code> 进行自定义。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果想在系统级禁用整个classpath解析功能，可以将系统属性\n<code>vertx.disableFileCPResolving</code> 设置为 <code>true</code>。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n当加载 <code>io.vertx.core.file.FileSystemOptions</code> 类时，这些系统属性将被加载一次。\n因此，在加载此类之前应该设置这些属性，或者在启动它时作为JVM系统属性来设置。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果要禁用特定应用程序的类路径解析，但默认情况下在系统范围内将其保持启用状态，\n则可以通过 <code><a href=\"../../apidocs/io/vertx/core/file/FileSystemOptions.html#setClassPathResolvingEnabled-boolean-\">setClassPathResolvingEnabled</a></code> 选项设置。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_an_asyncfile\"><a class=\"anchor\" href=\"#_closing_an_asyncfile\"></a>关闭 AsyncFile</h4>\n<div class=\"paragraph\">\n<p>您可调用 <code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html#close--\">close</a></code> 方法来关闭 <code>AsyncFile</code>。\n关闭是异步的，如果希望在关闭过后收到通知，您可指定一个处理器作为函数 <code>close</code> 的参数。。</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_datagram_sockets_udp\"><a class=\"anchor\" href=\"#_datagram_sockets_udp\"></a>数据报套接字（UDP）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在Vert.x中使用用户数据报协议（UDP）就是小菜一碟。</p>\n</div>\n<div class=\"paragraph\">\n<p>UDP是无连接的传输，这意味着您与远程客户端没有建立持续的连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>所以，您发送和接收的数据包都要包含有远程的地址。</p>\n</div>\n<div class=\"paragraph\">\n<p>除此之外，UDP不像TCP的使用那样安全，\n这也就意味着不能保证发送的数据包一定会被对应的接收端（Endpoint）接收。</p>\n</div>\n<div class=\"paragraph\">\n<p>唯一可以保证的是，数据包要么被完整地接收，要么完全收不到，</p>\n</div>\n<div class=\"paragraph\">\n<p>因为每一个数据包将会作为一个包发送，所以在通常情况下您不能发送大于网络接口的最大传输单元（MTU）的数据包。\n（译者注：实际上大于MTU的包是可以发送成功的，只不过数据包会在IP层做分片。由于分片不携带4层信息，所以有些NAT为了性能等因素会丢弃分片报文。而接收分片报文时，需要所有分片在规定时间内全部接收到，才算作收到一个完整的UDP包，所以分片报文的传输失败率会更高。一般不要发送超过 <code>MTU - len(IP.header) - len(UDP.header)</code> 长度的包。）</p>\n</div>\n<div class=\"paragraph\">\n<p>但是要注意，即使数据包尺寸小于MTU，它仍然可能会发送失败。</p>\n</div>\n<div class=\"paragraph\">\n<p>它失败的尺寸取决于操作系统等（其他原因），所以按照经验法则就是尝试发送小数据包。</p>\n</div>\n<div class=\"paragraph\">\n<p>依照UDP的本质，它最适合一些允许丢弃数据包的应用\n（如监视应用程序）。</p>\n</div>\n<div class=\"paragraph\">\n<p>其优点是与TCP相比具有更少的开销，\n而且可以由NetServer和NetClient处理（参考前文）。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_datagramsocket\"><a class=\"anchor\" href=\"#_creating_a_datagramsocket\"></a>创建 DatagramSocket</h3>\n<div class=\"paragraph\">\n<p>要使用UDP，您首先要创建一个 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code> 实例，\n无论您是要仅仅发送数据或者收发数据，这都是一样的。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DatagramSocket socket = vertx.createDatagramSocket(<span class=\"hljs-keyword\">new</span> DatagramSocketOptions());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>返回的 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code> 实例不会绑定到特定端口。\n如果您只想发送数据（如作为客户端）的话，这是没问题的，但更多详细的内容在下一节。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sending_datagram_packets\"><a class=\"anchor\" href=\"#_sending_datagram_packets\"></a>发送数据报包</h3>\n<div class=\"paragraph\">\n<p>如上所述，用户数据报协议（UDP）将数据分组发送给远程对等体，\n但是以不持续的方式来传送到它们。</p>\n</div>\n<div class=\"paragraph\">\n<p>这意味着每个数据包都可以发送到不同的远程对等体。</p>\n</div>\n<div class=\"paragraph\">\n<p>发送数据包很容易，如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DatagramSocket socket = vertx.createDatagramSocket(<span class=\"hljs-keyword\">new</span> DatagramSocketOptions());\nBuffer buffer = Buffer.buffer(<span class=\"hljs-string\">\"content\"</span>);\n<span class=\"hljs-comment\">// 发送Buffer</span>\nsocket.send(buffer, <span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"10.0.0.1\"</span>, asyncResult -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Send succeeded? \"</span> + asyncResult.succeeded());\n});\n<span class=\"hljs-comment\">// 发送一个字符串</span>\nsocket.send(<span class=\"hljs-string\">\"A string used as content\"</span>, <span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"10.0.0.1\"</span>, asyncResult -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Send succeeded? \"</span> + asyncResult.succeeded());\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_receiving_datagram_packets\"><a class=\"anchor\" href=\"#_receiving_datagram_packets\"></a>接收数据报包</h3>\n<div class=\"paragraph\">\n<p>若您想要接收数据包，则您需要调用 <code>listen(&#8230;&#8203;)</code> 方法绑定\n<code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>这样您就可以接收到被发送至 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramPacket.html\">DatagramPacket</a></code> 所监听的地址和端口的\n<code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>除此之外，您还要设置一个 <code>Handler</code>，每接收到一个 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramPacket.html\">DatagramPacket</a></code> 时它都会被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramPacket.html\">DatagramPacket</a></code> 有以下方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramPacket.html#sender--\">sender</a></code> ：表示数据发送方的InetSocketAddress。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramPacket.html#data--\">data</a></code> ：保存接收数据的Buffer。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>当您需要监听一个特定地址和端口时，您可以像下边这样：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DatagramSocket socket = vertx.createDatagramSocket(<span class=\"hljs-keyword\">new</span> DatagramSocketOptions());\nsocket.listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"0.0.0.0\"</span>, asyncResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (asyncResult.succeeded()) {\n    socket.handler(packet -&gt; {\n      <span class=\"hljs-comment\">// 对包进行处理</span>\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Listen failed\"</span> + asyncResult.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意，即使 <code>AsyncResult</code> 成功，它只意味着它可能已经写入了网络堆栈，\n但不保证它已经到达或者将到达远端。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您需要这样的保证，您可在TCP之上建立一些握手逻辑。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_multicast\"><a class=\"anchor\" href=\"#_multicast\"></a>多播</h3>\n<div class=\"sect3\">\n<h4 id=\"_sending_multicast_packets\"><a class=\"anchor\" href=\"#_sending_multicast_packets\"></a>发送多播数据包</h4>\n<div class=\"paragraph\">\n<p>多播允许多个Socket接收相同的数据包，\n该目标可以通过加入到同一个可发送数据包的多播组来实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们将在下一节中介绍如何加入多播组，从而接收数据包。</p>\n</div>\n<div class=\"paragraph\">\n<p>现在让我们专注于如何发送多播报文，发送多播报文与发送普通数据报报文没什么不同。\n唯一的区别是您可以将多播组的地址传递给send方法发送出去。</p>\n</div>\n<div class=\"paragraph\">\n<p>如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DatagramSocket socket = vertx.createDatagramSocket(<span class=\"hljs-keyword\">new</span> DatagramSocketOptions());\nBuffer buffer = Buffer.buffer(<span class=\"hljs-string\">\"content\"</span>);\n<span class=\"hljs-comment\">// 发送Buffer到多播地址</span>\nsocket.send(buffer, <span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"230.0.0.1\"</span>, asyncResult -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Send succeeded? \"</span> + asyncResult.succeeded());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>所有已经加入多播组 230.0.0.1 的Socket都将收到该报文。</p>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_receiving_multicast_packets\"><a class=\"anchor\" href=\"#_receiving_multicast_packets\"></a>接收多播数据包</h5>\n<div class=\"paragraph\">\n<p>若要接收特定多播组的数据包，您需要通过调用 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code> 的 <code>listen(&#8230;&#8203;)</code>\n方法来绑定一个地址并且加入多播组。</p>\n</div>\n<div class=\"paragraph\">\n<p>这样，您将能够接收到被发送到 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code> 所监听的地址和端口的数据报，\n同时也可以接收被发送到该多播组的数据报。</p>\n</div>\n<div class=\"paragraph\">\n<p>除此之外，您还可设置一个处理器，它在每次接收到DatagramPacket时会被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramPacket.html\">DatagramPacket</a></code> 有以下方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>sender()</code>: 表示数据报发送方的InetSocketAddress</p>\n</li>\n<li>\n<p><code>data()</code>: 保存接收数据的Buffer</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>因此，要监听指定的地址和端口、并且接收多播组230.0.0.1的数据报，\n您需要执行如下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DatagramSocket socket = vertx.createDatagramSocket(<span class=\"hljs-keyword\">new</span> DatagramSocketOptions());\nsocket.listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"0.0.0.0\"</span>, asyncResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (asyncResult.succeeded()) {\n    socket.handler(packet -&gt; {\n      <span class=\"hljs-comment\">// 对数据包进行处理</span>\n    });\n\n    <span class=\"hljs-comment\">// 加入多播组</span>\n    socket.listenMulticastGroup(<span class=\"hljs-string\">\"230.0.0.1\"</span>, asyncResult2 -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"Listen succeeded? \"</span> + asyncResult2.succeeded());\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Listen failed\"</span> + asyncResult.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_unlisten_leave_a_multicast_group\"><a class=\"anchor\" href=\"#_unlisten_leave_a_multicast_group\"></a>取消订阅/离开多播组</h5>\n<div class=\"paragraph\">\n<p>有时候您想只在特定时间内接收多播组的数据包。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种情况下，您可以先监听他们，之后再取消监听。</p>\n</div>\n<div class=\"paragraph\">\n<p>如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DatagramSocket socket = vertx.createDatagramSocket(<span class=\"hljs-keyword\">new</span> DatagramSocketOptions());\nsocket.listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"0.0.0.0\"</span>, asyncResult -&gt; {\n    <span class=\"hljs-keyword\">if</span> (asyncResult.succeeded()) {\n      socket.handler(packet -&gt; {\n        <span class=\"hljs-comment\">// 对数据包进行处理</span>\n      });\n\n      <span class=\"hljs-comment\">// 加入多播组</span>\n      socket.listenMulticastGroup(<span class=\"hljs-string\">\"230.0.0.1\"</span>, asyncResult2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (asyncResult2.succeeded()) {\n            <span class=\"hljs-comment\">// 现在将接收组的数据包</span>\n\n            <span class=\"hljs-comment\">// 做一些事情</span>\n\n            socket.unlistenMulticastGroup(<span class=\"hljs-string\">\"230.0.0.1\"</span>, asyncResult3 -&gt; {\n              System.out.println(<span class=\"hljs-string\">\"Unlisten succeeded? \"</span> + asyncResult3.succeeded());\n            });\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"Listen failed\"</span> + asyncResult2.cause());\n          }\n      });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Listen failed\"</span> + asyncResult.cause());\n    }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_blocking_multicast\"><a class=\"anchor\" href=\"#_blocking_multicast\"></a>屏蔽多播</h5>\n<div class=\"paragraph\">\n<p>除了取消监听一个多播地址以外，也可以做到屏蔽指定发送者地址的多播。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意这仅适用于某些操作系统和内核版本，\n所以请检查操作系统文档看是它是否支持。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是专家级别的技巧。</p>\n</div>\n<div class=\"paragraph\">\n<p>要屏蔽来自特定地址的多播，您可以在DatagramSocket上调用 <code>blockMulticastGroup(&#8230;&#8203;)</code>，\n如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DatagramSocket socket = vertx.createDatagramSocket(<span class=\"hljs-keyword\">new</span> DatagramSocketOptions());\n\n<span class=\"hljs-comment\">// 一些代码</span>\n\n<span class=\"hljs-comment\">// 这将拒收从10.0.0.2发送的数据包</span>\nsocket.blockMulticastGroup(<span class=\"hljs-string\">\"230.0.0.1\"</span>, <span class=\"hljs-string\">\"10.0.0.2\"</span>, asyncResult -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"block succeeded? \"</span> + asyncResult.succeeded());\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_datagramsocket_properties\"><a class=\"anchor\" href=\"#_datagramsocket_properties\"></a>DatagramSocket 属性</h4>\n<div class=\"paragraph\">\n<p>当创建 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code> 时，您可以通过\n<code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html\">DatagramSocketOptions</a></code> 对象来设置多个属性以更改它的功能。这些（属性）如下：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setSendBufferSize-int-\">setSendBufferSize</a></code> 以字节为单位设置发送缓冲区的大小。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setReceiveBufferSize-int-\">setReceiveBufferSize</a></code> 设置TCP接收缓冲区大小\n（以字节为单位）。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setReuseAddress-boolean-\">setReuseAddress</a></code> 若为true，\n则TIME_WAIT状态中的地址在关闭后可重用。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setTrafficClass-int-\">setTrafficClass</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setBroadcast-boolean-\">setBroadcast</a></code> 设置或清除SO_BROADCAST套接字选项。\n设置此选项时，数据报（UDP）数据包可能会发送到本地接口的广播地址。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setMulticastNetworkInterface-java.lang.String-\">setMulticastNetworkInterface</a></code> 设置或清除IP_MULTICAST_LOOP套接字选项，\n设置此选项时，多播数据包也将在\n本地接口上接收。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setMulticastTimeToLive-int-\">setMulticastTimeToLive</a></code> 设置IP_MULTICAST_TTL套接字选项。\nTTL表示“活动时间”，单这种情况下，它指定允许数据包经过的IP跳数，特别是用于多播流量。\n转发数据包的每个路由器或网关会递减TTL，\n如果路由器将TTL递减为0，则不会再转发。</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_datagramsocket_local_address\"><a class=\"anchor\" href=\"#_datagramsocket_local_address\"></a>DatagramSocket本地地址</h4>\n<div class=\"paragraph\">\n<p>您可以通过调用 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html#localAddress--\">localAddress</a></code> 来查找套接字的本地地址（即UDP Socket这边的地址）。\n若您在调用 <code>listen(&#8230;&#8203;)</code> 之前已经绑定了 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code>\n，则它将返回一个InetSocketAddress，否则返回null。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_a_datagramsocket\"><a class=\"anchor\" href=\"#_closing_a_datagramsocket\"></a>关闭DatagramSocket</h4>\n<div class=\"paragraph\">\n<p>您可以通过调用 <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html#close-io.vertx.core.Handler-\">close</a></code> 方法来关闭Socket，它将关闭\nSocket并释放所有资源。</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_dns_client\"><a class=\"anchor\" href=\"#_dns_client\"></a>DNS 客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>通常情况下，您需要以异步方式来获取DNS信息。\n但不幸的是，Java 虚拟机本身附带的API是不可能的，\n因此Vert.x提供了它自己的完全异步解析DNS的API。</p>\n</div>\n<div class=\"paragraph\">\n<p>若要获取DnsClient实例，您可以通过Vertx实例来创建一个。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"10.0.0.1\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>创建DnsClient时亦可通过传入配置设定查询的过期时间。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-keyword\">new</span> DnsClientOptions()\n  .setPort(<span class=\"hljs-number\">53</span>)\n  .setHost(<span class=\"hljs-string\">\"10.0.0.1\"</span>)\n  .setQueryTimeout(<span class=\"hljs-number\">10000</span>)\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>创建DnsClient的时候，不指定参数或者不指定服务器地址的话，DnsClient则会使用服务器内部地址，\n来进行非阻塞的域名解析。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client1 = vertx.createDnsClient();\n\n<span class=\"hljs-comment\">// 指定超时时间</span>\nDnsClient client2 = vertx.createDnsClient(<span class=\"hljs-keyword\">new</span> DnsClientOptions().setQueryTimeout(<span class=\"hljs-number\">10000</span>));</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_lookup\"><a class=\"anchor\" href=\"#_lookup\"></a>lookup</h3>\n<div class=\"paragraph\">\n<p>尝试为一个指定名称元素获取A（ipv4）或 AAAA（ipv6）记录时，第一条被返回的（记录）将会被使用。\n它的操作方式和操作系统上使用 \"nslookup\" 类似。</p>\n</div>\n<div class=\"paragraph\">\n<p>要为 <code>vertx.io</code> 获取 A/AAAA 记录，您需要像下面那样做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.lookup(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(ar.result());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_lookup4\"><a class=\"anchor\" href=\"#_lookup4\"></a>lookup4</h3>\n<div class=\"paragraph\">\n<p>尝试查找给定名称的A（ipv4）记录。第一个返回的（记录）将会被使用，\n因此它的操作方式与操作系统上使用 \"nslookup\" 类似。</p>\n</div>\n<div class=\"paragraph\">\n<p>要查找 \"vertx.io\" 的A记录，您需要像下面那样做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.lookup4(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(ar.result());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_lookup6\"><a class=\"anchor\" href=\"#_lookup6\"></a>lookup6</h3>\n<div class=\"paragraph\">\n<p>尝试查找给定名称的 AAAA（ipv6）记录。第一个返回的（记录）将会被使用，\n因此它的操作方式与在操作系统上使用 \"nslookup\" 类似。</p>\n</div>\n<div class=\"paragraph\">\n<p>要查找 \"vertx.io\" 的 AAAA记录，您需要像下面那样做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.lookup6(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(ar.result());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolvea\"><a class=\"anchor\" href=\"#_resolvea\"></a>resolveA</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的所有A（ipv4）记录，\n这与在类unix操作系统上使用 \"dig\" 类似。</p>\n</div>\n<div class=\"paragraph\">\n<p>要查找 \"vertx.io\" 的所有A记录，您通常会执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolveA(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;String&gt; records = ar.result();\n    <span class=\"hljs-keyword\">for</span> (String record : records) {\n      System.out.println(record);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolveaaaa\"><a class=\"anchor\" href=\"#_resolveaaaa\"></a>resolveAAAA</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的所有AAAA（ipv6）记录，\n这与在类unix操作系统上使用 \"dig\" 类似。</p>\n</div>\n<div class=\"paragraph\">\n<p>要查找 \"vertx.io\" 的所有AAAA记录，您通常会执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolveAAAA(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;String&gt; records = ar.result();\n    <span class=\"hljs-keyword\">for</span> (String record : records) {\n      System.out.println(record);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolvecname\"><a class=\"anchor\" href=\"#_resolvecname\"></a>resolveCNAME</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的所有CNAME记录，\n这与在类unix操作系统上使用 \"dig\" 类似。</p>\n</div>\n<div class=\"paragraph\">\n<p>要查找 \"vertx.io\" 的所有CNAME记录，您通常会执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolveCNAME(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;String&gt; records = ar.result();\n    <span class=\"hljs-keyword\">for</span> (String record : records) {\n      System.out.println(record);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolvemx\"><a class=\"anchor\" href=\"#_resolvemx\"></a>resolveMX</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的所有MX记录，\nMX记录用于定义哪个邮件服务器去接受指定域的电子邮件。</p>\n</div>\n<div class=\"paragraph\">\n<p>要查找 \"vertx.io\" 的所有MX记录，您通常会执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolveMX(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;MxRecord&gt; records = ar.result();\n    <span class=\"hljs-keyword\">for</span> (MxRecord record: records) {\n      System.out.println(record);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意，列表将包含按照它们优先级排序的 <code><a href=\"../../apidocs/io/vertx/core/dns/MxRecord.html\">MxRecord</a></code>\n，这意味着列表中优先级低的MX记录会第一个优先出现在列表中。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/MxRecord.html\">MxRecord</a></code> 允许您通过下边提供的方法访问MX记录的优先级和名称：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">record.priority();\nrecord.name();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolvetxt\"><a class=\"anchor\" href=\"#_resolvetxt\"></a>resolveTXT</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的所有TXT记录，TXT记录通常用于定义域的额外信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>要解析 \"vertx.io\" 的所有TXT记录，您可以使用下边几行代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolveTXT(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;String&gt; records = ar.result();\n    <span class=\"hljs-keyword\">for</span> (String record: records) {\n      System.out.println(record);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolvens\"><a class=\"anchor\" href=\"#_resolvens\"></a>resolveNS</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的所有NS记录，NS记录指定一个DNS服务器，\n这个服务器管理指定域的DNS信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>要解析 \"vertx.io\" 的所有NS记录，您可以使用下边几行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolveNS(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;String&gt; records = ar.result();\n    <span class=\"hljs-keyword\">for</span> (String record: records) {\n      System.out.println(record);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolvesrv\"><a class=\"anchor\" href=\"#_resolvesrv\"></a>resolveSRV</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的所有SRV记录，SRV记录用于定义服务端口和主机名等额外信息。\n一些协议需要这些额外信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>要查找 \"vertx.io\" 的所有SRV记录，您通常会执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolveSRV(<span class=\"hljs-string\">\"vertx.io\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;SrvRecord&gt; records = ar.result();\n    <span class=\"hljs-keyword\">for</span> (SrvRecord record: records) {\n      System.out.println(record);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意，列表将包含按照它们优先级排序的 <code>SrvRecord</code>\n，这意味着优先级低的记录会第一个优先出现在列表中。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/SrvRecord.html\">SrvRecord</a></code> 允许您访问SRV记录本身中包含的所有信息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">record.priority();\nrecord.name();\nrecord.weight();\nrecord.port();\nrecord.protocol();\nrecord.service();\nrecord.target();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>详细信息请参阅API文档</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_resolveptr\"><a class=\"anchor\" href=\"#_resolveptr\"></a>resolvePTR</h3>\n<div class=\"paragraph\">\n<p>尝试解析给定名称的PTR记录，PTR记录将ip地址映射到名称。</p>\n</div>\n<div class=\"paragraph\">\n<p>要解析IP地址 10.0.0.1 的PTR记录，您将使用 \"1.0.0.10.in-addr.arpa\"¸的PTR概念。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.resolvePTR(<span class=\"hljs-string\">\"1.0.0.10.in-addr.arpa\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    String record = ar.result();\n    System.out.println(record);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_reverselookup\"><a class=\"anchor\" href=\"#_reverselookup\"></a>reverseLookup</h3>\n<div class=\"paragraph\">\n<p>尝试对ipaddress进行反向查找，这与解析PTR记录类似。\n但是允许您传递非有效PTR查询字符串的ip地址。</p>\n</div>\n<div class=\"paragraph\">\n<p>按照类似于下面这种方式来进行ip地址 10.0.0.1 的反向查找：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"9.9.9.9\"</span>);\nclient.reverseLookup(<span class=\"hljs-string\">\"10.0.0.1\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    String record = ar.result();\n    System.out.println(record);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_error_handling\"><a class=\"anchor\" href=\"#_error_handling\"></a>错误处理</h3>\n<div class=\"paragraph\">\n<p>如前边部分所述，DnsClient允许您传递一个Handler，\n查询完成后会向其传入一个 AsyncResult。在出现错误的情况下，\n通知中将包含一个 <code>DnsException</code> ，该异常会包含一个说明为何失败的 <code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html\">DnsResponseCode</a></code> 。\n此DnsResponseCode可帮助你更详细地检查原因。</p>\n</div>\n<div class=\"paragraph\">\n<p>DnsResponseCode的可能取值包含：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#NOERROR\">NOERROR</a></code> 没有找到待查询的记录</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#FORMERROR\">FORMERROR</a></code> 格式错误</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#SERVFAIL\">SERVFAIL</a></code> 服务器故障</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#NXDOMAIN\">NXDOMAIN</a></code> 名称错误</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#NOTIMPL\">NOTIMPL</a></code> DNS 服务器未实现</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#REFUSED\">REFUSED</a></code> DNS 服务器拒绝查询</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#YXDOMAIN\">YXDOMAIN</a></code> 域名不应该存在</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#YXRRSET\">YXRRSET</a></code> 资源记录不应该存在</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#NXRRSET\">NXRRSET</a></code> RRSET不存在</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#NOTZONE\">NOTZONE</a></code> 名称不在区域内</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#BADVERS\">BADVERS</a></code> 错误的版本扩展机制</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#BADSIG\">BADSIG</a></code> 非法签名</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#BADKEY\">BADKEY</a></code> 非法密钥</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/dns/DnsResponseCode.html#BADTIME\">BADTIME</a></code> 错误时间戳</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>所有这些错误都由DNS服务器本身“生成”。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以从 DnsException 中获取 DnsResponseCode，如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(<span class=\"hljs-number\">53</span>, <span class=\"hljs-string\">\"10.0.0.1\"</span>);\nclient.lookup(<span class=\"hljs-string\">\"nonexisting.vert.xio\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    String record = ar.result();\n    System.out.println(record);\n  } <span class=\"hljs-keyword\">else</span> {\n    Throwable cause = ar.cause();\n    <span class=\"hljs-keyword\">if</span> (cause <span class=\"hljs-keyword\">instanceof</span> DnsException) {\n      DnsException exception = (DnsException) cause;\n      DnsResponseCode code = exception.code();\n      <span class=\"hljs-comment\">// ...</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failed to resolve entry\"</span> + ar.cause());\n    }\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"streams\"><a class=\"anchor\" href=\"#streams\"></a>流</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在Vert.x中，有许多对象可以用于读取和写入。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Vert.x 中，写调用是立即返回的，而写操作的实际是在内部队列中排队写入。</p>\n</div>\n<div class=\"paragraph\">\n<p>不难看出，若写入对象的速度比实际写入底层数据资源速度快，\n那么写入队列就会无限增长，\n最终导致内存耗尽。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了解决这个问题，Vert.x API中的一些对象提供了简单的流程控制（ <em>回压 back-pressure</em> ）功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>任何可控制的 <em>写入</em> 流对象都实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 接口，\n相应的，任何可控制的 <em>读取</em> 流对象都实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 接口。</p>\n</div>\n<div class=\"paragraph\">\n<p>让我们举个例子，我们要从 <code>ReadStream</code> 中读取数据，然后将数据写入 <code>WriteStream</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个非常简单的例子是从 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 读取然后写回到同一个 <code>NetSocket</code>\n—— 因为 <code>NetSocket</code> 既实现了 <code>ReadStream</code> 也实现了 <code>WriteStream</code> 接口。\n请注意，这些操作适用于任何实现了 <code>ReadStream</code> 和 <code>WriteStream</code> 接口的对象，\n包括HTTP 请求、HTTP 响应、异步文件 I/O 和 WebSocket等。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个最简单的方法是直接获取已经读取的数据，并立即将其写入\n<code>NetSocket</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer(\n    <span class=\"hljs-keyword\">new</span> NetServerOptions().setPort(<span class=\"hljs-number\">1234</span>).setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n);\nserver.connectHandler(sock -&gt; {\n  sock.handler(buffer -&gt; {\n    <span class=\"hljs-comment\">// 直接把数据写回</span>\n    sock.write(buffer);\n  });\n}).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上面的例子有一个问题：如果从Socket读取数据的速度比写回Socket的速度快，\n那么它将在 <code>NetSocket</code> 的写队列中不断堆积，\n最终耗尽内存。这是有可能会发生的，例如，若Socket另一端的客户端读取速度不够快，\n无法快速地向连接的另一端回压。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于 <code>NetSocket</code> 实现了 <code>WriteStream</code> 接口，我们可以在写入之前检查 <code>WriteStream</code>\n是否已满：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer(\n    <span class=\"hljs-keyword\">new</span> NetServerOptions().setPort(<span class=\"hljs-number\">1234</span>).setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n);\nserver.connectHandler(sock -&gt; {\n  sock.handler(buffer -&gt; {\n    <span class=\"hljs-keyword\">if</span> (!sock.writeQueueFull()) {\n      sock.write(buffer);\n    }\n  });\n\n}).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个例子不会耗尽内存，但如果写入队列已满，我们最终会丢失数据。\n我们真正想要做的是在写入队列已满时暂停读取 <code>NetSocket</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer(\n    <span class=\"hljs-keyword\">new</span> NetServerOptions().setPort(<span class=\"hljs-number\">1234</span>).setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n);\nserver.connectHandler(sock -&gt; {\n  sock.handler(buffer -&gt; {\n    sock.write(buffer);\n    <span class=\"hljs-keyword\">if</span> (sock.writeQueueFull()) {\n      sock.pause();\n    }\n  });\n}).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们已经快达到我们的目标，但还没有完全实现。现在 <code>NetSocket</code> 在文件已满时会暂停，\n但是当写队列处理完成时，我们需要取消暂停：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer(\n    <span class=\"hljs-keyword\">new</span> NetServerOptions().setPort(<span class=\"hljs-number\">1234</span>).setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n);\nserver.connectHandler(sock -&gt; {\n  sock.handler(buffer -&gt; {\n    sock.write(buffer);\n    <span class=\"hljs-keyword\">if</span> (sock.writeQueueFull()) {\n      sock.pause();\n      sock.drainHandler(done -&gt; {\n        sock.resume();\n      });\n    }\n  });\n}).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>至此，我们的目标实现了。当写队列准备好接收更多的数据时，<code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#drainHandler-io.vertx.core.Handler-\">drainHandler</a></code>\n事件处理器将被调用，它会恢复 <code>NetSocket</code> 的状态，\n允许读取更多的数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>在编写Vert.x 应用程序时，这样做是很常见的，因此我们提供了一个名为\n<code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#pipeTo-io.vertx.core.streams.WriteStream-\">pipeTo</a></code> 的方法替你完成这些繁杂的工作。\n您只需要把 <code>WriteStream</code> 传给它并调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetServer server = vertx.createNetServer(\n  <span class=\"hljs-keyword\">new</span> NetServerOptions().setPort(<span class=\"hljs-number\">1234</span>).setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n);\nserver.connectHandler(sock -&gt; {\n  sock.pipeTo(sock);\n}).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以上和下面更详细的例子完全一样，额外加上stream对于失败和结束的处理：\n当pipe最终成功或失败时， <code>WriteStream</code> 就会停止。</p>\n</div>\n<div class=\"paragraph\">\n<p>当读写操作结束时会发起通知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.connectHandler(sock -&gt; {\n\n  <span class=\"hljs-comment\">// pipe和socket传输数据时，提供一个处理通知结果的handler</span>\n  sock.pipeTo(sock, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      System.out.println(<span class=\"hljs-string\">\"Pipe succeeded\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Pipe failed\"</span>);\n    }\n  });\n}).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当你处理异步目标时，你可以创建一个 <code><a href=\"../../apidocs/io/vertx/core/streams/Pipe.html\">Pipe</a></code> 对象，\n这个对象会暂停源流，并在源流通过pipe传输到目标时恢复源流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.connectHandler(sock -&gt; {\n\n  <span class=\"hljs-comment\">// 创建异步操作管道</span>\n  Pipe&lt;Buffer&gt; pipe = sock.pipe();\n\n  <span class=\"hljs-comment\">// 打开目标文件</span>\n  fs.open(<span class=\"hljs-string\">\"/path/to/file\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      AsyncFile file = ar.result();\n\n      <span class=\"hljs-comment\">// 用管道传输socket当中的信息到文件中，并最终关闭文件</span>\n      pipe.to(file);\n    } <span class=\"hljs-keyword\">else</span> {\n      sock.close();\n    }\n  });\n}).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>取消传输操作需要关闭pipe：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer()\n  .requestHandler(request -&gt; {\n\n    <span class=\"hljs-comment\">// 创建异步操作管道</span>\n    Pipe&lt;Buffer&gt; pipe = request.pipe();\n\n    <span class=\"hljs-comment\">// 打开目标文件</span>\n    fs.open(<span class=\"hljs-string\">\"/path/to/file\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n        AsyncFile file = ar.result();\n\n        <span class=\"hljs-comment\">// 用管道传输socket当中的信息到文件中，并最终关闭文件</span>\n        pipe.to(file);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 关闭管道，恢复请求，body当中的缓冲数据被丢弃</span>\n        pipe.close();\n\n        <span class=\"hljs-comment\">// 返回错误</span>\n        request.response().setStatusCode(<span class=\"hljs-number\">500</span>).end();\n      }\n    });\n  }).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当pipe关闭，steams的handler会被重置，<code>ReadStream</code> 恢复工作。</p>\n</div>\n<div class=\"paragraph\">\n<p>从上面可以看出，默认情况下，stream传输完毕之后，目标流都会停止。你可以\n用pipe对象控制这些行为：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/Pipe.html#endOnFailure-boolean-\">endOnFailure</a></code> 控制失败时的操作</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/Pipe.html#endOnSuccess-boolean-\">endOnSuccess</a></code> 控制stream结束时的操作</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/Pipe.html#endOnComplete-boolean-\">endOnComplete</a></code> 控制所有情况下的操作</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>下面是一个简单例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">src.pipe()\n  .endOnSuccess(<span class=\"hljs-keyword\">false</span>)\n  .to(dst, rs -&gt; {\n    <span class=\"hljs-comment\">// 追加文本并关闭关闭文件</span>\n    dst.end(Buffer.buffer(<span class=\"hljs-string\">\"done\"</span>));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>让我们更进一步，看看 <code>ReadStream</code> 和 <code>WriteStream</code> 的细节。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_readstream\"><a class=\"anchor\" href=\"#_readstream\"></a>ReadStream</h3>\n<div class=\"paragraph\">\n<p><code>ReadStream</code>（可读流） 接口的实现类包括： <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html\">HttpClientResponse</a></code>， <code><a href=\"../../apidocs/io/vertx/core/datagram/DatagramSocket.html\">DatagramSocket</a></code>，\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html\">HttpClientRequest</a></code>， <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerFileUpload.html\">HttpServerFileUpload</a></code>，\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code>， <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code>，\n<code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code>， <code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html\">WebSocket</a></code>， <code><a href=\"../../apidocs/io/vertx/core/TimeoutStream.html\">TimeoutStream</a></code>，\n<code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html\">AsyncFile</a></code>。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-\">handler</a></code>：\n设置一个处理器，它将从 <code>ReadStream</code> 读取对象</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#pause--\">pause</a></code>：\n暂停处理器，暂停时，处理器中将不会收到任何对象</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#fetch-long-\">fetch</a></code>：\n从stream中抓取指定数量的对象，任意对象抵达stream时，都会触发handler，\nfetch操作是累积的。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#resume--\">resume</a></code>：\n恢复处理器，若任何对象到达目的地则handler将被触发；等价于 <code>fetch(Long.MAX_VALUE)</code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#exceptionHandler-io.vertx.core.Handler-\">exceptionHandler</a></code>：\n若ReadStream发生异常，将被调用</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#endHandler-io.vertx.core.Handler-\">endHandler</a></code>：\n当流的数据读取完毕时将被调用。触发原因是读取到了 <code>EOF</code> ，可能分别来自如下：\n与 <code>ReadStream</code> 关联的文件、HTTP请求、或TCP Socket的连接被关闭</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>可读流有 <em>flowing</em> 和 <em>fetch</em> 两个模式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>最初 stream 是 &lt;i&gt;flowing&lt;/i&gt; 模式</p>\n</li>\n<li>\n<p>当 stream 处于 <em>flowing</em> 模式，stream中的元素被传输到handler</p>\n</li>\n<li>\n<p>当 stream 处于 <em>fetch</em> 模式，只会将指定数量的元素传输到handler</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#pause--\">pause</a></code>, <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#resume--\">resume</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#fetch-long-\">fetch</a></code>\n会改变ReadStream的模式</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>resume()</code> 设置ReadStream 为 <em>flowing</em> 模式</p>\n</li>\n<li>\n<p><code>pause()</code> 设置ReadStream 为 <em>fetch</em> 模式 并设置demand值为0</p>\n</li>\n<li>\n<p><code>fetch(long)</code> 请求指定数量的stream元素并将该数量加到目前的demand值当中</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writestream\"><a class=\"anchor\" href=\"#_writestream\"></a>WriteStream</h3>\n<div class=\"paragraph\">\n<p><code>WriteStream</code>（可写流）接口的实现类包括：<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientRequest.html\">HttpClientRequest</a></code>，<code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html\">HttpServerResponse</a></code>\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html\">WebSocket</a></code>，<code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html\">AsyncFile</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>函数：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-\">write</a></code>：\n往WriteStream写入一个对象，该方法将永远不会阻塞，\n内部是排队写入并且底层资源是异步写入。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#setWriteQueueMaxSize-int-\">setWriteQueueMaxSize</a></code>：\n设置写入队列容量—— <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#writeQueueFull--\">writeQueueFull</a></code> 在队列 <em>写满</em> 时返回 <code>true</code>。\n注意，当写队列已满时，调用写（操作）时 数据依然会被接收和排队。\n实际数量取决于流的实现，对于 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code> ，\nsize代表实际写入的字节数，而并非缓冲区的数量。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#writeQueueFull--\">writeQueueFull</a></code>：\n若写队列被认为已满，则返回 <code>true</code> 。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#exceptionHandler-io.vertx.core.Handler-\">exceptionHandler</a></code>：\n<code>WriteStream</code> 发生异常时调用。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#drainHandler-io.vertx.core.Handler-\">drainHandler</a></code>：\n判定 <code>WriteStream</code> 有剩余空间时调用。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_record_parser\"><a class=\"anchor\" href=\"#_record_parser\"></a>记录解析器（Record Parser）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>记录解析器（Record Parser）允许您轻松解析由字节序列分割的协议，或者固定长度的协议。\n它将输入缓冲区序列转换为按照配置重组后的缓冲区序列\n（固定大小或带分隔符的记录）。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，若您使用 <code>\\n</code> 分割的简单ASCII文本协议，并输入如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>buffer1:HELLO\\nHOW ARE Y\nbuffer2:OU?\\nI AM\nbuffer3: DOING OK\nbuffer4:\\n</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>记录解析器将生成下结果：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>buffer1:HELLO\nbuffer2:HOW ARE YOU?\nbuffer3:I AM DOING OK</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们来看看相关代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">final</span> RecordParser parser = RecordParser.newDelimited(<span class=\"hljs-string\">\"\\n\"</span>, h -&gt; {\n  System.out.println(h.toString());\n});\n\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"HELLO\\nHOW ARE Y\"</span>));\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"OU?\\nI AM\"</span>));\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"DOING OK\"</span>));\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"\\n\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们还可以生成固定长度的块，如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RecordParser.newFixed(<span class=\"hljs-number\">4</span>, h -&gt; {\n  System.out.println(h.toString());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有关更多详细信息，请查看 <code><a href=\"../../apidocs/io/vertx/core/parsetools/RecordParser.html\">RecordParser</a></code> 类。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_json_parser\"><a class=\"anchor\" href=\"#_json_parser\"></a>Json 解析器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>解析JSON结构很容易，但这要求你一次性提供完整的JSON，\n而对于非常大的JSON结构，则并不是特别适合使用JSON解析器来处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>非阻塞JSON解析器 则是一个事件驱动的解析器, 它可以处理体积非常大的JSON。\n它会将一系列输入的buffer转换为一系列的JSON解析器事件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonParser parser = JsonParser.newParser();\n\n<span class=\"hljs-comment\">// 设置不同事件的handler</span>\nparser.handler(event -&gt; {\n  <span class=\"hljs-keyword\">switch</span> (event.type()) {\n    <span class=\"hljs-keyword\">case</span> START_OBJECT:\n      <span class=\"hljs-comment\">// Json对象的开始</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> END_OBJECT:\n      <span class=\"hljs-comment\">// Json对象的结束</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> START_ARRAY:\n      <span class=\"hljs-comment\">// Json数组的开始</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> END_ARRAY:\n      <span class=\"hljs-comment\">// Json数组的结束</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> VALUE:\n      <span class=\"hljs-comment\">// 处理一个取值</span>\n      String field = event.fieldName();\n      <span class=\"hljs-keyword\">if</span> (field != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// 当前处于Json对象内</span>\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 当前处于Json数组内，或Json最顶层</span>\n        <span class=\"hljs-keyword\">if</span> (event.isString()) {\n\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// ...</span>\n        }\n      }\n      <span class=\"hljs-keyword\">break</span>;\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该解析器是非阻塞的，并且事件由输入的buffer来驱动触发。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonParser parser = JsonParser.newParser();\n\n<span class=\"hljs-comment\">// start array event</span>\n<span class=\"hljs-comment\">// start object event</span>\n<span class=\"hljs-comment\">// \"firstName\":\"Bob\" event</span>\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"[{\\\"firstName\\\":\\\"Bob\\\",\"</span>));\n\n<span class=\"hljs-comment\">// \"lastName\":\"Morane\" event</span>\n<span class=\"hljs-comment\">// end object event</span>\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"\\\"lastName\\\":\\\"Morane\\\"},\"</span>));\n\n<span class=\"hljs-comment\">// start object event</span>\n<span class=\"hljs-comment\">// \"firstName\":\"Luke\" event</span>\n<span class=\"hljs-comment\">// \"lastName\":\"Lucky\" event</span>\n<span class=\"hljs-comment\">// end object event</span>\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"{\\\"firstName\\\":\\\"Luke\\\",\\\"lastName\\\":\\\"Lucky\\\"}\"</span>));\n\n<span class=\"hljs-comment\">// end array event</span>\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"]\"</span>));\n\n<span class=\"hljs-comment\">// Always call end</span>\nparser.end();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>事件驱动的解析过程提供了更多的控制能力，同时带来了“需要处理细粒度事件”的缺点，有时候不太方便。\n当你需要的时候，JSON解析器允许你将JSON结构作为值处理。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonParser parser = JsonParser.newParser();\n\nparser.objectValueMode();\n\nparser.handler(event -&gt; {\n  <span class=\"hljs-keyword\">switch</span> (event.type()) {\n    <span class=\"hljs-keyword\">case</span> START_ARRAY:\n      <span class=\"hljs-comment\">// Start the array</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> END_ARRAY:\n      <span class=\"hljs-comment\">// End the array</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> VALUE:\n      <span class=\"hljs-comment\">// Handle each object</span>\n      <span class=\"hljs-keyword\">break</span>;\n  }\n});\n\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"[{\\\"firstName\\\":\\\"Bob\\\"},\\\"lastName\\\":\\\"Morane\\\"),...]\"</span>));\nparser.end();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>value-mode</code> 可以在解析过程中启用或停用，\n允许你在细粒度事件与JSON对象事件之间自由切换。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonParser parser = JsonParser.newParser();\n\nparser.handler(event -&gt; {\n  <span class=\"hljs-comment\">// Start the object</span>\n\n  <span class=\"hljs-keyword\">switch</span> (event.type()) {\n    <span class=\"hljs-keyword\">case</span> START_OBJECT:\n      <span class=\"hljs-comment\">// 设置为 value-mode，自此开始，解析器则不会触发start-object事件</span>\n      parser.objectValueMode();\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> VALUE:\n      <span class=\"hljs-comment\">// 处理每一个对象</span>\n      <span class=\"hljs-comment\">// 获得从对象中解析出来的字段</span>\n      String id = event.fieldName();\n      System.out.println(<span class=\"hljs-string\">\"User with id \"</span> + id + <span class=\"hljs-string\">\" : \"</span> + event.value());\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> END_OBJECT:\n      <span class=\"hljs-comment\">// 设置为 event mode，所以解析器重新触发 start/end 事件</span>\n      parser.objectEventMode();\n      <span class=\"hljs-keyword\">break</span>;\n  }\n});\n\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"{\\\"39877483847\\\":{\\\"firstName\\\":\\\"Bob\\\"},\\\"lastName\\\":\\\"Morane\\\"),...}\"</span>));\nparser.end();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你也可以对数组做同样的事情</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonParser parser = JsonParser.newParser();\n\nparser.handler(event -&gt; {\n  <span class=\"hljs-comment\">// Json对象的开始</span>\n\n  <span class=\"hljs-keyword\">switch</span> (event.type()) {\n    <span class=\"hljs-keyword\">case</span> START_OBJECT:\n      <span class=\"hljs-comment\">// 设置为value mode来处理每个元素，自此开始，解析器不会触发 start-array 事件</span>\n      parser.arrayValueMode();\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> VALUE:\n      <span class=\"hljs-comment\">// 处理每一个数组</span>\n      <span class=\"hljs-comment\">// 获取对象中的字段</span>\n      System.out.println(<span class=\"hljs-string\">\"Value : \"</span> + event.value());\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> END_OBJECT:\n      <span class=\"hljs-comment\">// 设置为 event mode，从而解析器会重新触发 start/end 事件</span>\n      parser.arrayEventMode();\n      <span class=\"hljs-keyword\">break</span>;\n  }\n});\n\nparser.handle(Buffer.buffer(<span class=\"hljs-string\">\"[0,1,2,3,4,...]\"</span>));\nparser.end();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你也可以解码为POJO。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">parser.handler(event -&gt; {\n  <span class=\"hljs-comment\">// 获取每个对象</span>\n  <span class=\"hljs-comment\">// 获取对象中的字段</span>\n  String id = event.fieldName();\n  User user = event.mapTo(User<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n  System.out.println(<span class=\"hljs-string\">\"User with id \"</span> + id + <span class=\"hljs-string\">\" : \"</span> + user.firstName + <span class=\"hljs-string\">\" \"</span> + user.lastName);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>解析器解析buffer失败之后，会抛出异常；也可以通过设置 <code>exception handler</code> 处理异常：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonParser parser = JsonParser.newParser();\n\nparser.exceptionHandler(err -&gt; {\n  <span class=\"hljs-comment\">// 捕捉所有的解析/解码异常</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>解析器也可以解析JSON流：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>连续的JSON流： <code>{\"temperature\":30}{\"temperature\":50}</code></p>\n</li>\n<li>\n<p>行分割的JSON流： <code>{\"an\":\"object\"}\\r\\n3\\r\\n\"a string\"\\r\\nnull</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>更多细节，详见 <code><a href=\"../../apidocs/io/vertx/core/parsetools/JsonParser.html\">JsonParser</a></code> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_thread_safety\"><a class=\"anchor\" href=\"#_thread_safety\"></a>线程安全</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>大多数Vert.x 对象可以从不同的线程安全地访问， <em>然而</em>\n在相同的上下文中访问它们时，性能才是最优的。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，若您部署了一个创建了 <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html\">NetServer</a></code> 的Verticle，该 <code>NetServer</code> 在处理器中提供了\n<code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 实例，\n则最好始终从该Verticle的Event Loop中访问Socket 实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>如您已经遵守了标准的Vert.x Verticle部署模型，并注意避免在 Verticle 之间分享对象，\n那这种情况您无需考虑。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"blocking_code\"><a class=\"anchor\" href=\"#blocking_code\"></a>运行阻塞式代码</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在一个完美的世界中，不存在战争和饥饿，所有的API都将使用异步方式编写，\n兔兔和小羊羔将会在阳光明媚的绿色草地上手牵手地跳舞。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>但是……真实世界并非如此（您最近看新闻了吧？）</strong></p>\n</div>\n<div class=\"paragraph\">\n<p>事实是很多库含有同步的API（如果不是多数的库的话，尤其JVM生态中的库），这些API中许多方法都是阻塞式的。\n一个很好的例子就是 JDBC API，它本质上是同步的，无论多么努力地去尝试，Vert.x\n都不能像魔法小精灵撒尘变法一样将它转换成异步API。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们不会将所有的内容重写成异步方式，所以我们为您提供一种在\nVert.x 应用中安全调用\"传统\"阻塞API的方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>如之前讨论，您不能在 Event Loop 中直接调用阻塞式操作，因为这样做会阻止 Event Loop\n执行其他有用的任务。那您该怎么做？</p>\n</div>\n<div class=\"paragraph\">\n<p>可以通过调用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\">executeBlocking</a></code>\n方法来指定阻塞式代码的执行以及阻塞式代码执行后处理结果的异步回调。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.executeBlocking(promise -&gt; {\n  <span class=\"hljs-comment\">// 调用阻塞的、需要消耗显著执行时间的API</span>\n  String result = someAPI.blockingMethod(<span class=\"hljs-string\">\"hello\"</span>);\n  promise.complete(result);\n}, res -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"The result is: \"</span> + res.result());\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n阻塞式代码应该仅仅在合理的时间内阻塞（例如不超过几秒钟）。\n长时间阻塞的操作或者轮询操作（例如一个线程以阻塞的方式不断的循环轮询事件）都应该避免。\n当一个阻塞的操作持续超过10秒，blocked thread checker将会在控制台上打印一条消息。\n长时间阻塞的操作应该由程序使用一个专用的线程管理，\n他需要能够使用event-bus 或 <code><a href=\"../../apidocs/io/vertx/core/Context.html#runOnContext-io.vertx.core.Handler-\">runOnContext</a></code> 与verticles交互\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，如果 <code>executeBlocking</code> 在同一个上下文环境中（如：同一个 Verticle 实例）被调用了多次，\n那么这些不同的 <code>executeBlocking</code> 代码块会 <em>顺序执行</em>（一个接一个）。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您不关心您调用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\">executeBlocking</a></code> 的顺序，\n可以将 <code>ordered</code> 参数的值设为 <code>false</code>。这样任何 <code>executeBlocking</code>\n都会在 Worker Pool 中并行执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>另外一种运行阻塞式代码的方式是使用 <a href=\"#worker_verticles\">worker verticle</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个 Worker Verticle 始终会使用 Worker Pool 中的某个线程来执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，阻塞式代码会在 Vert.x 的 Worker Pool 中执行，通过 <code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html#setWorkerPoolSize-int-\">setWorkerPoolSize</a></code> 配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以为不同的用途创建不同的池（pool）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WorkerExecutor executor = vertx.createSharedWorkerExecutor(<span class=\"hljs-string\">\"my-worker-pool\"</span>);\nexecutor.executeBlocking(promise -&gt; {\n  <span class=\"hljs-comment\">// 调用阻塞的、需要消耗显著执行时间的API</span>\n  String result = someAPI.blockingMethod(<span class=\"hljs-string\">\"hello\"</span>);\n  promise.complete(result);\n}, res -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"The result is: \"</span> + res.result());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Worker Executor 在不需要的时候必须被关闭：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">executor.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当使用同一个名字创建了许多 worker 时，它们将共享同一个 pool。\n当所有的 worker executor 调用了 <code>close</code> 方法被关闭过后，对应的 worker pool 会被销毁。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果 Worker Executor 在 Verticle 中创建，那么 Verticle 实例销毁的同时 Vert.x\n将会自动关闭这个 Worker Executor。</p>\n</div>\n<div class=\"paragraph\">\n<p>Worker Executor 可以在创建的时候配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">int</span> poolSize = <span class=\"hljs-number\">10</span>;\n\n<span class=\"hljs-comment\">// 2分钟</span>\n<span class=\"hljs-keyword\">long</span> maxExecuteTime = <span class=\"hljs-number\">2</span>;\nTimeUnit maxExecuteTimeUnit = TimeUnit.MINUTES;\n\nWorkerExecutor executor = vertx.createSharedWorkerExecutor(<span class=\"hljs-string\">\"my-worker-pool\"</span>, poolSize, maxExecuteTime, maxExecuteTimeUnit);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n这些配置信息在 worker pool 创建的时候设置。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_metrics_spi\"><a class=\"anchor\" href=\"#_metrics_spi\"></a>Metrics SPI</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下，Vert.x不会记录任何指标。相反，它提供了一个SPI，其他人可以将它的实现类添加到类路径中。\n指标SPI是一项高级特性，允许实现类可以从Vert.x捕获事件以收集指标。\n有关详细信息，请参阅\n<code><a href=\"../../apidocs/io/vertx/core/spi/metrics/VertxMetrics.html\">API 文档</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>若使用 <code><a href=\"../../apidocs/io/vertx/core/metrics/MetricsOptions.html#setFactory-io.vertx.core.spi.VertxMetricsFactory-\">setFactory</a></code> 嵌入了Vert.x实例，\n也可以用编程方式指定一个指标工厂。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_vertx_command_line\"><a class=\"anchor\" href=\"#_the_vertx_command_line\"></a>\"vertx\" 命令行</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>vertx</code> 命令用于在命令行中与 Vert.x 进行交互。主要用于运行 Vert.x Verticle。\n为此，您需要下载并安装Vert.x 发行版，并将安装位置的 <code>bin</code> 目录添加\n到 <code>PATH</code> 环境变量中，还要确保您的 <code>PATH</code> 上已配置了Java 8的JDK的路径。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<code>PATH</code> 中的JDK是用于支持Java代码的快速编译。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_run_verticles\"><a class=\"anchor\" href=\"#_run_verticles\"></a>运行 Verticles</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code>vertx run</code> 从命令行直接运行Vert.x 的 Verticle，以下是\n<code>run</code> <em>命令</em> 的几个示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js                                 (1)\nvertx run my-verticle.groovy                             (2)\nvertx run my-verticle.rb                                 (3)\n\nvertx run io.vertx.example.MyVerticle                    (4)\nvertx run io.vertx.example.MVerticle -cp my-verticle.jar (5)\n\nvertx run MyVerticle.java                                (6)</code></pre>\n</div>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>部署一个JavaScript的Verticle</p>\n</li>\n<li>\n<p>部署一个Groovy的Verticle</p>\n</li>\n<li>\n<p>部署一个Ruby的Verticle</p>\n</li>\n<li>\n<p>部署一个已经编译好的Java的Verticle，类的根路径是当前目录</p>\n</li>\n<li>\n<p>部署一个已经打包成jar的Verticle，这个jar需要在类路径中</p>\n</li>\n<li>\n<p>编译Java源代码并进行部署</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>正如您在Java中可看到的，该Verticle的名称可以是class文件的全限定类名，\n也可以指定Java 源文件，Vert.x会为你编译它。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以在Verticle的名称前添加其他语言名称作为前缀来进行部署。例如：\n若某个Verticle是Groovy编译的类，您可以使用语言前缀 <code>groovy:</code> ，让Vert.x 知道它是一个Groovy 类而不是Java 类。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run groovy:io.vertx.example.MyGroovyVerticle</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx run</code> 命令可以使用几个可选参数，它们是：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>-options &lt;options&gt;</code> - 提供Vert.x选项。\n<code>options</code> 是一个包含描述Vert.x选项的json文件的名称。该参数是可选的。</p>\n</li>\n<li>\n<p><code>-conf &lt;config&gt;</code> - 提供了Verticle的一些配置，\n<code>config</code> 是一个包含描述Verticle配置的JSON文件的名称。该参数是可选的。</p>\n</li>\n<li>\n<p><code>-cp &lt;path&gt;</code> - 搜索Verticle和它使用的其他任何资源的路径，\n默认为 <code>.</code>（当前目录）。若您的Verticle引用了其他脚本、类或其他资源\n（例如jar文件），请确保这些资源存在此路径上。该路径可以包含多个路径条目，\n由 <code>:</code> （冒号）或 <code>;</code> （分号）进行分割——这取决于操作系统。每个路径条目可以是包含脚本的目录的绝对路径或相对路径，\n也可以是jar或zip文件的绝对或相对文件名。\n一个示例路径可能是 <code>-cp classes:lib/otherscripts:jars/myjar.jar:jars/otherjar.jar</code> 。\n始终使用路径引用您的Verticle需要的任何资源，<strong>不要</strong> 将它们放在系统类路径上，\n因为这会导致部署的Verticle之间的隔离问题。</p>\n</li>\n<li>\n<p><code>-instances &lt;instances&gt;</code>  - 要实例化的Verticle实例的数目，每个Verticle实例都是严格单线程（运行）的，\n因此为了在可用的cpu核心上扩展您的应用程序，您可能需要部署多个实例。\n若省略，则部署单个实例。</p>\n</li>\n<li>\n<p><code>-worker</code> - 此选项可确定一个Verticle是否为Worker Verticle。</p>\n</li>\n<li>\n<p><code>-cluster</code> -  此选项确定Vert.x实例是否尝试与网络上的其他Vert.x实例形成集群，\n集群Vert.x实例允许Vert.x与其他节点构建一个分布式Event Bus。\n默认为false（非集群模式）。</p>\n</li>\n<li>\n<p><code>-cluster-port</code> - 若指定了 <code>cluster</code> 选项，\n则可以确定哪个端口将用于与其他Vert.x实例进行集群通信。默认为 <code>0</code> ——这意味着“ <em>选择一个空闲的随机端口</em> ”。\n您通常不需要指定此参数，除非您需要绑定特定端口。</p>\n</li>\n<li>\n<p><code>-cluster-host</code> - 若指定了 <code>cluster</code> 选项，则可以确定哪个主机地址将用于与其他Vert.x实例进行集群通信。\n若没有设置，集群的eventbus会尝试绑定到同一个host作为底层集群管理。\n作为最后的手段，\n将会在可用网路接口中选取其中一个。</p>\n</li>\n<li>\n<p><code>-cluster-public-port</code> - 若指定了 <code>cluster</code> 选项，则可以确定哪个端口将被公布用于与其他Vert.x实例进行集群通信。\n默认值是 <code>-1</code> ，表示与 <code>cluster-port</code> 保持一致。</p>\n</li>\n<li>\n<p><code>-cluster-public-host</code> - 若指定了 <code>cluster</code> 选项，则可以确定哪个主机地址将被公布用于与其他Vert.x实例进行集群通信。\n如果没有指定，则默认使用 <code>cluster-host</code> 的值</p>\n</li>\n<li>\n<p><code>-ha</code> - 若指定，该Verticle将部署为（支持）高可用性（HA）。\n有关详细信息，请参阅相关章节。</p>\n</li>\n<li>\n<p><code>-quorum</code> - 该参数需要和 <code>-ha</code> 一起使用，它指定集群中所有 <em>HA deploymentIDs</em>\n处于活动状态的最小节点数，默认为0。</p>\n</li>\n<li>\n<p><code>-hagroup</code> - 该参数需要和 <code>-ha</code> 一起使用，它指定此节点将加入的HA组。\n集群中可以有多个HA组，节点只会故障转移到同一组中的其他节点。默认为\n<code>__DEFAULT__</code>。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您还可以使用下边方式设置系统属性：<code>-Dkey=value</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面有更多的例子：</p>\n</div>\n<div class=\"paragraph\">\n<p>使用默认设置运行JavaScript的Verticle：server.js：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run server.js</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>运行指定类路径的预编译好的10个Java Verticle实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run com.acme.MyVerticle -cp \"classes:lib/myjar.jar\" -instances 10</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过 <em>源文件</em> 运行10个Java Verticle的实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run MyVerticle.java -instances 10</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>运行20个Ruby语言的Worker Verticle实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run order_worker.rb -instances 20 -worker</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在同一台计算机上运行两个JavaScript Verticle，\n并让它们彼此以及在网络上的其他任何服务器构建一个集群：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run handler.js -cluster\nvertx run sender.js -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>运行一个Ruby Verticle并传入一些配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my_verticle.rb -conf my_verticle.conf</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>其中 <code>my_verticle.conf</code> 也许会包含以下配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-json\" data-lang=\"json\">{\n<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"foo\"</span>,\n<span class=\"hljs-attr\">\"num_widgets\"</span>: <span class=\"hljs-number\">46</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该配置可通过Core API在Verticle内部可用。</p>\n</div>\n<div class=\"paragraph\">\n<p>当使用Vert.x的高可用功能时，您可能需要创建一个Vert.x的 <em>裸</em> 实例。\n此实例在启动时不会部署任何Verticle，但如果集群中的另一个节点消失，则会在此节点运行之前消失的实例。\n如需要创建一个 <em>裸</em> 实例，执行以下命令：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx bare</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>根据您的集群配置，您可能需要添加 <code>cluster-host</code> 和 <code>cluster-port</code> 参数。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_executing_a_vert_x_application_packaged_as_a_fat_jar\"><a class=\"anchor\" href=\"#_executing_a_vert_x_application_packaged_as_a_fat_jar\"></a>执行打包成 fat-jar 的Vert.x 应用</h3>\n<div class=\"paragraph\">\n<p><em>fat jar</em> 是一个嵌入了所有依赖的可执行的jar，这意味着您不必在执行jar的机器上预先安装Vert.x。\n它像任何可执行的Java jar一样可直接执行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-application-fat.jar</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于这点，Vert.x 没什么特别的，您可以使用任何Java应用程序。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以创建自己的主类并在 MANIFEST 中指定，但建议您将代码编写成Verticle，\n并使用Vert.x中的  <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 类 (<code>io.vertx.core.Launcher</code>) 作为您的主类。\n这也是使用命令行运行Vert.x时使用的主类，因此允许您指定命令行参数，\n如 <code>-instances</code> 以便更轻松地扩展应用程序。</p>\n</div>\n<div class=\"paragraph\">\n<p>要将您的Verticle全部部署在这个 <em>fat-jar</em> 中时，您必须将下边信息写入 <em>manifest</em> ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Main-Class</code> 设置为 <code>io.vertx.core.Launcher</code></p>\n</li>\n<li>\n<p><code>Main-Verticle</code> 指定要运行的Main Verticle（Java完全限定类名或脚本文件名）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您还可以提供您将传递给 <code>vertx run</code> 的常用命令行参数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar -cluster -conf myconf.json\njava -jar my-verticle-fat.jar -cluster -conf myconf.json -cp path/to/dir/conf/cluster_xml</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n请参阅官方 Vert.x Examples 仓库中的 Maven/Gradle 相应示例来了解如何将应用打包成fat-jar。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>通过 fat jar 运行应用时，默认会执行 <code>run</code> 命令。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_displaying_version_of_vert_x\"><a class=\"anchor\" href=\"#_displaying_version_of_vert_x\"></a>显示Vert.x的版本</h3>\n<div class=\"paragraph\">\n<p>若想显示Vert.x的版本，只需执行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx version</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_other_commands\"><a class=\"anchor\" href=\"#_other_commands\"></a>其他命令</h3>\n<div class=\"paragraph\">\n<p>除了 <code>run</code> 和 <code>version</code> 以外，<code>vertx</code> 命令行和 <code>Launcher</code> 还提供了其他 <em>命令</em> ：</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用下边命令创建一个 <code>bare</code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx bare\n# or\njava -jar my-verticle-fat.jar bare</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还可以在后台启动应用程序：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar start --vertx-id=my-app-name</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若 <code>my-app-name</code> 未设置，将生成一个随机的id，并在命令提示符中打印。您可以将 <code>run</code>\n选项传递给 <code>start</code> 命令：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar start —-vertx-id=my-app-name -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦在后台启动，可以使用 <code>stop</code> 命令停止它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar stop my-app-name</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还可以使用以下方式列出后台启动的Vert.x应用程序：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar list</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx</code> 工具也可以使用 <code>start</code> 、 <code>stop</code> 和 <code>list</code> 命令，<code>start</code> 命令支持以下几个选项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>vertx-id</code> ：应用程序ID，若未设置，则使用随机UUID</p>\n</li>\n<li>\n<p><code>java-opts</code> ：Java虚拟机选项，若未设置，则使用 <code>JAVA_OPTS</code> 环境变量</p>\n</li>\n<li>\n<p><code>redirect-output</code> ：重定向生成的进程输出和错误流到父进程流</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>若选项值包含空白，则需使用 <code>\"\"</code> （双引号）将选项值括起来。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于 <code>start</code> 命令产生一个新的进程，传递给JVM的java选项不会被传播，所以您 <strong>必须</strong>\n使用 <code>java-opts</code> 来配置JVM（<code>-X</code>， <code>-D</code>&#8230;&#8203;）。若您使用 <code>CLASSPATH</code> 环境变量，\n请确保路径下包含所有需要的jar（vertx-core、您的jar和所有依赖项）。</p>\n</div>\n<div class=\"paragraph\">\n<p>该命令集是可扩展的，请参考 <a href=\"#_extending_the_vert_x_launcher\">扩展 Vert.x 启动器</a> 章节。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_live_redeploy\"><a class=\"anchor\" href=\"#_live_redeploy\"></a>实时重部署</h3>\n<div class=\"paragraph\">\n<p>在开发时，可以方便在文件更改时实时重新部署应用程序。<code>vertx</code>\n命令行工具和更普遍的 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 类提供了这个功能。\n这里有些例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run MyVerticle.groovy --redeploy=\"**/*.groovy\" --launcher-class=io.vertx.core.Launcher\nvertx run MyVerticle.groovy --redeploy=\"**/*.groovy,**/*.rb\"  --launcher-class=io.vertx.core.Launcher\njava io.vertx.core.Launcher run org.acme.MyVerticle --redeploy=\"**/*.class\"  --launcher-class=io.vertx.core\n.Launcher -cp ...</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>重新部署的过程执行如下。首先，您的应用程序作为后台应用程序启动\n（使用 <code>start</code> 命令）。当发现文件更改时，该进程将停止并重新启动该应用。\n这样可避免泄露。</p>\n</div>\n<div class=\"paragraph\">\n<p>要启用实时重新部署，请将 <code>--redeploy</code> 选项传递给 <code>run</code> 命令。<code>--redeploy</code> 表示要\n<em>监视</em> 的文件集，这个集合可使用 Ant样式模式（使用 <code>**</code>，<code>*</code> 和 <code>?</code>），\n您也可以使用逗号（<code>,</code>）分隔它们来指定多个集合。文件路径都是相对于当前工作目录。</p>\n</div>\n<div class=\"paragraph\">\n<p>传递给 <code>run</code> 命令的参数最终会传递给应用程序，可使用 <code>--java-opts</code> 配置JVM虚拟机选项。\n例如，如果想传入一个 <code>conf</code> 参数或是系统属性，\n您可以使用 <code>--java-opts=\"-conf=my-conf.json -Dkey=value\"</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>--launcher-class</code> 选项确定应用程序的 <em>主类</em> 启动器。它通常是\n<code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> ，但您也可以使用您自己的 <em>主类</em> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>也可以在IDE中使用重部署功能：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Eclipse - 创建一个 <em>Run</em> 配置，使用 <code>io.vertx.core.Launcher</code> 类作为 <em>主类</em> 。在 <em>Program Arguments</em>\n区域（ <em>Arguments</em> 选项卡中），写入 <code>run your-verticle-fully-qualified-name --redeploy=<strong>/</strong>.java\n--launcher-class=io.vertx.core.Launcher</code> ，您还可以添加其他参数。随着 Eclipse\n在保存时增量编译您的文件，重部署工作会顺利进行。</p>\n</li>\n<li>\n<p>IntelliJ - 创建一个 <em>Run</em> 配置（<em>Application</em>）,将主类设置为 <code>io.vertx.core.Launcher</code>。在\n程序参数中写：<code>run your-verticle-fully-qualified-name --redeploy=<strong>/</strong>.class\n--launcher-class=io.vertx.core.Launcher</code> 。要触发重新部署，您需要显式 <em>构造</em>\n项目或模块（<em>Build</em> &#8594; <em>Make project</em>）。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>要调试应用程序，请将运行配置创建为远程应用程序，\n并使用 <code>--java-opts</code> 配置调试器。每次重新部署后，请勿忘记重新插入(re-plug)调试器，\n因为它每次都会创建一个新进程。</p>\n</div>\n<div class=\"paragraph\">\n<p>您还可以在重新部署周期中挂接（hook）构建过程：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar target/my-fat-jar.jar --redeploy=\"**/*.java\" --on-redeploy=\"mvn package\"\njava -jar build/libs/my-fat-jar.jar --redeploy=\"src/**/*.java\" --on-redeploy='./gradlew shadowJar'</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>\"on-redeploy\"选项指定在应用程序关闭后和重新启动之前调用的命令。\n因此，如果构建工具更新了某些运行时构件，则可以将其挂接。例如，您可以启动 <code>gulp</code>\n或 <code>grunt</code> 来更新您的资源。如果需要传递参数到你的应用程序中，不要忘记将\n<code>--java-opts</code> 添加到命令参数里：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar target/my-fat-jar.jar --redeploy=\"**/*.java\" --on-redeploy=\"mvn package\" --java-opts=\"-Dkey=val\"\njava -jar build/libs/my-fat-jar.jar --redeploy=\"src/**/*.java\" --on-redeploy='./gradlew shadowJar' --java-opts=\"-Dkey=val\"</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>重新部署功能还支持以下设置：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>redeploy-scan-period</code> ：文件系统检查周期（以毫秒为单位），默认为250ms</p>\n</li>\n<li>\n<p><code>redeploy-grace-period</code> ：在2次重新部署之间等待的时间（以毫秒为单位），默认为1000ms</p>\n</li>\n<li>\n<p><code>redeploy-termination-period</code> ：停止应用程序后等待的时间\n（在启动用户命令之前）。这个在Windows上非常有用，因为这个进程并没立即被杀死。\n时间以毫秒为单位，默认0ms</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cluster_managers\"><a class=\"anchor\" href=\"#_cluster_managers\"></a>集群管理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在 Vert.x 中，集群管理器可用于各种功能，包括：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>集群中 Vert.x 节点的发现和分组</p>\n</li>\n<li>\n<p>维护集群范围中的主题订阅者列表（所以我们可知道哪些节点对哪个Event Bus地址感兴趣）</p>\n</li>\n<li>\n<p>分布式Map的支持</p>\n</li>\n<li>\n<p>分布式锁</p>\n</li>\n<li>\n<p>分布式计数器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>集群管理器 <em>不</em> 处理Event Bus节点之间的传输，这由 Vert.x 直接通过TCP连接完成。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x发行版中使用的默认集群管理器是使用的  <a href=\"http://hazelcast.com\">Hazelcast</a> 集群管理器，\n但是它可以简单被替换成其他实现类，因为Vert.x集群管理器可插拔的。</p>\n</div>\n<div class=\"paragraph\">\n<p>集群管理器必须实现 <code><a href=\"../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html\">ClusterManager</a></code> 接口，\nVert.x在运行时使用Java的服务加载器\n<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html\">Service Loader</a>\n功能在类路径中查找 <code><a href=\"../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html\">ClusterManager</a></code> 的实例，从而定位集群管理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您在命令行中使用Vert.x并要使用集群，则应确保Vert.x安装路径的 <code>lib</code>\n目录包含您的集群管理器的jar包。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您在 Maven/Gradle 项目使用Vert.x，则只需将集群管理器jar作为依赖添加到你的项目中。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以以编程的方式在嵌入Vert.x 时使用\n<code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html#setClusterManager-io.vertx.core.spi.cluster.ClusterManager-\">setClusterManager</a></code> 指定集群管理器。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_logging\"><a class=\"anchor\" href=\"#_logging\"></a>日志记录</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x使用内置的日志API进行记录日志，并支持各种日志记录后端。</p>\n</div>\n<div class=\"paragraph\">\n<p>日志后端选择如下：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>后端由设置的 <code>vertx.logger-delegate-factory-class-name</code> 系统属性表示，或者是</p>\n</li>\n<li>\n<p>当在类路径下存在 <code>vertx-default-jul-logging.properties</code> 文件时，则使用JDK logging，或者是</p>\n</li>\n<li>\n<p>类路径中存在以下实现，按照以下优先顺序进行选择：</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>SLF4J</p>\n</li>\n<li>\n<p>Log4J</p>\n</li>\n<li>\n<p>Log4J2</p>\n</li>\n</ol>\n</div>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>除此之外，Vert.x默认使用JDK日志记录</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_with_the_system_property\"><a class=\"anchor\" href=\"#_configuring_with_the_system_property\"></a>通过系统属性配置</h3>\n<div class=\"paragraph\">\n<p>设置 系统属性 <code>vertx.logger-delegate-factory-class-name</code> 的值为：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>io.vertx.core.logging.SLF4JLogDelegateFactory</code>，则使用SLF4J，</p>\n</li>\n<li>\n<p><code>io.vertx.core.logging.Log4j2LogDelegateFactory</code>，则使用Log4J2，</p>\n</li>\n<li>\n<p><code>io.vertx.core.logging.JULLogDelegateFactory</code>，则使用JDK日志记录</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_configuration\"><a class=\"anchor\" href=\"#_automatic_configuration\"></a>自动配置</h3>\n<div class=\"paragraph\">\n<p>当没有设置系统属性 <code>vertx.logger-delegate-factory-class-name</code> 的值时，\nVert.x会尝试查找最合适的日志框架：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当类路径下有SLF4J实现类时，则使用SLF4J，例如 <code>LoggerFactory.getILoggerFactory()</code> 返回值不是 <code>NOPLoggerFactory</code> 实例，</p>\n</li>\n<li>\n<p>否则，当classpath有Log4j2实现类时，则使用Log4j2</p>\n</li>\n<li>\n<p>除此之外，使用JUL</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_jul_logging\"><a class=\"anchor\" href=\"#_configuring_jul_logging\"></a>配置JUL日志记录</h3>\n<div class=\"paragraph\">\n<p>JUL日志配置文件可以使用普通的JUL方式指定 —— 通过设置系统属性 <code>java.util.logging.config.file</code> 的值为您的配置文件。\n更多关于此部分以及JUL配置文件结构的内容，请参阅 <code>JUL</code> 日志记录的文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x还提供了一种更方便的方式指定配置文件，无需设置系统属性。\n您只需在您的类路径中提供名为 <code>vertx-default-jul-logging.properties</code> 的JUL配置文件（例如在您的fatjar中），Vert.x将使用该配置文件配置JUL。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"netty-logging\"><a class=\"anchor\" href=\"#netty-logging\"></a>Netty 日志记录</h3>\n<div class=\"paragraph\">\n<p>Netty并不依赖外部的日志配置（例如，系统属性）。\n相反，它基于Netty类可见的日志库实现日志记录配置：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>使用 <code>SLF4J</code> 库，如果它可见，</p>\n</li>\n<li>\n<p>否则使用 <code>Log4j</code> ，如果它可见，</p>\n</li>\n<li>\n<p>否则使用 <code>Log4j2</code> ，如果它可见，</p>\n</li>\n<li>\n<p>否则使用默认的 <code>java.util.logging</code></p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n你们锐利的眼光可能已经注意到Vert.x遵循相同的优先级顺序\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code>io.netty.util.internal.logging.InternalLoggerFactory</code> 可以直接强制设置日志实现类。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// 将日志实现强制设为 Log4j 2</span>\nInternalLoggerFactory.setDefaultFactory(Log4J2LoggerFactory.INSTANCE);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_troubleshooting\"><a class=\"anchor\" href=\"#_troubleshooting\"></a>故障排除</h3>\n<div class=\"sect3\">\n<h4 id=\"_slf4j_warning_at_startup\"><a class=\"anchor\" href=\"#_slf4j_warning_at_startup\"></a>SLF4J启动警告</h4>\n<div class=\"paragraph\">\n<p>若您在启动应用程序时看到以下信息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这意味着您的类路径中有 SLF4J-API 却没绑定到具体的实例类中。使用SLF4J记录的消息将会丢失。\n您应该添加具体的实现到你的类路径下。参考 <a href=\"https://www.slf4j.org/manual.html#swapping\" class=\"bare\">https://www.slf4j.org/manual.html#swapping</a> 选择具体实现并配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意，Netty会寻找SLF4-API的jar，并在默认情况下使用它。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_connection_reset_by_peer\"><a class=\"anchor\" href=\"#_connection_reset_by_peer\"></a>对等连接重置</h4>\n<div class=\"paragraph\">\n<p>若您的日志显示一堆：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>io.vertx.core.net.impl.ConnectionBase\nSEVERE: java.io.IOException: Connection reset by peer</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这意味着客户端正在重置HTTP连接，而不是关闭它。\n此消息还可能表示您没有读取完整的有效负荷（连接在读取完全之前被切断）。（译者注：通常情况下，这是正常的，无需担心，如果您打开浏览器，按快捷键不停地刷新页面，就能看到该SEVERE日志。）</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_host_name_resolution\"><a class=\"anchor\" href=\"#_host_name_resolution\"></a>主机名解析</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 使用自带的网络地址解析器来执行主机名解析的工作（将主机名解析为IP地址），\n而没有使用JVM内置的阻塞式解析器。</p>\n</div>\n<div class=\"paragraph\">\n<p>把主机名解析成IP地址的操作将会使用到：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>操作系统的 <em>hosts</em> 文件</p>\n</li>\n<li>\n<p>DNS查询服务器列表</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下它使用系统环境中设定的DNS服务器地址列表，\n如果无法获取该列表，则会使用谷歌的公用DNS服务器地址 <code>\"8.8.8.8\"</code> 以及 <code>\"8.8.4.4\"</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>也可以在创建 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 实例的时候配置DNS服务器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = Vertx.vertx(<span class=\"hljs-keyword\">new</span> VertxOptions().\n    setAddressResolverOptions(\n        <span class=\"hljs-keyword\">new</span> AddressResolverOptions().\n            addServer(<span class=\"hljs-string\">\"192.168.0.1\"</span>).\n            addServer(<span class=\"hljs-string\">\"192.168.0.2:40000\"</span>))\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>DNS服务器的默认端口为 <code>53</code> ，当服务器使用不同的端口时，\n可以使用半角冒号作为分隔符来指定端口，例如： <code>192.168.0.2:40000</code> 。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果某些场景之下必须要使用JVM内置的解析器，此时可以通过在启动时设置系统属性\n<em>-Dvertx.disableDnsResolver=true</em> 来激活JVM内置的解析器。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_failover\"><a class=\"anchor\" href=\"#_failover\"></a>故障转移</h3>\n<div class=\"paragraph\">\n<p>当一个服务器没有及时响应时，解析器会从列表中取出下一个服务器进行查询，\n该故障转移操作的次数限制可以通过 <code><a href=\"../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#setMaxQueries-int-\">setMaxQueries</a></code> 来设置（默认设置是 <code>4</code> 次）。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果解析器在 <code><a href=\"../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#getQueryTimeout--\">getQueryTimeout</a></code> 毫秒内未接收到正常响应，则认为DNS查询失败\n（默认值是 <code>5</code> 秒）</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_server_list_rotation\"><a class=\"anchor\" href=\"#_server_list_rotation\"></a>服务器列表轮询</h3>\n<div class=\"paragraph\">\n<p>默认情况下，解析器总是使用服务器列表中的第一个服务器，剩下的服务器用于故障转移。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以将 <code><a href=\"../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#setRotateServers-boolean-\">setRotateServers</a></code> 设置为 <code>true</code>，\n此时解析器将会使用 round-robin 风格的轮询操作，将查询的负担分摊到列表中的每一个服务器上，\n从而避免所有的查询负担都落在列表中的第一个服务器上。</p>\n</div>\n<div class=\"paragraph\">\n<p>此时故障转移机制仍然有效，当某个服务器没有及时响应时，解析器会使用列表中的下一个服务器。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_hosts_mapping\"><a class=\"anchor\" href=\"#_hosts_mapping\"></a>主机映射</h3>\n<div class=\"paragraph\">\n<p>操作系统自身的 <em>hosts</em> 文件用于查找主机名对应的IP地址。</p>\n</div>\n<div class=\"paragraph\">\n<p>除此之外也可以使用另外的 <em>hosts</em> 文件来代替操作系统自身的 <em>hosts</em> 文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = Vertx.vertx(<span class=\"hljs-keyword\">new</span> VertxOptions().\n    setAddressResolverOptions(\n        <span class=\"hljs-keyword\">new</span> AddressResolverOptions().\n            setHostsPath(<span class=\"hljs-string\">\"/path/to/hosts\"</span>))\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_search_domains\"><a class=\"anchor\" href=\"#_search_domains\"></a>DNS搜索域</h3>\n<div class=\"paragraph\">\n<p>默认情况下，解析器使用系统环境中设置的DNS搜索域。如果要使用显式指定的搜索域，\n可以使用以下方式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = Vertx.vertx(<span class=\"hljs-keyword\">new</span> VertxOptions().\n    setAddressResolverOptions(\n        <span class=\"hljs-keyword\">new</span> AddressResolverOptions().addSearchDomain(<span class=\"hljs-string\">\"foo.com\"</span>).addSearchDomain(<span class=\"hljs-string\">\"bar.com\"</span>))\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当使用搜索域列表时， “.” 符号数量的阈值一般为 <code>1</code> ，在Linux操作系统里该阈值由 <code>/etc/resolv.conf</code> 文件来指定，\n通过 <code><a href=\"../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#setNdots-int-\">setNdots</a></code> 可以人为指定该阈值的大小。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_high_availability_and_fail_over\"><a class=\"anchor\" href=\"#_high_availability_and_fail_over\"></a>高可用与故障转移</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 可以支持 verticle 运行于高可用（HA）模式。这种模式之下，\n如果一个 vert.x 实例所运行的 verticle 突然宕掉，该 verticle 将会被迁移到其他的 vert.x 实例中\n（该 vert.x 实例必须处于同一个集群之中）。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_failover\"><a class=\"anchor\" href=\"#_automatic_failover\"></a>自动故障转移</h3>\n<div class=\"paragraph\">\n<p>当运行 vert.x 时开启了高可用（<em>HA</em>）选项，此时如果某个 vert.x 实例中的某个 verticle 运行失败或者宕掉，\n该 verticle 将会被自动重新部署于集群中的另一个 vert.x 实例中。我们把这种机制称为 <em>verticle故障转移</em>。</p>\n</div>\n<div class=\"paragraph\">\n<p>只要在运行 vert.x 的命令行中追加 <code>-ha</code> 参数，就可以开启 <em>高可用</em> 模式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>要让高可用机制起作用，您需要在集群中开启至少2个 Vert.x 实例，\n现在假设您已经在集群中运行了一个 Vert.x 实例，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-other-verticle.js -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>此时如果运行 <code>my-verticle.js</code> 的 Vert.x 实例宕掉了（例如您可以使用 <code>kill -9</code> 命令强行杀掉这个进程来模拟此场景），\n运行 <code>my-other-verticle.js</code> 的 Vert.x 实例会自动地部署 <code>my-verticle.js</code> ，\n此时该 Vert.x 实例同时运行了这两个 verticle （my-other-verticle.js 和 my-verticle.js）。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果要使得这种迁移机制起作用，则必须保证第二个 vert.x 实例可以访问到该 verticle 对应的文件\n（在此场景中指的是 <code>my-verticle.js</code>）。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n请注意，通过正常方式退出的 Vert.x 实例不会触发故障转移操作\n（例如使用 <code>CTRL-C</code> 组合键或者 <code>kill -SIGINT</code> 命令）。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>您也可以启动若干个 Vert.x <em>裸</em> 实例————指的是它们在启动时没有加载任何 verticle，此时，\n它们一样可以对集群中的其他节点起到故障转移的作用。启动一个空白的 Vert.x 实例很简单，只需要执行以下命令：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当使用 <code>-ha</code> 参数时， 可以不需要再追加 <code>-cluster</code> 参数，\n因为高可用模式是假定了您需要运行在集群模式之下的。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n依据您的集群配置选项，您可能还是需要自定义集群管理器\n（默认使用 Hazelcast），以及追加集群主机（<code>cluster-host</code>）和集群端口（<code>cluster-port</code>）等参数。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_ha_groups\"><a class=\"anchor\" href=\"#_ha_groups\"></a>高可用组</h3>\n<div class=\"paragraph\">\n<p>当 Vert.x 实例运行于高可用模式时，您还可以对其进行高可用分组，这里称之为 <em>高可用组</em> 。\n此处的高可用组指的是一个集群之中的节点的一种逻辑分组，被分配了高可用组的节点只会对同一个高可用组之下的其他节点执行故障转移操作。\n如果没有指定高可用组，系统会自动将节点分配到默认的 <code>__DEFAULT__</code> 高可用组。</p>\n</div>\n<div class=\"paragraph\">\n<p>在运行 verticle 时可以使用 <code>-hagroup</code> 参数指定高可用分组，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha -hagroup my-group</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>举个例子：</p>\n</div>\n<div class=\"paragraph\">\n<p>在第一个终端里运行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha -hagroup g1</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在第二个终端里，我们以同一个高可用组运行另一个 verticle：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-other-verticle.js -ha -hagroup g1</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>最后，在第三个终端里，我们以不同的高可用组再运行一个其他的 verticle：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run yet-another-verticle.js -ha -hagroup g2</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果我们杀掉第一个终端里的实例，这里面的 verticle 将会通过故障转移机制迁移到第二个终端里的实例中，\n而不是第三个终端里的实例中，因为第三个终端里的实例被分配了不同的高可用组。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果杀掉第三个终端里的实例，则不会发生故障转移操作，\n因为此终端里的 vert.x 实例被分配了不同的高可用组。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_dealing_with_network_partitions_quora\"><a class=\"anchor\" href=\"#_dealing_with_network_partitions_quora\"></a>处理网络分区 - Quora</h3>\n<div class=\"paragraph\">\n<p>高可用实现也支持 <code>quora</code> （一种多数派机制）。在分布式系统中， Quorum 是指一种投票机制，在这种投票机制之下，\n某个分布式事务只有获得不少于指定投票数量的票数，才允许执行某个操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>启动 Vert.x 实例的时候，您可以将其设置成在进行高可用（HA）部署之前需要一个 <code>quorum</code> 。\n在这个语境之下， <code>quorum</code> 指的是集群中某个特定的分组内的节点数量的下限。\n典型的例如您将 <code>quorum</code> 的数值设置为 <code>1 + N/2</code> （现在以 Q 指代该数值，其中的 N 代表分组中的节点总数），\n那么如果集群中少于 <code>Q</code> 个节点的情况下，该高可用（HA）部署将被取消，待到节点数量达到这个 Q 数值的时候，会再次进行部署。\n这种机制可以防止出现网络分区（亦称 <em>脑裂</em>）。</p>\n</div>\n<div class=\"paragraph\">\n<p>关于 <code>quora</code> 的更多信息请参考 <a href=\"http://en.wikipedia.org/wiki/Quorum_(distributed_computing)\">这里</a> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>要在运行 vert.x 实例的时候启用 <code>quorum</code> ，您只需要在命令行中指定 <code>-quorum</code> 参数，例如</p>\n</div>\n<div class=\"paragraph\">\n<p>在第一个终端中执行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha -quorum 3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>此时 Vert.x 实例将会启动，但是并不会部署这个模块，因为现在只有1个节点，\n而不是3个。</p>\n</div>\n<div class=\"paragraph\">\n<p>在第二个终端中执行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-other-verticle.js -ha -quorum 3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>此时 Vert.x 实例将会启动，但是并不会部署这个模块，因为现在只有2个节点，\n而不是3个。</p>\n</div>\n<div class=\"paragraph\">\n<p>在第三个终端中，您可以启动另一个 vert.x 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run yet-another-verticle.js -ha -quorum 3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>哇！————我们有了3个节点，这正是 <code>quorum</code> 的数值。\n此时此刻这些模块将会被自动地部署到所有实例上。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果我们关闭或者强行杀死其中一个节点，那么这些模块将会被自动卸载，\n因为节点数量已经不满足 <code>quorum</code> 数值条件。</p>\n</div>\n<div class=\"paragraph\">\n<p>Quora 也可以和高可用分组联合使用，此时 quora\n仅在指定的分组中起作用。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_native_transports\"><a class=\"anchor\" href=\"#_native_transports\"></a>本地传输</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在BSD（OSX）和Linux操作系统中运行 Vert.x 的时候，如果条件允许，可以启用 <a href=\"http://netty.io/wiki/native-transports.html\">native transports</a> 这种特性：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = Vertx.vertx(<span class=\"hljs-keyword\">new</span> VertxOptions().\n  setPreferNativeTransport(<span class=\"hljs-keyword\">true</span>)\n);\n\n<span class=\"hljs-comment\">// 如果本地传输已启用，则返回 true</span>\n<span class=\"hljs-keyword\">boolean</span> usingNative = vertx.isNativeTransportEnabled();\nSystem.out.println(<span class=\"hljs-string\">\"Running with native: \"</span> + usingNative);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果倾向于启用本地传输而相关条件却不满足的时候（例如相关JAR包缺失），程序依然可以运行。\n如果您要求您的程序必须启用本地传输，您必须首先通过 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#isNativeTransportEnabled--\">isNativeTransportEnabled</a></code> 来确认是否启用了本地传输。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_native_linux_transport\"><a class=\"anchor\" href=\"#_native_linux_transport\"></a>Linux 下的本地传输</h3>\n<div class=\"paragraph\">\n<p>您需要在classpath中加入以下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.netty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>netty-transport-native-epoll<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>linux-x86_64<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n <span class=\"hljs-comment\">&lt;!--&lt;version&gt;Should align with netty version that Vert.x uses&lt;/version&gt;--&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Linux下的本地传输可以设置更多的网络选项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>SO_REUSEPORT</code></p>\n</li>\n<li>\n<p><code>TCP_QUICKACK</code></p>\n</li>\n<li>\n<p><code>TCP_CORK</code></p>\n</li>\n<li>\n<p><code>TCP_FASTOPEN</code></p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions()\n  .setTcpFastOpen(fastOpen)\n  .setTcpCork(cork)\n  .setTcpQuickAck(quickAck)\n  .setReusePort(reusePort)\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_native_bsd_transport\"><a class=\"anchor\" href=\"#_native_bsd_transport\"></a>BSD 下的本地传输</h3>\n<div class=\"paragraph\">\n<p>您需要在classpath中加入以下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.netty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>netty-transport-native-kqueue<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>osx-x86_64<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n <span class=\"hljs-comment\">&lt;!--&lt;version&gt;必须和 Vert.x 所使用的 netty 的版本一致&lt;/version&gt;--&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>MacOS 中，Sierra及以上的版本支持这种特性。</p>\n</div>\n<div class=\"paragraph\">\n<p>BSD 下的本地传输可以启用以下额外的网络选项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>SO_REUSEPORT</code></p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions().setReusePort(reusePort));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_domain_sockets\"><a class=\"anchor\" href=\"#_domain_sockets\"></a>域套接字</h3>\n<div class=\"paragraph\">\n<p>通过本地传输，网络服务可以使用域套接字：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createNetServer().connectHandler(so -&gt; {\n  <span class=\"hljs-comment\">// 处理请求</span>\n}).listen(SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>http服务示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.createHttpServer().requestHandler(req -&gt; {\n  <span class=\"hljs-comment\">// 处理请求</span>\n}).listen(SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 绑定到 socket</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    ar.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也适用于网络客户端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">NetClient netClient = vertx.createNetClient();\n\n<span class=\"hljs-comment\">// 仅在 Linux 和 BSD 中可以使用</span>\nSocketAddress addr = SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>);\n\n<span class=\"hljs-comment\">// 连接到服务器</span>\nnetClient.connect(addr, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 连接成功</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    ar.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>http客户端示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient httpClient = vertx.createHttpClient();\n\n<span class=\"hljs-comment\">// 仅在 Linux 和 BSD 中可以使用</span>\nSocketAddress addr = SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>);\n\n<span class=\"hljs-comment\">// 向服务器发送请求</span>\nhttpClient.request(<span class=\"hljs-keyword\">new</span> RequestOptions()\n  .setServer(addr)\n  .setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n  .setPort(<span class=\"hljs-number\">8080</span>)\n  .setURI(<span class=\"hljs-string\">\"/\"</span>))\n  .onSuccess(request -&gt; {\n    request.send().onComplete(response -&gt; {\n      <span class=\"hljs-comment\">// 处理响应信息</span>\n    });\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_security_notes\"><a class=\"anchor\" href=\"#_security_notes\"></a>安全提示</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 是一套工具集，而不是一种强迫人们使用指定方式行事的框架，对于开发者而言，\n这赋予了你们强大的力量，但也使得你们必须负起不小的责任。</p>\n</div>\n<div class=\"paragraph\">\n<p>与任何一种工具集一样，写出不安全的程序是难以避免的，所以您在开发程序时需要时刻小心，\n特别是这个程序是暴露于毫无保护的公共场合（例如互联网）的情况下。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_web_applications\"><a class=\"anchor\" href=\"#_web_applications\"></a>Web 应用</h3>\n<div class=\"paragraph\">\n<p>如果要编写一个 web 应用程序，这里强烈建议您使用 Vert.x-Web\n来实现资源服务和文件上传功能，而不是直接使用 Vert.x core 。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web 会对请求路径进行规整化，这可以阻止那些不怀好意的人利用精心构建的特殊URL，\n来访问web应用根目录之外的资源的企图。</p>\n</div>\n<div class=\"paragraph\">\n<p>在文件上传方面也是如此， Vert.x-Web 不会完全信赖客户所端提供的文件名，因为客户端有可能精心设置一个特殊的文件名，\n使得上传的文件被保存到磁盘上某个意料之外的位置上。 Vert.x-Web 可以保证上传的文件是被存放到磁盘上确切可知道位置的。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x core没有这样的检查，您需要自己实现。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_clustered_event_bus_traffic\"><a class=\"anchor\" href=\"#_clustered_event_bus_traffic\"></a>集群模式事件总线流量</h3>\n<div class=\"paragraph\">\n<p>在网络上使用集群模式的事件总线连接不同的 Vert.x 节点时，总线里的流量是未经加密的，\n因此，若您的 Vert.x 节点处于不可信任的网络之上，则应该避免使用这种方式向这样的 Vert.x 节点发送信息。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_standard_security_best_practices\"><a class=\"anchor\" href=\"#_standard_security_best_practices\"></a>安全方面的标准最佳实践</h3>\n<div class=\"paragraph\">\n<p>任何服务都可能存在潜在的漏洞，无论是使用 Vert.x 还是任何其他工具包来进行编写，\n因此始终应该遵循安全最佳实践，特别是当您的服务面向公众时。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您应该始终在DMZ（隔离区）中运行它们，并使用权限受限的用户账户，\n以确保服务被渗透以后只会遭受有限的破坏。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_vert_x_command_line_interface_api\"><a class=\"anchor\" href=\"#_vert_x_command_line_interface_api\"></a>Vert.x 命令行界面（CLI）API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Core 提供了一套用于解析传递给程序的命令行参数的API。\n这套API也可以用于打印命令行相关参数、选项的详细帮助信息。\n即使这些功能远离Vert.x Core主题，该API已在 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 类中使用，\n因此您可以在 <em>fat-jar</em> 和 <code>vertx</code> 命令行工具中使用它们。\n此外，它支持多语言（可用于任何已支持的语言），并可在 Vert.x Shell 中使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x CLI 不但提供一个编程模型用以描述命令行界面，还提供一个语法解析器。\n这个语法解析器支持不同类型的语法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>POSIX 风格的选项参数 （例如： <code>tar -zxvf foo.tar.gz</code>）</p>\n</li>\n<li>\n<p>GNU 的长字符串风格的选项参数 （例如： <code>du --human-readable --max-depth=1</code>）</p>\n</li>\n<li>\n<p>Java 风格的属性参数 （例如： <code>java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo</code>）</p>\n</li>\n<li>\n<p>附带选项值的简短风格的选项参数 （例如： <code>gcc -O2 foo.c</code>）</p>\n</li>\n<li>\n<p>包含单个连接符的长字符串风格的选项参数 (例如： <code>ant -projecthelp</code>）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>使用这个命令行API只需要三个步骤：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>定义命令行接口</p>\n</li>\n<li>\n<p>解析用户输入的命令行</p>\n</li>\n<li>\n<p>进行查询/问答交互操作</p>\n</li>\n</ol>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_definition_stage\"><a class=\"anchor\" href=\"#_definition_stage\"></a>定义阶段</h3>\n<div class=\"paragraph\">\n<p>每个命令行界面都必须定义所要使用的选项和参数集合。这些选项和参数也需命名。\n命令行API使用 <code><a href=\"../../apidocs/io/vertx/core/cli/Option.html\">Option</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html\">Argument</a></code>\n类来描述选项和参数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"copy\"</span>)\n    .setSummary(<span class=\"hljs-string\">\"A command line interface to copy files.\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"directory\"</span>)\n        .setShortName(<span class=\"hljs-string\">\"R\"</span>)\n        .setDescription(<span class=\"hljs-string\">\"enables directory support\"</span>)\n        .setFlag(<span class=\"hljs-keyword\">true</span>))\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setIndex(<span class=\"hljs-number\">0</span>)\n        .setDescription(<span class=\"hljs-string\">\"The source\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"source\"</span>))\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setIndex(<span class=\"hljs-number\">1</span>)\n        .setDescription(<span class=\"hljs-string\">\"The destination\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"target\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>正如您所见到的一样，您可以通过 <code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html#create-java.lang.String-\">CLI.create</a></code> 方法来创建一个新的\n<code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html\">CLI</a></code> 。此处传入的字符串参数就是这个CLI的名称。\n创建之后，可以给它设置摘要和描述。一般来说，摘要是指一行简短的文字说明，\n描述是指篇幅较长的详细说明。每个选项和参数可以使用\n<code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html#addArgument-io.vertx.core.cli.Argument-\">addArgument</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html#addOption-io.vertx.core.cli.Option-\">addOption</a></code> 方法加入到 <code>CLI</code> 对象中。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_options\"><a class=\"anchor\" href=\"#_options\"></a>选项列表</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/cli/Option.html\">Option</a></code> 是指用户输入的命令行中出现的以 <em>键</em> 来标识的命令行参数。\n选项必须至少有一个长名称或一个短名称。通常情况下，长名称使用 <code>--</code> 前缀，\n短名称使用单个 <code>-</code> 前缀。这些名称都是大小写敏感的；但是，在 <a href=\"#query_interrogation_stage\">查询/问答交互阶段</a> 的环节中，\n如果输入的名称无法精确匹配，则会使用大小写不敏感的方式进行匹配。\n选项可以在用法说明的部分显示出相关的描述（见下文）。选项可以接收0个，1个或者若干个选项值。\n接收0个选项值的选项称作 <code>标识（flag）</code>，标识必须使用\n<code><a href=\"../../apidocs/io/vertx/core/cli/Option.html#setFlag-boolean-\">setFlag</a></code> 来声明。缺省情况下，选项接收单个选项值，但是您也可以使用\n<code><a href=\"../../apidocs/io/vertx/core/cli/Option.html#setMultiValued-boolean-\">setMultiValued</a></code> 将其设置成接收多个选项值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"some-name\"</span>)\n    .setSummary(<span class=\"hljs-string\">\"A command line interface illustrating the options valuation.\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"flag\"</span>).setShortName(<span class=\"hljs-string\">\"f\"</span>).setFlag(<span class=\"hljs-keyword\">true</span>).setDescription(<span class=\"hljs-string\">\"a flag\"</span>))\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"single\"</span>).setShortName(<span class=\"hljs-string\">\"s\"</span>).setDescription(<span class=\"hljs-string\">\"a single-valued option\"</span>))\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"multiple\"</span>).setShortName(<span class=\"hljs-string\">\"m\"</span>).setMultiValued(<span class=\"hljs-keyword\">true</span>)\n        .setDescription(<span class=\"hljs-string\">\"a multi-valued option\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>选项可以标记必填。用户如果没有输入必填选项，\n则会在命令行解析的过程中抛出异常：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"some-name\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"mandatory\"</span>)\n        .setRequired(<span class=\"hljs-keyword\">true</span>)\n        .setDescription(<span class=\"hljs-string\">\"a mandatory option\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>非必填选项可以拥有一个 <em>缺省值</em> ，在用户没有输入对应的选项值时，\n则会启用这个默认选项值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"some-name\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"optional\"</span>)\n        .setDefaultValue(<span class=\"hljs-string\">\"hello\"</span>)\n        .setDescription(<span class=\"hljs-string\">\"an optional option with a default value\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>选项也可以通过 <code><a href=\"../../apidocs/io/vertx/core/cli/Option.html#setHidden-boolean-\">setHidden</a></code> 方法设置成 <em>隐藏</em> 的。\n隐藏的选项不会在使用说明中显示出来，但是仍然可以起作用（提供给高级用户使用）。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果选项值是一组固定的集合，可以设置允许输入哪些内容：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"some-name\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"color\"</span>)\n        .setDefaultValue(<span class=\"hljs-string\">\"green\"</span>)\n        .addChoice(<span class=\"hljs-string\">\"blue\"</span>).addChoice(<span class=\"hljs-string\">\"red\"</span>).addChoice(<span class=\"hljs-string\">\"green\"</span>)\n        .setDescription(<span class=\"hljs-string\">\"a color\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>选项列表配置也可以通过其对应格式的 JSON 数据来创建。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_arguments\"><a class=\"anchor\" href=\"#_arguments\"></a>参数</h4>\n<div class=\"paragraph\">\n<p>和选项不一样，参数不以 <em>键</em> 进行标识而是以其 <em>索引</em> 作为标识。\n例如，在 <code>java com.acme.Foo</code> 里， <code>com.acme.Foo</code> 就是一个参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>参数没有名称，它们以从 <code>0</code> 开始计数的索引为标识。\n第一个参数的索引为 <code>0</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"some-name\"</span>)\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setIndex(<span class=\"hljs-number\">0</span>)\n        .setDescription(<span class=\"hljs-string\">\"the first argument\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"arg1\"</span>))\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setIndex(<span class=\"hljs-number\">1</span>)\n        .setDescription(<span class=\"hljs-string\">\"the second argument\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"arg2\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果不设置参数的索引，则基于声明顺序自动计算索引值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"some-name\"</span>)\n    <span class=\"hljs-comment\">// will have the index 0</span>\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setDescription(<span class=\"hljs-string\">\"the first argument\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"arg1\"</span>))\n    <span class=\"hljs-comment\">// will have the index 1</span>\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setDescription(<span class=\"hljs-string\">\"the second argument\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"arg2\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>argName</code> 是可选的，并且在说明信息中会使用这个字段。</p>\n</div>\n<div class=\"paragraph\">\n<p>和选项一样，<code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html\">Argument</a></code> 也可以：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html#setHidden-boolean-\">setHidden</a></code> 设置为隐藏的</p>\n</li>\n<li>\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html#setRequired-boolean-\">setRequired</a></code> 设置为必填的</p>\n</li>\n<li>\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html#setDefaultValue-java.lang.String-\">setDefaultValue</a></code> 设置默认参数值</p>\n</li>\n<li>\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html#setMultiValued-boolean-\">setMultiValued</a></code> 来接收多个参数值————只有最后一个参数才\n允许设置成接收多个参数值。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>参数也可以通过其对应格式的 JSON 数据来创建。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_usage_generation\"><a class=\"anchor\" href=\"#_usage_generation\"></a>生成使用说明信息</h4>\n<div class=\"paragraph\">\n<p>当 <code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html\">CLI</a></code> 实例配置完成之后，您可以用它来生成 <em>使用说明</em> 信息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"copy\"</span>)\n    .setSummary(<span class=\"hljs-string\">\"A command line interface to copy files.\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> Option()\n        .setLongName(<span class=\"hljs-string\">\"directory\"</span>)\n        .setShortName(<span class=\"hljs-string\">\"R\"</span>)\n        .setDescription(<span class=\"hljs-string\">\"enables directory support\"</span>)\n        .setFlag(<span class=\"hljs-keyword\">true</span>))\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setIndex(<span class=\"hljs-number\">0</span>)\n        .setDescription(<span class=\"hljs-string\">\"The source\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"source\"</span>))\n    .addArgument(<span class=\"hljs-keyword\">new</span> Argument()\n        .setIndex(<span class=\"hljs-number\">0</span>)\n        .setDescription(<span class=\"hljs-string\">\"The destination\"</span>)\n        .setArgName(<span class=\"hljs-string\">\"target\"</span>));\n\nStringBuilder builder = <span class=\"hljs-keyword\">new</span> StringBuilder();\ncli.usage(builder);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这可以生成诸如此类的使用说明信息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>Usage: copy [-R] source target\n\nA command line interface to copy files.\n\n -R,--directory   enables directory support</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果需要调整这个使用说明信息，请参考 <code><a href=\"../../apidocs/io/vertx/core/cli/UsageMessageFormatter.html\">UsageMessageFormatter</a></code> 类。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_parsing_stage\"><a class=\"anchor\" href=\"#_parsing_stage\"></a>解析阶段</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html\">CLI</a></code> 配置完成以后，您可以解析用户输入的命令行，\n并以此处理每个参数和选项：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CommandLine commandLine = cli.parse(userCommandLineArguments);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html#parse-java.util.List-\">parse</a></code> 方法返回一个包含了这些值的 <code><a href=\"../../apidocs/io/vertx/core/cli/CommandLine.html\">CommandLine</a></code> 对象。\n默认情况下，它会对用户输入的命令行进行检查校验，并确认哪些必填选项和必填参数有无缺失，\n以及每个选项值的数量是否符合要求。您可以将\n<code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html#parse-java.util.List-boolean-\">parse</a></code> 方法中的第二个参数传入 <code>false</code> 值来禁用这项校验功能。\n这可以用来检查某个参数或选项是否存在，无论命令行输入是否合规。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用\n<code><a href=\"../../apidocs/io/vertx/core/cli/CommandLine.html#isValid--\">isValid</a></code> 方法来检查 <code><a href=\"../../apidocs/io/vertx/core/cli/CommandLine.html\">CommandLine</a></code> 对象是否合规。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"query_interrogation_stage\"><a class=\"anchor\" href=\"#query_interrogation_stage\"></a>查询/问答交互阶段</h3>\n<div class=\"paragraph\">\n<p>命令行解析完成之后，您可以从\n<code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html#parse-java.util.List-\">parse</a></code> 方法返回的 <code><a href=\"../../apidocs/io/vertx/core/cli/CommandLine.html\">CommandLine</a></code>\n对象中获取到选项值和参数值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CommandLine commandLine = cli.parse(userCommandLineArguments);\nString opt = commandLine.getOptionValue(<span class=\"hljs-string\">\"my-option\"</span>);\n<span class=\"hljs-keyword\">boolean</span> flag = commandLine.isFlagEnabled(<span class=\"hljs-string\">\"my-flag\"</span>);\nString arg0 = commandLine.getArgumentValue(<span class=\"hljs-number\">0</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>其中一个选项可以标记为“帮助”。如果命令行启用了“帮助”选项，\n命令行的校验不会失败，而你有机会检查用户是否在寻求帮助：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"test\"</span>)\n    .addOption(\n        <span class=\"hljs-keyword\">new</span> Option().setLongName(<span class=\"hljs-string\">\"help\"</span>).setShortName(<span class=\"hljs-string\">\"h\"</span>).setFlag(<span class=\"hljs-keyword\">true</span>).setHelp(<span class=\"hljs-keyword\">true</span>))\n    .addOption(\n        <span class=\"hljs-keyword\">new</span> Option().setLongName(<span class=\"hljs-string\">\"mandatory\"</span>).setRequired(<span class=\"hljs-keyword\">true</span>));\n\nCommandLine line = cli.parse(Collections.singletonList(<span class=\"hljs-string\">\"-h\"</span>));\n\n<span class=\"hljs-comment\">// The parsing does not fail and let you do:</span>\n<span class=\"hljs-keyword\">if</span> (!line.isValid() &amp;&amp; line.isAskingForHelp()) {\n  StringBuilder builder = <span class=\"hljs-keyword\">new</span> StringBuilder();\n  cli.usage(builder);\n  stream.print(builder.toString());\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_typed_options_and_arguments\"><a class=\"anchor\" href=\"#_typed_options_and_arguments\"></a>类型化的选项和参数</h3>\n<div class=\"paragraph\">\n<p>上述的 <code><a href=\"../../apidocs/io/vertx/core/cli/Option.html\">Option</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html\">Argument</a></code> 类是 <em>无类型</em> 的，\n意味着只能从中获取到字符串类型的值。\n<code><a href=\"../../apidocs/io/vertx/core/cli/TypedOption.html\">TypedOption</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/cli/TypedArgument.html\">TypedArgument</a></code> 能让您对其赋予一个 <em>类型</em> ，\n这样（字符串类型的）原始值将被转换成对应的类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>在\n<code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html\">CLI</a></code> 对象的定义中使用 <code><a href=\"../../apidocs/io/vertx/core/cli/TypedOption.html\">TypedOption</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/cli/TypedArgument.html\">TypedArgument</a></code> 来取代\n <code><a href=\"../../apidocs/io/vertx/core/cli/Option.html\">Option</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/cli/Argument.html\">Argument</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"copy\"</span>)\n    .setSummary(<span class=\"hljs-string\">\"A command line interface to copy files.\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> TypedOption&lt;Boolean&gt;()\n        .setType(Boolean<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n        .<span class=\"hljs-title\">setLongName</span>(\"<span class=\"hljs-title\">directory</span>\")\n        .<span class=\"hljs-title\">setShortName</span>(\"<span class=\"hljs-title\">R</span>\")\n        .<span class=\"hljs-title\">setDescription</span>(\"<span class=\"hljs-title\">enables</span> <span class=\"hljs-title\">directory</span> <span class=\"hljs-title\">support</span>\")\n        .<span class=\"hljs-title\">setFlag</span>(<span class=\"hljs-title\">true</span>))\n    .<span class=\"hljs-title\">addArgument</span>(<span class=\"hljs-title\">new</span> <span class=\"hljs-title\">TypedArgument</span>&lt;<span class=\"hljs-title\">File</span>&gt;()\n        .<span class=\"hljs-title\">setType</span>(<span class=\"hljs-title\">File</span>.<span class=\"hljs-title\">class</span>)\n        .<span class=\"hljs-title\">setIndex</span>(0)\n        .<span class=\"hljs-title\">setDescription</span>(\"<span class=\"hljs-title\">The</span> <span class=\"hljs-title\">source</span>\")\n        .<span class=\"hljs-title\">setArgName</span>(\"<span class=\"hljs-title\">source</span>\"))\n    .<span class=\"hljs-title\">addArgument</span>(<span class=\"hljs-title\">new</span> <span class=\"hljs-title\">TypedArgument</span>&lt;<span class=\"hljs-title\">File</span>&gt;()\n        .<span class=\"hljs-title\">setType</span>(<span class=\"hljs-title\">File</span>.<span class=\"hljs-title\">class</span>)\n        .<span class=\"hljs-title\">setIndex</span>(0)\n        .<span class=\"hljs-title\">setDescription</span>(\"<span class=\"hljs-title\">The</span> <span class=\"hljs-title\">destination</span>\")\n        .<span class=\"hljs-title\">setArgName</span>(\"<span class=\"hljs-title\">target</span>\"))</span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这时您就可以通过如下方式获取转换后的值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CommandLine commandLine = cli.parse(userCommandLineArguments);\n<span class=\"hljs-keyword\">boolean</span> flag = commandLine.getOptionValue(<span class=\"hljs-string\">\"R\"</span>);\nFile source = commandLine.getArgumentValue(<span class=\"hljs-string\">\"source\"</span>);\nFile target = commandLine.getArgumentValue(<span class=\"hljs-string\">\"target\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x CLI 可以转换具有如下特征的类：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>拥有参数签名为一个 <code><a href=\"../../apidocs/java/lang/String.html\">String</a></code> 类型的构造函数，\n例如 <code><a href=\"../../apidocs/java/io/File.html\">File</a></code> 或者 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code></p>\n</li>\n<li>\n<p>拥有一个名为 <code>from</code> 或者 <code>fromString</code> 的静态方法</p>\n</li>\n<li>\n<p>拥有一个静态的 <code>valueOf</code> 方法，例如原始类型和枚举类型</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>此外您也可以实现自定义的 <code><a href=\"../../apidocs/io/vertx/core/cli/converters/Converter.html\">Converter</a></code>\n并在 <code>CLI</code> 对象使用它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(<span class=\"hljs-string\">\"some-name\"</span>)\n    .addOption(<span class=\"hljs-keyword\">new</span> TypedOption&lt;Person&gt;()\n        .setType(Person<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n        .<span class=\"hljs-title\">setConverter</span>(<span class=\"hljs-title\">new</span> <span class=\"hljs-title\">PersonConverter</span>())\n        .<span class=\"hljs-title\">setLongName</span>(\"<span class=\"hljs-title\">person</span>\"))</span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于布尔类型而言，这些值将被视为 <code>true</code> ：<code>on</code>， <code>yes</code>， <code>1</code>， <code>true</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您的命令行选项存在 <code>enum</code> 类型，则会自动计算出一组可选值。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_annotations\"><a class=\"anchor\" href=\"#_using_annotations\"></a>注解的使用</h3>\n<div class=\"paragraph\">\n<p>您也可以使用注解来定义CLI对象。可以通过在类和 <em>setter</em>\n方法上使用注解来完成定义：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Name</span>(<span class=\"hljs-string\">\"some-name\"</span>)\n<span class=\"hljs-meta\">@Summary</span>(<span class=\"hljs-string\">\"some short summary.\"</span>)\n<span class=\"hljs-meta\">@Description</span>(<span class=\"hljs-string\">\"some long description\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnnotatedCli</span> </span>{\n\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> flag;\n <span class=\"hljs-keyword\">private</span> String name;\n <span class=\"hljs-keyword\">private</span> String arg;\n\n<span class=\"hljs-meta\">@Option</span>(shortName = <span class=\"hljs-string\">\"f\"</span>, flag = <span class=\"hljs-keyword\">true</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setFlag</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> flag)</span> </span>{\n  <span class=\"hljs-keyword\">this</span>.flag = flag;\n}\n\n<span class=\"hljs-meta\">@Option</span>(longName = <span class=\"hljs-string\">\"name\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(String name)</span> </span>{\n  <span class=\"hljs-keyword\">this</span>.name = name;\n}\n\n<span class=\"hljs-meta\">@Argument</span>(index = <span class=\"hljs-number\">0</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setArg</span><span class=\"hljs-params\">(String arg)</span> </span>{\n <span class=\"hljs-keyword\">this</span>.arg = arg;\n}\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>加上注解之后，您就可以使用以下方法来定义 <code><a href=\"../../apidocs/io/vertx/core/cli/CLI.html\">CLI</a></code> 对象并将对应的值注入进去：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CLI cli = CLI.create(AnnotatedCli<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\nCommandLine commandLine = cli.parse(userCommandLineArguments);\nAnnotatedCli instance = <span class=\"hljs-keyword\">new</span> AnnotatedCli();\nCLIConfigurator.inject(commandLine, instance);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_vert_x_launcher\"><a class=\"anchor\" href=\"#_the_vert_x_launcher\"></a>Vert.x 启动器（Launcher）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 在 <em>fat-jar</em> 中作为主类，由 <code>vertx</code> 命令行程序调用。\n它可执行一组 <em>命令</em> ，如 <em>run</em> 、 <em>bare</em> 和 <em>start</em> 等</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_extending_the_vert_x_launcher\"><a class=\"anchor\" href=\"#_extending_the_vert_x_launcher\"></a>扩展 Vert.x 启动器（Launcher）</h3>\n<div class=\"paragraph\">\n<p>您可以通过实现自己的 <code><a href=\"../../apidocs/io/vertx/core/spi/launcher/Command.html\">Command</a></code> 类来扩展命令集（仅限于Java）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Name</span>(<span class=\"hljs-string\">\"my-command\"</span>)\n<span class=\"hljs-meta\">@Summary</span>(<span class=\"hljs-string\">\"A simple hello command.\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCommand</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">DefaultCommand</span> </span>{\n\n <span class=\"hljs-keyword\">private</span> String name;\n\n <span class=\"hljs-meta\">@Option</span>(longName = <span class=\"hljs-string\">\"name\"</span>, required = <span class=\"hljs-keyword\">true</span>)\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(String n)</span> </span>{\n   <span class=\"hljs-keyword\">this</span>.name = n;\n }\n\n <span class=\"hljs-meta\">@Override</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> CLIException </span>{\n   System.out.println(<span class=\"hljs-string\">\"Hello \"</span> + name);\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还需要实现一个 <code><a href=\"../../apidocs/io/vertx/core/spi/launcher/CommandFactory.html\">CommandFactory</a></code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloCommandFactory</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">DefaultCommandFactory</span>&lt;<span class=\"hljs-title\">HelloCommand</span>&gt; </span>{\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">HelloCommandFactory</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">super</span>(HelloCommand<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后创建 <code>src/main/resources/META-INF/services/io.vertx.core.spi.launcher.CommandFactory</code>\n并且添加一行表示工厂类的完全限定名称：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>io.vertx.core.launcher.example.HelloCommandFactory</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>构建包含命令的jar。确保包含了SPI文件\n(<code>META-INF/services/io.vertx.core.spi.launcher.CommandFactory</code>)。</p>\n</div>\n<div class=\"paragraph\">\n<p>然后，将包含该命令的jar放入fat-jar（或包含在其中）的类路径中，或放在Vert.x发行版的 <code>lib</code>\n目录中，您将可以执行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx hello vert.x\njava -jar my-fat-jar.jar hello vert.x</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_the_launcher_in_fat_jars\"><a class=\"anchor\" href=\"#_using_the_launcher_in_fat_jars\"></a>在 fat-jar 中使用启动器（Launcher）</h3>\n<div class=\"paragraph\">\n<p>要在 <em>fat-jar</em> 中使用 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 类，只需要将 <em>MANIFEST</em> 的 <code>Main-Class</code> 设置为\n<code>io.vertx.core.Launcher</code>。另外，将 <em>MANIFEST</em> 中 <code>Main-Verticle</code> 条目设置为您的Main Verticle的名称。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，它会执行 <code>run</code> 命令。但是，您可以通过设置 <em>MANIFEST</em> 的 <code>Main-Command</code> 条目来配置默认命令。\n若在没有命令的情况下启动 <em>fat-jar</em> 会使用默认命令。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sub_classing_the_launcher\"><a class=\"anchor\" href=\"#_sub_classing_the_launcher\"></a>启动器（Launcher）子类</h3>\n<div class=\"paragraph\">\n<p>您还可以创建 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 的子类来启动您的应用程序。\n这个类设计得易于扩展。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个启动器 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 的子类可以：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>在 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html#beforeStartingVertx-io.vertx.core.VertxOptions-\">beforeStartingVertx</a></code> 中自定义 Vert.x 配置</p>\n</li>\n<li>\n<p>通过重写 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html#afterStartingVertx-io.vertx.core.Vertx-\">afterStartingVertx</a></code>\n来检索由“run”或“bare”命令创建的Vert.x实例</p>\n</li>\n<li>\n<p>使用\n<code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getMainVerticle--\">getMainVerticle</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getDefaultCommand--\">getDefaultCommand</a></code> 方法配置默认的Verticle和命令</p>\n</li>\n<li>\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#register-java.lang.Class-\">register</a></code>\n和 <code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#unregister-java.lang.String-\">unregister</a></code> 方法添加/删除命令</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_launcher_and_exit_code\"><a class=\"anchor\" href=\"#_launcher_and_exit_code\"></a>启动器（Launcher）和退出代码</h3>\n<div class=\"paragraph\">\n<p>当您使用 <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> 类作为主类时，它的退出码有以下取值：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>0</code> :进程顺利结束，或抛出未捕获的错误；</p>\n</li>\n<li>\n<p><code>1</code> :用于通用错误；</p>\n</li>\n<li>\n<p><code>11</code>:Vert.x无法初始化；</p>\n</li>\n<li>\n<p><code>12</code>:生成的进程无法启动、发现或停止，该错误代码一般由 <code>start</code> 和\n<code>stop</code> 命令使用；</p>\n</li>\n<li>\n<p><code>14</code>:系统配置不符合系统要求（如找不到 <code>java</code> 命令）；</p>\n</li>\n<li>\n<p><code>15</code>:主Verticle不能被部署；</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_vert_x_cache\"><a class=\"anchor\" href=\"#_configuring_vert_x_cache\"></a>配置 Vert.x 缓存</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当 Vert.x 需要从类路径中读取文件（嵌入在 fat-jar 中，在classpath中jar文件或classpath中其他文件）时，\n它会把文件复制到缓存目录。背后原因很简单：\n从 jar 或从输入流读取文件是阻塞的。所以为了避免每次都付出损耗，\nVert.x 会将文件复制到其缓存目录中，并随后读取该文件。也可以配置此行为。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先，默认情况下，Vert.x 使用 <code>$CWD/.vertx</code> 作为缓存目录，它在此目录创建一个唯一的目录，\n以避免冲突。可以使用 <code>vertx.cacheDirBase</code> 系统属性配置该位置。\n如，若当前工作目录不可写（例如在不可变容器中），\n请使用以下命令启动应用程序：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my.Verticle -Dvertx.cacheDirBase=/tmp/vertx-cache\n# or\njava -jar my-fat.jar vertx.cacheDirBase=/tmp/vertx-cache</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n该目录必须是 <strong>可写的</strong> 。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>当您编辑资源（如HTML、CSS或JavaScript）时，这种缓存机制可能令人讨厌，因为它仅仅提供文件的第一个版本\n（因此，如果您想重新加载页面，不会显示到您的编辑改变）。要避免此情况，\n请使用 <code>-Dvertx.disableFileCaching=true</code> 启动应用程序。使用此设置，Vert.x 仍然使用缓存，\n但会始终读取原文件然后刷新在缓存中的版本。\n因此，如果您编辑从类路径提供的文件并刷新浏览器，Vert.x 会从类路径读取它，将其复制到缓存目录并从中提供。\n不要在生产环境使用这个设置，它很有可能影响性能。</p>\n</div>\n<div class=\"paragraph\">\n<p>最后，您可以使用 <code>-Dvertx.disableFileCPResolving=true</code> 完全禁用缓存。\n这个设置的副作用是：Vert.x将无法从类路径中读取任何文件（仅从文件系统中读取）。\n使用此设置时要非常小心。</p>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}