{"pageProps":{"categories":["releases","guides","news"],"post":{"meta":{"title":"An Introduction to the Vert.x Context Object","category":"guides","authors":[{"name":"Jez Prime","github_id":"millross"}],"summary":"Under the hood, the vert.x Context class plays a critical part in maintaining the thread-safety guarantees of verticles. Most of the time, vert.x coders don't need to make use of Context objects directly."},"date":"2017-01-31","slug":"an-introduction-to-the-vert-x-context-object","readingTime":{"text":"6 min read","minutes":5.915,"time":354900,"words":1183},"content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Under the hood, the vert.x Con\\xADtext class plays a crit\\xADi\\xADcal part in main\\xADtain\\xADing the thread-\\u200Bsafety guar\\xADan\\xADtees of ver\\xADti\\xADcles. Most of the time, vert.x coders don\\u2019t need to make use of Con\\xADtext ob\\xADjects di\\xADrectly. How\\xADever, some\\xADtimes you may need to. This ar\\xADti\\xADcle pro\\xADvides a brief in\\xADtro\\xADduc\\xADtion to the vert.x Con\\xADtext class, which cov\\xADers why it\\u2019s im\\xADpor\\xADtant, and why and when you might wish to make use of the Con\\xADtext di\\xADrectly, based on the au\\xADthor\\u2019s ex\\xADpe\\xADri\\xADence of build\\xADing a generic async li\\xADbrary which can be used with vert.x.\"), mdx(Alert, {\n    info: true,\n    mdxType: \"Alert\"\n  }, mdx(\"p\", null, \"This is a re-\\u200Bpublication of the fol\\xADlow\\xADing \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.millross-consultants.com/vertx_context_object.html\"\n  }), \"blog post\"))), mdx(\"h2\", {\n    \"id\": \"introduction\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#introduction\"\n  })), \"Introduction\"), mdx(\"p\", null, \"Re\\xADcently I\\u2019ve been look\\xADing at the pos\\xADsi\\xADbil\\xADity of build\\xADing an asyn\\xADchro\\xADnous ver\\xADsion of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.pac4j.org\"\n  }), \"pac4j\"), \" li\\xADbrary, with a view to then mi\\xADgrat\\xADing the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/pac4j/vertx-pac4j\"\n  }), \"vertx-\\u200Bpac4j\"), \" im\\xADple\\xADmen\\xADta\\xADtion to use the asyn\\xADchro\\xADnous ver\\xADsion of pac4j by de\\xADfault.\"), mdx(\"p\", null, \"I\\u2019m keen (for ob\\xADvi\\xADous rea\\xADsons) that the async ver\\xADsion of pac4j is not tightly cou\\xADpled to  one par\\xADtic\\xADu\\xADlar asyn\\xADchro\\xADnous/non-\\u200Bblocking frame\\xADwork, I de\\xADcided to ex\\xADpose the API via the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\"\n  }), \"Com\\xADpletable\\xADFu\\xADture\"), \" class, using this to wrap val\\xADues which will be de\\xADter\\xADmined in the fu\\xADture. How\\xADever, I opted to use the \", mdx(Link, {\n    href: \"/\",\n    passHref: true,\n    mdxType: \"Link\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }), \"vert.x\")), \" frame\\xADwork for my asyn\\xADchro\\xADnous test\\xADing as a way of test\\xADing the API as it emerged. This in turn has led me to learn some as\\xADpects of the vert.x \", mdx(Link, {\n    href: \"/docs/apidocs/io/vertx/core/Context.html\",\n    passHref: true,\n    mdxType: \"Link\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }), \"Con\\xADtext\")), \" class which I didn\\u2019t re\\xADally un\\xADder\\xADstand be\\xADfore.\"), mdx(Alert, {\n    info: true,\n    mdxType: \"Alert\"\n  }, mdx(\"p\", null, \"The in\\xADfor\\xADma\\xADtion pre\\xADsented re\\xADlates to Vert.x ver\\xADsion 3.3.3. It is con\\xADceiv\\xADable that later ver\\xADsions of vert.x could ren\\xADder as\\xADpects of this ar\\xADti\\xADcle in\\xADcor\\xADrect.\")), mdx(\"h2\", {\n    \"id\": \"introduction-to-the-context-class\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#introduction-to-the-context-class\"\n  })), \"Introduction to the Context class\"), mdx(\"p\", null, \"When\\xADever a vert.x \", mdx(Link, {\n    href: \"/docs/apidocs/io/vertx/core/Handler.html\",\n    passHref: true,\n    mdxType: \"Link\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }), \"Han\\xADdler\")), \" is ex\\xADe\\xADcuted, or the start or step method of a ver\\xADti\\xADcle is called, then that ex\\xADe\\xADcu\\xADtion is as\\xADso\\xADci\\xADated with a spe\\xADcific con\\xADtext. Gen\\xADer\\xADally a con\\xADtext is an event-\\u200Bloop con\\xADtext and is there\\xADfore as\\xADso\\xADci\\xADated with an event loop thread (ex\\xADcep\\xADtions are cov\\xADered in the Fur\\xADther Read\\xADing ref\\xADer\\xADenced below). Con\\xADtexts are prop\\xADa\\xADgated. When a han\\xADdler is set by code run\\xADning on a spe\\xADcific con\\xADtext, then that han\\xADdler will also be ex\\xADe\\xADcuted on the same con\\xADtext. This means for ex\\xADam\\xADple, that if the start method of a ver\\xADti\\xADcle in\\xADstance sets a num\\xADber of event bus han\\xADdlers (as many do), then they will all run on the same con\\xADtext as the start method for that ver\\xADti\\xADcle (so all han\\xADdlers for that ver\\xADti\\xADcle in\\xADstance will share a com\\xADmon con\\xADtext). \"), mdx(\"p\", null, \"A schematic of the re\\xADla\\xADtion\\xADships be\\xADtween non-\\u200Bworker ver\\xADti\\xADcles, con\\xADtexts and event\\xADloop threads is shown in Fig\\xADure 1. \"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"/images/blog/vertx3-intro-to-context-object/VertxContextRelationships.png\",\n    \"alt\": \"Vertx Context/Thread/Verticle Relationships\"\n  }))), mdx(\"p\", null, \"Note that each ver\\xADti\\xADcle ef\\xADfec\\xADtively has only one con\\xADtext for han\\xADdlers cre\\xADated by its start method, and each con\\xADtext is bound to a sin\\xADgle event-\\u200Bloop thread. A given event-\\u200Bloop thread can, how\\xADever, have mul\\xADti\\xADple con\\xADtexts bound to it. \"), mdx(\"h2\", {\n    \"id\": \"when-are-contexts-not-propagated\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#when-are-contexts-not-propagated\"\n  })), \"When are contexts not propagated?\"), mdx(\"p\", null, \"When a ver\\xADti\\xADcle\\u2019s start method is called, a new con\\xADtext is cre\\xADated. If 4 iden\\xADti\\xADcal ver\\xADti\\xADcles are de\\xADployed via the in\\xADstances pa\\xADra\\xADme\\xADter on De\\xADploy\\xADmen\\xADtOp\\xADtions, the start method of each will be on a new con\\xADtext. This is log\\xADi\\xADcal as we may not want all non-\\u200Bworker ver\\xADti\\xADcles to be bound to a sin\\xADgle event\\xADloop thread when mul\\xADti\\xADple event\\xADloop threads are avail\\xADable. \"), mdx(\"h2\", {\n    \"id\": \"threading-guarantees\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#threading-guarantees\"\n  })), \"Threading Guarantees\"), mdx(\"p\", null, \"There are cer\\xADtain con\\xADse\\xADquences of the prop\\xADa\\xADga\\xADtion of con\\xADtexts to han\\xADdlers as men\\xADtioned above. The most im\\xADpor\\xADtant one is that since all han\\xADdlers in a given event\\xADloop ver\\xADti\\xADcle run on the same con\\xADtext (the one on which its start method ran), they all run on the same event\\xADloop thread. This gives rise to the thread\\xADing guar\\xADan\\xADtee within vert.x, that as long as a given ver\\xADti\\xADcle is the only one to ever ac\\xADcess a piece of state, then that state is being ac\\xADcessed by only one thread, so no syn\\xADchro\\xADniza\\xADtion will be nec\\xADes\\xADsary. \"), mdx(\"h2\", {\n    \"id\": \"exception-handling\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#exception-handling\"\n  })), \"Exception Handling\"), mdx(\"p\", null, \"Each con\\xADtext can have its own ex\\xADcep\\xADtion han\\xADdler at\\xADtached for han\\xADdling ex\\xADcep\\xADtions which occur dur\\xADing event loop pro\\xADcess\\xADing.\"), mdx(\"h3\", {\n    \"id\": \"why-might-you-not-want-the-default-exception-handler\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#why-might-you-not-want-the-default-exception-handler\"\n  })), \"Why might you not want the default exception handler?\"), mdx(\"p\", null, \"As one ex\\xADam\\xADple, you might have some ver\\xADti\\xADcles run\\xADning whose job it is to mon\\xADi\\xADtor other ver\\xADti\\xADcles, and if some\\xADthing ap\\xADpears to go wrong with them, un\\xADde\\xADploy and restart them, a fre\\xADquent pat\\xADtern in an actor-\\u200B or microservices-\\u200B style archic\\xADtec\\xADture. So one op\\xADtion could be that when a su\\xADper\\xADvised ver\\xADti\\xADcle en\\xADcoun\\xADters an un\\xADre\\xADcov\\xADer\\xADable error, it could sim\\xADply no\\xADtify its su\\xADper\\xADvi\\xADsor that it has gone wrong via an event\\xADbus mes\\xADsage, and its su\\xADper\\xADvi\\xADsor could then un\\xADde\\xADploy and re\\xADde\\xADploy (and after a num\\xADber of fail\\xADures in rapid suc\\xADces\\xADsion pos\\xADsi\\xADbly give up hope or es\\xADca\\xADlate to its own su\\xADper\\xADvi\\xADsor.\"), mdx(\"h2\", {\n    \"id\": \"going-off-context-and-getting-back-onto-a-particular-context\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#going-off-context-and-getting-back-onto-a-particular-context\"\n  })), \"Going off-context and getting back onto a particular context\"), mdx(\"p\", null, \"There are sev\\xADeral rea\\xADsons why you might ex\\xADe\\xADcute code off-\\u200Bcontext and then want to op\\xADer\\xADate back on a vert.x con\\xADtext when com\\xADplete. I\\u2019ll out\\xADline a cou\\xADple of sce\\xADnar\\xADios below\"), mdx(\"h3\", {\n    \"id\": \"running-code-on-a-separate-thread\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#running-code-on-a-separate-thread\"\n  })), \"Running code on a separate thread\"), mdx(\"p\", null, \"Firstly you might be using an asyn\\xADchro\\xADnous dri\\xADver which is en\\xADtirely vertx-\\u200Bunaware. Its code will run on non-\\u200Beventloop threads but it\\u2019s pos\\xADsi\\xADble you may then want to use the re\\xADsults of that code to up\\xADdate in\\xADfor\\xADma\\xADtion within your ver\\xADti\\xADcle. If you don\\u2019t get back onto the cor\\xADrect con\\xADtext, you can\\u2019t make any guar\\xADan\\xADtees about thread-\\u200Bsafety, so your sub\\xADse\\xADquent pro\\xADcess\\xADing needs to be run back on the cor\\xADrect event\\xADloop thread.\"), mdx(\"h3\", {\n    \"id\": \"using-asynchronous-java-8-apis\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#using-asynchronous-java-8-apis\"\n  })), \"Using asynchronous Java 8 APIs\"), mdx(\"p\", null, \"APIs such as Com\\xADpletable\\xADFu\\xADture are context-\\u200Bunaware. In one ex\\xADam\\xADple, I cre\\xADated an al\\xADready com\\xADpleted fu\\xADture on the vert.x event loop in a test. I then at\\xADtached sub\\xADse\\xADquent pro\\xADcess\\xADing to it via then run:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-meta\"\n  }), \"@RunWith(VertxUnitRunner.class)\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"public\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-class\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"class\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"ImmediateCompletionTest\"), \" \"), \"{\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-meta\"\n  }), \"@Rule\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"public\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"final\"), \" RunTestOnContext rule = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" RunTestOnContext();\\n\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-meta\"\n  }), \"@Test\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"public\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"void\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"testImmediateCompletion\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"(TestContext context)\"), \" \"), \"{\\n\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"final\"), \" Async async = context.async();\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"final\"), \" Vertx vertx = rule.vertx();\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"final\"), \" CompletableFuture<Integer> toComplete = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" CompletableFuture<>();\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// delay future completion by 500 ms\"), \"\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"final\"), \" String threadName = Thread.currentThread().getName();\\n        toComplete.complete(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"100\"), \");\\n        toComplete.thenRun(() -> {\\n            assertThat(Thread.currentThread().getName(), is(threadName));\\n            async.complete();\\n        });\\n    }\\n}\\n\")), mdx(\"p\", null, \"Naively one might ex\\xADpect this to au\\xADto\\xADmat\\xADi\\xADcally run on the con\\xADtext, since it hasn\\u2019t left the event\\xADloop thread on which the fu\\xADture was com\\xADpleted, and in\\xADdeed it\\u2019s prov\\xADable that it is on the cor\\xADrect thread. How\\xADever, it will not be on the cor\\xADrect con\\xADtext. This would mean that it wouldn\\u2019t, for ex\\xADam\\xADple, in\\xADvoke any mod\\xADi\\xADfied ex\\xADcep\\xADtion han\\xADdler at\\xADtached to the con\\xADtext.\"), mdx(\"h3\", {\n    \"id\": \"getting-back-on-context\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#getting-back-on-context\"\n  })), \"Getting back on context\"), mdx(\"p\", null, \"For\\xADtu\\xADnately, once we\\u2019ve left the con\\xADtext, it\\u2019s quite straight\\xADfor\\xADward to re\\xADturn to it. Prior to de\\xADf\\xADi\\xADn\\xADi\\xADtion of the code block within then\\xADRun, we can use Vertx.cur\\xADrent\\xADCon\\xADtext() or vertx.getOr\\xADCre\\xADate\\xADCon\\xADtext() to get a han\\xADdle to the con\\xADtext on which our event\\xADloop code is run\\xADning, We can then ex\\xADe\\xADcute the code block in\\xADside a call to Con\\xADtext::runOn\\xADCon\\xADtext, sim\\xADi\\xADlar to\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"final\"), \" Context currentContext = vertx.getOrCreateContext();\\ntoComplete.thenRun(() -> {\\n        currentContext.runOnContext(v -> {\\n        assertThat(Thread.currentThread().getName(), is(threadName));\\n        async.complete();\\n    }\\n});\\n\")), mdx(\"p\", null, \"While get\\xADting back onto the cor\\xADrect con\\xADtext may not be crit\\xADi\\xADcal if you have re\\xADmained on the event loop thread through\\xADout, it is crit\\xADi\\xADcal if you are going to in\\xADvoke sub\\xADse\\xADquent vert.x han\\xADdlers, up\\xADdate ver\\xADti\\xADcle state or any\\xADthing sim\\xADi\\xADlar, so it\\u2019s a sen\\xADsi\\xADble gen\\xADeral ap\\xADproach.\"), mdx(\"h2\", {\n    \"id\": \"further-reading\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#further-reading\"\n  })), \"Further Reading\"), mdx(\"p\", null, \"The vert.x team them\\xADselves offer an ex\\xADcel\\xADlent blog about the Vert.x event\\xADloop, with ex\\xADcel\\xADlent ma\\xADte\\xADr\\xADial on the con\\xADtext, on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/vietj/vertx-materials/blob/master/src/main/asciidoc/Demystifying_the_event_loop.adoc\"\n  }), \"Github\"), \".\"), mdx(\"h2\", {\n    \"id\": \"thanks\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#thanks\"\n  })), \"Thanks\"), mdx(\"p\", null, \"Thanks very much to the vert.x core team for their clear github pages on the event\\xADloop, and also to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/alexlehm?lang=en\"\n  }), \"Alexan\\xADder Lehmann\"), \" for his an\\xADswers to my stu\\xADpid and naive ques\\xADtions on the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://groups.google.com/forum/#!forum/vertx\"\n  }), \"Vert.x google group\"), \".\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>Under the hood, the vert.x Con­text class plays a crit­i­cal part in main­tain­ing the thread-​safety guar­an­tees of ver­ti­cles. Most of the time, vert.x coders don’t need to make use of Con­text ob­jects di­rectly. How­ever, some­times you may need to. This ar­ti­cle pro­vides a brief in­tro­duc­tion to the vert.x Con­text class, which cov­ers why it’s im­por­tant, and why and when you might wish to make use of the Con­text di­rectly, based on the au­thor’s ex­pe­ri­ence of build­ing a generic async li­brary which can be used with vert.x.</p><div class=\"alert info\"><p>This is a re-​publication of the fol­low­ing <a href=\"http://www.millross-consultants.com/vertx_context_object.html\">blog post</a></p></div><h2 id=\"introduction\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#introduction\"></a>Introduction</h2><p>Re­cently I’ve been look­ing at the pos­si­bil­ity of build­ing an asyn­chro­nous ver­sion of the <a href=\"http://www.pac4j.org\">pac4j</a> li­brary, with a view to then mi­grat­ing the <a href=\"https://github.com/pac4j/vertx-pac4j\">vertx-​pac4j</a> im­ple­men­ta­tion to use the asyn­chro­nous ver­sion of pac4j by de­fault.</p><p>I’m keen (for ob­vi­ous rea­sons) that the async ver­sion of pac4j is not tightly cou­pled to  one par­tic­u­lar asyn­chro­nous/non-​blocking frame­work, I de­cided to ex­pose the API via the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\">Com­pletable­Fu­ture</a> class, using this to wrap val­ues which will be de­ter­mined in the fu­ture. How­ever, I opted to use the <a href=\"/\">vert.x</a> frame­work for my asyn­chro­nous test­ing as a way of test­ing the API as it emerged. This in turn has led me to learn some as­pects of the vert.x <a href=\"/docs/apidocs/io/vertx/core/Context.html\">Con­text</a> class which I didn’t re­ally un­der­stand be­fore.</p><div class=\"alert info\"><p>The in­for­ma­tion pre­sented re­lates to Vert.x ver­sion 3.3.3. It is con­ceiv­able that later ver­sions of vert.x could ren­der as­pects of this ar­ti­cle in­cor­rect.</p></div><h2 id=\"introduction-to-the-context-class\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#introduction-to-the-context-class\"></a>Introduction to the Context class</h2><p>When­ever a vert.x <a href=\"/docs/apidocs/io/vertx/core/Handler.html\">Han­dler</a> is ex­e­cuted, or the start or step method of a ver­ti­cle is called, then that ex­e­cu­tion is as­so­ci­ated with a spe­cific con­text. Gen­er­ally a con­text is an event-​loop con­text and is there­fore as­so­ci­ated with an event loop thread (ex­cep­tions are cov­ered in the Fur­ther Read­ing ref­er­enced below). Con­texts are prop­a­gated. When a han­dler is set by code run­ning on a spe­cific con­text, then that han­dler will also be ex­e­cuted on the same con­text. This means for ex­am­ple, that if the start method of a ver­ti­cle in­stance sets a num­ber of event bus han­dlers (as many do), then they will all run on the same con­text as the start method for that ver­ti­cle (so all han­dlers for that ver­ti­cle in­stance will share a com­mon con­text). </p><p>A schematic of the re­la­tion­ships be­tween non-​worker ver­ti­cles, con­texts and event­loop threads is shown in Fig­ure 1. </p><p><img src=\"/images/blog/vertx3-intro-to-context-object/VertxContextRelationships.png\" alt=\"Vertx Context/Thread/Verticle Relationships\"/></p><p>Note that each ver­ti­cle ef­fec­tively has only one con­text for han­dlers cre­ated by its start method, and each con­text is bound to a sin­gle event-​loop thread. A given event-​loop thread can, how­ever, have mul­ti­ple con­texts bound to it. </p><h2 id=\"when-are-contexts-not-propagated\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#when-are-contexts-not-propagated\"></a>When are contexts not propagated?</h2><p>When a ver­ti­cle’s start method is called, a new con­text is cre­ated. If 4 iden­ti­cal ver­ti­cles are de­ployed via the in­stances pa­ra­me­ter on De­ploy­men­tOp­tions, the start method of each will be on a new con­text. This is log­i­cal as we may not want all non-​worker ver­ti­cles to be bound to a sin­gle event­loop thread when mul­ti­ple event­loop threads are avail­able. </p><h2 id=\"threading-guarantees\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#threading-guarantees\"></a>Threading Guarantees</h2><p>There are cer­tain con­se­quences of the prop­a­ga­tion of con­texts to han­dlers as men­tioned above. The most im­por­tant one is that since all han­dlers in a given event­loop ver­ti­cle run on the same con­text (the one on which its start method ran), they all run on the same event­loop thread. This gives rise to the thread­ing guar­an­tee within vert.x, that as long as a given ver­ti­cle is the only one to ever ac­cess a piece of state, then that state is being ac­cessed by only one thread, so no syn­chro­niza­tion will be nec­es­sary. </p><h2 id=\"exception-handling\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#exception-handling\"></a>Exception Handling</h2><p>Each con­text can have its own ex­cep­tion han­dler at­tached for han­dling ex­cep­tions which occur dur­ing event loop pro­cess­ing.</p><h3 id=\"why-might-you-not-want-the-default-exception-handler\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#why-might-you-not-want-the-default-exception-handler\"></a>Why might you not want the default exception handler?</h3><p>As one ex­am­ple, you might have some ver­ti­cles run­ning whose job it is to mon­i­tor other ver­ti­cles, and if some­thing ap­pears to go wrong with them, un­de­ploy and restart them, a fre­quent pat­tern in an actor-​ or microservices-​ style archic­tec­ture. So one op­tion could be that when a su­per­vised ver­ti­cle en­coun­ters an un­re­cov­er­able error, it could sim­ply no­tify its su­per­vi­sor that it has gone wrong via an event­bus mes­sage, and its su­per­vi­sor could then un­de­ploy and re­de­ploy (and after a num­ber of fail­ures in rapid suc­ces­sion pos­si­bly give up hope or es­ca­late to its own su­per­vi­sor.</p><h2 id=\"going-off-context-and-getting-back-onto-a-particular-context\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#going-off-context-and-getting-back-onto-a-particular-context\"></a>Going off-context and getting back onto a particular context</h2><p>There are sev­eral rea­sons why you might ex­e­cute code off-​context and then want to op­er­ate back on a vert.x con­text when com­plete. I’ll out­line a cou­ple of sce­nar­ios below</p><h3 id=\"running-code-on-a-separate-thread\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#running-code-on-a-separate-thread\"></a>Running code on a separate thread</h3><p>Firstly you might be using an asyn­chro­nous dri­ver which is en­tirely vertx-​unaware. Its code will run on non-​eventloop threads but it’s pos­si­ble you may then want to use the re­sults of that code to up­date in­for­ma­tion within your ver­ti­cle. If you don’t get back onto the cor­rect con­text, you can’t make any guar­an­tees about thread-​safety, so your sub­se­quent pro­cess­ing needs to be run back on the cor­rect event­loop thread.</p><h3 id=\"using-asynchronous-java-8-apis\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#using-asynchronous-java-8-apis\"></a>Using asynchronous Java 8 APIs</h3><p>APIs such as Com­pletable­Fu­ture are context-​unaware. In one ex­am­ple, I cre­ated an al­ready com­pleted fu­ture on the vert.x event loop in a test. I then at­tached sub­se­quent pro­cess­ing to it via then run:</p><pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@RunWith(VertxUnitRunner.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ImmediateCompletionTest</span> </span>{\n    <span class=\"hljs-meta\">@Rule</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> RunTestOnContext rule = <span class=\"hljs-keyword\">new</span> RunTestOnContext();\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testImmediateCompletion</span><span class=\"hljs-params\">(TestContext context)</span> </span>{\n\n        <span class=\"hljs-keyword\">final</span> Async async = context.async();\n        <span class=\"hljs-keyword\">final</span> Vertx vertx = rule.vertx();\n        <span class=\"hljs-keyword\">final</span> CompletableFuture&lt;Integer&gt; toComplete = <span class=\"hljs-keyword\">new</span> CompletableFuture&lt;&gt;();\n        <span class=\"hljs-comment\">// delay future completion by 500 ms</span>\n        <span class=\"hljs-keyword\">final</span> String threadName = Thread.currentThread().getName();\n        toComplete.complete(<span class=\"hljs-number\">100</span>);\n        toComplete.thenRun(() -&gt; {\n            assertThat(Thread.currentThread().getName(), is(threadName));\n            async.complete();\n        });\n    }\n}\n</code></pre><p>Naively one might ex­pect this to au­to­mat­i­cally run on the con­text, since it hasn’t left the event­loop thread on which the fu­ture was com­pleted, and in­deed it’s prov­able that it is on the cor­rect thread. How­ever, it will not be on the cor­rect con­text. This would mean that it wouldn’t, for ex­am­ple, in­voke any mod­i­fied ex­cep­tion han­dler at­tached to the con­text.</p><h3 id=\"getting-back-on-context\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#getting-back-on-context\"></a>Getting back on context</h3><p>For­tu­nately, once we’ve left the con­text, it’s quite straight­for­ward to re­turn to it. Prior to de­f­i­n­i­tion of the code block within then­Run, we can use Vertx.cur­rent­Con­text() or vertx.getOr­Cre­ate­Con­text() to get a han­dle to the con­text on which our event­loop code is run­ning, We can then ex­e­cute the code block in­side a call to Con­text::runOn­Con­text, sim­i­lar to</p><pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">final</span> Context currentContext = vertx.getOrCreateContext();\ntoComplete.thenRun(() -&gt; {\n        currentContext.runOnContext(v -&gt; {\n        assertThat(Thread.currentThread().getName(), is(threadName));\n        async.complete();\n    }\n});\n</code></pre><p>While get­ting back onto the cor­rect con­text may not be crit­i­cal if you have re­mained on the event loop thread through­out, it is crit­i­cal if you are going to in­voke sub­se­quent vert.x han­dlers, up­date ver­ti­cle state or any­thing sim­i­lar, so it’s a sen­si­ble gen­eral ap­proach.</p><h2 id=\"further-reading\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#further-reading\"></a>Further Reading</h2><p>The vert.x team them­selves offer an ex­cel­lent blog about the Vert.x event­loop, with ex­cel­lent ma­te­r­ial on the con­text, on <a href=\"https://github.com/vietj/vertx-materials/blob/master/src/main/asciidoc/Demystifying_the_event_loop.adoc\">Github</a>.</p><h2 id=\"thanks\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#thanks\"></a>Thanks</h2><p>Thanks very much to the vert.x core team for their clear github pages on the event­loop, and also to <a href=\"https://twitter.com/alexlehm?lang=en\">Alexan­der Lehmann</a> for his an­swers to my stu­pid and naive ques­tions on the <a href=\"https://groups.google.com/forum/#!forum/vertx\">Vert.x google group</a>.</p>","scope":{}}},"prevPost":{"meta":{"title":"Vert.x 3.4.0.Beta1 release","category":"guides","authors":[{"name":"Julien Viet","github_id":"vietj"}],"summary":"We have released 3.4.0.Beta1, this release is the biggest since Vert.x 3.0.0 with plenty of great features."},"date":"2017-02-09","slug":"vert-x-3-4-0-beta1-release"},"nextPost":{"meta":{"title":"Building services and APIs with AMQP 1.0","category":"guides","authors":[{"name":"Jakub Scholz","github_id":"scholzj"}],"summary":"Microservices and APIs are everywhere. Everyone talks about them, presentation slides are full of them ... some people are actually even building them."},"date":"2017-01-25","slug":"building-services-and-apis-with-amqp-1-0"},"relatedPosts":[{"meta":{"title":"Some Rest with Vert.x","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"This post is part of the Introduction to Vert.x series. Let’s go a bit further this time and develop a CRUD-ish application"},"date":"2015-07-27","slug":"some-rest-with-vert-x"},{"meta":{"title":"My first Vert.x 3 Application","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"Let's say, you heard someone saying that Vert.x is awesome. Ok great, but you may want to try it by yourself. Well, the next natural question is “where do I start ?”"},"date":"2015-07-14","slug":"my-first-vert-x-3-application"},{"meta":{"title":"Real-time bidding with Websockets and Vert.x","category":"guides","authors":[{"name":"Marcin Warczyglowa","github_id":"mwarc"}],"summary":"The expectations of users for interactivity with web applications have changed over the past few years.\n    Users during bidding in auction no longer want to press the refresh button."},"date":"2016-01-15","slug":"real-time-bidding-with-websockets-and-vert-x"}]},"__N_SSG":true}