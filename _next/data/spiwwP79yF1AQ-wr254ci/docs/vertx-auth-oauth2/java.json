{"pageProps":{"slug":"vertx-auth-oauth2/java","title":"OAuth2 鉴权与授权提供程序","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_authorization_code_flow\">授权码模式 （Authorization Code Flow）</a></li>\n<li><a href=\"#_password_credentials_flow\">密码凭证模式 （Password Credentials Flow）</a></li>\n<li><a href=\"#_client_credentials_flow\">客户端凭证模式 (Client Credentials Flow)</a></li>\n<li><a href=\"#_jwt_on_behalf_of_flow\">JWT (代表/on behalf of) 模式</a></li>\n<li><a href=\"#_extensions\">拓展</a></li>\n<li><a href=\"#_getting_started\">由此开始</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_authorization_code_flow_2\">授权码模式</a></li>\n<li><a href=\"#_password_credentials_flow_2\">密码凭证模式</a></li>\n<li><a href=\"#_client_credentials_flow_2\">客户端凭证模式</a></li>\n</ul>\n</li>\n<li><a href=\"#_openid_connect_discovery\">OpenID Connect 发现(Discovery)</a></li>\n<li><a href=\"#_user_object\">用户对象(User object)</a></li>\n<li><a href=\"#_example_configuration_for_common_oauth2_providers\">通用 OAuth2 程序的配置示例</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_jboss_keycloak\">JBoss Keycloak</a></li>\n<li><a href=\"#_google_server_to_server\">Google Server to Server</a></li>\n</ul>\n</li>\n<li><a href=\"#_token_introspection\">令牌自检(Token Introspection)</a></li>\n<li><a href=\"#_verifying_jwt_tokens\">验证 JWT 令牌</a></li>\n<li><a href=\"#_role_based_access_control\">基于角色(role)的访问控制</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_keycloak_jwt\">Keycloak JWT</a></li>\n<li><a href=\"#_microprofile_jwt_1_1_spec\">MicroProfile JWT 1.1 规格说明</a></li>\n</ul>\n</li>\n<li><a href=\"#_token_management\">令牌管理(Token Management)</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_check_if_it_is_expired\">检查是否过期</a></li>\n<li><a href=\"#_refresh_token\">刷新令牌</a></li>\n<li><a href=\"#_revoke_token\">撤销令牌</a></li>\n<li><a href=\"#_introspect\">自检(Introspect)</a></li>\n<li><a href=\"#_logging_out\">注销(Logging out)</a></li>\n</ul>\n</li>\n<li><a href=\"#_key_management\">密匙管理(Key Management)</a></li>\n</ul>\n</div>","contents":"<h1>OAuth2 鉴权与授权提供程序</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x OAuth2 组件包括一个开箱即用的 OAuth2 (以及一定程度的 OpenID Connect) 依赖实现。\n如果需要使用本项目，请在您使用的依赖管理工具中添加相关配置：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-auth-oauth2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.7<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-auth-oauth2:4.2.7&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>OAuth2 允许用户 (user) 向第三方应用程序授予访问所需资源的权限，\n同时让用户可以在任何时候开启或者禁用这些访问。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x OAuth2 支持以下模式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>授权码模式 （Authorization Code Flow） ：用于那些可以存储持久化信息的服务端应用。</p>\n</li>\n<li>\n<p>密码凭证模式 （Password Credentials Flow） ：当之前的模式不可行或者项目已在开发过程中。</p>\n</li>\n<li>\n<p>客户端凭证模式 （Client Credentials Flow） ：客户端可以仅通过客户端凭证请求一个访问令牌（access token）。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>同样的代码可以用于 OpenID Connect <a href=\"https://openid.net/connect/\" class=\"bare\">https://openid.net/connect/</a> 服务器，\n并且支持 <a href=\"http://openid.net/specs/openid-connect-discovery-1_0.html\" class=\"bare\">http://openid.net/specs/openid-connect-discovery-1_0.html</a> 中的发现协议规范。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authorization_code_flow\"><a class=\"anchor\" href=\"#_authorization_code_flow\"></a>授权码模式 （Authorization Code Flow）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>此授权类型可以用于获取访问令牌和刷新访问令牌，并针对可信任的客户端做了优化。\n作为一个基于重定向（redirection）功能的授权模式， 客户端必须能够与资源所有者（resource\nowner）的用户代理（user-agent，通常是web浏览器）进行交互，\n并且能够接受来自授权服务器的传入请求（通过重定向）。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多细节请参照 <code><a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.1\"> OAuth2 specification, section 4.1</a></code>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_password_credentials_flow\"><a class=\"anchor\" href=\"#_password_credentials_flow\"></a>密码凭证模式 （Password Credentials Flow）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>此授权类型适用于资源所有者与客户端存在信任关系的场景，\n例如设备操作系统或者具备高权限的应用程序。\n授权服务器在启用这种授权类型必须十分谨慎，\n应当只有在其他模式不可行的情况下才允许使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>此授权类型适用于能够获得资源所有者凭证(用户名和密码，通常使用交互式表单)的客户端。\n它还可以通过将保存的凭证转为访问令牌，\n使用直接身份验证方案(如 <code>HTTP Basic/Digest</code> 身份验证)将现有客户端迁移到 OAuth。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多细节请参照 <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.3\">Oauth2 specification, section 4.3</a> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_client_credentials_flow\"><a class=\"anchor\" href=\"#_client_credentials_flow\"></a>客户端凭证模式 (Client Credentials Flow)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当客户端请求受控制的受保护资源或者授权服务器所认同的其他资源所有者时\n(这种方法不在该规范的范围内)，\n可以仅使用其客户端凭证\n(或其它被支持的认证方式)请求访问令牌，</p>\n</div>\n<div class=\"paragraph\">\n<p>此授权类型必须只用于那些可以充分信任的客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多细节请参照 <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.4\">Oauth2 specification, section 4.4</a> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_jwt_on_behalf_of_flow\"><a class=\"anchor\" href=\"#_jwt_on_behalf_of_flow\"></a>JWT (代表/on behalf of) 模式</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>客户端可以使用 JWTs 请求访问令牌。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_extensions\"><a class=\"anchor\" href=\"#_extensions\"></a>拓展</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x OAuth2 支持 RFC7523 扩展，允许服务器之间基于 JWT 进行授权。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>由此开始</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>下面是一个怎么使用 Vert.x OAuth2 和 GitHub 认证的示例实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> OAuth2Auth.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setClientId(<span class=\"hljs-string\">&quot;YOUR_CLIENT_ID&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;YOUR_CLIENT_SECRET&quot;</span>)\n  .setSite(<span class=\"hljs-string\">&quot;https://github.com/login&quot;</span>)\n  .setTokenPath(<span class=\"hljs-string\">&quot;/oauth/access_token&quot;</span>)\n  .setAuthorizationPath(<span class=\"hljs-string\">&quot;/oauth/authorize&quot;</span>)\n);\n\n<span class=\"hljs-comment\">// when there is a need to access a protected resource</span>\n<span class=\"hljs-comment\">// or call a protected method, call the authZ url for</span>\n<span class=\"hljs-comment\">// a challenge</span>\n\n<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">authorization_uri</span> <span class=\"hljs-operator\">=</span> oauth2.authorizeURL(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n  .put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:8080/callback&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;scope&quot;</span>, <span class=\"hljs-string\">&quot;notifications&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;state&quot;</span>, <span class=\"hljs-string\">&quot;3(#0/!~&quot;</span>));\n\n<span class=\"hljs-comment\">// when working with web application use the above string as a redirect url</span>\n\n<span class=\"hljs-comment\">// in this case GitHub will call you back in the callback uri one</span>\n<span class=\"hljs-comment\">// should now complete the handshake as:</span>\n\n<span class=\"hljs-comment\">// the code is provided as a url parameter by github callback call</span>\n<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">code</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;xxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;\n\noauth2.authenticate(\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n    .put(<span class=\"hljs-string\">&quot;code&quot;</span>, code)\n    .put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:8080/callback&quot;</span>))\n  .onSuccess(user -&gt; {\n    <span class=\"hljs-comment\">// save the token and continue...</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// error, the code provided is not valid</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_authorization_code_flow_2\"><a class=\"anchor\" href=\"#_authorization_code_flow_2\"></a>授权码模式</h3>\n<div class=\"paragraph\">\n<p>授权码模式分为两部分。首先您的应用程序向用户请求访问其数据的权限，\n如果用户批准 OAuth2 服务器则向客户端发送一个授权码。\n第二部分中，客户端将授权码和客户端机密(client secret)通过 POST\n方式发送到授权服务器以获取访问令牌。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Options</span> <span class=\"hljs-variable\">credentials</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setClientId(<span class=\"hljs-string\">&quot;&lt;client-id&gt;&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;&lt;client-secret&gt;&quot;</span>)\n  .setSite(<span class=\"hljs-string\">&quot;https://api.oauth.com&quot;</span>);\n\n\n<span class=\"hljs-comment\">// Initialize the OAuth2 Library</span>\n<span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> OAuth2Auth.create(vertx, credentials);\n\n<span class=\"hljs-comment\">// Authorization oauth2 URI</span>\n<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">authorization_uri</span> <span class=\"hljs-operator\">=</span> oauth2.authorizeURL(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n  .put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:8080/callback&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;scope&quot;</span>, <span class=\"hljs-string\">&quot;&lt;scope&gt;&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;state&quot;</span>, <span class=\"hljs-string\">&quot;&lt;state&gt;&quot;</span>));\n\n<span class=\"hljs-comment\">// Redirect example using Vert.x</span>\nresponse.putHeader(<span class=\"hljs-string\">&quot;Location&quot;</span>, authorization_uri)\n  .setStatusCode(<span class=\"hljs-number\">302</span>)\n  .end();\n\n<span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">tokenConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n  .put(<span class=\"hljs-string\">&quot;code&quot;</span>, <span class=\"hljs-string\">&quot;&lt;code&gt;&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:3000/callback&quot;</span>);\n\n<span class=\"hljs-comment\">// Callbacks</span>\n<span class=\"hljs-comment\">// Save the access token</span>\noauth2.authenticate(tokenConfig)\n  .onSuccess(user -&gt; {\n    <span class=\"hljs-comment\">// Get the access token object</span>\n    <span class=\"hljs-comment\">// (the authorization code is given from the previous step).</span>\n  })\n  .onFailure(err -&gt; {\n    System.err.println(<span class=\"hljs-string\">&quot;Access Token Error: &quot;</span> + err.getMessage());\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_password_credentials_flow_2\"><a class=\"anchor\" href=\"#_password_credentials_flow_2\"></a>密码凭证模式</h3>\n<div class=\"paragraph\">\n<p>此模式适用于资源所有者和客户端存在信任关系，\n例如设备操作系统和高权限的应用程序。\n应当只有在其他模式不可行或者需要尽快测试应用程序的时候才使用该模式。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> OAuth2Auth.create(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setFlow(OAuth2FlowType.PASSWORD));\n\n<span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">tokenConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n  .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;username&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;password&quot;</span>);\n\noauth2.authenticate(tokenConfig)\n  .onSuccess(user -&gt; {\n    <span class=\"hljs-comment\">// Get the access token object</span>\n    <span class=\"hljs-comment\">// (the authorization code is given from the previous step).</span>\n\n    <span class=\"hljs-comment\">// you can now make requests using the</span>\n    <span class=\"hljs-comment\">// `Authorization` header and the value:</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">httpAuthorizationHeader</span> <span class=\"hljs-operator\">=</span> user.principal()\n      .getString(<span class=\"hljs-string\">&quot;access_token&quot;</span>);\n\n  })\n  .onFailure(err -&gt; {\n    System.err.println(<span class=\"hljs-string\">&quot;Access Token Error: &quot;</span> + err.getMessage());\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_client_credentials_flow_2\"><a class=\"anchor\" href=\"#_client_credentials_flow_2\"></a>客户端凭证模式</h3>\n<div class=\"paragraph\">\n<p>当客户端访问受其控制的受保护资源时，此模式适用。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Options</span> <span class=\"hljs-variable\">credentials</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n  .setFlow(OAuth2FlowType.CLIENT)\n  .setClientId(<span class=\"hljs-string\">&quot;&lt;client-id&gt;&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;&lt;client-secret&gt;&quot;</span>)\n  .setSite(<span class=\"hljs-string\">&quot;https://api.oauth.com&quot;</span>);\n\n\n<span class=\"hljs-comment\">// Initialize the OAuth2 Library</span>\n<span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> OAuth2Auth.create(vertx, credentials);\n\n<span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">tokenConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>();\n\noauth2.authenticate(tokenConfig)\n  .onSuccess(user -&gt; {\n    <span class=\"hljs-comment\">// Success</span>\n  })\n  .onFailure(err -&gt; {\n    System.err.println(<span class=\"hljs-string\">&quot;Access Token Error: &quot;</span> + err.getMessage());\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_openid_connect_discovery\"><a class=\"anchor\" href=\"#_openid_connect_discovery\"></a>OpenID Connect 发现(Discovery)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x OAuth2 对 OpenID 发现服务器的支持有限。使用 OIDC Discovery 可以把您的 auth 模块的配置简化为一行代码，\n例如，可以考虑使用 Google 设置您的 auth :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OpenIDConnectAuth.discover(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setClientId(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n    .setClientSecret(<span class=\"hljs-string\">&quot;clientSecret&quot;</span>)\n    .setSite(<span class=\"hljs-string\">&quot;https://accounts.google.com&quot;</span>))\n  .onSuccess(oauth2 -&gt; {\n    <span class=\"hljs-comment\">// the setup call succeeded.</span>\n    <span class=\"hljs-comment\">// at this moment your auth is ready to use and</span>\n    <span class=\"hljs-comment\">// google signature keys are loaded so tokens can be decoded and verified.</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// the setup failed.</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这些代码逻辑背后执行了几个动作：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>HTTP 获取对 <code>well-known/openid-configuration</code> 资源的请求。</p>\n</li>\n<li>\n<p>按照规范对响应中 <code>issuer</code> 字段进行校验(issuer值必须与请求相匹配)。</p>\n</li>\n<li>\n<p>如果存在 JWK URL ，则从服务器加载密钥并添加到 auth 密钥链中。</p>\n</li>\n<li>\n<p>对 auth 模块进行配置并返回给用户。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>以下是几个知名的 OpenID Connect Discovery服务提供方:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Keycloak: <code><a href=\"http://keycloakhost:keycloakport/auth/realms/{realm}\" class=\"bare\">http://keycloakhost:keycloakport/auth/realms/{realm}</a></code></p>\n</li>\n<li>\n<p>Google: <code><a href=\"https://accounts.google.com\" class=\"bare\">https://accounts.google.com</a></code></p>\n</li>\n<li>\n<p>SalesForce: <code><a href=\"https://login.salesforce.com\" class=\"bare\">https://login.salesforce.com</a></code></p>\n</li>\n<li>\n<p>Microsoft: <code><a href=\"https://login.windows.net/common\" class=\"bare\">https://login.windows.net/common</a></code></p>\n</li>\n<li>\n<p>IBM Cloud: <code><a href=\"https://&lt;region-id&gt;.appid.cloud.ibm.com/oauth/v4/&lt;tenant-id&gt\" class=\"bare\">https://&lt;region-id&gt;.appid.cloud.ibm.com/oauth/v4/&lt;tenant-id&gt</a>;</code></p>\n</li>\n<li>\n<p>Amazon Cognito: <code><a href=\"https://cognito-idp.&lt;region&gt;.amazonaws.com/&lt;user-pool-id&gt\" class=\"bare\">https://cognito-idp.&lt;region&gt;.amazonaws.com/&lt;user-pool-id&gt</a>;</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这些再加上给定的 <code>client id/client secret</code> 足够配置您的auth程序对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于以上这些知名提供方，我们还提供了一些快捷方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">KeycloakAuth.discover(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setClientId(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n    .setClientSecret(<span class=\"hljs-string\">&quot;clientSecret&quot;</span>)\n    .setSite(<span class=\"hljs-string\">&quot;https://keycloakhost:keycloakport/auth/realms/{realm}&quot;</span>)\n    .setTenant(<span class=\"hljs-string\">&quot;your-realm&quot;</span>))\n  .onSuccess(oauth2 -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });\n\n<span class=\"hljs-comment\">// Google example</span>\nGoogleAuth.discover(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setClientId(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n    .setClientSecret(<span class=\"hljs-string\">&quot;clientSecret&quot;</span>))\n  .onSuccess(oauth2 -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });\n\n<span class=\"hljs-comment\">// Salesforce example</span>\nSalesforceAuth.discover(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setClientId(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n    .setClientSecret(<span class=\"hljs-string\">&quot;clientSecret&quot;</span>))\n  .onSuccess(oauth2 -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });\n\n<span class=\"hljs-comment\">// Azure AD example</span>\nAzureADAuth.discover(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setClientId(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n    .setClientSecret(<span class=\"hljs-string\">&quot;clientSecret&quot;</span>)\n    .setTenant(<span class=\"hljs-string\">&quot;your-app-guid&quot;</span>))\n  .onSuccess(oauth2 -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });\n\n<span class=\"hljs-comment\">// IBM Cloud example</span>\nIBMCloudAuth.discover(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setClientId(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n    .setClientSecret(<span class=\"hljs-string\">&quot;clientSecret&quot;</span>)\n    .setSite(<span class=\"hljs-string\">&quot;https://&lt;region-id&gt;.appid.cloud.ibm.com/oauth/v4/{tenant}&quot;</span>)\n    .setTenant(<span class=\"hljs-string\">&quot;your-tenant-id&quot;</span>))\n  .onSuccess(oauth2 -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_user_object\"><a class=\"anchor\" href=\"#_user_object\"></a>用户对象(User object)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当一个令牌(token)过期时，我们需要对其进行更新。对于这种需求，\nOAuth2 提供了包含一些常用方法的 AccessToken 类用于刷新访问令牌。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (user.expired()) {\n  <span class=\"hljs-comment\">// Callbacks</span>\n  oauth2.refresh(user)\n    .onSuccess(refreshedUser -&gt; {\n      <span class=\"hljs-comment\">// the refreshed user is now available</span>\n    })\n    .onFailure(err -&gt; {\n      <span class=\"hljs-comment\">// error handling...</span>\n    });\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您已经使用完或者想要注销令牌时，可以撤销访问令牌并刷新令牌。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">oauth2.revoke(user, <span class=\"hljs-string\">&quot;access_token&quot;</span>)\n  .onSuccess(v -&gt; {\n    <span class=\"hljs-comment\">// Session ended. But the refresh_token is still valid.</span>\n\n    <span class=\"hljs-comment\">// Revoke the refresh_token</span>\n    oauth2.revoke(user, <span class=\"hljs-string\">&quot;refresh_token&quot;</span>)\n      .onSuccess(v2 -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;token revoked.&quot;</span>);\n      });\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_example_configuration_for_common_oauth2_providers\"><a class=\"anchor\" href=\"#_example_configuration_for_common_oauth2_providers\"></a>通用 OAuth2 程序的配置示例</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了方便起见，我们提供了几个辅助工具帮助您进行配置。目前我们提供:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Amazon Cognito <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/AmazonCognitoAuth.html\">AmazonCognitoAuth</a></code></p>\n</li>\n<li>\n<p>Azure Active Directory <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/AzureADAuth.html\">AzureADAuth</a></code></p>\n</li>\n<li>\n<p>Box.com <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/BoxAuth.html\">BoxAuth</a></code></p>\n</li>\n<li>\n<p>CloudFoundry <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/CloudFoundryAuth.html\">CloudFoundryAuth</a></code></p>\n</li>\n<li>\n<p>Dropbox <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/DropboxAuth.html\">DropboxAuth</a></code></p>\n</li>\n<li>\n<p>Facebook <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FacebookAuth.html\">FacebookAuth</a></code></p>\n</li>\n<li>\n<p>Foursquare <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FoursquareAuth.html\">FoursquareAuth</a></code></p>\n</li>\n<li>\n<p>Github <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GithubAuth.html\">GithubAuth</a></code></p>\n</li>\n<li>\n<p>GitLab <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GitLabAuth.html\">GitLabAuth</a></code></p>\n</li>\n<li>\n<p>Google <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GoogleAuth.html\">GoogleAuth</a></code></p>\n</li>\n<li>\n<p>Heroku <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/HerokuAuth.html\">HerokuAuth</a></code></p>\n</li>\n<li>\n<p>IBM Cloud <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/IBMCloudAuth.html\">IBMCloudAuth</a></code></p>\n</li>\n<li>\n<p>Instagram <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/InstagramAuth.html\">InstagramAuth</a></code></p>\n</li>\n<li>\n<p>Keycloak <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/KeycloakAuth.html\">KeycloakAuth</a></code></p>\n</li>\n<li>\n<p>LinkedIn <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/LinkedInAuth.html\">LinkedInAuth</a></code></p>\n</li>\n<li>\n<p>Live.com <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/LiveAuth.html\">LiveAuth</a></code></p>\n</li>\n<li>\n<p>Mailchimp <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/MailchimpAuth.html\">MailchimpAuth</a></code></p>\n</li>\n<li>\n<p>OpenIDConnect <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/OpenIDConnectAuth.html\">OpenIDConnectAuth</a></code></p>\n</li>\n<li>\n<p>Salesforce <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SalesforceAuth.html\">SalesforceAuth</a></code></p>\n</li>\n<li>\n<p>Shopify <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/ShopifyAuth.html\">ShopifyAuth</a></code></p>\n</li>\n<li>\n<p>Soundcloud <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SoundcloudAuth.html\">SoundcloudAuth</a></code></p>\n</li>\n<li>\n<p>Stripe <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/StripeAuth.html\">StripeAuth</a></code></p>\n</li>\n<li>\n<p>Twitter <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/TwitterAuth.html\">TwitterAuth</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_jboss_keycloak\"><a class=\"anchor\" href=\"#_jboss_keycloak\"></a>JBoss Keycloak</h3>\n<div class=\"paragraph\">\n<p>当使用 Keycloak 时,Vert.x OAuth2 应该知道如何解析访问令牌并从中提取授权。\n这些信息很有价值，因为它允许在API级别进行授权，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">keycloakJson</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n  .put(<span class=\"hljs-string\">&quot;realm&quot;</span>, <span class=\"hljs-string\">&quot;master&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;realm-public-key&quot;</span>, <span class=\"hljs-string\">&quot;MIIBIjANBgkqhk...wIDAQAB&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;auth-server-url&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:9000/auth&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;ssl-required&quot;</span>, <span class=\"hljs-string\">&quot;external&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;resource&quot;</span>, <span class=\"hljs-string\">&quot;frontend&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;credentials&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n    .put(<span class=\"hljs-string\">&quot;secret&quot;</span>, <span class=\"hljs-string\">&quot;2fbf5e18-b923-4a83-9657-b4ebd5317f60&quot;</span>));\n\n<span class=\"hljs-comment\">// Initialize the OAuth2 Library</span>\n<span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> KeycloakAuth\n  .create(vertx, OAuth2FlowType.PASSWORD, keycloakJson);\n\n<span class=\"hljs-comment\">// first get a token (authenticate)</span>\noauth2.authenticate(\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n    .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;user&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;secret&quot;</span>))\n  .onSuccess(user -&gt; {\n    <span class=\"hljs-comment\">// now check for permissions</span>\n    <span class=\"hljs-type\">AuthorizationProvider</span> <span class=\"hljs-variable\">authz</span> <span class=\"hljs-operator\">=</span> KeycloakAuthorization.create();\n\n    authz.getAuthorizations(user)\n      .onSuccess(v -&gt; {\n        <span class=\"hljs-keyword\">if</span> (\n          RoleBasedAuthorization.create(<span class=\"hljs-string\">&quot;manage-account&quot;</span>)\n            .setResource(<span class=\"hljs-string\">&quot;account&quot;</span>)\n            .match(user)) {\n          <span class=\"hljs-comment\">// this user is authorized to manage its account</span>\n        }\n      });\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们还为 Keycloak 提供了一个辅助类，这样我们就可以轻松地从 Keycloak 主体中获取解码的令牌和一些必要的数据\n(例如 <code>preferred_username</code> )。例如:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">idToken</span> <span class=\"hljs-operator\">=</span> user.attributes().getJsonObject(<span class=\"hljs-string\">&quot;idToken&quot;</span>);\n\n<span class=\"hljs-comment\">// you can also retrieve some properties directly from the Keycloak principal</span>\n<span class=\"hljs-comment\">// e.g. `preferred_username`</span>\n<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">username</span> <span class=\"hljs-operator\">=</span> user.principal().getString(<span class=\"hljs-string\">&quot;preferred_username&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请记住 Keycloak 实现了 OpenID Connect ，所以您可以使用它的发现地址(discovery url)来配置:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OpenIDConnectAuth.discover(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n    .setClientId(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n    .setTenant(<span class=\"hljs-string\">&quot;your_realm&quot;</span>)\n    .setSite(<span class=\"hljs-string\">&quot;https://server:port/auth/realms/{tenant}&quot;</span>))\n  .onSuccess(oauth2 -&gt; {\n    <span class=\"hljs-comment\">// the setup call succeeded.</span>\n    <span class=\"hljs-comment\">// at this moment your auth is ready to use</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>因为您可以在任何地方部署 Keycloak 服务器，所以只需将 <code>server:port</code> 替换为正确的值，\n并将 <code>your_realm</code> 值替换为您的应用程序路径。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_google_server_to_server\"><a class=\"anchor\" href=\"#_google_server_to_server\"></a>Google Server to Server</h3>\n<div class=\"paragraph\">\n<p>Vert.x OAuth2 还支持 Server to Server 或 RFC7523 扩展。\n这是伴随 Google 账户的一个特性。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_token_introspection\"><a class=\"anchor\" href=\"#_token_introspection\"></a>令牌自检(Token Introspection)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>令牌可以进行自检，以便断言自身依然有效。虽然这是RFC7662出现的目的，\n但实现它的项目并不多。取而代之的是一些被称为 <code>TokenInfo</code> 端点的变体。 Vert.x OAuth2 同时接受这两种形式作为配置。\n目前已知可以与 <code>Google</code> 和 <code>Keycloak</code> 一起协作。</p>\n</div>\n<div class=\"paragraph\">\n<p>令牌自检假定自身是不透明的，因此需要在部署程序的服务器上对它们进行验证。\n每次验证都需要一次到服务器上的完整往返。\n自检可以在 OAuth2 服务级别或用户级别执行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">oauth2.authenticate(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;access_token&quot;</span>, <span class=\"hljs-string\">&quot;opaque string&quot;</span>))\n  .onSuccess(theUser -&gt; {\n    <span class=\"hljs-comment\">// token is valid!</span>\n  });\n\n<span class=\"hljs-comment\">// User level</span>\noauth2.authenticate(user.principal())\n  .onSuccess(authenticatedUser -&gt; {\n    <span class=\"hljs-comment\">// Token is valid!</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_verifying_jwt_tokens\"><a class=\"anchor\" href=\"#_verifying_jwt_tokens\"></a>验证 JWT 令牌</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>我们刚刚介绍了如何自检一个令牌，不过在处理JWT令牌时可以减少到部署服务器的访问次数以提高总体的响应时间。\n这种情况下，可以仅在应用端使用JWT协议验证令牌。\n验证JWT令牌成本更低，性能也更好，\n但是由于 JWTs 的无状态性，导致我们不可能知道用户是否注销和令牌是否无效。\n对于这种特殊情况，如果服务提供方支持自检，则需要使用自检。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">oauth2.authenticate(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;access_token&quot;</span>, <span class=\"hljs-string\">&quot;jwt-token&quot;</span>))\n  .onSuccess(theUser -&gt; {\n    <span class=\"hljs-comment\">// token is valid!</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>截止到目前为止，我们已经讨论了很多认证模式，尽管实现它们是依赖方的事情(这也意味着真正的认证过程发生在应用端之外)，\n但您可以通过这些实现处理很多事情。\n例如在服务提供方支持JSON WEB令牌的时候，您就可以进行授权。\n如果您的服务提供方是 OpenID Connect 服务提供者或者他们确实支持 <code>access_token</code> 作为JWTs，那么这将是个很常见的功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>类似的服务提供方是 Keycloak ，它实现了一个 OpenID Connect。在这种情况下，\n您可以用非常简单的方式进行授权。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_role_based_access_control\"><a class=\"anchor\" href=\"#_role_based_access_control\"></a>基于角色(role)的访问控制</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>OAuth2 是一个 AuthN 协议，但是 OpenID Connect 将 JWTs 添加到了令牌格式中，\n这意味着 AuthZ 可以在令牌级别进行编码。目前已知的 JWT AuthZ 格式有两种:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Keycloak</p>\n</li>\n<li>\n<p>MicroProfile JWT 1.1 spec (来自 auth-jwt 模块)</p>\n</li>\n</ul>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_keycloak_jwt\"><a class=\"anchor\" href=\"#_keycloak_jwt\"></a>Keycloak JWT</h3>\n<div class=\"paragraph\">\n<p>考虑到 Keycloak 确实提供了JWT访问令牌，所以我们可以在两个不同的层次进行授权:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>角色(role)</p>\n</li>\n<li>\n<p>授权权限(authority)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>为了区分两者，认证服务提供者遵循基本用户类的共同定义，即使用 <code>:</code> 作为两者的分隔符。\n需要指出的一点是，角色和授权权限并不需要同时存在，\n在最简单的情况下仅有授权权限就足够了。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了映射到 Keycloak 的令牌格式，需要执行以下校验:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>如果没有提供任何角色，则假定使用服务提供者的域(realm)名称。</p>\n</li>\n<li>\n<p>如果角色是 <code>realm</code> 那么会在对应的 <code>realm_access</code> 列表中进行查询。</p>\n</li>\n<li>\n<p>如果提供了角色，则在角色名下的 <code>resource_access</code> 列表中进行查询。</p>\n</li>\n</ol>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_check_for_a_specific_authorities\"><a class=\"anchor\" href=\"#_check_for_a_specific_authorities\"></a>检查特定的授权</h4>\n<div class=\"paragraph\">\n<p>这里有一个例子，指导您如何在用户进行 OAuth2 握手加载后执行授权，\n例如您想看看用户是否可以在当前应用程序中进行 <code>print</code> :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (PermissionBasedAuthorization.create(<span class=\"hljs-string\">&quot;print&quot;</span>).match(user)) {\n  <span class=\"hljs-comment\">// Yes the user can print</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然而您可能需要更具体地验证用户是否能够向整个系统(域)进行 <code>add-user</code> 操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (\n  PermissionBasedAuthorization.create(<span class=\"hljs-string\">&quot;add-user&quot;</span>)\n    .setResource(<span class=\"hljs-string\">&quot;realm&quot;</span>)\n    .match(user)) {\n  <span class=\"hljs-comment\">// Yes the user can add users to the application</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>又或者用户是否可以访问 <code>finance</code> 部门下的 <code>year-report</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (\n  PermissionBasedAuthorization.create(<span class=\"hljs-string\">&quot;year-report&quot;</span>)\n    .setResource(<span class=\"hljs-string\">&quot;finance&quot;</span>)\n    .match(user)) {\n  <span class=\"hljs-comment\">// Yes the user can access the year report from the finance department</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_microprofile_jwt_1_1_spec\"><a class=\"anchor\" href=\"#_microprofile_jwt_1_1_spec\"></a>MicroProfile JWT 1.1 规格说明</h3>\n<div class=\"paragraph\">\n<p>另一种规范形式是 MP-JWT 1.1。\n该规范在名为 <code>groups</code> 的属性下声明了JSON字符串数组用来定义令牌拥有的权限组。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了使用这个规范来断言 AuthZ ，\n可以使用 <code>auth-jwt</code> 模块中提供的 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code>。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_token_management\"><a class=\"anchor\" href=\"#_token_management\"></a>令牌管理(Token Management)</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_check_if_it_is_expired\"><a class=\"anchor\" href=\"#_check_if_it_is_expired\"></a>检查是否过期</h3>\n<div class=\"paragraph\">\n<p>令牌通常从服务器获取并缓存，在这种情况下使用它们时，它们可能已经过期并且无效，\n所以您可以像下面这样验证令牌是否仍然有效:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isExpired</span> <span class=\"hljs-operator\">=</span> user.expired();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个校验是在本地完成的，所以仍然可能出现 OAuth2 服务器使令牌无效，但您得到了一个未过期的令牌的结果。\n原因是该方法检查是否过期是根据令牌的过期日期进行的，\n而不是日期之前的值(not before date and such values)。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_refresh_token\"><a class=\"anchor\" href=\"#_refresh_token\"></a>刷新令牌</h3>\n<div class=\"paragraph\">\n<p>有时候您知道令牌即将过期，并希望避免用户再次重定向。\n在这种情况下，您可以刷新令牌。要刷新一个令牌，您需要已有一个用户并调用:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">oauth2.refresh(user)\n  .onSuccess(refreshedUser -&gt; {\n    <span class=\"hljs-comment\">// the refresh call succeeded</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// the token was not refreshed, a best practise would be</span>\n    <span class=\"hljs-comment\">// to forcefully logout the user since this could be a</span>\n    <span class=\"hljs-comment\">// symptom that you&#x27;re logged out by the server and this</span>\n    <span class=\"hljs-comment\">// token is not valid anymore.</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_revoke_token\"><a class=\"anchor\" href=\"#_revoke_token\"></a>撤销令牌</h3>\n<div class=\"paragraph\">\n<p>由于令牌可以在各种应用程序之间共享，因此您可能希望禁止任何应用程序使用当前令牌。\n为了做到这一点，需要撤销 OAuth2 服务器的令牌:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">oauth2.revoke(user, <span class=\"hljs-string\">&quot;access_token&quot;</span>)\n  .onSuccess(v -&gt; {\n    <span class=\"hljs-comment\">// the revoke call succeeded</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// the token was not revoked.</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>需要注意的是，调用这个方法需要一个令牌类型。原因是一些提供商会返回多个令牌，\n例如:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>id_token</p>\n</li>\n<li>\n<p>refresh_token</p>\n</li>\n<li>\n<p>access_token</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>所以我们需要知道让哪个令牌无效。显而易见，如果您使 <code>refresh_token</code> 无效，但此时仍然在登录状态并已经不能再刷新了，\n这就意味着一旦令牌过期，\n之后必须需要让用户重定向到登录页面。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_introspect\"><a class=\"anchor\" href=\"#_introspect\"></a>自检(Introspect)</h3>\n<div class=\"paragraph\">\n<p>自检一个令牌类似于过期检查，但是需要注意该检查是完全在线的。\n这意味着检查发生在 OAuth2 服务器上。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">oauth2.authenticate(user.principal())\n  .onSuccess(validUser -&gt; {\n    <span class=\"hljs-comment\">// the introspection call succeeded</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// the token failed the introspection. You should proceed</span>\n    <span class=\"hljs-comment\">// to logout the user since this means that this token is</span>\n    <span class=\"hljs-comment\">// not valid anymore.</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>非常重要的一点是，即使调用 <code>expired()</code> 返回了 <code>true</code> ，<code>introspect</code> 的响应仍然可能是错误的。\n这是因为在此期间， OAuth2 可能已经收到了一个撤销令牌或者注销的请求。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_logging_out\"><a class=\"anchor\" href=\"#_logging_out\"></a>注销(Logging out)</h3>\n<div class=\"paragraph\">\n<p>注销不是 OAuth2 的特性，但它存在于 OpenID Connect 中，\n而且大多数服务提供方都支持某种形式的注销。如果配置足够进行调用，那么 Vert-OAuth2 的操作会覆盖整个区域。\n对于用户来说这很简单:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">logoutUrl</span> <span class=\"hljs-operator\">=</span> oauth2.endSessionURL(user);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_key_management\"><a class=\"anchor\" href=\"#_key_management\"></a>密匙管理(Key Management)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当服务提供者配置 <code>jwks</code> 路径的时候，无论是手动还是使用发现机制，\n都存在必须旋转(be rotated)密钥的事件。因此，\n服务提供者实现了 OpenID Connect 核心规范推荐的两种方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>当调用刷新方法时，如果服务器返回了推荐的缓存头(cache header)，\n正如 <code><a href=\"https://openid.net/specs/openid-connect-core-1_0.html#RotateEncKeys\" class=\"bare\">https://openid.net/specs/openid-connect-core-1_0.html#RotateEncKeys</a></code> 所描述的，\n那么服务器将在推荐的时间执行一个周期性任务用于重新加载密钥。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isExpired</span> <span class=\"hljs-operator\">=</span> user.expired();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>但是，有时候服务器更改密钥，而这个服务提供者不知情。\n例如用于缓解泄漏或过期证书。 在这种情况下，\n服务器将开始发出与 <code><a href=\"https://openid.net/specs/openid-connect-core-1_0.html#rotatesigkeys\" class=\"bare\">https://openid.net/specs/openid-connect-core-1_0.html#rotatesigkeys</a></code> 描述中不同的令牌。\n为了避免DDoS攻击，Vert.x OAuth2 会通知您缺少一个未知的密钥:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">oauth2.refresh(user)\n  .onSuccess(refreshedUser -&gt; {\n    <span class=\"hljs-comment\">// the refresh call succeeded</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// the token was not refreshed, a best practise would be</span>\n    <span class=\"hljs-comment\">// to forcefully logout the user since this could be a</span>\n    <span class=\"hljs-comment\">// symptom that you&#x27;re logged out by the server and this</span>\n    <span class=\"hljs-comment\">// token is not valid anymore.</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>需要特别注意的一点是，如果一个用户发送了许多缺少密钥的请求，\n程序应该对其的调用操作进行限制，否则可能会造成IdP服务器的DDoS。</p>\n</div>\n</div>\n</div>"},"__N_SSG":true}