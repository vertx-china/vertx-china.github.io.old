{"pageProps":{"slug":"4.1.5/vertx-web-openapi/java","title":"Vert.x OpenAPI","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_openapi\">使用 Vert.x OpenAPI</a></li>\n<li><a href=\"#_routerbuilder\"><code>RouterBuilder</code></a></li>\n<li><a href=\"#_access_to_operations\">获取operation</a></li>\n<li><a href=\"#_configuring_authentication_handler\">配置定义在 OpenAPI 文档中的 <code>AuthenticationHandler</code></a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_blocking_vs_nonblocking\">阻塞 vs 非阻塞</a></li>\n</ul>\n</li>\n<li><a href=\"#_map_authenticationhandler_to_openapi_security_schemes\">将 <code>AuthenticationHandler</code> 映射到 OpenAPI 安全约束</a></li>\n<li><a href=\"#_not_implemented_error\">未实现的错误</a></li>\n<li><a href=\"#_response_content_type_handler\">响应内容类型处理器</a></li>\n<li><a href=\"#_operation_model\">operation 模型</a></li>\n<li><a href=\"#_body_handler\">请求体处理器</a></li>\n<li><a href=\"#_multipart_form_data_validation\"><code>multipart/form-data</code> 校验</a></li>\n<li><a href=\"#_custom_global_handlers\">自定义全局处理器</a></li>\n<li><a href=\"#_router_builder_handlers_mount_order\">Router builder 处理器的挂载顺序</a></li>\n<li><a href=\"#_generate_the_router\">生成路由器</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x OpenAPI</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x OpenAPI 继承了 Vert.x Web 用以支持 <a href=\"https://www.openapis.org/\">OpenAPI 3</a> ，同时为您提供了简便的接口来构建一个符合您接口协议的Vert.x Web 路由器。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x OpenAPI 可以做到如下事情：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>解析并校验您的 OpenAPI 3 协议</p>\n</li>\n<li>\n<p>根据您的约束来生成路由器（带有正确的路径以及方法）</p>\n</li>\n<li>\n<p>提供基于您接口协议的请求解析和校验的功能，该功能用 <a href=\"https://vertx.io/docs/vertx-web-validation/java/\">Vert.x Web Validation</a> 实现。</p>\n</li>\n<li>\n<p>挂载必要的安全处理器</p>\n</li>\n<li>\n<p>在 OpenAPI 风格和 Vert.x 风格之间转换路径</p>\n</li>\n<li>\n<p>用 <a href=\"https://vertx.io/docs/vertx-web-api-service/java/\">Vert.x Web API Service</a> 来将请求路由到事件总线</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_openapi\"><a class=\"anchor\" href=\"#_using_vert_x_openapi\"></a>使用 Vert.x OpenAPI</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用Vert.x OpenAPI，您需要添加如下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-openapi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-web-openapi:4.1.5&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routerbuilder\"><a class=\"anchor\" href=\"#_routerbuilder\"></a><code>RouterBuilder</code></h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html\">RouterBuilder</a></code> 是这个模块的主要元素，它提供了用来挂载请求处理器的接口，并且生成最终的 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>要使用 Vert.x Web OpenAPI ，您必须用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#create-io.vertx.core.Vertx-java.lang.String-io.vertx.core.Handler-\">RouterBuilder.create</a></code> 方法并传入您的接口协议来实例化 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html\">RouterBuilder</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>例如从本地文件系统来加载一个约束：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RouterBuilder.create(vertx, <span class=\"hljs-string\">&quot;src/main/resources/petstore.yaml&quot;</span>)\n  .onSuccess(routerBuilder -&gt; {\n    <span class=\"hljs-comment\">// 约束加载成功</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// router builder 初始化失败</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以从一个远程约束构建一个 router builder ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RouterBuilder.create(\n  vertx,\n  <span class=\"hljs-string\">&quot;https://raw.githubusercontent&quot;</span> +\n    <span class=\"hljs-string\">&quot;.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml&quot;</span>)\n  .onSuccess(routerBuilder -&gt; {\n    <span class=\"hljs-comment\">// 约束加载成功</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// router builder 初始化失败</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过配置 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/OpenAPILoaderOptions.html\">OpenAPILoaderOptions</a></code> 以获取私有的远程约束：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OpenAPILoaderOptions</span> <span class=\"hljs-variable\">loaderOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenAPILoaderOptions</span>()\n  .putAuthHeader(<span class=\"hljs-string\">&quot;Authorization&quot;</span>, <span class=\"hljs-string\">&quot;Bearer xx.yy.zz&quot;</span>);\nRouterBuilder.create(\n  vertx,\n  <span class=\"hljs-string\">&quot;https://raw.githubusercontent&quot;</span> +\n    <span class=\"hljs-string\">&quot;.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml&quot;</span>,\n  loaderOptions)\n  .onSuccess(routerBuilder -&gt; {\n    <span class=\"hljs-comment\">// 约束加载成功</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// router builder 初始化失败</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html\">RouterBuilderOptions</a></code> 来修改 router builder 的各种行为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder.setOptions(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RouterBuilderOptions</span>());</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_access_to_operations\"><a class=\"anchor\" href=\"#_access_to_operations\"></a>获取operation</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了获取协议中定义的 <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#operationObject\">Operation</a> ，您需要用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#operation-java.lang.String-\">operation</a></code> 方法。\n这个方法返回了一个 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/Operation.html\">Operation</a></code> 对象，您可以既可以用它来获取模型，又可以用来注册处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/Operation.html#handler-io.vertx.core.Handler-\">handler</a></code> 为一个operation来挂载处理器，\n使用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/Operation.html#failureHandler-io.vertx.core.Handler-\">failureHandler</a></code> 来挂载失败处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以 <strong>在一个 operation 当中添加多个处理器</strong> ，而不覆盖已经存在的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder\n  .operation(<span class=\"hljs-string\">&quot;awesomeOperation&quot;</span>)\n  .handler(routingContext -&gt; {\n    <span class=\"hljs-type\">RequestParameters</span> <span class=\"hljs-variable\">params</span> <span class=\"hljs-operator\">=</span>\n      routingContext.get(ValidationHandler.REQUEST_CONTEXT_KEY);\n    <span class=\"hljs-type\">RequestParameter</span> <span class=\"hljs-variable\">body</span> <span class=\"hljs-operator\">=</span> params.body();\n    <span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">jsonBody</span> <span class=\"hljs-operator\">=</span> body.getJsonObject();\n    <span class=\"hljs-comment\">// 处理请求体</span>\n  }).failureHandler(routingContext -&gt; {\n  <span class=\"hljs-comment\">// 处理失败</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>没有 <code>operationId</code> 的话，那么您不能获取到这个operation。 没有 <code>operationId</code> 的operation，会被 <code>RouterBuilder</code> 忽略。</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x OpenAPI 为您挂载了正确的 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/ValidationHandler.html\">ValidationHandler</a></code> ，所以您才可以获取到请求参数和请求体。\n请参考 <a href=\"https://vertx.io/docs/vertx-web-validation/java/\">Vert.x Web 校验文档</a> 来学习如何获取请求参数以及请求体，并学习如何管理校验失败的处理方式。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_authentication_handler\"><a class=\"anchor\" href=\"#_configuring_authentication_handler\"></a>配置定义在 OpenAPI 文档中的 <code>AuthenticationHandler</code></h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>安全是任何API的一个重要部分。OpenAPI定义了如何在api文档中强调安全性。</p>\n</div>\n<div class=\"paragraph\">\n<p>所有安全约束信息都在 <code>/components/securitySchemes</code> 组件下。\n对于每种类型的身份验证，该对象中的信息是不同的而且是特别指定的\n为了避免重复配置，这个模块允许您为从原文档中读取源配置的身份验证处理器提供工厂</p>\n</div>\n<div class=\"paragraph\">\n<p>举个例子，下面是一个定义了 <code>Basic Authentication</code> 的文档：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openapi: 3.0.0\n...\ncomponents:\n securitySchemes:\n   basicAuth:     # &lt;-- 为这个security scheme随便提供一个名字\n     type: http\n     scheme: basic</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以这样配置一个工厂：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder\n  .securityHandler(<span class=\"hljs-string\">&quot;basicAuth&quot;</span>)\n  .bindBlocking(config -&gt; BasicAuthHandler.create(authProvider));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>尽管这个例子配置起来很简单，但是创建一个身份验证处理器需要配置\n例如从一个API Key处理器中获取配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre> openapi: 3.0.0\n ...\n # 1) 定义key的名字和位置\n components:\n   securitySchemes:\n     ApiKeyAuth:        # 为这个安全约束随便提供一个名字\n       type: apiKey\n       in: header       # 可以是\"header\", \"query\" 或者 \"cookie\"\n       name: X-API-KEY  # \"header\", \"query\" 或者 \"cookie\"中的名字</pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder\n  .securityHandler(<span class=\"hljs-string\">&quot;ApiKeyAuth&quot;</span>)\n  .bindBlocking(config -&gt;\n    APIKeyHandler.create(authProvider)\n      .header(config.getString(<span class=\"hljs-string\">&quot;name&quot;</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者你可以配置更多复杂场景的情况，比如需要服务发现的OpenId Connect</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openapi: 3.0.0\n...\n# 1) 定义安全约束的类型和属性\ncomponents:\n securitySchemes:\n   openId:   # &lt;--- 为这个安全约束随便提供一个名字。就可以利用该名从别处引用。\n     type: openIdConnect\n     openIdConnectUrl: https://example.com/.well-known/openid-configuration</pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder\n  .securityHandler(<span class=\"hljs-string\">&quot;openId&quot;</span>)\n  .bind(config -&gt;\n    OpenIDConnectAuth\n      .discover(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n        .setClientId(<span class=\"hljs-string\">&quot;client-id&quot;</span>) <span class=\"hljs-comment\">// user provided</span>\n        .setClientSecret(<span class=\"hljs-string\">&quot;client-secret&quot;</span>) <span class=\"hljs-comment\">// user provided</span>\n        .setSite(config.getString(<span class=\"hljs-string\">&quot;openIdConnectUrl&quot;</span>)))\n      .compose(authProvider -&gt; {\n        <span class=\"hljs-type\">AuthenticationHandler</span> <span class=\"hljs-variable\">handler</span> <span class=\"hljs-operator\">=</span>\n          OAuth2AuthHandler.create(vertx, authProvider);\n        <span class=\"hljs-keyword\">return</span> Future.succeededFuture(handler);\n      }))\n  .onSuccess(self -&gt; {\n    <span class=\"hljs-comment\">//创建成功</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// 出了一些问题</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个API被设计为流式的，所以它用起来很简洁，举个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder\n  .securityHandler(<span class=\"hljs-string\">&quot;api_key&quot;</span>)\n  .bindBlocking(config -&gt; APIKeyHandler.create(authProvider))\n  .operation(<span class=\"hljs-string\">&quot;listPetsSingleSecurity&quot;</span>)\n  .handler(routingContext -&gt; {\n    routingContext\n      .response()\n      .setStatusCode(<span class=\"hljs-number\">200</span>)\n      .setStatusMessage(<span class=\"hljs-string\">&quot;Cats and Dogs&quot;</span>)\n      .end();\n  });\n\n<span class=\"hljs-comment\">// 非阻塞绑定</span>\nrouterBuilder\n  .securityHandler(<span class=\"hljs-string\">&quot;oauth&quot;</span>)\n  .bind(config -&gt; OpenIDConnectAuth.discover(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>(config))\n    .compose(oidc -&gt; Future.succeededFuture(\n      OAuth2AuthHandler.create(vertx, oidc))))\n\n  .onSuccess(self -&gt; {\n    self\n      .operation(<span class=\"hljs-string\">&quot;listPetsSingleSecurity&quot;</span>)\n      .handler(routingContext -&gt; {\n        routingContext\n          .response()\n          .setStatusCode(<span class=\"hljs-number\">200</span>)\n          .setStatusMessage(<span class=\"hljs-string\">&quot;Cats and Dogs&quot;</span>)\n          .end();\n      });\n  });</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_blocking_vs_nonblocking\"><a class=\"anchor\" href=\"#_blocking_vs_nonblocking\"></a>阻塞 vs 非阻塞</h3>\n<div class=\"paragraph\">\n<p>从上面的例子可以看出，处理器可以以阻塞或非阻塞的方式添加。\n使用非阻塞方式的原因不仅仅是为了支持像 <code>OAuth2</code> 这样的处理器。\n非阻塞方式对于JWT或基本身份验证之类的处理器很有用，因为其中身份验证提供者需要加载密钥或配置文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个使用JWT的例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder\n  .securityHandler(<span class=\"hljs-string\">&quot;oauth&quot;</span>)\n  .bind(config -&gt;\n    <span class=\"hljs-comment\">// 当读取公钥的时候，我们不想阻塞</span>\n    <span class=\"hljs-comment\">// 我们可以使用非阻塞绑定</span>\n    vertx.fileSystem()\n      .readFile(<span class=\"hljs-string\">&quot;public.key&quot;</span>)\n      <span class=\"hljs-comment\">//  我们把future映射为身份验证提供程序</span>\n      .map(key -&gt;\n        JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JWTAuthOptions</span>()\n          .addPubSecKey(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PubSecKeyOptions</span>()\n            .setAlgorithm(<span class=\"hljs-string\">&quot;RS256&quot;</span>)\n            .setBuffer(key))))\n      <span class=\"hljs-comment\">// and map again to create the final handler</span>\n      .map(JWTAuthHandler::create))\n\n  .onSuccess(self -&gt;\n    self\n      .operation(<span class=\"hljs-string\">&quot;listPetsSingleSecurity&quot;</span>)\n      .handler(routingContext -&gt; {\n        routingContext\n          .response()\n          .setStatusCode(<span class=\"hljs-number\">200</span>)\n          .setStatusMessage(<span class=\"hljs-string\">&quot;Cats and Dogs&quot;</span>)\n          .end();\n      }));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_map_authenticationhandler_to_openapi_security_schemes\"><a class=\"anchor\" href=\"#_map_authenticationhandler_to_openapi_security_schemes\"></a>将 <code>AuthenticationHandler</code> 映射到 OpenAPI 安全约束</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您已经知道了您如何将 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthenticationHandler.html\">AuthenticationHandler</a></code> 映射为一个定义在约定中的安全约束\n前面的示例会验证配置，如果找不到配置就会导致您的路由构建失败</p>\n</div>\n<div class=\"paragraph\">\n<p>在某些情况下，约定是不完整的，您需要显式地定义安全处理器。\n在这种情况下API略有不同，不会强制验证任何约束。\n但是，无论如何，安全处理器对构建器都是可用的。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，给出一个名为 <code>security_scheme_name</code> 接口约束：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder.securityHandler(\n  <span class=\"hljs-string\">&quot;security_scheme_name&quot;</span>,\n  authenticationHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以挂载包含在Vert.x Web中模块中的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthenticationHandler.html\">AuthenticationHandler</a></code> ，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder.securityHandler(<span class=\"hljs-string\">&quot;jwt_auth&quot;</span>,\n  JWTAuthHandler.create(jwtAuthProvider));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您生成 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code> 之后，router builder会解析operation所必须的安全约束。\n如果一个operation所必须的 <code>AuthenticationHandler</code> 缺失，则这个过程会失败。</p>\n</div>\n<div class=\"paragraph\">\n<p>调试/测试时，您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setRequireSecurityHandlers-boolean-\">setRequireSecurityHandlers</a></code> 来禁用这个检验。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_not_implemented_error\"><a class=\"anchor\" href=\"#_not_implemented_error\"></a>未实现的错误</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果未指定处理器，那么Router builder会为一个operation自动挂载一个默认的处理器。\n这个默认的处理器会让 routing context 处于  405 <code>Method Not Allowed</code> 或者 501 <code>Not Implemented</code> 错误状态。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setMountNotImplementedHandler-boolean-\">setMountNotImplementedHandler</a></code> 启用/禁用它，并且您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code> 自定义这个错误的处理方式。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_response_content_type_handler\"><a class=\"anchor\" href=\"#_response_content_type_handler\"></a>响应内容类型处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当接口协议需要的时候，Router builder 自动挂载一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ResponseContentTypeHandler.html\">ResponseContentTypeHandler</a></code> 处理器。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setMountResponseContentTypeHandler-boolean-\">setMountResponseContentTypeHandler</a></code> 禁用这个特性。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_operation_model\"><a class=\"anchor\" href=\"#_operation_model\"></a>operation 模型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果您在处理请求的时候需要获取到operation模型，那么您可以配置router builder，从而用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setOperationModelKey-java.lang.String-\">setOperationModelKey</a></code> 将其放入 <code>RoutingContext</code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setOperationModelKey(<span class=\"hljs-string\">&quot;operationModel&quot;</span>);\nrouterBuilder.setOptions(options);\n\n<span class=\"hljs-comment\">// 添加一个用这个operation模型的处理器</span>\nrouterBuilder\n  .operation(<span class=\"hljs-string\">&quot;listPets&quot;</span>)\n  .handler(\n    routingContext -&gt; {\n      <span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">operation</span> <span class=\"hljs-operator\">=</span> routingContext.get(<span class=\"hljs-string\">&quot;operationModel&quot;</span>);\n\n      routingContext\n        .response()\n        .setStatusCode(<span class=\"hljs-number\">200</span>)\n        .setStatusMessage(<span class=\"hljs-string\">&quot;OK&quot;</span>)\n        <span class=\"hljs-comment\">// 以&quot;listPets&quot;为 operation id 回写响应</span>\n        .end(operation.getString(<span class=\"hljs-string\">&quot;operationId&quot;</span>));\n    });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_body_handler\"><a class=\"anchor\" href=\"#_body_handler\"></a>请求体处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Router builder自动挂载一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 用以管理请求体。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#bodyHandler-io.vertx.ext.web.handler.BodyHandler-\">bodyHandler</a></code> 来配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 对象（例如，更换上传目录）</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_multipart_form_data_validation\"><a class=\"anchor\" href=\"#_multipart_form_data_validation\"></a><code>multipart/form-data</code> 校验</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>校验处理器像如下描述来区分文件上传和表单属性：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果参数中没有编码相关的字段：</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果参数存在 <code>type: string</code> 和 <code>format: base64</code> ，或者存在 <code>format: binary</code> ，那么它就是 content-type请求头为 <code>application/octet-stream</code> 的一个请求。</p>\n</li>\n<li>\n<p>否则是一个表单请求</p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>如果参数存在编码相关字段，则是一个文件上传的请求。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>对于表单属性，他们被解析、转换为Json、然后校验，\n然而对于文件上传请求，校验处理器仅仅检查存在性和Content-Type。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_custom_global_handlers\"><a class=\"anchor\" href=\"#_custom_global_handlers\"></a>自定义全局处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果您需要挂载一个处理器，而这个处理器在您路由器中每个operation执行之前都需要执行特定操作，那么您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#rootHandler-io.vertx.core.Handler-\">rootHandler</a></code></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_router_builder_handlers_mount_order\"><a class=\"anchor\" href=\"#_router_builder_handlers_mount_order\"></a>Router builder 处理器的挂载顺序</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>router builder以如下顺序加载处理器：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>请求体处理器</p>\n</li>\n<li>\n<p>自定义全局处理器</p>\n</li>\n<li>\n<p>已配置的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthenticationHandler.html\">AuthenticationHandler</a></code></p>\n</li>\n<li>\n<p>生成的 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/ValidationHandler.html\">ValidationHandler</a></code></p>\n</li>\n<li>\n<p>用户处理器 或者 \"未实现的\"处理器（如果启用）</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_generate_the_router\"><a class=\"anchor\" href=\"#_generate_the_router\"></a>生成路由器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>万事俱备，生成路由器并使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> routerBuilder.createRouter();\n\n<span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span>\n  vertx.createHttpServer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerOptions</span>().setPort(<span class=\"hljs-number\">8080</span>).setHost(\n    <span class=\"hljs-string\">&quot;localhost&quot;</span>));\nserver.requestHandler(router).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个方法可能会失败并抛出 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderException.html\">RouterBuilderException</a></code> 。</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>如果您需要挂载所有router builder生成的具有相同父级路径的路由器，您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#mountSubRouter-java.lang.String-io.vertx.ext.web.Router-\">mountSubRouter</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">global</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">generated</span> <span class=\"hljs-operator\">=</span> routerBuilder.createRouter();\nglobal.mountSubRouter(<span class=\"hljs-string\">&quot;/v1&quot;</span>, generated);</code></pre>\n</div>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>","version":"4.1.5"},"__N_SSG":true}