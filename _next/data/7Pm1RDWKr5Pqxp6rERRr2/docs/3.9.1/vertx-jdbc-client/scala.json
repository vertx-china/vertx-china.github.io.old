{"pageProps":{"slug":"3.9.1/vertx-jdbc-client/scala","title":"Vert.x JDBC client","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_creating_a_the_client\">Creating a the client</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_default_shared_data_source\">Using default shared data source</a></li>\n<li><a href=\"#_specifying_a_data_source_name\">Specifying a data source name</a></li>\n<li><a href=\"#_creating_a_client_with_a_non_shared_data_source\">Creating a client with a non shared data source</a></li>\n<li><a href=\"#_specifying_a_data_source\">Specifying a data source</a></li>\n</ul>\n</li>\n<li><a href=\"#_closing_the_client\">Closing the client</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_automatic_clean_up_in_verticles\">Automatic clean-up in verticles</a></li>\n</ul>\n</li>\n<li><a href=\"#_getting_a_connection\">Getting a connection</a></li>\n<li><a href=\"#_configuration\">Configuration</a></li>\n<li><a href=\"#_jdbc_drivers\">JDBC Drivers</a></li>\n<li><a href=\"#_data_types\">Data types</a></li>\n<li><a href=\"#_use_as_osgi_bundle\">Use as OSGi bundle</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x JDBC client</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This client allows you to interact with any JDBC compliant database using an asynchronous API from your Vert.x\napplication.</p>\n</div>\n<div class=\"paragraph\">\n<p>The client API is represented with the interface <code><a href=\"../../scaladocs/io/vertx/scala/ext/jdbc/JDBCClient.html\">JDBCClient</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To use this project, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-jdbc-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${maven.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-jdbc-client:${maven.version}'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_the_client\"><a class=\"anchor\" href=\"#_creating_a_the_client\"></a>Creating a the client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>There are several ways to create a client. Let&#8217;s go through them all.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_default_shared_data_source\"><a class=\"anchor\" href=\"#_using_default_shared_data_source\"></a>Using default shared data source</h3>\n<div class=\"paragraph\">\n<p>In most cases you will want to share a data source between different client instances.</p>\n</div>\n<div class=\"paragraph\">\n<p>E.g. you scale your application by deploying multiple instances of your verticle and you want each verticle instance\nto share the same datasource so you don&#8217;t end up with multiple pools</p>\n</div>\n<div class=\"paragraph\">\n<p>You do this as follows:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">var</span> client = JDBCClient.createShared(vertx, config)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The first call to <code><a href=\"../../scaladocs/io/vertx/scala/ext/jdbc/JDBCClient.html#createShared(io.vertx.core.Vertx)\">JDBCClient.createShared</a></code>\nwill actually create the data source, and the specified config will be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Subsequent calls will return a new client instance that uses the same data source, so the configuration won&#8217;t be used.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_specifying_a_data_source_name\"><a class=\"anchor\" href=\"#_specifying_a_data_source_name\"></a>Specifying a data source name</h3>\n<div class=\"paragraph\">\n<p>You can create a client specifying a data source name as follows</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">var</span> client = JDBCClient.createShared(vertx, config, <span class=\"hljs-string\">\"MyDataSource\"</span>)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If different clients are created using the same Vert.x instance and specifying the same data source name, they will\nshare the same data source.</p>\n</div>\n<div class=\"paragraph\">\n<p>The first call to <code><a href=\"../../scaladocs/io/vertx/scala/ext/jdbc/JDBCClient.html#createShared(io.vertx.core.Vertx)\">JDBCClient.createShared</a></code>\nwill actually create the data source, and the specified config will be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Subsequent calls will return a new client instance that uses the same data source, so the configuration won&#8217;t be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Use this way of creating if you wish different groups of clients to have different data sources, e.g. they&#8217;re\ninteracting with different databases.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_client_with_a_non_shared_data_source\"><a class=\"anchor\" href=\"#_creating_a_client_with_a_non_shared_data_source\"></a>Creating a client with a non shared data source</h3>\n<div class=\"paragraph\">\n<p>In most cases you will want to share a data source between different client instances.\nHowever, it&#8217;s possible you want to create a client instance that doesn&#8217;t share its data source with any other client.</p>\n</div>\n<div class=\"paragraph\">\n<p>In that case you can use <code><a href=\"../../scaladocs/io/vertx/scala/ext/jdbc/JDBCClient.html#create(io.vertx.core.Vertx)\">JDBCClient.create</a></code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">var</span> client = JDBCClient.create(vertx, config)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is equivalent to calling <code><a href=\"../../scaladocs/io/vertx/scala/ext/jdbc/JDBCClient.html#createShared(io.vertx.core.Vertx,%20io.vertx.core.json.JsonObject)\">JDBCClient.createShared</a></code>\nwith a unique data source name each time.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_specifying_a_data_source\"><a class=\"anchor\" href=\"#_specifying_a_data_source\"></a>Specifying a data source</h3>\n<div class=\"paragraph\">\n<p>If you already have a pre-existing data source, you can also create the client directly specifying that:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">var</span> client = JDBCClient.create(vertx, dataSource)</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_closing_the_client\"><a class=\"anchor\" href=\"#_closing_the_client\"></a>Closing the client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>It&#8217;s fine to keep hold of the client for a long time (e.g. the lifetime of your verticle), but once you&#8217;re\ndone with it you should close it.</p>\n</div>\n<div class=\"paragraph\">\n<p>Clients that share a data source with other client instances are reference counted. Once the last one that references\nthe same data source is closed, the data source will be closed.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_clean_up_in_verticles\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles\"></a>Automatic clean-up in verticles</h3>\n<div class=\"paragraph\">\n<p>If you&#8217;re creating clients from inside verticles, the clients will be automatically closed when the verticle is undeployed.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>Getting a connection</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Once you&#8217;ve created a client you use <code><a href=\"../../scaladocs/io/vertx/scala/ext/sql/SQLClient.html#getConnection()\">getConnection</a></code> to get\na connection.</p>\n</div>\n<div class=\"paragraph\">\n<p>This will return the connection in the handler when one is ready from the pool.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// Now do stuff with it:</span>\n\nclient.getConnectionFuture().onComplete{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">case</span> <span class=\"hljs-title\">Success</span><span class=\"hljs-params\">(result)</span> </span>=&gt; {\n\n    <span class=\"hljs-keyword\">var</span> connection = result\n\n    connection.queryFuture(<span class=\"hljs-string\">\"SELECT * FROM some_table\"</span>).onComplete{\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">case</span> <span class=\"hljs-title\">Success</span><span class=\"hljs-params\">(result)</span> </span>=&gt; {\n\n        <span class=\"hljs-keyword\">var</span> rs = result\n        <span class=\"hljs-comment\">// Do something with results</span>\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">case</span> <span class=\"hljs-title\">Failure</span><span class=\"hljs-params\">(cause)</span> </span>=&gt; println(<span class=\"hljs-string\">\"Failure\"</span>)\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">case</span> <span class=\"hljs-title\">Failure</span><span class=\"hljs-params\">(cause)</span> </span>=&gt; {\n    println(s<span class=\"hljs-string\">\"$cause\"</span>)\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The connection is an instance of <code><a href=\"../../scaladocs/io/vertx/scala/ext/sql/SQLConnection.html\">SQLConnection</a></code> which is a common interface not only used by\nthe Vert.x JDBC Client.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can learn how to use it in the <a href=\"http://vertx.io/docs/vertx-sql-common/scala/\">common sql interface</a> documentation.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>Configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Configuration is passed to the client when creating or deploying it.</p>\n</div>\n<div class=\"paragraph\">\n<p>The following configuration properties generally apply:</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>provider_class</code></dt>\n<dd>\n<p>The class name of the class actually used to manage the database connections. By default this is\n<code>io.vertx.ext.jdbc.spi.impl.C3P0DataSourceProvider</code> but if you want to use a different provider you can override\nthis property and provide your implementation.</p>\n</dd>\n<dt class=\"hdlist1\"><code>row_stream_fetch_size</code></dt>\n<dd>\n<p>The size of <code>SQLRowStream</code> internal cache which used to better performance. By default\nit equals to <code>128</code></p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>Assuming the C3P0 implementation is being used (the default), the following extra configuration properties apply:</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>url</code></dt>\n<dd>\n<p>the JDBC connection URL for the database</p>\n</dd>\n<dt class=\"hdlist1\"><code>driver_class</code></dt>\n<dd>\n<p>the class of the JDBC driver</p>\n</dd>\n<dt class=\"hdlist1\"><code>user</code></dt>\n<dd>\n<p>the username for the database</p>\n</dd>\n<dt class=\"hdlist1\"><code>password</code></dt>\n<dd>\n<p>the password for the database</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_pool_size</code></dt>\n<dd>\n<p>the maximum number of connections to pool - default is <code>15</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>initial_pool_size</code></dt>\n<dd>\n<p>the number of connections to initialise the pool with - default is <code>3</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>min_pool_size</code></dt>\n<dd>\n<p>the minimum number of connections to pool</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_statements</code></dt>\n<dd>\n<p>the maximum number of prepared statements to cache - default is <code>0</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_statements_per_connection</code></dt>\n<dd>\n<p>the maximum number of prepared statements to cache per connection - default is <code>0</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_idle_time</code></dt>\n<dd>\n<p>number of seconds after which an idle connection will be closed - default is <code>0</code> (never expire).</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>Other Connection Pool providers are:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>BoneCP (<strong>DEPRECATED</strong> you should avoid this pool as it has been deprecated upstream)</p>\n</li>\n<li>\n<p>Hikari</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Similar to C3P0 they can be configured by passing the configuration values on the JSON config object. For the special\ncase where you do not want to deploy your app as a fat jar but run with a vert.x distribution, then it is recommented\nto use BoneCP if you have no write permissions to add the JDBC driver to the vert.x lib directory and are passing it\nusing the <code>-cp</code> command line flag.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want to configure any other C3P0 properties, you can add a file <code>c3p0.properties</code> to the classpath.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example of configuring a service:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">var</span> config = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.JsonObject().put(<span class=\"hljs-string\">\"url\"</span>, <span class=\"hljs-string\">\"jdbc:hsqldb:mem:test?shutdown=true\"</span>).put(<span class=\"hljs-string\">\"driver_class\"</span>, <span class=\"hljs-string\">\"org.hsqldb.jdbcDriver\"</span>).put(<span class=\"hljs-string\">\"max_pool_size\"</span>, <span class=\"hljs-number\">30</span>)\n\n<span class=\"hljs-keyword\">var</span> client = JDBCClient.createShared(vertx, config)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Hikari uses a different set of properties:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>jdbcUrl</code> for the JDBC URL</p>\n</li>\n<li>\n<p><code>driverClassName</code> for the JDBC driven class name</p>\n</li>\n<li>\n<p><code>maximumPoolSize</code> for the pool size</p>\n</li>\n<li>\n<p><code>username</code> for the login (<code>password</code> for the password)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Refer to the <a href=\"https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby\">Hikari documentation</a>\nfor further details. Also refer to the <a href=\"http://www.jolbox.com/configuration.html\">BoneCP documentation</a>\nto configure BoneCP.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_jdbc_drivers\"><a class=\"anchor\" href=\"#_jdbc_drivers\"></a>JDBC Drivers</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>If you are using the default <code>DataSourceProvider</code> (relying on c3p0), you would need to copy the JDBC driver class\nin your <em>classpath</em>.</p>\n</div>\n<div class=\"paragraph\">\n<p>If your application is packaged as a <em>fat jar</em>, be sure to embed the jdbc driver. If your application is launched\nwith the <code>vertx</code> command line, copy the JDBC driver to <code>${VERTX_HOME}/lib</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The behavior may be different when using a different connection pool.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_data_types\"><a class=\"anchor\" href=\"#_data_types\"></a>Data types</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Due to the fact that Vert.x uses JSON as its standard message format there will be many limitations to the data types\naccepted by the client. You will get out of the box the standard:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>null</p>\n</li>\n<li>\n<p>boolean</p>\n</li>\n<li>\n<p>number</p>\n</li>\n<li>\n<p>string</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>There is also an optimistic cast for temporal types (TIME, DATE, TIMESTAMP) and optionally disabled for UUID. UUIDs\nare supported by many databases but not all. For example MySQL does not support it so the recommended way is to use\na VARCHAR(36) column. For other engines UUID optimistic casting can be enabled using the client config json as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{ \"castUUID\": true }</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When this config is present UUIDs will be handled as a native type.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_use_as_osgi_bundle\"><a class=\"anchor\" href=\"#_use_as_osgi_bundle\"></a>Use as OSGi bundle</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x JDBC client can be used as an OSGi bundle. However notice that you would need to deploy all dependencies\nfirst. Some connection pool requires the JDBC driver to be loaded from the classpath, and so cannot be packaged /\ndeployed as bundle.</p>\n</div>\n</div>\n</div>","version":"3.9.1"},"__N_SSG":true}