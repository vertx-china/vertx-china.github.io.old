{"pageProps":{"slug":"vertx-jdbc-client/java","title":"Vert.x JDBC 客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_the_sql_client_api\">使用Sql 客户端 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_db_pool\">创建一个数据库连接池</a></li>\n</ul>\n</li>\n<li><a href=\"#_legacy_jdbc_client_api\">旧版JDBC客户端API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_a_connection\">建立连接</a></li>\n<li><a href=\"#_simple_sql_operations\">简单的SQL操作</a></li>\n<li><a href=\"#_creating_a_the_client\">创建一个客户端</a></li>\n<li><a href=\"#_closing_the_client\">关闭客户端</a></li>\n<li><a href=\"#_the_sql_connection\">SQL连接</a></li>\n<li><a href=\"#_configuration\">配置项</a></li>\n<li><a href=\"#_data_types\">数据类型</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x JDBC 客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Verx.x JDBC 客户端允许您使用 Vert.x 应用程序中的异步API\n与任何符合JDBC协议的数据库进行交互。</p>\n</div>\n<div class=\"paragraph\">\n<p>JDBC 客户端 API 接口描述请参考 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\">JDBCClient</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>如需使用Vert.x JDBC Client，请先将以下依赖添加到您的构建描述中的 <em>依赖</em> 部分 ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件中添加）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-jdbc-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中添加）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-jdbc-client:4.0.2'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_sql_client_api\"><a class=\"anchor\" href=\"#_using_the_sql_client_api\"></a>使用Sql 客户端 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>SQL客户端是使用SQL数据库通信的vert.x响应式API，\n已经实现了MySQL、PostgreSQL、MSSQL和IBM DB2等多个流行数据的异步驱动程序。\n但是，由于还有许多其他数据库没有异步驱动程序，\n因此JDBC客户端实现了相同的API，直接使用JDBC驱动，以实现数据库的异步支持。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_db_pool\"><a class=\"anchor\" href=\"#_creating_a_db_pool\"></a>创建一个数据库连接池</h3>\n<div class=\"paragraph\">\n<p>一切始于连接池，创建一个连接池是非常简单的。最简单的例子如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JDBCPool pool = JDBCPool.pool(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，我们将重用JDBC client 的 API 来创建池。\n该配置为自由格式，用户需要查找对应JDBC连接池所需的属性。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于类型安全的替代方案， 存在第二种工厂方法。\n第二种工厂方法可确保配置正确(因为其属性和类型已由编译器验证)，\n但当前仅适用于Agroal连接池。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JDBCPool pool = JDBCPool.pool(\n  vertx,\n  <span class=\"hljs-comment\">// configure the connection</span>\n  <span class=\"hljs-keyword\">new</span> JDBCConnectOptions()\n    <span class=\"hljs-comment\">// H2 connection string</span>\n    .setJdbcUrl(<span class=\"hljs-string\">\"jdbc:h2:~/test\"</span>)\n    <span class=\"hljs-comment\">// username</span>\n    .setUser(<span class=\"hljs-string\">\"sa\"</span>)\n    <span class=\"hljs-comment\">// password</span>\n    .setPassword(<span class=\"hljs-string\">\"\"</span>),\n  <span class=\"hljs-comment\">// configure the pool</span>\n  <span class=\"hljs-keyword\">new</span> PoolOptions()\n    .setMaxSize(<span class=\"hljs-number\">16</span>)\n);</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_the_pool\"><a class=\"anchor\" href=\"#_using_the_pool\"></a>使用连接池</h4>\n<div class=\"paragraph\">\n<p>有了链接池后，就可以开始使用数据库了，连接池以两种模式运行：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>托管连接模式</p>\n</li>\n<li>\n<p>手动连接方式</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>在托管连接模式下工作时，\n作为用户，您无需关心获取连接和将其返回到池中。\n可以直接对该链接池运行查询，并且该链接池可确保在查询终止后获取并返回连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .query(<span class=\"hljs-string\">\"SELECT * FROM user\"</span>)\n  .execute()\n  .onFailure(e -&gt; {\n    <span class=\"hljs-comment\">// handle the failure</span>\n  })\n  .onSuccess(rows -&gt; {\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(row.getString(<span class=\"hljs-string\">\"FIRST_NAME\"</span>));\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这也适用于准备好的sql语句：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM user WHERE emp_id &gt; ?\"</span>)\n  <span class=\"hljs-comment\">// the emp id to look up</span>\n  .execute(Tuple.of(<span class=\"hljs-number\">1000</span>))\n  .onFailure(e -&gt; {\n    <span class=\"hljs-comment\">// handle the failure</span>\n  })\n  .onSuccess(rows -&gt; {\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(row.getString(<span class=\"hljs-string\">\"FIRST_NAME\"</span>));\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>使用此模式非常方便，因为它使您可以专注于业务逻辑，而不是连接管理。\n有时可能需要保留秩序和因果关系。\n在这种情况下，我们需要在手动连接模式下执行查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .getConnection()\n  .onFailure(e -&gt; {\n    <span class=\"hljs-comment\">// failed to get a connection</span>\n  })\n  .onSuccess(conn -&gt; {\n    conn\n      .query(<span class=\"hljs-string\">\"SELECT * FROM user\"</span>)\n      .execute()\n      .onFailure(e -&gt; {\n        <span class=\"hljs-comment\">// handle the failure</span>\n\n        <span class=\"hljs-comment\">// very important! don't forget to return the connection</span>\n        conn.close();\n      })\n      .onSuccess(rows -&gt; {\n        <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n          System.out.println(row.getString(<span class=\"hljs-string\">\"FIRST_NAME\"</span>));\n        }\n\n        <span class=\"hljs-comment\">// very important! don't forget to return the connection</span>\n        conn.close();\n      });\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当然，预准备的sql语句也适用于此模式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .getConnection()\n  .onFailure(e -&gt; {\n    <span class=\"hljs-comment\">// failed to get a connection</span>\n  })\n  .onSuccess(conn -&gt; {\n    conn\n      .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM user WHERE emp_id &gt; ?\"</span>)\n      <span class=\"hljs-comment\">// the emp_id to look up</span>\n      .execute(Tuple.of(<span class=\"hljs-number\">1000</span>))\n      .onFailure(e -&gt; {\n        <span class=\"hljs-comment\">// handle the failure</span>\n\n        <span class=\"hljs-comment\">// very important! don't forget to return the connection</span>\n        conn.close();\n      })\n      .onSuccess(rows -&gt; {\n        <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n          System.out.println(row.getString(<span class=\"hljs-string\">\"FIRST_NAME\"</span>));\n        }\n\n        <span class=\"hljs-comment\">// very important! don't forget to return the connection</span>\n        conn.close();\n      });\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_legacy_jdbc_client_api\"><a class=\"anchor\" href=\"#_legacy_jdbc_client_api\"></a>旧版JDBC客户端API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>现在已弃用Vert.x 3中创建的JDBC客户端API，而应使用新的SQL客户端API。</p>\n</div>\n<div class=\"paragraph\">\n<p>在Vert.x 4的生命周期内仍将支持该功能，\n以允许将应用程序迁移到新的SQL Client API。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>建立连接</h3>\n<div class=\"paragraph\">\n<p>创建客户端后，您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#getConnection-io.vertx.core.Handler-\">getConnection</a></code>\n以获取一个连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>当池中有连接处于准备（ready）状态时，将在处理器（handler）中返回。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.getConnection(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    SQLConnection connection = res.result();\n\n    connection.query(<span class=\"hljs-string\">\"SELECT * FROM some_table\"</span>, res2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (res2.succeeded()) {\n\n        ResultSet rs = res2.result();\n        <span class=\"hljs-comment\">// Do something with results</span>\n      }\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed to get connection - deal with it</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该连接是 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html\">SQLConnection</a></code> 的一个实例，\n它是一个通用接口，不仅由Vert.x JDBC客户端使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以在 <a href=\"http://vertx.io/docs/vertx-sql-common/java/\">常见的sql接口</a> 文档中学习如何使用它。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simple_sql_operations\"><a class=\"anchor\" href=\"#_simple_sql_operations\"></a>简单的SQL操作</h3>\n<div class=\"paragraph\">\n<p>有时，您将需要运行单个SQL操作，\n例如：单行查询或对一组行的更新，这些操作不需要成为事务的一部分，也不必依赖于上一个或下一个操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于这些情况，客户端提供了无模板的API <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLOperations.html\">SQLOperations</a></code> ，\n该接口将为您执行以下步骤：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>从连接池获取连接</p>\n</li>\n<li>\n<p>执行您的动作</p>\n</li>\n<li>\n<p>关闭并将连接返回到连接池</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>从`USERS`表中加载用户的示例如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.query(<span class=\"hljs-string\">\"SELECT * FROM USERS\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      ResultSet result = ar.result();\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// Failed!</span>\n    }\n    <span class=\"hljs-comment\">// NOTE that you don't need to worry about</span>\n    <span class=\"hljs-comment\">// the connection management (e.g.: close)</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过一个简单的 \"shot\" 方法调用来执行以下操作：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#query-java.lang.String-io.vertx.core.Handler-\">query</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#queryWithParams-java.lang.String-io.vertx.core.json.JsonArray-io.vertx.core.Handler-\">queryWithParams</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLOperations.html#querySingle-java.lang.String-io.vertx.core.Handler-\">querySingle</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLOperations.html#querySingleWithParams-java.lang.String-io.vertx.core.json.JsonArray-io.vertx.core.Handler-\">querySingleWithParams</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#update-java.lang.String-io.vertx.core.Handler-\">update</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#updateWithParams-java.lang.String-io.vertx.core.json.JsonArray-io.vertx.core.Handler-\">updateWithParams</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#call-java.lang.String-io.vertx.core.Handler-\">call</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#callWithParams-java.lang.String-io.vertx.core.json.JsonArray-io.vertx.core.json.JsonArray-io.vertx.core.Handler-\">callWithParams</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>有关这些API的更多详细信息，请参阅 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLOperations.html\">SQLOperations</a></code> 接口。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_the_client\"><a class=\"anchor\" href=\"#_creating_a_the_client\"></a>创建一个客户端</h3>\n<div class=\"paragraph\">\n<p>有几种创建客户端的方法。让我们把它们都过一遍。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_default_shared_data_source\"><a class=\"anchor\" href=\"#_using_default_shared_data_source\"></a>使用默认的共享数据源</h4>\n<div class=\"paragraph\">\n<p>在大多数情况下，您需要在不同的客户端实例之间共享数据源。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您通过部署多个Verticle实例来扩展应用程序，并且希望每个Verticle实例共享相同的数据源，这样就不会有多个链接池。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以按照以下步骤进行操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SQLClient client = JDBCClient.createShared(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>第一次调用 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">JDBCClient.createShared</a></code>\n将实际创建数据源，并使用指定的配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>随后的调用将返回使用相同数据源的新客户端实例，因此将不会使用该配置。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_specifying_a_data_source_name\"><a class=\"anchor\" href=\"#_specifying_a_data_source_name\"></a>指定数据源名称</h4>\n<div class=\"paragraph\">\n<p>您可以创建一个指定数据源名称的客户端，如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SQLClient client = JDBCClient.createShared(vertx, config, <span class=\"hljs-string\">\"MyDataSource\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果使用相同的Vert.x实例并指定相同的数据源名称创建了不同的客户端，\n则它们将共享相同的数据源。</p>\n</div>\n<div class=\"paragraph\">\n<p>第一次调用 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">JDBCClient.createShared</a></code>\n将实际创建数据源，并使用指定的配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>后续调用将返回使用相同数据源的新客户端实例，因此将不使用该配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您希望不同的客户端组具有不同的数据源(例如，它们与不同的数据库进行交互)，请使用这种创建方式。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_creating_a_client_with_a_non_shared_data_source\"><a class=\"anchor\" href=\"#_creating_a_client_with_a_non_shared_data_source\"></a>使用非共享数据源创建客户端</h4>\n<div class=\"paragraph\">\n<p>在大多数情况下，您将需要在不同的客户端实例之间共享数据源。\n但是，您可能想要创建一个不与任何其他客户端共享其数据源的客户端实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，\n您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html#create-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">JDBCClient.create</a></code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SQLClient client = JDBCClient.create(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这等效于 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-java.lang.String-\">JDBCClient.createShared</a></code>\n每次使用唯一的数据源名称进行调用。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_specifying_a_data_source\"><a class=\"anchor\" href=\"#_specifying_a_data_source\"></a>指定数据源</h4>\n<div class=\"paragraph\">\n<p>如果您已经有一个预先存在的数据源，则还可以直接指定以下内容来创建客户端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SQLClient client = JDBCClient.create(vertx, dataSource);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_closing_the_client\"><a class=\"anchor\" href=\"#_closing_the_client\"></a>关闭客户端</h3>\n<div class=\"paragraph\">\n<p>长时间保持客户端（例如，在您的verticle的生命周期内）是可以的，\n但是一旦完成，就应该关闭它。</p>\n</div>\n<div class=\"paragraph\">\n<p>共享同一数据源的客户端将计算引用次数（reference counted）。\n一旦最后一个引用的相同数据源被关闭，该数据源将被关闭。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_automatic_clean_up_in_verticles\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles\"></a>verticles中自动清理</h4>\n<div class=\"paragraph\">\n<p>如果要从verticle内部创建客户端，则取消部署verticle时将自动关闭客户端。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_sql_connection\"><a class=\"anchor\" href=\"#_the_sql_connection\"></a>SQL连接</h3>\n<div class=\"paragraph\">\n<p>与数据库的连接用表示 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html\">SQLConnection</a></code>。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_auto_commit\"><a class=\"anchor\" href=\"#_auto_commit\"></a>自动提交</h4>\n<div class=\"paragraph\">\n<p>获取连接时，自动提交设置为true。\n这意味着您执行的每个操作将有效地在其自己的事务中执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您希望在单个事务中执行多个操作，\n则应使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#setAutoCommit-boolean-io.vertx.core.Handler-\">setAutoCommit</a></code> 将自动提交设置为false</p>\n</div>\n<div class=\"paragraph\">\n<p>操作完成后，将调用处理程序：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.setAutoCommit(<span class=\"hljs-keyword\">false</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// OK!</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_executing_queries\"><a class=\"anchor\" href=\"#_executing_queries\"></a>执行查询</h4>\n<div class=\"paragraph\">\n<p>执行查询使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#query-java.lang.String-io.vertx.core.Handler-\">query</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>查询字符串是传递给实际数据库的原始SQL。</p>\n</div>\n<div class=\"paragraph\">\n<p>当执行查询时，\n结果通过 <code><a href=\"../../apidocs/io/vertx/ext/sql/ResultSet.html\">ResultSet</a></code> 返回。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.query(<span class=\"hljs-string\">\"SELECT ID, FNAME, LNAME, SHOE_SIZE from PEOPLE\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Get the result set</span>\n    ResultSet resultSet = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/sql/ResultSet.html\">ResultSet</a></code> 表示查询的结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>列名称列表可通过 <code><a href=\"../../apidocs/io/vertx/ext/sql/ResultSet.html#getColumnNames--\">getColumnNames</a></code> 获取，\n而实际结果通过 <code><a href=\"../../apidocs/io/vertx/ext/sql/ResultSet.html#getResults--\">getResults</a></code> 获取。</p>\n</div>\n<div class=\"paragraph\">\n<p>结果是 <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> 类型，每个元素对应一行查询结果</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;String&gt; columnNames = resultSet.getColumnNames();\n\nList&lt;JsonArray&gt; results = resultSet.getResults();\n\n<span class=\"hljs-keyword\">for</span> (JsonArray row : results) {\n\n  String id = row.getString(<span class=\"hljs-number\">0</span>);\n  String fName = row.getString(<span class=\"hljs-number\">1</span>);\n  String lName = row.getString(<span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-keyword\">int</span> shoeSize = row.getInteger(<span class=\"hljs-number\">3</span>);\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还可以使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/ResultSet.html#getRows--\">getRows</a></code>\n- 作为Json对象实例的列表来检索行\n- 这可以使您使用的API稍微简单一些，但是请注意，SQL结果可以包含重复的列名 - 如果是这种情况\n则应改用 <code><a href=\"../../apidocs/io/vertx/ext/sql/ResultSet.html#getResults--\">getResults</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>使用Json对象作为返回类型，进行迭代的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;JsonObject&gt; rows = resultSet.getRows();\n\n<span class=\"hljs-keyword\">for</span> (JsonObject row : rows) {\n\n  String id = row.getString(<span class=\"hljs-string\">\"ID\"</span>);\n  String fName = row.getString(<span class=\"hljs-string\">\"FNAME\"</span>);\n  String lName = row.getString(<span class=\"hljs-string\">\"LNAME\"</span>);\n  <span class=\"hljs-keyword\">int</span> shoeSize = row.getInteger(<span class=\"hljs-string\">\"SHOE_SIZE\"</span>);\n\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_prepared_statement_queries\"><a class=\"anchor\" href=\"#_prepared_statement_queries\"></a>预备语句查询</h4>\n<div class=\"paragraph\">\n<p>要执行准备好的语句查询，\n可以使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#queryWithParams-java.lang.String-io.vertx.core.json.JsonArray-io.vertx.core.Handler-\">queryWithParams</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将执行查询，其中包括参数占位符和一个 <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code>\n或参数值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String query = <span class=\"hljs-string\">\"SELECT ID, FNAME, LNAME, SHOE_SIZE from PEOPLE WHERE LNAME=? AND SHOE_SIZE &gt; ?\"</span>;\nJsonArray params = <span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">\"Fox\"</span>).add(<span class=\"hljs-number\">9</span>);\n\nconnection.queryWithParams(query, params, res -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Get the result set</span>\n    ResultSet resultSet = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_executing_insert_update_or_delete\"><a class=\"anchor\" href=\"#_executing_insert_update_or_delete\"></a>执行INSERT，UPDATE或DELETE</h4>\n<div class=\"paragraph\">\n<p>要执行更新数据库的操作，请使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#update-java.lang.String-io.vertx.core.Handler-\">update</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>更新字符串是原始SQL，无需更改实际数据库即可通过。</p>\n</div>\n<div class=\"paragraph\">\n<p>更新执行完成后，\n通过回调返回 <code><a href=\"../../apidocs/io/vertx/ext/sql/UpdateResult.html\">UpdateResult</a></code> 的结果</p>\n</div>\n<div class=\"paragraph\">\n<p>更新内容的行数通过 <code><a href=\"../../apidocs/io/vertx/ext/sql/UpdateResult.html#getUpdated--\">getUpdated</a></code> 获取，\n如果更新生成了键，则可以使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/UpdateResult.html#getKeys--\">getKeys</a></code> 获取</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.update(<span class=\"hljs-string\">\"INSERT INTO PEOPLE VALUES (null, 'john', 'smith', 9)\"</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    UpdateResult result = res.result();\n    System.out.println(<span class=\"hljs-string\">\"Updated no. of rows: \"</span> + result.getUpdated());\n    System.out.println(<span class=\"hljs-string\">\"Generated keys: \"</span> + result.getKeys());\n\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_prepared_statement_updates\"><a class=\"anchor\" href=\"#_prepared_statement_updates\"></a>准备的语句更新</h4>\n<div class=\"paragraph\">\n<p>要执行准备好的语句更新，\n可以使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#updateWithParams-java.lang.String-io.vertx.core.json.JsonArray-io.vertx.core.Handler-\">updateWithParams</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种方式的更新语句包含参数占位符，\n和JsonArray参数列表或参数值进行更新</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String update = <span class=\"hljs-string\">\"UPDATE PEOPLE SET SHOE_SIZE = 10 WHERE LNAME=?\"</span>;\nJsonArray params = <span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">\"Fox\"</span>);\n\nconnection.updateWithParams(update, params, res -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    UpdateResult updateResult = res.result();\n\n    System.out.println(<span class=\"hljs-string\">\"No. of rows updated: \"</span> + updateResult.getUpdated());\n\n  } <span class=\"hljs-keyword\">else</span> {\n\n    <span class=\"hljs-comment\">// Failed!</span>\n\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_callable_statements\"><a class=\"anchor\" href=\"#_callable_statements\"></a>可赎回声明</h4>\n<div class=\"paragraph\">\n<p>要执行可调用语句(SQL函数或SQL过程)，可以使用\n<code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#callWithParams-java.lang.String-io.vertx.core.json.JsonArray-io.vertx.core.json.JsonArray-io.vertx.core.Handler-\">callWithParams</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将使用标准JDBC格式 <code>{call func_proc_name()}</code> 接受可调用语句，\n还可以选择包含参数占位符，例如：<code>{call func_proc_name(?,?)}</code> ，\n<code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> 包含参数值，\n最后是 <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> 包含输出类型，例如： <code>[null，'VARCHAR']</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意，输出类型的索引与params数组一样重要。\n如果返回值是第二个参数，则输出数组必须包含一个空值作为第一个元素。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个SQL函数使用return关键字返回一些输出，在这种情况下，可以这样调用它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String func = <span class=\"hljs-string\">\"{ call one_hour_ago() }\"</span>;\n\nconnection.call(func, res -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    ResultSet result = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在使用Procedures时，仍然通过其参数从过程中返回值，如果不返回任何内容，\n用法如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String func = <span class=\"hljs-string\">\"{ call new_customer(?, ?) }\"</span>;\n\nconnection.callWithParams(func, <span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">\"John\"</span>).add(<span class=\"hljs-string\">\"Doe\"</span>), <span class=\"hljs-keyword\">null</span>, res -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Success!</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>但是，您还可以返回如下值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String func = <span class=\"hljs-string\">\"{ call customer_lastname(?, ?) }\"</span>;\n\nconnection.callWithParams(func, <span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">\"John\"</span>), <span class=\"hljs-keyword\">new</span> JsonArray().addNull().add(<span class=\"hljs-string\">\"VARCHAR\"</span>), res -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    ResultSet result = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意，参数的索引与 <code>?</code> 的索引匹配，\n并且输出参数期望是描述您要接收的类型的字符串。</p>\n</div>\n<div class=\"paragraph\">\n<p>为避免歧义，实现应遵循以下规则：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当 <code>IN</code> 数组中的占位符为 <code>NOT NULL</code> 时，它将被采用</p>\n</li>\n<li>\n<p>当 <code>IN</code> 值为 <code>NULL</code> 时，对 <code>OUT</code> 进行检查\n当 <code>OUT</code> 值不为空时，它将被注册为输出参数\n当 <code>OUT</code> 也为空时，预期 <code>IN</code> 值为 <code>NULL</code> 值。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>已注册的 <code>OUT</code> 参数将以数组形式出现在 <code>output</code> 属性下的结果集中。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_batch_operations\"><a class=\"anchor\" href=\"#_batch_operations\"></a>批量操作</h4>\n<div class=\"paragraph\">\n<p>SQL通用接口还定义了如何执行批处理操作。批处理操作分为3种类型：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>批量执行sql语句 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#batch-java.util.List-io.vertx.core.Handler-\">batch</a></code></p>\n</li>\n<li>\n<p>批量执行预处理sql语句 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#batchWithParams-java.lang.String-java.util.List-io.vertx.core.Handler-\">batchWithParams</a></code></p>\n</li>\n<li>\n<p>批量执行可调用语句 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#batchCallableWithParams-java.lang.String-java.util.List-java.util.List-io.vertx.core.Handler-\">batchCallableWithParams</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>批量执行sql语句示例如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;String&gt; batch = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\nbatch.add(<span class=\"hljs-string\">\"INSERT INTO emp (NAME) VALUES ('JOE')\"</span>);\nbatch.add(<span class=\"hljs-string\">\"INSERT INTO emp (NAME) VALUES ('JANE')\"</span>);\n\nconnection.batch(batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    List&lt;Integer&gt; result = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>执行一个预处理sql语句，并且使用一个参数列表，示例如下</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;JsonArray&gt; batch = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\nbatch.add(<span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">\"joe\"</span>));\nbatch.add(<span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">\"jane\"</span>));\n\nconnection.batchWithParams(<span class=\"hljs-string\">\"INSERT INTO emp (name) VALUES (?)\"</span>, batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    List&lt;Integer&gt; result = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_executing_other_operations\"><a class=\"anchor\" href=\"#_executing_other_operations\"></a>执行其他操作</h4>\n<div class=\"paragraph\">\n<p>要执行任何其他数据库操作，例如 <code>CREATE TABLE</code> 您可以使用\n<code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#execute-java.lang.String-io.vertx.core.Handler-\">execute</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>sql语句将会直接在数据库中执行。操作完成后调用处理程序</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String sql = <span class=\"hljs-string\">\"CREATE TABLE PEOPLE (ID int generated by default as identity (start with 1 increment by 1) not null,\"</span> +\n  <span class=\"hljs-string\">\"FNAME varchar(255), LNAME varchar(255), SHOE_SIZE int);\"</span>;\n\nconnection.execute(sql, execute -&gt; {\n  <span class=\"hljs-keyword\">if</span> (execute.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Table created !\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_multiple_resultset_responses\"><a class=\"anchor\" href=\"#_multiple_resultset_responses\"></a>多个ResultSet响应</h4>\n<div class=\"paragraph\">\n<p>在某些情况下，您的查询可能返回多个结果集，\n在这种情况下，为了保持兼容性，当返回的结果集对象转换为纯json时，使用当前结果集的 <code>next</code> 链接到下一个结果集。\n可以像这样简单地遍历所有结果集：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">while</span> (rs != <span class=\"hljs-keyword\">null</span>) {\n  <span class=\"hljs-comment\">// do something with the result set...</span>\n\n  <span class=\"hljs-comment\">// next step</span>\n  rs = rs.getNext();\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming\"><a class=\"anchor\" href=\"#_streaming\"></a>流式返回</h4>\n<div class=\"paragraph\">\n<p>在处理大量数据返回时，建议不要使用刚刚描述的API，而是使用流式返回。\n因为这样可以避免将整个响应内容填充到内存和JSON中，而是逐行处理数据，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.queryStream(<span class=\"hljs-string\">\"SELECT * FROM large_table\"</span>, stream -&gt; {\n  <span class=\"hljs-keyword\">if</span> (stream.succeeded()) {\n    stream.result().handler(row -&gt; {\n      <span class=\"hljs-comment\">// do something with the row...</span>\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以完全控制流何时暂停，恢复和结束。\n对于查询返回多个结果集的情况，您应该使用结果集结束事件来获取下一个结果(如果有)。\n如果有更多数据，则流处理程序将接收新数据，否则将调用结束处理程序。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.queryStream(<span class=\"hljs-string\">\"SELECT * FROM large_table; SELECT * FROM other_table\"</span>, stream -&gt; {\n  <span class=\"hljs-keyword\">if</span> (stream.succeeded()) {\n    SQLRowStream sqlRowStream = stream.result();\n\n    sqlRowStream\n      .resultSetClosedHandler(v -&gt; {\n        <span class=\"hljs-comment\">// will ask to restart the stream with the new result set if any</span>\n        sqlRowStream.moreResults();\n      })\n      .handler(row -&gt; {\n        <span class=\"hljs-comment\">// do something with the row...</span>\n      })\n      .endHandler(v -&gt; {\n        <span class=\"hljs-comment\">// no more data available...</span>\n      });\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_transactions\"><a class=\"anchor\" href=\"#_using_transactions\"></a>使用事务</h4>\n<div class=\"paragraph\">\n<p>要使用事务，请先使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#setAutoCommit-boolean-io.vertx.core.Handler-\">setAutoCommit</a></code> 将自动提交设置为false。</p>\n</div>\n<div class=\"paragraph\">\n<p>然后，您可以进行事务性操作，并在要提交或回滚时使用\n<code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#commit-io.vertx.core.Handler-\">commit</a></code>\n或\n<code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#rollback-io.vertx.core.Handler-\">rollback</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>提交/回滚完成后，将调用处理程序，并且下一个事务将自动启动。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.commit(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Committed OK!</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_connections\"><a class=\"anchor\" href=\"#_closing_connections\"></a>关闭连接</h4>\n<div class=\"paragraph\">\n<p>完成连接后，应使用 <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html#close-io.vertx.core.Handler-\">close</a></code> 将其返回到池中。</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in index.adoc - include::override/rxjava2.adoc[]</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>配置项</h3>\n<div class=\"paragraph\">\n<p>在创建或部署配置时，会将配置传递给客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下配置属性通常适用：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>provider_class</code></dt>\n<dd>\n<p>实际用于管理数据库连接的类的类名。\n默认情况下是， <code>io.vertx.ext.jdbc.spi.impl.C3P0DataSourceProvider</code> 但是如果您要使用其他提供程序，则可以覆盖此属性并提供您的实现。</p>\n</dd>\n<dt class=\"hdlist1\"><code>row_stream_fetch_size</code></dt>\n<dd>\n<p><code>SQLRowStream</code> 内部缓存的大小，\n曾经用来提高性能。默认情况下等于128</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>假设正在使用C3P0实现(默认设置)，则将应用以下额外的配置属性：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>url</code></dt>\n<dd>\n<p>数据库的JDBC连接URL</p>\n</dd>\n<dt class=\"hdlist1\"><code>driver_class</code></dt>\n<dd>\n<p>JDBC驱动程序的类</p>\n</dd>\n<dt class=\"hdlist1\"><code>user</code></dt>\n<dd>\n<p>数据库的用户名</p>\n</dd>\n<dt class=\"hdlist1\"><code>password</code></dt>\n<dd>\n<p>数据库的密码</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_pool_size</code></dt>\n<dd>\n<p>池的最大连接数 ， 默认为 <code>15</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>initial_pool_size</code></dt>\n<dd>\n<p>用于初始化池的连接数 ， 默认为 <code>3</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>min_pool_size</code></dt>\n<dd>\n<p>连接池的最小连接数</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_statements</code></dt>\n<dd>\n<p><code>PreparedStatement</code> 缓存的数量，默认值为 <code>0</code>。</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_statements_per_connection</code></dt>\n<dd>\n<p>每个链接 <code>PreparedStatement</code> 缓存的数量 ， 默认值为 <code>0</code>。</p>\n</dd>\n<dt class=\"hdlist1\"><code>max_idle_time</code></dt>\n<dd>\n<p>空闲连接将关闭之前经过的秒数 ，默认值为 <code>0</code> (永不过期)。</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>其他连接池提供程序是：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Hikari</p>\n</li>\n<li>\n<p>Agroal</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>与C3P0类似，它们可以通过在JSON配置对象上传递配置值来进行配置。\n对于特殊情况，您不想将应用程序部署为 <em>fat jar</em> ，而是使用 vert.x 发行版运行，\n如果您没有写权限将JDBC驱动程序添加到vert.x lib目录，\n并使用 <code>-cp</code> 命令行标志传递它，则建议使用Agroal。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果要配置任何其他C3P0属性，可以将文件 <code>c3p0.properties</code> 添加到类路径。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是配置服务的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject config = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">\"url\"</span>, <span class=\"hljs-string\">\"jdbc:hsqldb:mem:test?shutdown=true\"</span>)\n  .put(<span class=\"hljs-string\">\"driver_class\"</span>, <span class=\"hljs-string\">\"org.hsqldb.jdbcDriver\"</span>)\n  .put(<span class=\"hljs-string\">\"max_pool_size\"</span>, <span class=\"hljs-number\">30</span>);\n\nSQLClient client = JDBCClient.createShared(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Hikari使用一组不同的属性：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>jdbcUrl</code> JDBC的URL</p>\n</li>\n<li>\n<p><code>driverClassName</code> JDBC驱动的类名</p>\n</li>\n<li>\n<p><code>maximumPoolSize</code> 连接池的大小</p>\n</li>\n<li>\n<p><code>username</code> 数据库用户名（<code>password</code> 数据库密码）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>有关更多详细信息，\n请参阅 <a href=\"https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby\">Hikari documentation</a> 。\n另请参阅  <a href=\"https://agroal.github.io/\">Agroal documentation</a> 以配置Agroal。</p>\n</div>\n<div id=\"_jdbc_drivers\" class=\"paragraph\">\n<p>JDBC驱动程序</p>\n</div>\n<div class=\"paragraph\">\n<p>如果使用默认值 <code>DataSourceProvider</code>(依赖于c3p0)，则需要在类路径中复制JDBC驱动程序类。\n如果您的应用程序打包为  <em>fat jar</em> ，请确保嵌入jdbc驱动程序。如果您的应用程序是通过 <code>vertx</code> 命令行启动的，请将JDBC驱动程序复制到 <code>${VERTX_HOME}/lib</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用不同的连接池时，行为可能会有所不同。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_data_types\"><a class=\"anchor\" href=\"#_data_types\"></a>数据类型</h3>\n<div class=\"paragraph\">\n<p>由于Vert.x使用JSON作为其标准消息格式，因此客户端接受的数据类型会有很多限制。\n您可以获取标准的：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>null</p>\n</li>\n<li>\n<p>boolean</p>\n</li>\n<li>\n<p>number</p>\n</li>\n<li>\n<p>string</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>对于时态类型(时间、日期、时间戳)也有一个乐观强制转换，对于UUID也可以选择禁用。许多数据库支持uuid，但并非所有数据库都支持。\n例如MySQL不支持它，所以建议使用VARCHAR(36)列。\n对于其他引擎，可以使用客户端配置json启用UUID乐观强制转换，如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{ \"castUUID\": true }</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当此配置存在时，uuid将作为本机类型处理。</p>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}