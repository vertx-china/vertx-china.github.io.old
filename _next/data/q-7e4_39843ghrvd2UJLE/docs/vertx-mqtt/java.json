{"pageProps":{"slug":"vertx-mqtt/java","title":"Vert.x MQTT","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_mqtt\">使用 Vert.x MQTT</a></li>\n<li><a href=\"#_vert_x_mqtt_server\">Vert.x MQTT 服务端</a>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">开始</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_handling_client_connectiondisconnection\">处理客户端连接/断开</a></li>\n<li><a href=\"#_handling_client_connectiondisconnection_with_ssltls_support\">支持使用SSL / TLS 处理客户端连接/断开连接</a></li>\n<li><a href=\"#_handling_client_connections_via_websocket\">通过 WebSocket 处理客户端的连接</a></li>\n<li><a href=\"#_handling_client_subscriptionunsubscription_request\">处理客户端 订阅/退订 请求</a></li>\n<li><a href=\"#_handling_client_published_message\">处理客户端发布的消息</a></li>\n<li><a href=\"#_publish_message_to_the_client\">发布消息到客户端</a></li>\n<li><a href=\"#_be_notified_by_client_keep_alive\">客户端保活通知</a></li>\n<li><a href=\"#_closing_the_server\">关闭服务端</a></li>\n<li><a href=\"#_automatic_clean_up_in_verticles\">在verticles中自动清理</a></li>\n<li><a href=\"#_scaling_sharing_mqtt_servers\">扩展：共享MQTT服务器</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#_vert_x_mqtt_client\">Vert.x MQTT 客户端</a>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started_2\">开始</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_connectdisconnect\">连接建立/连接断开</a></li>\n<li><a href=\"#_subscribe_to_a_topic\">订阅主题消息</a></li>\n<li><a href=\"#_publishing_message_to_a_topic\">发布主题消息</a></li>\n<li><a href=\"#_keep_connection_with_server_alive\">与服务端保持连接</a></li>\n<li><a href=\"#_be_notified_when\">通知时机</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x MQTT</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_mqtt\"><a class=\"anchor\" href=\"#_using_vert_x_mqtt\"></a>使用 Vert.x MQTT</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>这个组件已经在Vertx栈中正式发布了，现在只需要在构建描述符中添加如下内容即可使用：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mqtt<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile io.<span class=\"hljs-string\">vertx:</span>vertx-<span class=\"hljs-string\">mqtt:</span><span class=\"hljs-number\">4.0</span><span class=\"hljs-number\">.2</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<h1 id=\"_vert_x_mqtt_server\" class=\"sect0\"><a class=\"anchor\" href=\"#_vert_x_mqtt_server\"></a>Vert.x MQTT 服务端</h1>\n<div class=\"paragraph\">\n<p>这个组件提供了一个服务，它能处理远程 <a href=\"http://mqtt.org/\">MQTT</a> 连接，通信和信息交换。\n它的API提供了一系列接收客户端原生协议消息的事件，并且提供了一些发送信息到客户端的功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>它不是一个功能齐全的MQTT broker，但可以用来建立类似的东西或者进行协议转换</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n这个模块还处于技术预览阶段,这意味着它的API在接下来的版本中可能会改变\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>开始</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_handling_client_connectiondisconnection\"><a class=\"anchor\" href=\"#_handling_client_connectiondisconnection\"></a>处理客户端连接/断开</h3>\n<div class=\"paragraph\">\n<p>这个例子展示了如何处理一个来自远程MQTT客户端的请求，首先，它会创建一个 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttServer.html\">MqttServer</a></code> 实例，\n然后使用endpointHandler方法指定一个处理器来处理远程客户端发送的CONNECT信息，一个 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code>\n实例会作为handler的参数传入，它携带了所有与CONNECT消息相关联的主要信息，例如客户端标识符，用户名/密码，\"will\"信息，session清除标志，协议版本和保活超时等。\n在handler内,<em>endpoint</em> 实例提供accept方法以相应的CONNACK消息响应远程客户端，通过这种方式，成功建立连接。\n最后，通过 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttServer.html#listen-io.vertx.core.Handler-\">listen</a></code> 方法启动一个默认的服务端（运行在localhost上并且默认MQTT端口为1883），\n这个方法同样允许指定一个 handler 来检查是否服务器是否已经正常启动。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MqttServer mqttServer = MqttServer.create(vertx);\nmqttServer.endpointHandler(endpoint -&gt; {\n\n  <span class=\"hljs-comment\">// shows main connect info</span>\n  System.out.println(<span class=\"hljs-string\">\"MQTT client [\"</span> + endpoint.clientIdentifier() + <span class=\"hljs-string\">\"] request to connect, clean session = \"</span> + endpoint.isCleanSession());\n\n  <span class=\"hljs-keyword\">if</span> (endpoint.auth() != <span class=\"hljs-keyword\">null</span>) {\n    System.out.println(<span class=\"hljs-string\">\"[username = \"</span> + endpoint.auth().getUsername() + <span class=\"hljs-string\">\", password = \"</span> + endpoint.auth().getPassword() + <span class=\"hljs-string\">\"]\"</span>);\n  }\n  <span class=\"hljs-keyword\">if</span> (endpoint.will() != <span class=\"hljs-keyword\">null</span>) {\n    System.out.println(<span class=\"hljs-string\">\"[will topic = \"</span> + endpoint.will().getWillTopic() + <span class=\"hljs-string\">\" msg = \"</span> + <span class=\"hljs-keyword\">new</span> String(endpoint.will().getWillMessageBytes()) +\n      <span class=\"hljs-string\">\" QoS = \"</span> + endpoint.will().getWillQos() + <span class=\"hljs-string\">\" isRetain = \"</span> + endpoint.will().isWillRetain() + <span class=\"hljs-string\">\"]\"</span>);\n  }\n\n  System.out.println(<span class=\"hljs-string\">\"[keep alive timeout = \"</span> + endpoint.keepAliveTimeSeconds() + <span class=\"hljs-string\">\"]\"</span>);\n\n  <span class=\"hljs-comment\">// accept connection from the remote client</span>\n  endpoint.accept(<span class=\"hljs-keyword\">false</span>);\n\n})\n  .listen(ar -&gt; {\n\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      System.out.println(<span class=\"hljs-string\">\"MQTT server is listening on port \"</span> + ar.result().actualPort());\n    } <span class=\"hljs-keyword\">else</span> {\n\n      System.out.println(<span class=\"hljs-string\">\"Error on starting the server\"</span>);\n      ar.cause().printStackTrace();\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当远程客户端发送一个 DISCONNECT 消息来主动断开与服务端的连接，这个 <em>endpoint</em> 实例提供了一个 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#disconnectHandler-io.vertx.core.Handler-\">disconnectHandler</a></code> 方法来指定 handler 进行处理，\n该handler没有参数</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">endpoint.disconnectHandler(v -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"Received disconnect from client\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_client_connectiondisconnection_with_ssltls_support\"><a class=\"anchor\" href=\"#_handling_client_connectiondisconnection_with_ssltls_support\"></a>支持使用SSL / TLS 处理客户端连接/断开连接</h3>\n<div class=\"paragraph\">\n<p>服务端支持通过SSL/TLS方式来授权和加密客户端的连接请求，为了做到这一点，<code><a href=\"../../apidocs/io/vertx/mqtt/MqttServerOptions.html\">MqttServerOptions</a></code> 类提供了 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttServerOptions.html#setSsl-boolean-\">setSsl</a></code>\n方法来启用 SSL/TLS(值设为true)，以及一些其他有用的方法来配置服务端证书和相关私钥（作为java键存储引用，PEM或PFX格式），在下面的例子中，<code><a href=\"../../apidocs/io/vertx/mqtt/MqttServerOptions.html#setKeyCertOptions-io.vertx.core.net.KeyCertOptions-\">setKeyCertOptions</a></code> 方法可以用来配置PEM格式的证书，\n这个方法需要一个 <code><a href=\"../../apidocs/io/vertx/core/net/KeyCertOptions.html\">KeyCertOptions</a></code> 接口的实例作为参数传入。与此同时，<code><a href=\"../../apidocs/io/vertx/core/net/PemKeyCertOptions.html\">PemKeyCertOptions</a></code> 类提供了\n<code><a href=\"../../apidocs/io/vertx/core/net/PemKeyCertOptions.html#setCertPath-java.lang.String-\">setCertPath</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/net/PemKeyCertOptions.html#setKeyPath-java.lang.String-\">setKeyPath</a></code> 来分别设置 服务端的证书和私钥的路径。\nMQTT服务端需要一个 Vert.x实例和一个上面提到的MQTT配置实例作为参数来启动。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MqttServerOptions options = <span class=\"hljs-keyword\">new</span> MqttServerOptions()\n  .setPort(<span class=\"hljs-number\">8883</span>)\n  .setKeyCertOptions(<span class=\"hljs-keyword\">new</span> PemKeyCertOptions()\n    .setKeyPath(<span class=\"hljs-string\">\"./src/test/resources/tls/server-key.pem\"</span>)\n    .setCertPath(<span class=\"hljs-string\">\"./src/test/resources/tls/server-cert.pem\"</span>))\n  .setSsl(<span class=\"hljs-keyword\">true</span>);\n\nMqttServer mqttServer = MqttServer.create(vertx, options);\nmqttServer.endpointHandler(endpoint -&gt; {\n\n  <span class=\"hljs-comment\">// shows main connect info</span>\n  System.out.println(<span class=\"hljs-string\">\"MQTT client [\"</span> + endpoint.clientIdentifier() + <span class=\"hljs-string\">\"] request to connect, clean session = \"</span> + endpoint.isCleanSession());\n\n  <span class=\"hljs-keyword\">if</span> (endpoint.auth() != <span class=\"hljs-keyword\">null</span>) {\n    System.out.println(<span class=\"hljs-string\">\"[username = \"</span> + endpoint.auth().getUsername() + <span class=\"hljs-string\">\", password = \"</span> + endpoint.auth().getPassword() + <span class=\"hljs-string\">\"]\"</span>);\n  }\n  <span class=\"hljs-keyword\">if</span> (endpoint.will() != <span class=\"hljs-keyword\">null</span>) {\n    System.out.println(<span class=\"hljs-string\">\"[will topic = \"</span> + endpoint.will().getWillTopic() + <span class=\"hljs-string\">\" msg = \"</span> + <span class=\"hljs-keyword\">new</span> String(endpoint.will().getWillMessageBytes()) +\n      <span class=\"hljs-string\">\" QoS = \"</span> + endpoint.will().getWillQos() + <span class=\"hljs-string\">\" isRetain = \"</span> + endpoint.will().isWillRetain() + <span class=\"hljs-string\">\"]\"</span>);\n  }\n\n  System.out.println(<span class=\"hljs-string\">\"[keep alive timeout = \"</span> + endpoint.keepAliveTimeSeconds() + <span class=\"hljs-string\">\"]\"</span>);\n\n  <span class=\"hljs-comment\">// accept connection from the remote client</span>\n  endpoint.accept(<span class=\"hljs-keyword\">false</span>);\n\n})\n  .listen(ar -&gt; {\n\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n      System.out.println(<span class=\"hljs-string\">\"MQTT server is listening on port \"</span> + ar.result().actualPort());\n    } <span class=\"hljs-keyword\">else</span> {\n\n      System.out.println(<span class=\"hljs-string\">\"Error on starting the server\"</span>);\n      ar.cause().printStackTrace();\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_client_connections_via_websocket\"><a class=\"anchor\" href=\"#_handling_client_connections_via_websocket\"></a>通过 WebSocket 处理客户端的连接</h3>\n<div class=\"paragraph\">\n<p>如果你想要通过 WebSocket 来进行连接，可以通过 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttServerOptions.html\">MqttServerOptions</a></code> 来启用它，\n调用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttServerOptions.html#setUseWebSocket-boolean-\">setUseWebSocket</a></code> 方法并设置参数为 <code>true</code> ，\n它将会监听 <code>/mqtt</code> 路径上所有的 websocket 连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>与其他连接的配置方式一样，这种方式下 endpoint 的连接创建以及连接断开与常规的连接管理方式相同。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DeploymentOptions options = <span class=\"hljs-keyword\">new</span> DeploymentOptions().setInstances(<span class=\"hljs-number\">10</span>);\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyVerticle\"</span>, options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_client_subscriptionunsubscription_request\"><a class=\"anchor\" href=\"#_handling_client_subscriptionunsubscription_request\"></a>处理客户端 订阅/退订 请求</h3>\n<div class=\"paragraph\">\n<p>在客户端和服务端的连接建立后，客户端可以发送 SUBSCRIBE 消息以订阅主题。 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code> 允许使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#subscribeHandler-io.vertx.core.Handler-\">subscribeHandler</a></code>\n方法来指定一个 handler 处理到来的订阅请求，这个 handler 接收一个 <code><a href=\"../../apidocs/io/vertx/mqtt/messages/MqttSubscribeMessage.html\">MqttSubscribeMessage</a></code> 类型的实例，该实例携带了主题列表以及客户端指定的 QoS 等级。\n最后，这个 endpoint 实例提供了 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#subscribeAcknowledge-int-java.util.List-\">subscribeAcknowledge</a></code> 方法来回复一个包含相关许可 QoS 等级的 SUBACK 消息给客户端。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">endpoint.subscribeHandler(subscribe -&gt; {\n\n  List&lt;MqttQoS&gt; grantedQosLevels = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n  <span class=\"hljs-keyword\">for</span> (MqttTopicSubscription s: subscribe.topicSubscriptions()) {\n    System.out.println(<span class=\"hljs-string\">\"Subscription for \"</span> + s.topicName() + <span class=\"hljs-string\">\" with QoS \"</span> + s.qualityOfService());\n    grantedQosLevels.add(s.qualityOfService());\n  }\n  <span class=\"hljs-comment\">// ack the subscriptions request</span>\n  endpoint.subscribeAcknowledge(subscribe.messageId(), grantedQosLevels);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>相应的，也可以使用endpoint上的 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#unsubscribeHandler-io.vertx.core.Handler-\">unsubscribeHandler</a></code> 方法来指定一个handler来处理客户端的UNSUBSCRIBE消息，\n这个handler接收一个携带退订主题列表的 <code><a href=\"../../apidocs/io/vertx/mqtt/messages/MqttUnsubscribeMessage.html\">MqttUnsubscribeMessage</a></code> 类型实例作为参数。\n最后，这个endpoint实例提供了 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#unsubscribeAcknowledge-int-\">unsubscribeAcknowledge</a></code> 方法来回复客户端相关的UNSUBACK消息。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">endpoint.unsubscribeHandler(unsubscribe -&gt; {\n\n  <span class=\"hljs-keyword\">for</span> (String t: unsubscribe.topics()) {\n    System.out.println(<span class=\"hljs-string\">\"Unsubscription for \"</span> + t);\n  }\n  <span class=\"hljs-comment\">// ack the subscriptions request</span>\n  endpoint.unsubscribeAcknowledge(unsubscribe.messageId());\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_client_published_message\"><a class=\"anchor\" href=\"#_handling_client_published_message\"></a>处理客户端发布的消息</h3>\n<div class=\"paragraph\">\n<p>为了处理远程客户端发布的消息，<code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code> 接口提供了\n<code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishHandler-io.vertx.core.Handler-\">publishHandler</a></code> 方法来指定一个handler,\n这个handler接收一个 <code><a href=\"../../apidocs/io/vertx/mqtt/messages/MqttPublishMessage.html\">MqttPublishMessage</a></code> 类型的实例作为参数，该实例\n包含了载荷信息，QoS 等级以及复制和保留标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果 QoS 等级是 0（AT_MOST_ONCE），endpoint就没有必要回复客户端了。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果 QoS 等级是 1（AT_LEAST_ONCE），endpoint 需要使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishAcknowledge-int-\">publishAcknowledge</a></code> 方法回复一个PUBACK消息给客户端</p>\n</div>\n<div class=\"paragraph\">\n<p>如果 QoS 等级是 2（EXACTLY_ONCE），endpoint 需要使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishReceived-int-\">publishReceived</a></code> 方法回复一个PUBREC消息给客户端。\n在这种情况下，这个 endpoint 同时也要通过 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishReleaseHandler-io.vertx.core.Handler-\">publishReleaseHandler</a></code> 指定一个 handler 来处理来自客户端的PUBREL（远程客户端接收到 endpoint 发送的 PUBREC 后发送的）消息\n为了结束 QoS 等级为2的消息的传递，endpoint 可以使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishComplete-int-\">publishComplete</a></code> 方法发送一个 PUBCOMP 消息给客户端。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">endpoint.publishHandler(message -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"Just received message [\"</span> + message.payload().toString(Charset.defaultCharset()) + <span class=\"hljs-string\">\"] with QoS [\"</span> + message.qosLevel() + <span class=\"hljs-string\">\"]\"</span>);\n\n  <span class=\"hljs-keyword\">if</span> (message.qosLevel() == MqttQoS.AT_LEAST_ONCE) {\n    endpoint.publishAcknowledge(message.messageId());\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message.qosLevel() == MqttQoS.EXACTLY_ONCE) {\n    endpoint.publishReceived(message.messageId());\n  }\n\n}).publishReleaseHandler(messageId -&gt; {\n\n  endpoint.publishComplete(messageId);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_publish_message_to_the_client\"><a class=\"anchor\" href=\"#_publish_message_to_the_client\"></a>发布消息到客户端</h3>\n<div class=\"paragraph\">\n<p>可以使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publish-java.lang.String-io.vertx.core.buffer.Buffer-io.netty.handler.codec.mqtt.MqttQoS-boolean-boolean-\">publish</a></code> 方法发布一个消息到远程客户端，该方法需要补充一下参数：\n发布主题，消息载荷，QoS 等级，复制和保留标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果 QoS 等级是 0（AT_MOST_ONCE），endpoint 就不会收到任何客户端的响应</p>\n</div>\n<div class=\"paragraph\">\n<p>如果 QoS 等级是 1（AT_LEAST_ONCE），endpoint需要处理客户端的PUBACK消息,为了收到最后的确认消息，需要使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishAcknowledgeHandler-io.vertx.core.Handler-\">publishAcknowledgeHandler</a></code> 指定一个handler来接收。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果 QoS 等级是 2（EXACTLY_ONCE），endpoint 需要处理客户端的PUBREC消息，可以通过 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishReceivedHandler-io.vertx.core.Handler-\">publishReceivedHandler</a></code> 方法指定一个handler来实现。\n在这个handler内，endpoint 可以使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishRelease-int-\">publishRelease</a></code> 方法回复客户端 PUBREL 消息。最后一步是处理来自客户端的PUBCOMP消息作为已发布消息的最终确认。\n这可以使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#publishCompletionHandler-io.vertx.core.Handler-\">publishCompletionHandler</a></code> 方法指定一个handler来处理最终接收到的 PUBCOMP 消息。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">endpoint.publish(<span class=\"hljs-string\">\"my_topic\"</span>,\n  Buffer.buffer(<span class=\"hljs-string\">\"Hello from the Vert.x MQTT server\"</span>),\n  MqttQoS.EXACTLY_ONCE,\n  <span class=\"hljs-keyword\">false</span>,\n  <span class=\"hljs-keyword\">false</span>);\n\n<span class=\"hljs-comment\">// specifing handlers for handling QoS 1 and 2</span>\nendpoint.publishAcknowledgeHandler(messageId -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"Received ack for message = \"</span> +  messageId);\n\n}).publishReceivedHandler(messageId -&gt; {\n\n  endpoint.publishRelease(messageId);\n\n}).publishCompletionHandler(messageId -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"Received ack for message = \"</span> +  messageId);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_be_notified_by_client_keep_alive\"><a class=\"anchor\" href=\"#_be_notified_by_client_keep_alive\"></a>客户端保活通知</h3>\n<div class=\"paragraph\">\n<p>MQTT底层的保活机制是由服务端内部处理的。当接收到CONNECT消息，服务端解析消息中指定的保活超时时间以便于检查客户端在这段时间内是否有发送消息，\n与此同时，没收到一个PINGREQ消息，服务端都会回复一个相关的PINGRESP消息。\n尽管上层应用不需要处理这些，<code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code> 依然提供了 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttEndpoint.html#pingHandler-io.vertx.core.Handler-\">pingHandler</a></code> 方法来选定一个handler\n来自客户端的PINGREQ消息。对于应用程序来说这只是一个通知，客户端只会发送一个用于检测保活的没有任何意义的ping消息。无论如何，PINGRESP都会被服务端内部自动发送。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">endpoint.pingHandler(v -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"Ping received from client\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_closing_the_server\"><a class=\"anchor\" href=\"#_closing_the_server\"></a>关闭服务端</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/mqtt/MqttServer.html\">MqttServer</a></code> 提供了 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttServer.html#close-io.vertx.core.Handler-\">close</a></code> 方法来关闭服务。\n他会停止监听到来的连接以及关闭所有已经建立的连接，该方法是一个异步方法，并且可以指定一个成功回调handler，这个handler会在服务端完全关闭后被调用</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mqttServer.close(v -&gt; {\n\n  System.out.println(<span class=\"hljs-string\">\"MQTT server closed\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_clean_up_in_verticles\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles\"></a>在verticles中自动清理</h3>\n<div class=\"paragraph\">\n<p>如果你是在verticles内部创建的MQTT服务端，当verticle卸载时这些服务端会被自动关闭。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scaling_sharing_mqtt_servers\"><a class=\"anchor\" href=\"#_scaling_sharing_mqtt_servers\"></a>扩展：共享MQTT服务器</h3>\n<div class=\"paragraph\">\n<p>与MQTT服务器相关的handler总是在同一个event loop线程中执行。这意味着在一个多核系统中，仅有一个实例被部署，一个核被使用。\n为了使用更多的核，可以部署更多的MQTT服务端实例\n可以通过编程方式实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n\n  MqttServer mqttServer = MqttServer.create(vertx);\n  mqttServer.endpointHandler(endpoint -&gt; {\n    <span class=\"hljs-comment\">// handling endpoint</span>\n  })\n    .listen(ar -&gt; {\n\n      <span class=\"hljs-comment\">// handling start listening</span>\n    });\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者使用一个verticle指定实例的数量：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DeploymentOptions options = <span class=\"hljs-keyword\">new</span> DeploymentOptions().setInstances(<span class=\"hljs-number\">10</span>);\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyVerticle\"</span>, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>实际上，尽管仅有一个MQTT服务器被部署，\n但是当传入的连接到达时，会被Vert.x使用轮转算法分发到不同的核上运行的处理器（handlers）上。</p>\n</div>\n</div>\n</div>\n</div>\n<h1 id=\"_vert_x_mqtt_client\" class=\"sect0\"><a class=\"anchor\" href=\"#_vert_x_mqtt_client\"></a>Vert.x MQTT 客户端</h1>\n<div class=\"paragraph\">\n<p>这个组件提供了一个符合3.1.1版本规范的 <a href=\"http://mqtt.org/\">MQTT</a> 客户端，它的API提供了一系列方法来处理连接建立/断开，发布消息（完整支持3种不同等级的 QoS）以及主题订阅</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n这个模块还处于技术预览阶段，这意味着它的API在接下来的版本中可能会改变\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started_2\"><a class=\"anchor\" href=\"#_getting_started_2\"></a>开始</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_connectdisconnect\"><a class=\"anchor\" href=\"#_connectdisconnect\"></a>连接建立/连接断开</h3>\n<div class=\"paragraph\">\n<p>这个客户端让你可以与服务端建立连接或者断开连接。\n相应的，你可以通过构造函数的方式传入一个 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClientOptions.html\">MqttClientOptions</a></code> 类型的实例\n来指定想要建立连接的服务端的地址和端口号。</p>\n</div>\n<div class=\"paragraph\">\n<p>正如下面这个例子所展示的，你可以使用Vert.x MQTT客户端实例，分别调用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#connect-int-java.lang.String-io.vertx.core.Handler-\">connect</a></code> 和 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#disconnect--\">disconnect</a></code> 方法\n来完成与服务端的连接建立或者断开。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MqttClient client = MqttClient.create(vertx);\n\nclient.connect(<span class=\"hljs-number\">1883</span>, <span class=\"hljs-string\">\"mqtt.eclipse.org\"</span>, s -&gt; {\n  client.disconnect();\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果你在使用SSL/TSL，服务端 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClientOptions.html\">MqttClientOptions</a></code> 提供的默认的地址是 localhost:1883 和 localhost:8883 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_subscribe_to_a_topic\"><a class=\"anchor\" href=\"#_subscribe_to_a_topic\"></a>订阅主题消息</h3>\n<div class=\"paragraph\">\n<p>现在，让我们再仔细看一下这个示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.publishHandler(s -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"There are new message in topic: \"</span> + s.topicName());\n  System.out.println(<span class=\"hljs-string\">\"Content(as string) of the message: \"</span> + s.payload().toString());\n  System.out.println(<span class=\"hljs-string\">\"QoS: \"</span> + s.qosLevel());\n})\n  .subscribe(<span class=\"hljs-string\">\"rpi2/temp\"</span>, <span class=\"hljs-number\">2</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这里我们有一个使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#subscribe-java.lang.String-int-\">subscribe</a></code> 方法的例子， 为了接收到主题为 rpi2/temp 的消息，\n我们调用了 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#subscribe-java.lang.String-int-\">subscribe</a></code> 方法， 因此，为了能接收到的服务端的消息，你需要提供一个handler，每当你订阅的主题有新的消息传来，这个handler就会被调用。\n正如这个实例描述的，你需要通过 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#publishHandler-io.vertx.core.Handler-\">publishHandler</a></code> 方法来指定handler。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_publishing_message_to_a_topic\"><a class=\"anchor\" href=\"#_publishing_message_to_a_topic\"></a>发布主题消息</h3>\n<div class=\"paragraph\">\n<p>如果你想要发布消息到主题上去就需要使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#publish-java.lang.String-io.vertx.core.buffer.Buffer-io.netty.handler.codec.mqtt.MqttQoS-boolean-boolean-\">publish</a></code> 方法。\n让我们来看下面这个示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.publish(<span class=\"hljs-string\">\"temperature\"</span>,\n  Buffer.buffer(<span class=\"hljs-string\">\"hello\"</span>),\n  MqttQoS.AT_LEAST_ONCE,\n  <span class=\"hljs-keyword\">false</span>,\n  <span class=\"hljs-keyword\">false</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这个示例中我们发布了消息到名称为 “temperature” 的主题上去。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_keep_connection_with_server_alive\"><a class=\"anchor\" href=\"#_keep_connection_with_server_alive\"></a>与服务端保持连接</h3>\n<div class=\"paragraph\">\n<p>为了保持与服务端的连接，你需要时不时地发送一些数据到服务端，否则服务端可能会断开连接。\n使用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#ping--\">ping</a></code> 方法来保持连接是一个不错的选择。</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n你的客户端默认情况下会自动保持与服务端的连接，这也意味着你不需要调用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#ping--\">ping</a></code> 方法来保活，因为 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html\">MqttClient</a></code> 已经帮你做了这些事。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果你不想要这个特性，你需要调用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClientOptions.html#setAutoKeepAlive-boolean-\">setAutoKeepAlive</a></code> 方法，设置参数为 <code>false</code> 即可。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setAutoKeepAlive(<span class=\"hljs-keyword\">false</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_be_notified_when\"><a class=\"anchor\" href=\"#_be_notified_when\"></a>通知时机</h3>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>发布完成</p>\n<div class=\"paragraph\">\n<p>你需要调用 <code><a href=\"../../apidocs/io/vertx/mqtt/MqttClient.html#publishCompletionHandler-io.vertx.core.Handler-\">publishCompletionHandler</a></code> 来指定一个handler，这个handler每次发布完成都会被调用。\n这一步是非常有用的，因为你可以看到 PUBACK 或者 PUBCOMP 数据包的 packetId。</p>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>client.publishCompletionHandler(id -&gt; {\n  System.out.println(\"Id of just received PUBACK or PUBCOMP packet is \" + id);\n});\n  // The line of code below will trigger publishCompletionHandler (QoS 2)\nclient.publish(\"hello\", Buffer.buffer(\"hello\"), MqttQoS.EXACTLY_ONCE, false, false);\n  // The line of code below will trigger publishCompletionHandler (QoS is 1)\nclient.publish(\"hello\", Buffer.buffer(\"hello\"), MqttQoS.AT_LEAST_ONCE, false, false);\n  // The line of code below does not trigger because QoS value is 0\nclient.publish(\"hello\", Buffer.buffer(\"hello\"), MqttQoS.AT_LEAST_ONCE, false, false);</pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n如果设置发布消息的 QoS=0，这个handler就不会被调用。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>订阅完成</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.subscribeCompletionHandler(mqttSubAckMessage -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Id of just received SUBACK packet is \"</span> + mqttSubAckMessage.messageId());\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> s : mqttSubAckMessage.grantedQoSLevels()) {\n    <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-number\">0x80</span>) {\n      System.out.println(<span class=\"hljs-string\">\"Failure\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Success. Maximum QoS is \"</span> + s);\n    }\n  }\n});\nclient.subscribe(<span class=\"hljs-string\">\"temp\"</span>, <span class=\"hljs-number\">1</span>);\nclient.subscribe(<span class=\"hljs-string\">\"temp2\"</span>, <span class=\"hljs-number\">2</span>);</code></pre>\n</div>\n</div>\n</li>\n<li>\n<p>退订完成</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .unsubscribeCompletionHandler(id -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"Id of just received UNSUBACK packet is \"</span> + id);\n  });\nclient.subscribe(<span class=\"hljs-string\">\"temp\"</span>, <span class=\"hljs-number\">1</span>);\nclient.unsubscribe(<span class=\"hljs-string\">\"temp\"</span>);</code></pre>\n</div>\n</div>\n</li>\n<li>\n<p>退订发布</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.subscribe(<span class=\"hljs-string\">\"temp\"</span>, <span class=\"hljs-number\">1</span>);\nclient.unsubscribe(<span class=\"hljs-string\">\"temp\"</span>, id -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"Id of just sent UNSUBSCRIBE packet is \"</span> + id);\n  });</code></pre>\n</div>\n</div>\n</li>\n<li>\n<p>接收PINGRESP</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.pingResponseHandler(s -&gt; {\n  <span class=\"hljs-comment\">//The handler will be called time to time by default</span>\n  System.out.println(<span class=\"hljs-string\">\"We have just received PINGRESP packet\"</span>);\n});</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}