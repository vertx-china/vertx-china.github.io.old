{"pageProps":{"slug":"vertx-web-validation/java","title":"Vert.x Web Validation","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_web_validation\">使用 Vert.x Web Validation</a></li>\n<li><a href=\"#_without_vert_x_web_validation\">不使用 Vert.x Web Validation 时</a></li>\n<li><a href=\"#_creating_the_validationhandler\">创建 <code>ValidationHandler</code></a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_defining_parameters\">定义参数</a></li>\n<li><a href=\"#_defining_request_bodies\">定义请求体</a></li>\n<li><a href=\"#_defining_request_predicates\">定义请求断言</a></li>\n<li><a href=\"#_building_the_validationhandler\">构建 <code>ValidationHandler</code></a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_parsed_parameters_and_body\">使用解析的参数和请求体</a></li>\n<li><a href=\"#_manage_the_failures\">处理失败</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Web Validation</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web Validation可以帮助您解析校验您的参数以及来自请求体中的内容</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以做到如下事情：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>解析校验请求参数，也可以序列化和分解</p>\n</li>\n<li>\n<p>解析和校验请求体（包括json和form格式）</p>\n</li>\n<li>\n<p>配置请求方式</p>\n</li>\n<li>\n<p>允许同一路由中的不同请求体同时进行的解析和验证</p>\n</li>\n<li>\n<p>自定义解析校验规则</p>\n</li>\n<li>\n<p>管理解析校验失败的处理逻辑</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>它用 <a href=\"https://vertx.io/docs/vertx-json-schema/java/\">Vert.x Json Schema</a> 来定义您的请求参数和请求体</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_web_validation\"><a class=\"anchor\" href=\"#_using_vert_x_web_validation\"></a>使用 Vert.x Web Validation</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了使用Vert.x Web Validation，请在您的build模块中添加如下的依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven ( <code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-validation<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle ( <code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-validation:4.0.2'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_without_vert_x_web_validation\"><a class=\"anchor\" href=\"#_without_vert_x_web_validation\"></a>不使用 Vert.x Web Validation 时</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您接收到一个HTTP请求时，您经常需要解析请求中的参数以及请求体：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/user\"</span>)\n  .handler(routingContext -&gt; {\n    <span class=\"hljs-comment\">// 接收 aParam</span>\n    String aParamUnparsed = routingContext.queryParam(<span class=\"hljs-string\">\"aParam\"</span>).get(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">if</span> (aParamUnparsed == <span class=\"hljs-keyword\">null</span>) {\n      routingContext.fail(<span class=\"hljs-number\">400</span>);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-comment\">// 解析 aParam</span>\n    <span class=\"hljs-keyword\">int</span> aParam;\n    <span class=\"hljs-keyword\">try</span> {\n      aParam = Integer.parseInt(aParamUnparsed);\n    } <span class=\"hljs-keyword\">catch</span> (NumberFormatException e) {\n      routingContext.fail(<span class=\"hljs-number\">400</span>, e);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-comment\">// 校验aParam是否大于 100</span>\n    <span class=\"hljs-keyword\">if</span> (aParam &gt; <span class=\"hljs-number\">100</span>) {\n      routingContext.fail(<span class=\"hljs-number\">400</span>);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-comment\">// aParam接收完毕，现在我们可以专注于处理请求的业务逻辑</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web Validation 提供了非常好用的API来构建一个解析和校验请求的handler</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/user\"</span>)\n  .handler(\n    ValidationHandler\n      .builder(schemaParser)\n      .queryParameter(param(\n        <span class=\"hljs-string\">\"aParam\"</span>,\n        intSchema().with(maximum(<span class=\"hljs-number\">100</span>))\n      ))\n      .build()\n  )\n  .handler(routingContext -&gt; {\n    RequestParameters parameters = routingContext.get(ValidationHandler.REQUEST_CONTEXT_KEY);\n    <span class=\"hljs-keyword\">int</span> aParam = parameters.queryParameter(<span class=\"hljs-string\">\"aParam\"</span>).getInteger();\n    <span class=\"hljs-comment\">// 处理请求的业务逻辑</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_the_validationhandler\"><a class=\"anchor\" href=\"#_creating_the_validationhandler\"></a>创建 <code>ValidationHandler</code></h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>这个模块提供了一个简单好用的builder API 来创建 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/ValidationHandler.html\">ValidationHandler</a></code> ，\n这个 <code><a href=\"../../apidocs/io/vertx/core/Handler.html\">Handler</a></code> 用于解析和校验请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>用 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/ValidationHandler.html#builder-io.vertx.json.schema.SchemaParser-\">ValidationHandler.builder</a></code> 创建这个 <code>builder</code></p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/json/schema/SchemaParser.html\">SchemaParser</a></code> 用来解析所有由 <a href=\"https://vertx.io/docs/vertx-json-schema/java/\">Vert.x Json Schema DSL</a> 定义的schema</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_defining_parameters\"><a class=\"anchor\" href=\"#_defining_parameters\"></a>定义参数</h3>\n<div class=\"paragraph\">\n<p>您可以在请求中4个不同的位置来定义参数: query， cookie， header， path。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个参数都由一个 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/impl/parameter/ParameterProcessor.html\">ParameterProcessor</a></code> 所接收， 您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/builder/Parameters.html\">Parameters</a></code> 中提供的方法来创建这个 <code>Processor</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ValidationHandler\n  .builder(schemaParser)\n  .pathParameter(Parameters.param(<span class=\"hljs-string\">\"myPathParam\"</span>, stringSchema()))\n  .queryParameter(Parameters.optionalParam(<span class=\"hljs-string\">\"myQueryParam\"</span>, intSchema()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意：所有这些方法都需要一个schema参数，validator要用这个schema做校验操作。这个schema也可以用来指定正确的parser</p>\n</div>\n<div class=\"paragraph\">\n<p>尽管请求头和路径参数只允许传简单参数，但是 query 和cookie允许传复杂参数(url参数的或层次较深的对象)；</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ValidationHandler\n  .builder(schemaParser)\n  .queryParameter(Parameters.explodedParam(\n    <span class=\"hljs-string\">\"myArray\"</span>,\n    arraySchema().items(stringSchema())\n  ))  <span class=\"hljs-comment\">// 接收 myArray=item1&amp;myArray=item2</span>\n  .queryParameter(Parameters.deepObjectParam(\n    <span class=\"hljs-string\">\"myDeepObject\"</span>,\n    objectSchema()\n      .property(<span class=\"hljs-string\">\"name\"</span>, stringSchema())\n  )); <span class=\"hljs-comment\">// 接收 myDeepObject[name]=francesco</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多关于参数的文档 可见于 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/builder/Parameters.html\">Parameters</a></code></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_defining_request_bodies\"><a class=\"anchor\" href=\"#_defining_request_bodies\"></a>定义请求体</h3>\n<div class=\"paragraph\">\n<p>每个请求体类型都被符合某个 <code>Content-type</code> 请求头的 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/impl/parameter/ParameterProcessor.html\">ParameterProcessor</a></code> 所解析。如果没有找到匹配的请求体处理器，除非您指定了下述的解析器，否则验证<strong>不会</strong>失败</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/builder/Bodies.html\">Bodies</a></code> 提供的方法来轻松创建这些解析器。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ObjectSchemaBuilder bodySchemaBuilder = objectSchema()\n  .property(<span class=\"hljs-string\">\"username\"</span>, stringSchema())\n  .property(<span class=\"hljs-string\">\"password\"</span>, stringSchema());\nValidationHandler\n  .builder(schemaParser)\n  .body(Bodies.json(bodySchemaBuilder))\n  .body(Bodies.formUrlEncoded(bodySchemaBuilder));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个例子中 <code>ValidationHandler</code> 可以管理两个不同的请求体类型(同时解析校验) 尤其是form类型的请求体 会被转换成json。当您接收解析后的结果时，不需要关心请求体时form还是json。</p>\n</div>\n<div class=\"paragraph\">\n<p>关于请求体解析器的更多信息，见于 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/builder/Bodies.html\">Bodies</a></code></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_defining_request_predicates\"><a class=\"anchor\" href=\"#_defining_request_predicates\"></a>定义请求断言</h3>\n<div class=\"paragraph\">\n<p>您可以在 <code>ValidationHandler</code> 中用 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/RequestPredicate.html\">RequestPredicate</a></code> 来定义请求断言 ，例如 断言请求体非空：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ValidationHandler\n  .builder(schemaParser)\n  .predicate(RequestPredicate.BODY_REQUIRED);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_building_the_validationhandler\"><a class=\"anchor\" href=\"#_building_the_validationhandler\"></a>构建 <code>ValidationHandler</code></h3>\n<div class=\"paragraph\">\n<p>在您配置了所有的 '参数'、'请求体'、'断言&#8217;之后， 您可以创建 <code>ValidationHandler</code> :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/user\"</span>)\n  .handler(\n    ValidationHandler\n      .builder(schemaParser)\n      .build()\n  );</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_parsed_parameters_and_body\"><a class=\"anchor\" href=\"#_using_the_parsed_parameters_and_body\"></a>使用解析的参数和请求体</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>ValidationHandler</code> 会把解析到的参数放入 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/user\"</span>)\n  .handler(\n    ValidationHandler\n      .builder(schemaParser)\n      .queryParameter(Parameters.explodedParam(\n        <span class=\"hljs-string\">\"myArray\"</span>,\n        arraySchema().items(stringSchema())\n      ))\n      .body(Bodies.json(objectBodySchemaBuilder))\n      .body(Bodies.formUrlEncoded(objectBodySchemaBuilder))\n      .build()\n  ).handler(routingContext -&gt; {\n    RequestParameters parameters = routingContext.get(ValidationHandler.REQUEST_CONTEXT_KEY);\n    JsonArray myArray = parameters.queryParameter(<span class=\"hljs-string\">\"myArray\"</span>).getJsonArray();\n    JsonObject body = parameters.body().getJsonObject();\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_manage_the_failures\"><a class=\"anchor\" href=\"#_manage_the_failures\"></a>处理失败</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>ValidationHandler</code> 每次遇到解析错误或者校验错误，它会让 <code>RoutingContext</code> 以400的状态码结束请求，\n然后抛出 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/BadRequestException.html\">BadRequestException</a></code> 。\n想要了解如何处理请求失败，请查看 <a href=\"https://vertx.io/docs/vertx-web/java/#_error_handling\">Vert.x Web doc</a> 和 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code> 方法.</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/validation/BadRequestException.html\">BadRequestException</a></code> 的子类如下：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/validation/ParameterProcessorException.html\">ParameterProcessorException</a></code>: 用来管理参数校验失败</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/validation/BodyProcessorException.html\">BodyProcessorException</a></code>: 用来管理请求体校验失败</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/validation/RequestPredicateException.html\">RequestPredicateException</a></code>: 用来管理断言失败</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.errorHandler(<span class=\"hljs-number\">400</span>, routingContext -&gt; {\n  <span class=\"hljs-keyword\">if</span> (routingContext.failure() <span class=\"hljs-keyword\">instanceof</span> BadRequestException) {\n    <span class=\"hljs-keyword\">if</span> (routingContext.failure() <span class=\"hljs-keyword\">instanceof</span> ParameterProcessorException) {\n      <span class=\"hljs-comment\">// 解析或校验参数失败</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (routingContext.failure() <span class=\"hljs-keyword\">instanceof</span> BodyProcessorException) {\n      <span class=\"hljs-comment\">// 解析或校验请求体失败</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (routingContext.failure() <span class=\"hljs-keyword\">instanceof</span> RequestPredicateException) {\n      <span class=\"hljs-comment\">// 不满足请求断言</span>\n    }\n  }\n });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>BadRequestException</code> 也提供一个便捷的 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/BadRequestException.html#toJson--\">toJson</a></code> 方法，它将异常转换成了Json。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意 <code>ValidationHandler</code> 的设计为 <em>迅速失败</em> ，即一旦遇到错误，<code>ValidationHandler</code> 将置  <code>RoutingContext</code> 为失败状态。</p>\n</div>\n</div>\n</div>"},"__N_SSG":true}