{"pageProps":{"slug":"vertx-infinispan/java","title":"Infinispan 集群管理器","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_this_cluster_manager\">使用集群管理器</a></li>\n<li><a href=\"#_configuring_this_cluster_manager\">配置集群管理器</a></li>\n<li><a href=\"#_using_an_existing_infinispan_cache_manager\">使用已有的 Infinispan 缓存管理器</a></li>\n<li><a href=\"#_packaging_an_executable_uber_jar\">打包可执行的 fat-jar 包</a></li>\n<li><a href=\"#_configuring_for_kubernetes\">适配 Kubernetes</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_rolling_updates\">滚动更新</a></li>\n</ul>\n</li>\n<li><a href=\"#_configuring_for_docker_compose\">适配 Docker Compose</a></li>\n<li><a href=\"#_trouble_shooting_clustering\">集群故障排查</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_multicast_not_enabled_on_the_machine\">机器禁用组播</a></li>\n<li><a href=\"#_using_wrong_network_interface\">使用错误的网络接口</a></li>\n<li><a href=\"#_using_a_vpn\">使用VPN</a></li>\n<li><a href=\"#_when_multicast_is_not_available\">组播不可用</a></li>\n<li><a href=\"#_problems_with_ipv6\">使用IPv6的问题</a></li>\n<li><a href=\"#_enabling_logging\">开启日志</a></li>\n</ul>\n</li>\n<li><a href=\"#_infinispan_logging\">Infinispan 日志配置</a></li>\n<li><a href=\"#_jgroups_logging\">JGroups 日志配置</a></li>\n<li><a href=\"#_sharedData_extensions\">SharedData 扩展</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_asyncMap_content_streams\">AsyncMap 内容流</a></li>\n</ul>\n</li>\n<li><a href=\"#_cluster_administration\">集群管理</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_rebalancing\">再平衡（Rebalancing）</a></li>\n<li><a href=\"#_split_brain_syndrome\">脑裂</a></li>\n<li><a href=\"#_recommendations\">建议</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Infinispan 集群管理器</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>本项目基于 <a href=\"https://infinispan.org/\">Infinispan</a> 实现了一个集群管理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个集群管理器的实现由以下依赖引入：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-infinispan<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 集群管理器包含以下几项功能：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>发现并管理集群中的节点</p>\n</li>\n<li>\n<p>管理集群的 EventBus 地址订阅清单（这样就可以轻松得知集群中的哪些节点订阅了哪些 EventBus 地址）</p>\n</li>\n<li>\n<p>分布式 Map 支持</p>\n</li>\n<li>\n<p>分布式锁</p>\n</li>\n<li>\n<p>分布式计数器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 集群器 <strong>并不</strong> 处理节点之间的通信。在 Vert.x 中，集群节点间通信是直接由 TCP 连接处理的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_this_cluster_manager\"><a class=\"anchor\" href=\"#_using_this_cluster_manager\"></a>使用集群管理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果通过命令行来使用 Vert.x，对应集群管理器的 <code>jar</code> 包（名为 <code>vertx-infinispan-4.0.2.jar</code> ）\n应该在 Vert.x 中安装路径的 <code>lib</code> 目录中。</p>\n</div>\n<div class=\"paragraph\">\n<p>若您希望在集群中使用此集群管理器，只需要在您的Vert.x Maven 或 Gradle 工程中添加依赖：\n<code>io.vertx:vertx-infinispan:4.0.2</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果（集群管理器的）jar 包在 classpath 中，Vert.x将自动检测到并将其作为集群管理器。\n需要注意的是，要确保 Vert.x 的 classpath 中没有其它的集群管理器实现，\n否则会使用错误的集群管理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>编程内嵌 Vert.x 可以在创建 Vert.x 实例时，\n通过代码显式配置 Vert.x 集群管理器，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ClusterManager mgr = <span class=\"hljs-keyword\">new</span> InfinispanClusterManager();\n\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions().setClusterManager(mgr);\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 失败！</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_this_cluster_manager\"><a class=\"anchor\" href=\"#_configuring_this_cluster_manager\"></a>配置集群管理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认的集群管理器配置可以通过 <code>infinispan.xml</code> 及/或 <code>jgroups.xml</code> 文件进行修改。\n前者配置数据网格（data grid），后者配置组管理和集群成员发现。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以在 classpath 中替换这些配置文件（其中一个或两个）。\n如果想在 fat jar 中内嵌自己的配置文件，这些文件必须在 fat jar 的根目录中。\n如果这些配置文件是外部文件，则必须将其所在的 <strong>目录</strong> 添加至 classpath 中。\n举个例子，如果使用 Vert.x 的 <em>launcher</em> 类启动应用，则 classpath 应该设置为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 如果 infinispan.xml 及/或 jgroups.xml 在当前目录：</span>\njava -jar my-app.jar -cp . -cluster\n<span class=\"hljs-meta\">\n#</span><span class=\"bash\"> 如果 infinispan.xml 及/或 jgroups.xml 在 conf 目录：</span>\njava -jar my-app.jar -cp conf -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>还可以通过配置系统属性 <code>vertx.infinispan.config</code> 及/或 <code>vertx.jgroups.config</code>\n覆盖默认配置、指定配置文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 指定一个外部文件为自定义配置文件</span>\njava -Dvertx.infinispan.config=./config/my-infinispan.xml -jar ... -cluster\n<span class=\"hljs-meta\">\n#</span><span class=\"bash\"> 或从 classpath 中加载一个文件为自定义配置文件</span>\njava -Dvertx.infinispan.config=my/package/config/my-infinispan.xml -jar ... -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>集群管理器优先在 classpath 查找指定的配置文件，如果没有找到，则在文件系统中查找指定的配置文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果设置了上述系统属性，则会覆盖 classpath 中的 <code>infinispan.xml</code> 或 <code>jgroups.xml</code> 文件。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>jgroup.xml</code> 与 <code>infinispan.xml</code> 分别是 JGroups 、 Infinispan 配置文件。在对应的官方可以网站可以详细的配置攻略。</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n如果 classpath 中包含 <code>jgroups.xml</code> 文件，同时也设置了 <code>vertx.jgroups.config</code> 系统属性，\n那么 Infinispan 配置中所有的 JGroups 的 <code>stack-file</code> 路径配置会被 <code>jgroups.xml</code> 中的覆盖。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>在默认的 JGroups 配置中，节点发现使用组播，组管理使用 TCP 。\n请确认您的网络支持组播。</p>\n</div>\n<div class=\"paragraph\">\n<p>有关如何配置或使用其他传输方式的完整文档，\n请查询 Infinispan 或 JGroups 文档。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_an_existing_infinispan_cache_manager\"><a class=\"anchor\" href=\"#_using_an_existing_infinispan_cache_manager\"></a>使用已有的 Infinispan 缓存管理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>构造集群管理器时，传入已有的 <code>DefaultCacheManager</code> 可以复用已有的缓存管理器。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ClusterManager mgr = <span class=\"hljs-keyword\">new</span> InfinispanClusterManager(cacheManager);\n\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions().setClusterManager(mgr);\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 失败！</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，Vert.x 并不是缓存管理器的所有者，因此不能在关闭 Vert.x 时停止 Infinispan 。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意，可通过如下配置以定制 Infinispan 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cache-container</span> <span class=\"hljs-attr\">default-cache</span>=<span class=\"hljs-string\">\"distributed-cache\"</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">distributed-cache</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"distributed-cache\"</span>/&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">replicated-cache</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__vertx.subs\"</span>/&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">replicated-cache</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__vertx.haInfo\"</span>/&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">replicated-cache</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__vertx.nodeInfo\"</span>/&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">distributed-cache-configuration</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__vertx.distributed.cache.configuration\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">cache-container</span>&gt;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_packaging_an_executable_uber_jar\"><a class=\"anchor\" href=\"#_packaging_an_executable_uber_jar\"></a>打包可执行的 fat-jar 包</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Infinispan 在运行时使用 Java SPI 机制（<code>ServiceLoader</code>） 发现一些类/接口的实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>构建可执行的超级 JAR（也称为 fat-JAR ）包时，必须在构建工具中配置将服务描述文件打包。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 Maven 及 Maven Shade 插件，插件应该配置如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transformers</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transformer</span> <span class=\"hljs-attr\">implementation</span>=<span class=\"hljs-string\">\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"</span>/&gt;</span>\n   <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transformers</span>&gt;</span>\n <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 Gradle 及 Gradle Shadow 插件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">shadowJar {\n mergeServiceFiles()\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_for_kubernetes\"><a class=\"anchor\" href=\"#_configuring_for_kubernetes\"></a>适配 Kubernetes</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在 Kubernetes 上，JGroups 的节点发现配置可选择使用 Kubernetes API (<code>KUBE_PING</code>) 或 DNS (<code>DNS_PING</code>)。\n本文将使用 DNS 发现。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先通过以下系统属性配置 JVM 强制使用 IPv4：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\">-Djava.net.preferIPv4Stack=true</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后设置系统属性 <code>vertx.jgroups.config</code> 为 <code>default-configs/default-jgroups-kubernetes.xml</code>。\nJGroups 的 stack-file 在 <code>infinispan-core</code> 的JAR包中，并已为 Kubernetes 做了预配置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\">-Dvertx.jgroups.config=default-configs/default-jgroups-kubernetes.xml</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同时设置 JGroups DNS 查询以便发现集群成员。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\">-Djgroups.dns.query=MY-SERVICE-DNS-NAME</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>其中 <code>MY-SERVICE-DNS-NAME</code> 的取值必须是一个 <a href=\"https://kubernetes.io/docs/user-guide/services/#headless-services\">Kubernetes <strong>无头</strong> 服务（Headless Service）</a> 名，JGroups 会用该名称来标识所有集群成员。\n无头服务的创建配置可参考下面代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-yaml\" data-lang=\"yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Service</span>\n<span class=\"hljs-attr\">metadata:</span>\n <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">clustered-app</span>\n<span class=\"hljs-attr\">spec:</span>\n <span class=\"hljs-attr\">selector:</span>\n   <span class=\"hljs-attr\">cluster:</span> <span class=\"hljs-string\">clustered-app</span> <b class=\"conum\">(2)</b>\n <span class=\"hljs-attr\">ports:</span>\n   <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">jgroups</span>\n     <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">7800</span> <b class=\"conum\">(1)</b>\n     <span class=\"hljs-attr\">protocol:</span> <span class=\"hljs-string\">TCP</span>\n <span class=\"hljs-attr\">publishNotReadyAddresses:</span> <span class=\"hljs-literal\">true</span> <b class=\"conum\">(3)</b>\n <span class=\"hljs-attr\">clusterIP:</span> <span class=\"hljs-string\">None</span></code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>JGroups TCP 端口</p>\n</li>\n<li>\n<p>由 <code>cluster=clustered-app</code> 标签选择的集群成员</p>\n</li>\n<li>\n<p>设置为true，则可以在不干涉就绪探针（readiness probe）逻辑的前提下，发现集群成员</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>最后，属于集群的所有 Kubernetes 部署需要增加 <code>cluster=clustered-app</code> 标签：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-yaml\" data-lang=\"yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps/v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Deployment</span>\n<span class=\"hljs-attr\">spec:</span>\n <span class=\"hljs-attr\">template:</span>\n   <span class=\"hljs-attr\">metadata:</span>\n     <span class=\"hljs-attr\">labels:</span>\n       <span class=\"hljs-attr\">cluster:</span> <span class=\"hljs-string\">clustered-app</span></code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rolling_updates\"><a class=\"anchor\" href=\"#_rolling_updates\"></a>滚动更新</h3>\n<div class=\"paragraph\">\n<p>Infinispan 团队 <a href=\"http://infinispan.org/docs/stable/user_guide/user_guide.html#using_kubernetes_and_openshift_rolling_updates\">建议</a> 在滚动更新期间逐一更换 Pod。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，我们必须将 Kubernetes 配置为：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>不要同时启动多个新 Pod</p>\n</li>\n<li>\n<p>在滚动更新过程中，不可用的 Pod 不能多于一个</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-yaml\" data-lang=\"yaml\"><span class=\"hljs-attr\">spec:</span>\n <span class=\"hljs-attr\">strategy:</span>\n   <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">Rolling</span>\n   <span class=\"hljs-attr\">rollingParams:</span>\n     <span class=\"hljs-attr\">updatePeriodSeconds:</span> <span class=\"hljs-number\">10</span>\n     <span class=\"hljs-attr\">intervalSeconds:</span> <span class=\"hljs-number\">20</span>\n     <span class=\"hljs-attr\">timeoutSeconds:</span> <span class=\"hljs-number\">600</span>\n     <span class=\"hljs-attr\">maxUnavailable:</span> <span class=\"hljs-number\">1</span> <b class=\"conum\">(1)</b>\n     <span class=\"hljs-attr\">maxSurge:</span> <span class=\"hljs-number\">1</span> <b class=\"conum\">(2)</b></code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>在升级过程中允许 不可用的最大 Pod 数</p>\n</li>\n<li>\n<p>允许超过预期创建数量的最大 Pod 数（译者注：即，实际创建的 Pod 数量 ≤ 预期 Pod 数量 + maxSurge）</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>同样地，Pod 的就绪探针（readiness probe）必须考虑集群状态。\n请参阅 <a href=\"#one-by-one\">集群管理</a> 章节，了解如何使用 <a href=\"../../vertx-health-check/java/\">Vert.x 健康检查</a> 实现准备情况探针。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_for_docker_compose\"><a class=\"anchor\" href=\"#_configuring_for_docker_compose\"></a>适配 Docker Compose</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>确认 JVM 在启动时 设置了下面的配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\">-Djava.net.preferIPv4Stack=true -Djgroups.bind.address=NON_LOOPBACK</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过上述两项系统配置，JGroups 才能正确地选择 Docker 创建的虚拟网络接口。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_trouble_shooting_clustering\"><a class=\"anchor\" href=\"#_trouble_shooting_clustering\"></a>集群故障排查</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果默认的组播配置不能正常运行，通常有以下原因：</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_multicast_not_enabled_on_the_machine\"><a class=\"anchor\" href=\"#_multicast_not_enabled_on_the_machine\"></a>机器禁用组播</h3>\n<div class=\"paragraph\">\n<p>通常来说，OSX 默认禁用组播。\n请自行Google一下如何启用组播。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_wrong_network_interface\"><a class=\"anchor\" href=\"#_using_wrong_network_interface\"></a>使用错误的网络接口</h3>\n<div class=\"paragraph\">\n<p>如果机器上有多个网络接口（也有可能是在运行 VPN 的情况下），\n那么 JGroups 很有可能使用错误的网络接口。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了确保 JGroups 使用正确的网络接口，在配置文件中将 <code>bind_addr</code> 设置为指定IP地址。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TCP</span> <span class=\"hljs-attr\">bind_addr</span>=<span class=\"hljs-string\">\"192.168.1.20\"</span>\n    <span class=\"hljs-attr\">...</span>\n    /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MPING</span> <span class=\"hljs-attr\">bind_addr</span>=<span class=\"hljs-string\">\"192.168.1.20\"</span>\n    <span class=\"hljs-attr\">...</span>\n    /&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您直接使用了内置的 <code>jgroups.xml</code> 配置文件，也可以通过设置 <code>jgroups.bind.address</code> 系统属性来指定 JGroups 的网络接口：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Djgroups.bind.address=192.168.1.20</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 运行在集群模式时，必须确保 Vert.x 获取到正确的网络接口。\n在 Vert.x 命令行模式下，可以通过 <code>cluster-host</code> 选项指定集群的网络接口：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>vertx run myverticle.js -cluster -cluster-host your-ip-address</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>其中 <code>your-ip-address</code> 与 JGroups 配置中指定的IP地址一致。</p>\n</div>\n<div class=\"paragraph\">\n<p>若使用编码的方式启动 Vert.x，可以通过 <code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html#getEventBusOptions--\">.setHost(java.lang.String)</a></code> 设置集群的网络接口。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_a_vpn\"><a class=\"anchor\" href=\"#_using_a_vpn\"></a>使用VPN</h3>\n<div class=\"paragraph\">\n<p>使用VPN是上述问题的变种。\nVPN 软件工作时通常会创建虚拟网络接口，但往往不支持组播。\n在 VPN 环境中，如果 JGroups 与 Vert.x 没有配置正确的话，\n将会选择 VPN 创建的网络接口，而不是正确的网络接口。</p>\n</div>\n<div class=\"paragraph\">\n<p>所以，如果您的应用运行在 VPN 环境中，请参考上述章节，\n设置正确的网络接口。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_when_multicast_is_not_available\"><a class=\"anchor\" href=\"#_when_multicast_is_not_available\"></a>组播不可用</h3>\n<div class=\"paragraph\">\n<p>在某些情况下，由于特殊的运行环境，可能无法使用组播。\n在这种情况下，应该配置为其他协议，例如配置 <code>TCPPING</code> 以使用 TCP 套接字，或配置 <code>S3_PING</code> 以使用亚马逊 EC2。</p>\n</div>\n<div class=\"paragraph\">\n<p>有关其他可用的 JGroups 发现协议及其如何配置的更多信息，请查阅 <a href=\"http://www.jgroups.org/manual/index.html#Discovery\">JGroups文档</a> 。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_problems_with_ipv6\"><a class=\"anchor\" href=\"#_problems_with_ipv6\"></a>使用IPv6的问题</h3>\n<div class=\"paragraph\">\n<p>如果在 IPv6 地址配置遇到困难，可以通过设置系统属性 <code>java.net.preferIPv4Stack</code> 强制使用 IPv4：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Djava.net.preferIPv4Stack=true</pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_enabling_logging\"><a class=\"anchor\" href=\"#_enabling_logging\"></a>开启日志</h3>\n<div class=\"paragraph\">\n<p>在排除故障时，开启 Infinispan 和 JGroups 日志很有帮助，可以观察是否组成了集群。\n使用默认的 JUL 日志时，在 classpath 中添加 <code>vertx-default-jul-logging.properties</code> 文件可开启 Infinispan 和 JGroups 日志。\n这是一个标准 java.util.logging（JUL） 配置文件。\n具体配置如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>org.infinispan.level=INFO\norg.jgroups.level=INFO</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以及</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>java.util.logging.ConsoleHandler.level=INFO\njava.util.logging.FileHandler.level=INFO</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_infinispan_logging\"><a class=\"anchor\" href=\"#_infinispan_logging\"></a>Infinispan 日志配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Infinispan 依赖与 JBoss Logging 。JBoss Logging 是一个与多种日志框架的桥接器。</p>\n</div>\n<div class=\"paragraph\">\n<p>请将日志框架实现的jar包放入 classpath 中，JBoss Logging 能够自动检测到并使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果在 classpath 有多种日志框架，可以通过设置系统变量 <code>org.jboss.logging.provider</code> 来指定具体的实现。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Dorg.jboss.logging.provider=log4j2</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多配置信息请参考 <a href=\"http://docs.jboss.org/hibernate/orm/4.3/topical/html/logging/Logging.html\">JBoss日志指南</a> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_jgroups_logging\"><a class=\"anchor\" href=\"#_jgroups_logging\"></a>JGroups 日志配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>JGroups 默认采用 JDK Logging 实现。同时也支持 log4j 与 log4j2 ，只要相应的 jar 包 在 classpath 中。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果想查阅更详细的信息，或实现自己的日志后端，请参考\n<a href=\"http://www.jgroups.org/manual/index.html#Logging\">JGroups日志文档</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sharedData_extensions\"><a class=\"anchor\" href=\"#_sharedData_extensions\"></a>SharedData 扩展</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_asyncMap_content_streams\"><a class=\"anchor\" href=\"#_asyncMap_content_streams\"></a>AsyncMap 内容流</h3>\n<div class=\"paragraph\">\n<p><code>InfinispanAsyncMap</code> API支持将 AsyncMap 的键、值及 Entry 作为流进行读取。\n如果您需要遍历读取很大的 AsyncMap 并进行批量处理，这将很有帮助。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">InfinispanAsyncMap&lt;K, V&gt; infinispanAsyncMap = InfinispanAsyncMap.unwrap(asyncMap);\nReadStream&lt;K&gt; keyStream = infinispanAsyncMap.keyStream();\nReadStream&lt;V&gt; valueStream = infinispanAsyncMap.valueStream();\nReadStream&lt;Map.Entry&lt;K, V&gt;&gt; entryReadStream = infinispanAsyncMap.entryStream();</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cluster_administration\"><a class=\"anchor\" href=\"#_cluster_administration\"></a>集群管理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Infinispan 集群管理器的工作原理是将 Vert.x 节点作为 Infinispan 集群的成员。\n因此，Vert.x 使用 Infinispan 集群管理器时，应遵循 Infinispan 的管理准则。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先介绍下再平衡（Rebalancing）和脑裂。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rebalancing\"><a class=\"anchor\" href=\"#_rebalancing\"></a>再平衡（Rebalancing）</h3>\n<div class=\"paragraph\">\n<p>每个 Vert.x 节点都包含部分集群数据，包括：EventBus 订阅，异步 Map，分布式计数器等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>当有节点加入或离开集群时，Infinispan 会在新的集群拓扑中重新平衡分配（rebalance）缓存条目。\n换句话说，它可以移动数据以适应新的集群拓扑。\n此过程可能需要一些时间，具体取决于集群数据量和节点数量。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_split_brain_syndrome\"><a class=\"anchor\" href=\"#_split_brain_syndrome\"></a>脑裂</h3>\n<div class=\"paragraph\">\n<p>在理想环境中，不会出现网络设备故障。\n实际上，集群迟早会被分成多个小组，彼此之间不可见。</p>\n</div>\n<div class=\"paragraph\">\n<p>Infinispan 能够将节点合并回单个集群。\n但是，就像数据分区迁移一样，此过程可能需要一些时间。\n在集群变回可用之前，某些 EventBus 的消费者可能无法获取到消息。\n否则，重新部署故障的 Verticle 过程中无法保证高可用。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>很难（或者说基本不可能）区分脑裂和:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>长时间的GC暂停 （导致错过了心跳检查），</p>\n</li>\n<li>\n<p>部署新版本应用时，同时强制关闭了很多节点</p>\n</li>\n</ul>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_recommendations\"><a class=\"anchor\" href=\"#_recommendations\"></a>建议</h3>\n<div class=\"paragraph\">\n<p>考虑到上面讨论的常见集群问题，建议遵循下述的最佳实践。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_graceful_shutdown\"><a class=\"anchor\" href=\"#_graceful_shutdown\"></a>优雅地关闭</h4>\n<div class=\"paragraph\">\n<p>应该避免强行停止集群成员节点（例如，对节点进程使用 <code>kill -9</code> ）。</p>\n</div>\n<div class=\"paragraph\">\n<p>当然，进程崩溃是不可避免的，但是优雅地关闭进程有助于其余节点更快地恢复稳定状态。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"one-by-one\"><a class=\"anchor\" href=\"#one-by-one\"></a>逐个添加或移除节点</h4>\n<div class=\"paragraph\">\n<p>滚动更新新版本应用时，或扩大/缩小集群时，应该一个接一个地添加或移除节点。</p>\n</div>\n<div class=\"paragraph\">\n<p>逐个停止节点可避免集群误以为发生了脑裂。\n逐个添加节点可以进行干净的增量数据分区迁移。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以使用 <a href=\"../../vertx-health-check/java/\">Vert.x 运行状况检查</a> 来验证集群安全性：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;Promise&lt;Status&gt;&gt; procedure = ClusterHealthCheck.createProcedure(vertx, <span class=\"hljs-keyword\">true</span>);\nHealthChecks checks = HealthChecks.create(vertx).register(<span class=\"hljs-string\">\"cluster-health\"</span>, procedure);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>完成集群创建后，可以通过 <a href=\"../../vertx-web/java/\">Vert.x Web</a> 路由 Handler 编写的HTTP程序进行健康检查：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\nrouter.get(<span class=\"hljs-string\">\"/readiness\"</span>).handler(HealthCheckHandler.createWithHealthChecks(checks));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}