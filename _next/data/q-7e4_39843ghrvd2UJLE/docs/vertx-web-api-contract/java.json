{"pageProps":{"slug":"vertx-web-api-contract/java","title":"Vert.x Web API Contract","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_api_contract\">使用 Vert.x API Contract</a></li>\n<li><a href=\"#_http_requests_validation\">HTTP 请求校验</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_types_of_request_parameters\">请求参数类型</a></li>\n<li><a href=\"#_handling_parameters\">处理参数</a></li>\n<li><a href=\"#_manage_validation_failures\">管理校验失败的情况</a></li>\n</ul>\n</li>\n<li><a href=\"#_openapi_3\">OpenAPI 3</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_the_router_factory\">路由器工厂</a></li>\n<li><a href=\"#_create_a_new_router_factory\">创建新的路由器工厂</a></li>\n<li><a href=\"#_mount_the_handlers\">挂载处理器</a></li>\n<li><a href=\"#_define_security_handlers\">定义安全处理器</a></li>\n<li><a href=\"#_not_implemented_error\">未实现错误</a></li>\n<li><a href=\"#_response_content_type_handler\">响应内容类型处理器</a></li>\n<li><a href=\"#_operation_model\">Operation model</a></li>\n<li><a href=\"#_body_handler\">请求体处理器</a></li>\n<li><a href=\"#_multipart_form_data_validation\"><code>multipart/form-data</code> 校验</a></li>\n<li><a href=\"#_custom_global_handlers\">自定义全局处理器</a></li>\n<li><a href=\"#_router_factory_handlers_mount_order\">路由器工厂处理器挂载顺序</a></li>\n<li><a href=\"#_generate_the_router\">生成路由器</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxjava_2_api\">RxJava 2 API</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Web API Contract</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web API Contract 继承了 Vert.x Web 用以支持 <a href=\"https://www.openapis.org/\">OpenAPI 3</a> ，为您提供了一个简单的接口来创建您的路由器并挂载了安全和校验处理器</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您对构建一个转发API请求到事件总线到应用感兴趣，那么请查阅 <a href=\"https://vertx.io/docs/vertx-web-api-service/java/\">Vert.x Web API 服务文档</a></p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n这个模块已经过时了，如果您想构建一个新的应用，请查阅 <a href=\"https://vertx.io/docs/vertx-web-openapi/java/\">Vert.x Web OpenAPI 文档</a>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_api_contract\"><a class=\"anchor\" href=\"#_using_vert_x_api_contract\"></a>使用 Vert.x API Contract</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用Vert.x API Contract 请添加如下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-api-contract<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-api-contract:4.0.2'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_http_requests_validation\"><a class=\"anchor\" href=\"#_http_requests_validation\"></a>HTTP 请求校验</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x提供了一个框架，这个框架校验了请求并且在一个容器当中放入校验结果。定义一个 <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/HTTPRequestValidationHandler.html\">HTTPRequestValidationHandler</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HTTPRequestValidationHandler validationHandler = HTTPRequestValidationHandler.create().addQueryParam(<span class=\"hljs-string\">\"parameterName\"</span>, ParameterType.INT, <span class=\"hljs-keyword\">true</span>).addFormParamWithPattern(<span class=\"hljs-string\">\"formParameterName\"</span>, <span class=\"hljs-string\">\"a{4}\"</span>, <span class=\"hljs-keyword\">true</span>).addPathParam(<span class=\"hljs-string\">\"pathParam\"</span>, ParameterType.FLOAT);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后您可以挂载这个校验处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(BodyHandler.create());\n\nrouter.get(<span class=\"hljs-string\">\"/awesome/:pathParam\"</span>)\n  <span class=\"hljs-comment\">// 挂载校验处理器</span>\n  .handler(validationHandler)\n  <span class=\"hljs-comment\">//挂载您的处理器</span>\n  .handler((routingContext) -&gt; {\n    <span class=\"hljs-comment\">// 获取请求参数的容器</span>\n    RequestParameters params = routingContext.get(<span class=\"hljs-string\">\"parsedParameters\"</span>);\n\n    <span class=\"hljs-comment\">// 获取参数</span>\n    Integer parameterName = params.queryParameter(<span class=\"hljs-string\">\"parameterName\"</span>).getInteger();\n    String formParameterName = params.formParameter(<span class=\"hljs-string\">\"formParameterName\"</span>).getString();\n    Float pathParam = params.pathParameter(<span class=\"hljs-string\">\"pathParam\"</span>).getFloat();\n  })\n\n  <span class=\"hljs-comment\">// 挂载失败处理器</span>\n  .failureHandler((routingContext) -&gt; {\n    Throwable failure = routingContext.failure();\n    <span class=\"hljs-keyword\">if</span> (failure <span class=\"hljs-keyword\">instanceof</span> ValidationException) {\n      <span class=\"hljs-comment\">// 校验过程中失败</span>\n      String validationErrorMessage = failure.getMessage();\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果校验成功，则在 <code><a href=\"../../apidocs/io/vertx/ext/web/api/RequestParameters.html\">RequestParameters</a></code> 中返回请求参数，\n否则，会让 <code>RoutingContext</code> 以400状态码失败，并抛出 <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ValidationException.html\">ValidationException</a></code> 。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_types_of_request_parameters\"><a class=\"anchor\" href=\"#_types_of_request_parameters\"></a>请求参数类型</h3>\n<div class=\"paragraph\">\n<p>每一个参数都有一个类型校验器，即一个描述期望类型的参数。\n一个类型校验器对一个值进行校验，在转换成特定语言的类型，然后在 <code><a href=\"../../apidocs/io/vertx/ext/web/api/RequestParameter.html\">RequestParameter</a></code> 对象中加载它。描述参数类型有三种方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>这里有一系列预置类型供您使用： <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ParameterType.html\">ParameterType</a></code></p>\n</li>\n<li>\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ParameterTypeValidator.html\">ParameterTypeValidator</a></code> 的静态方法来实例化您的自定义预置类型的实例，然后用后缀是 <code>WithCustomTypeValidator</code> 的函数将它加载到 <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/HTTPRequestValidationHandler.html\">HTTPRequestValidationHandler</a></code></p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_parameters\"><a class=\"anchor\" href=\"#_handling_parameters\"></a>处理参数</h3>\n<div class=\"paragraph\">\n<p>现在您可以处理参数值</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RequestParameters params = routingContext.get(<span class=\"hljs-string\">\"parsedParameters\"</span>);\nRequestParameter awesomeParameter = params.queryParameter(<span class=\"hljs-string\">\"awesomeParameter\"</span>);\n<span class=\"hljs-keyword\">if</span> (awesomeParameter != <span class=\"hljs-keyword\">null</span>) {\n  <span class=\"hljs-keyword\">if</span> (!awesomeParameter.isEmpty()) {\n    <span class=\"hljs-comment\">// 参数存在且非空</span>\n    <span class=\"hljs-comment\">// ParameterTypeValidator将参数映射为相应语言的对象</span>\n    Integer awesome = awesomeParameter.getInteger();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 参数存在但为空</span>\n  }\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">// 参数不存在 (非必需)</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如您所见，所有的参数都映射为相应语言中的对象，您也可以获得json请求体：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RequestParameter body = params.body();\n<span class=\"hljs-keyword\">if</span> (body != <span class=\"hljs-keyword\">null</span>) {\n  JsonObject jsonBody = body.getJsonObject();\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_manage_validation_failures\"><a class=\"anchor\" href=\"#_manage_validation_failures\"></a>管理校验失败的情况</h3>\n<div class=\"paragraph\">\n<p>校验失败了，则 <code>RoutingContext</code> 的状态码则变成400，并抛出 <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ValidationException.html\">ValidationException</a></code> 异常。\n您在路由层面即可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#failureHandler-io.vertx.core.Handler-\">failureHandler</a></code> 也可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code> 来管理失败情况下的处理方式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">\"/awesome/:pathParam\"</span>)\n  <span class=\"hljs-comment\">// 挂载校验处理器</span>\n  .handler(validationHandler)\n  <span class=\"hljs-comment\">// 挂载您的处理器</span>\n  .handler((routingContext) -&gt; {\n    <span class=\"hljs-comment\">// 您的业务逻辑</span>\n  })\n  <span class=\"hljs-comment\">// 挂载失败处理器来管理路径级别的校验失败请况</span>\n  .failureHandler((routingContext) -&gt; {\n    Throwable failure = routingContext.failure();\n    <span class=\"hljs-keyword\">if</span> (failure <span class=\"hljs-keyword\">instanceof</span> ValidationException) {\n      <span class=\"hljs-comment\">// 校验过程中失败!</span>\n      String validationErrorMessage = failure.getMessage();\n    }\n  });\n\n<span class=\"hljs-comment\">// 管理针对于路由器中所有路由的失败处理</span>\nrouter.errorHandler(<span class=\"hljs-number\">400</span>, routingContext -&gt; {\n  <span class=\"hljs-keyword\">if</span> (routingContext.failure() <span class=\"hljs-keyword\">instanceof</span> ValidationException) {\n    <span class=\"hljs-comment\">// 校验过程中失败!</span>\n    String validationErrorMessage = routingContext.failure().getMessage();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 未知的400状态码的失败</span>\n    routingContext.response().setStatusCode(<span class=\"hljs-number\">400</span>).end();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_openapi_3\"><a class=\"anchor\" href=\"#_openapi_3\"></a>OpenAPI 3</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x允许您使用“设计优先”方法直接在代码内部使用OpenAPI 3规范，Vert.x-Web API Contract提供了如下功能：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>通过 <strong>自动加载外部Json schema</strong> 来校验符合OpenAPI 3的API规范</p>\n</li>\n<li>\n<p>自动校验请求</p>\n</li>\n<li>\n<p>自动挂载安全校验器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您也可以用社区项目 <a href=\"https://github.com/pmlopes/vertx-starter\"><code>vertx-starter</code></a> 来从您的OpenAPI3规范来生成服务端代码</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_router_factory\"><a class=\"anchor\" href=\"#_the_router_factory\"></a>路由器工厂</h3>\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html\">OpenAPI3RouterFactory</a></code> 来创建您自己的基于 OpenAPI 3 规范的web应用。\n<code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html\">OpenAPI3RouterFactory</a></code> 用来给您提供简易的用户接口来使用OpenAPI 3的相关特性，其中包括：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>规范的异步加载以及schema的依赖</p>\n</li>\n<li>\n<p>用 operationId 或绑定路径和HTTP请求方式来挂载路径</p>\n</li>\n<li>\n<p>自动生成校验处理器</p>\n</li>\n<li>\n<p>OpenAPI风格和Vert.x风格路径的自动转换</p>\n</li>\n<li>\n<p>声明式方法：在规范中以声明的顺序来挂载处理步骤</p>\n</li>\n<li>\n<p>自动挂载安全处理器</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_create_a_new_router_factory\"><a class=\"anchor\" href=\"#_create_a_new_router_factory\"></a>创建新的路由器工厂</h3>\n<div class=\"paragraph\">\n<p>要创建新的路由器工厂，则使用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html#create-io.vertx.core.Vertx-java.lang.String-io.vertx.core.Handler-\">OpenAPI3RouterFactory.create</a></code> 方法。\n它以接收到的绝对路径、本地路径、本地/远程URL（HTTP或文件协议）来作为location。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如从本地文件系统加载一个规范：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OpenAPI3RouterFactory.create(vertx, <span class=\"hljs-string\">\"src/main/resources/petstore.yaml\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 规范加载成功</span>\n    OpenAPI3RouterFactory routerFactory = ar.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 路由器工厂初始化过程中失败</span>\n    Throwable exception = ar.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以从远程规范来构建路由器工厂：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OpenAPI3RouterFactory.create(\n  vertx,\n  <span class=\"hljs-string\">\"https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml\"</span>,\n  ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// 规范加载成功</span>\n      OpenAPI3RouterFactory routerFactory = ar.result();\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 路由器工厂初始化过程中失败</span>\n      Throwable exception = ar.cause();\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者，您也可以通过传递一个或多个 <a href=\"https://github.com/swagger-api/swagger-parser#usage\">AuthorizationValue</a> 来获取私有的远程规范：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">AuthorizationValue authorizationValue = <span class=\"hljs-keyword\">new</span> AuthorizationValue()\n  .type(<span class=\"hljs-string\">\"header\"</span>)\n  .keyName(<span class=\"hljs-string\">\"Authorization\"</span>)\n  .value(<span class=\"hljs-string\">\"Bearer xx.yy.zz\"</span>);\nList&lt;JsonObject&gt; authorizations = Collections.singletonList(JsonObject.mapFrom(authorizationValue));\nOpenAPI3RouterFactory.create(\n  vertx,\n  <span class=\"hljs-string\">\"https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml\"</span>,\n  authorizations,\n  ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// 规范加载成功</span>\n      OpenAPI3RouterFactory routerFactory = ar.result();\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 路由器工厂初始化过程中失败</span>\n      Throwable exception = ar.cause();\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html\">RouterFactoryOptions</a></code> 来修改路由器工厂的行为。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mount_the_handlers\"><a class=\"anchor\" href=\"#_mount_the_handlers\"></a>挂载处理器</h3>\n<div class=\"paragraph\">\n<p>现在挂载您的第一个操作处理器：\n要加载一个处理器，则使用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html#addHandlerByOperationId-java.lang.String-io.vertx.core.Handler-\">addHandlerByOperationId</a></code> 。\n要加载一个失败处理器，则使用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html#addFailureHandlerByOperationId-java.lang.String-io.vertx.core.Handler-\">addFailureHandlerByOperationId</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>当然，您也可以 <strong>在一个操作中加入多个处理器</strong> ，这样不会覆盖已经存在的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerFactory.addHandlerByOperationId(<span class=\"hljs-string\">\"awesomeOperation\"</span>, routingContext -&gt; {\n  RequestParameters params = routingContext.get(<span class=\"hljs-string\">\"parsedParameters\"</span>);\n  RequestParameter body = params.body();\n  JsonObject jsonBody = body.getJsonObject();\n  <span class=\"hljs-comment\">// 处理请求体</span>\n});\nrouterFactory.addFailureHandlerByOperationId(<span class=\"hljs-string\">\"awesomeOperation\"</span>, routingContext -&gt; {\n  <span class=\"hljs-comment\">// 处理失败</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在您可以如上述所示来使用您的参数值。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_define_security_handlers\"><a class=\"anchor\" href=\"#_define_security_handlers\"></a>定义安全处理器</h3>\n<div class=\"paragraph\">\n<p>一个安全处理器是由 schema name 和 scope的绑定关系所定义。一个安全处理器只能挂载一对绑定关系：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerFactory.addSecurityHandler(<span class=\"hljs-string\">\"security_scheme_name\"</span>, securityHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您当然也可以用Vert.x内置的安全处理器，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerFactory.addSecurityHandler(<span class=\"hljs-string\">\"jwt_auth\"</span>, JWTAuthHandler.create(jwtAuthProvider));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于 调试/测试 的目的，您在生成 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code> 的时候，路由器工厂会执行失败。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_not_implemented_error\"><a class=\"anchor\" href=\"#_not_implemented_error\"></a>未实现错误</h3>\n<div class=\"paragraph\">\n<p>路由器工厂在没有指定处理器时，会挂载默认的处理器。\n这个默认处理器让 <code>routing context</code> 处于405 <code>Method Not Allowed</code> 错误状态 或 处于 501 <code>Not Implemented</code> 错误状态。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html#setMountNotImplementedHandler-boolean-\">setMountNotImplementedHandler</a></code> 来启用/禁用它，而且您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code> 来自定义错误的处理方式。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_response_content_type_handler\"><a class=\"anchor\" href=\"#_response_content_type_handler\"></a>响应内容类型处理器</h3>\n<div class=\"paragraph\">\n<p>当接口需要时，路由器工厂会自动挂载一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ResponseContentTypeHandler.html\">ResponseContentTypeHandler</a></code> 处理器。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html#setMountResponseContentTypeHandler-boolean-\">setMountResponseContentTypeHandler</a></code> 来禁用这个特性。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_operation_model\"><a class=\"anchor\" href=\"#_operation_model\"></a>Operation model</h3>\n<div class=\"paragraph\">\n<p>如果您在处理请求时需要获取接口协议，\n您可以配置路由器工厂来将它设置在 <code>RoutingContext</code> 中，这需要使用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html#setOperationModelKey-java.lang.String-\">setOperationModelKey</a></code> 。 例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setOperationModelKey(<span class=\"hljs-string\">\"operationPOJO\"</span>);\nrouterFactory.setOptions(options);\n\n<span class=\"hljs-comment\">// 添加一个使用operation model的处理器</span>\nrouterFactory.addHandlerByOperationId(<span class=\"hljs-string\">\"listPets\"</span>, routingContext -&gt; {\n  io.swagger.v3.oas.models.Operation operation = routingContext.get(<span class=\"hljs-string\">\"operationPOJO\"</span>);\n\n  routingContext\n    .response()\n    .setStatusCode(<span class=\"hljs-number\">200</span>)\n    .setStatusMessage(<span class=\"hljs-string\">\"OK\"</span>)\n    <span class=\"hljs-comment\">// 以\"listPets\"为操作id，回写响应</span>\n    .end(operation.getOperationId());\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_body_handler\"><a class=\"anchor\" href=\"#_body_handler\"></a>请求体处理器</h3>\n<div class=\"paragraph\">\n<p>路由器工厂为了管理请求体，会自动挂载一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactory.html#setBodyHandler-io.vertx.ext.web.handler.BodyHandler-\">setBodyHandler</a></code> 配置一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 对象（例如 更改上传目录）：</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_multipart_form_data_validation\"><a class=\"anchor\" href=\"#_multipart_form_data_validation\"></a><code>multipart/form-data</code> 校验</h3>\n<div class=\"paragraph\">\n<p>校验处理器像如下描述来区分文件上传和表单属性：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果参数中没有编码相关的字段：</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果参数存在 <code>type: string</code> 和 <code>format: base64</code> ，或者存在 <code>format: binary</code> ，那么它就是 content-type请求头为 <code>application/octet-stream</code> 的一个请求。</p>\n</li>\n<li>\n<p>否则 就是一个表单请求</p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>如果参数存在编码相关字段，则是一个文件上传的请求。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>对于表单属性，他们被解析为其他请求参数并校验，\n然而对于文件上传请求，校验处理器仅仅检查存在性和Content-Type。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_custom_global_handlers\"><a class=\"anchor\" href=\"#_custom_global_handlers\"></a>自定义全局处理器</h3>\n<div class=\"paragraph\">\n<p>如果您需要挂载一个处理器，而这个处理器在您路由器中每个操作执行之前都需要执行特定操作，那么您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactory.html#addGlobalHandler-io.vertx.core.Handler-\">addGlobalHandler</a></code></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_router_factory_handlers_mount_order\"><a class=\"anchor\" href=\"#_router_factory_handlers_mount_order\"></a>路由器工厂处理器挂载顺序</h3>\n<div class=\"paragraph\">\n<p>路由器工厂以如下顺序加载处理器：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>请求体处理器</p>\n</li>\n<li>\n<p>自定义全局处理器</p>\n</li>\n<li>\n<p>在规范之上级别的全局安全处理器</p>\n</li>\n<li>\n<p>安全处理器中指定的操作</p>\n</li>\n<li>\n<p>生成的校验处理器</p>\n</li>\n<li>\n<p>用户处理器 或者 \"尚未实现的\"处理器（如果启用）</p>\n</li>\n</ol>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_generate_the_router\"><a class=\"anchor\" href=\"#_generate_the_router\"></a>生成路由器</h3>\n<div class=\"paragraph\">\n<p>您准备就绪时，便生成路由器并使用它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = routerFactory.getRouter();\n\nHttpServer server = vertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions().setPort(<span class=\"hljs-number\">8080</span>).setHost(<span class=\"hljs-string\">\"localhost\"</span>));\nserver.requestHandler(router).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您没有提供必要的安全处理器，则这个方法会以 <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryException.html\">RouterFactoryException</a></code> 异常结束而失败。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_2_api\"><a class=\"anchor\" href=\"#_rxjava_2_api\"></a>RxJava 2 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Web API Contract 提供了RxJava版本的API。</p>\n</div>\n<div class=\"paragraph\">\n<p>如下为完整例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OpenAPI3RouterFactory\n  .rxCreate(vertx, <span class=\"hljs-string\">\"src/main/resources/petstore.yaml\"</span>)\n  .flatMap(routerFactory -&gt; {\n    <span class=\"hljs-comment\">// 规范加载成功，路由器工厂包含了OpenAPI3RouterFactory</span>\n    <span class=\"hljs-comment\">// 设置路由器工厂</span>\n    RouterFactoryOptions options = <span class=\"hljs-keyword\">new</span> RouterFactoryOptions().setOperationModelKey(<span class=\"hljs-string\">\"openapi_model\"</span>);\n    <span class=\"hljs-comment\">// 挂载设置</span>\n    routerFactory.setOptions(options);\n    <span class=\"hljs-comment\">// 以operationId添加处理器</span>\n    routerFactory.addHandlerByOperationId(<span class=\"hljs-string\">\"listPets\"</span>, routingContext -&gt; {\n      <span class=\"hljs-comment\">// 处理 listPets 操作</span>\n      routingContext.response().setStatusMessage(<span class=\"hljs-string\">\"Called listPets\"</span>).end();\n    });\n\n    <span class=\"hljs-comment\">// 添加安全处理器</span>\n    routerFactory.addSecurityHandler(<span class=\"hljs-string\">\"api_key\"</span>, JWTAuthHandler.create(jwtAuth));\n\n    <span class=\"hljs-comment\">// 现在您必须生成路由器</span>\n    Router router = routerFactory.getRouter();\n\n    <span class=\"hljs-comment\">// 现在 您可以使用路由器对象</span>\n    HttpServer server = vertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions().setPort(<span class=\"hljs-number\">8080</span>).setHost(<span class=\"hljs-string\">\"localhost\"</span>));\n    <span class=\"hljs-keyword\">return</span> server.requestHandler(router).rxListen();\n  })\n  .subscribe(httpServer -&gt; {\n    <span class=\"hljs-comment\">// 服务启动运行</span>\n  }, throwable -&gt; {\n    <span class=\"hljs-comment\">// http服务启动失败 或 路由器工厂初始化失败</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}