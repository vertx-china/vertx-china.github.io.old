{"pageProps":{"slug":"vertx-tcp-eventbus-bridge/java","title":"Vert.x-tcp-eventbus-bridge","fallbackGitHubStars":null,"toc":"","contents":"<h1>Vert.x-tcp-eventbus-bridge</h1>\n<div class=\"paragraph\">\n<p>Vert.x-tcp-eventbus-bridge是连接Vert.x EventBus的TCP bridge。要使用此项目，请先加入以下依赖：</p>\n</div>\n<div class=\"paragraph\">\n<p>Maven（在您的 <code>pom.xml</code>）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-tcp-eventbus-bridge<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-tcp-eventbus-bridge:4.0.2'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>TCP EventBus bridge建立在TCP之上，任何能够创建TCP套接字的应用程序都可以通过它的EventBus与远端的Vert.x程序沟通。</p>\n</div>\n<div class=\"paragraph\">\n<p>因为整个HTTP WebSockets已经替换为纯TCP套接字，所以相比于SockJS bridge来说TCP bridge的主要使用场景是有限资源的轻量化应用程序。</p>\n</div>\n<div class=\"paragraph\">\n<p>即使是对于没有严格资源限制的应用程序，协议仍然有用: 该协议足够简单，便于与非JVM程序高效集成。</p>\n</div>\n<div class=\"paragraph\">\n<p>该协议已尽可能的保持简单，通信使用双向帧。\n帧结构如下:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>&lt;Length: uInt32&gt;&lt;{\n  type: String,\n  address: String,\n  (replyAddress: String)?,\n  headers: JsonObject,\n  body: JsonObject\n}: JsonObject&gt;</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该消息内包含一个可能未被压缩过的JSON文档。\n该消息必须以大端序32位整数(4 bytes)作为前缀来指示JSON文档的完整长度(以字节为单位)。</p>\n</div>\n<div class=\"paragraph\">\n<p>TCP客户端可以发送如下 <code>类型 type</code> 的消息：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><code>send</code> 发送消息到 <code>address</code> ，</p>\n</li>\n<li>\n<p><code>publish</code> 发布消息到 <code>address</code> ，</p>\n</li>\n<li>\n<p><code>register</code> 订阅发送或发布到 <code>address</code> 的消息，</p>\n</li>\n<li>\n<p><code>unregister</code> 退订已经发送或发布到 <code>address</code> 的消息，</p>\n</li>\n<li>\n<p><code>ping</code> 发送 <code>ping</code> 请求到bridge。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>请注意 <code>replyAddress</code> 字段是可选的，并且只能用于 <code>send</code> 消息。\n带有该字段的消息希望 <em>最终</em> 从服务端收到一条对应的返回消息，返回消息中 <code>address</code> 的值便是原先消息中的 <code>replyAddress</code> 的值。</p>\n</div>\n<div class=\"paragraph\">\n<p>服务端返回到客户端的消息可以是如下的 <code>类型 type</code> ：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><code>message</code> 发送或者发布到 <code>address</code> ，</p>\n</li>\n<li>\n<p><code>err</code> 报告错误( <code>body</code> 应该包含详细信息)，</p>\n</li>\n<li>\n<p><code>pong</code> 响应客户端发送的 <code>ping</code> 请求。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>项目源代码中提供了一个可用的NodeJS客户端示例。</p>\n</div>\n<div class=\"paragraph\">\n<p>该客户端使用了与SockJS对应部分相同的API这将会便于在TCP与SockJS之间切换。</p>\n</div>\n<div class=\"paragraph\">\n<p>关于如何开始使用此birdge的示例如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">TcpEventBusBridge bridge = TcpEventBusBridge.create(\n    vertx,\n    <span class=\"hljs-keyword\">new</span> BridgeOptions()\n        .addInboundPermitted(<span class=\"hljs-keyword\">new</span> PermittedOptions().setAddress(<span class=\"hljs-string\">\"in\"</span>))\n        .addOutboundPermitted(<span class=\"hljs-keyword\">new</span> PermittedOptions().setAddress(<span class=\"hljs-string\">\"out\"</span>)));\n\nbridge.listen(<span class=\"hljs-number\">7000</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 成功……</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 失败……</span>\n  }\n});</code></pre>\n</div>\n</div>"},"__N_SSG":true}