{"pageProps":{"slug":"vertx-pg-client/java","title":"响应式（Reactive） PostgreSQL 客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_usage\">用法</a></li>\n<li><a href=\"#_getting_started\">开始使用</a></li>\n<li><a href=\"#_connecting_to_postgresql\">连接PostgreSQL</a></li>\n<li><a href=\"#_connect_retries\">重连</a></li>\n<li><a href=\"#_configuration\">配置</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_object\">data object</a></li>\n<li><a href=\"#_connection_uri\">连接uri</a></li>\n<li><a href=\"#_environment_variables\">环境变量</a></li>\n<li><a href=\"#_sasl_scram_sha_256_authentication_mechanism\">SASL SCRAM-SHA-256 鉴权机制。</a></li>\n</ul>\n</li>\n<li><a href=\"#_running_queries\">执行查询</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_queries\">预查询</a></li>\n<li><a href=\"#_batches\">批处理</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_connections\">使用连接</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_a_connection\">获取一条连接</a></li>\n<li><a href=\"#_simplified_connection_api\">简化的连接API</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_transactions\">使用事务</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_transactions_with_connections\">连接中使用事务操作</a></li>\n<li><a href=\"#_simplified_transaction_api\">简化版事务API</a></li>\n</ul>\n</li>\n<li><a href=\"#_cursors_and_streaming\">游标和流式操作</a></li>\n<li><a href=\"#_tracing_queries\">跟踪查询</a></li>\n<li><a href=\"#_postgresql_type_mapping\">PostgreSQL 类型映射</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_handling_json\">JSON</a></li>\n<li><a href=\"#_handling_numeric\">数字类型（Numeric）</a></li>\n</ul>\n</li>\n<li><a href=\"#_handling_arrays\">数组</a></li>\n<li><a href=\"#_handling_datetime_infinity\">日期/时间类型（Date/Time）的最值</a></li>\n<li><a href=\"#_handling_custom_types\">自定义类型</a></li>\n<li><a href=\"#_handling_text_search\">文本检索</a></li>\n<li><a href=\"#_handling_enumerated_types\">枚举类型</a></li>\n<li><a href=\"#_using_java_enum_types\">使用Java枚举类型</a></li>\n<li><a href=\"#_collector_queries\">Collector式查询</a></li>\n<li><a href=\"#_pubsub\">发布/订阅</a></li>\n<li><a href=\"#_cancelling_request\">取消请求</a></li>\n<li><a href=\"#_using_ssltls\">使用 SSL/TLS</a></li>\n<li><a href=\"#_using_a_proxy\">使用代理</a></li>\n<li><a href=\"#_rxjava_2_api\">RxJava 2 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_connection\">连接</a></li>\n<li><a href=\"#_transaction\">事务</a></li>\n<li><a href=\"#_streaming\">流式操作</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>响应式（Reactive） PostgreSQL 客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>响应式PostgreSQL客户端是一款以可扩展性和低开销为目标而专门为PostgreSQL数据库设计的\n客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端是响应式和非阻塞的，可以仅仅使用一条线程来处理大量的数据库连接。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>事件驱动</p>\n</li>\n<li>\n<p>轻量级</p>\n</li>\n<li>\n<p>内置连接池</p>\n</li>\n<li>\n<p>预查询缓存</p>\n</li>\n<li>\n<p>基于PostgreSQL的`NOTIFY/LISTEN`机制实现的发布/订阅</p>\n</li>\n<li>\n<p>批处理和游标</p>\n</li>\n<li>\n<p>支持原生流式操作</p>\n</li>\n<li>\n<p>命令管道（pipeline）</p>\n</li>\n<li>\n<p>RxJava 1 and RxJava 2</p>\n</li>\n<li>\n<p>使用直接内存存储对象，避免了不必要的复制</p>\n</li>\n<li>\n<p>支持Java 8 Date and Time</p>\n</li>\n<li>\n<p>SSL/TLS</p>\n</li>\n<li>\n<p>Unix domain socket</p>\n</li>\n<li>\n<p>支持HTTP/1.x， SOCKS4a 或 SOCKS5 代理</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_usage\"><a class=\"anchor\" href=\"#_usage\"></a>用法</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在 <em>dependencies</em> 里添加如下依赖来引入响应式PostgreSQL客户端：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件里）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-pg-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件里）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-pg-client:4.0.2'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>开始使用</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如下是一种最为简单的连接、查询、关闭连接的方式</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the client pool</span>\nPgPool client = PgPool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// A simple query</span>\nclient\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n\n  <span class=\"hljs-comment\">// Now close the pool</span>\n  client.close();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_postgresql\"><a class=\"anchor\" href=\"#_connecting_to_postgresql\"></a>连接PostgreSQL</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>大多数时间，您将使用连接池连接到 PostgreSQL：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nPgPool client = PgPool.pool(connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>池化PostgreSQL客户端使用连接池去执行数据库操作，\n所有操作都会遵循从池里拿到连接、执行、释放连接到池里这三个步骤。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以传入一个连接池到正在运行的Vert.x实例里：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nPgPool client = PgPool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果不再需要连接池，您需要将其释放：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您想要在同一条连接上执行多个操作时，您需要使用客户端\n<code><a href=\"../../apidocs/io/vertx/pgclient/PgConnection.html\">connection</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以很方便地从连接池里拿到一条连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nPgPool client = PgPool.pool(vertx, connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// Get a connection from the pool</span>\nclient.getConnection().compose(conn -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Got a connection from the pool\"</span>);\n\n  <span class=\"hljs-comment\">// All operations execute on the same connection</span>\n  <span class=\"hljs-keyword\">return</span> conn\n    .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n    .execute()\n    .compose(res -&gt; conn\n      .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='emad'\"</span>)\n      .execute())\n    .onComplete(ar -&gt; {\n      <span class=\"hljs-comment\">// Release the connection to the pool</span>\n      conn.close();\n    });\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    System.out.println(<span class=\"hljs-string\">\"Done\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了连接可以重用，一旦当前连接上的操作已经完成，您需要关闭并释放连接到连接池里。</p>\n</div>\n<div class=\"paragraph\">\n<p>某些情况下您希望通过Unix domain socket类型的连接来提升性能，我们通过Vert.x本机传输支持了这种方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先确保您已经在classpath下添加了 <code>netty-transport-native</code> 这个必须的依赖，同时开启了Unix domain socket功能（pg）选项。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setHost(<span class=\"hljs-string\">\"/var/run/postgresql\"</span>)\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nPgPool client = PgPool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// Create the pooled client with a vertx instance</span>\n<span class=\"hljs-comment\">// Make sure the vertx instance has enabled native transports</span>\nPgPool client2 = PgPool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多详情可以在这里找到 <a href=\"https://vertx.io/docs/vertx-core/java/#_native_transports\">Vert.x 文档</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connect_retries\"><a class=\"anchor\" href=\"#_connect_retries\"></a>重连</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以配置客户端在建立连接失败的时候的重试策略</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options\n  .setReconnectAttempts(<span class=\"hljs-number\">2</span>)\n  .setReconnectInterval(<span class=\"hljs-number\">1000</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>有如下几种配置客户端的可选方案。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_data_object\"><a class=\"anchor\" href=\"#_data_object\"></a>data object</h3>\n<div class=\"paragraph\">\n<p>通过指定 <code>PgConnectOptions</code> 数据对象是一种简单的客户端的配置方式。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool Options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pool from the data object</span>\nPgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);\n\npool.getConnection(ar -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <code>setProperties`或 `addProperty`方法配置通用属性。注意 `setProperties</code> 将覆盖默认的客户端属性。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您可以通过添加 <code>search_path</code> 属性来配置一个默认的schema。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> PgConnectOptions();\n\n<span class=\"hljs-comment\">// Set the default schema</span>\nMap&lt;String, String&gt; props = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\nprops.put(<span class=\"hljs-string\">\"search_path\"</span>, <span class=\"hljs-string\">\"myschema\"</span>);\nconnectOptions.setProperties(props);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于可用属性的更多信息可以在这里找到 <a href=\"https://www.postgresql.org/docs/current/runtime-config-client.html\">PostgreSQL Manuals</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection_uri\"><a class=\"anchor\" href=\"#_connection_uri\"></a>连接uri</h3>\n<div class=\"paragraph\">\n<p>除了使用 <code>PgConnectionOptions</code> 对象，我们也提供了另一种基于URI的可选配置方案：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String connectionUri = <span class=\"hljs-string\">\"postgresql://dbuser:secretpassword@database.server.com:3211/mydb\"</span>;\n\n<span class=\"hljs-comment\">// Create the pool from the connection URI</span>\nPgPool pool = PgPool.pool(connectionUri);\n\n<span class=\"hljs-comment\">// Create the connection from the connection URI</span>\nPgConnection.connect(vertx, connectionUri, res -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于连接uri字符串格式的更多信息可以在这里找到 <a href=\"https://www.postgresql.org/docs/9.6/static/libpq-connect.html#LIBPQ-CONNSTRING\">PostgreSQL 手册</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>当前版本的客户端支持在连接uri里使用如下参数</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>host</p>\n</li>\n<li>\n<p>hostaddr</p>\n</li>\n<li>\n<p>port</p>\n</li>\n<li>\n<p>user</p>\n</li>\n<li>\n<p>password</p>\n</li>\n<li>\n<p>dbname</p>\n</li>\n<li>\n<p>sslmode</p>\n</li>\n<li>\n<p>properties including(application_name, fallback_application_name, search_path)</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n通过URI配置的属性将会覆盖默认的配置属性。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_environment_variables\"><a class=\"anchor\" href=\"#_environment_variables\"></a>环境变量</h3>\n<div class=\"paragraph\">\n<p>您也可以使用环境变量来设置连接的属性值，以此来避免硬编码数据库连接信息。\n您可以参考 <a href=\"https://www.postgresql.org/docs/9.6/static/libpq-envars.html\">官方文档</a>来了解更多详情。\n目前支持下列这些配置参数：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>PGHOST</code></p>\n</li>\n<li>\n<p><code>PGHOSTADDR</code></p>\n</li>\n<li>\n<p><code>PGPORT</code></p>\n</li>\n<li>\n<p><code>PGDATABASE</code></p>\n</li>\n<li>\n<p><code>PGUSER</code></p>\n</li>\n<li>\n<p><code>PGPASSWORD</code></p>\n</li>\n<li>\n<p><code>PGSSLMODE</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>如果您没有在连接时指定连接对象或者URI字符串，此时将会使用环境变量。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">$ PGUSER=user \\\n PGHOST=the-host \\\n PGPASSWORD=secret \\\n PGDATABASE=the-db \\\n PGPORT=<span class=\"hljs-number\">5432</span> \\\n PGSSLMODE=DISABLE</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgPool pool = PgPool.pool();\n\n<span class=\"hljs-comment\">// Create the connection from the environment variables</span>\nPgConnection.connect(vertx, res -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sasl_scram_sha_256_authentication_mechanism\"><a class=\"anchor\" href=\"#_sasl_scram_sha_256_authentication_mechanism\"></a>SASL SCRAM-SHA-256 鉴权机制。</h3>\n<div class=\"paragraph\">\n<p>为了使用 sasl SCRAM-SHA-256鉴权，需要在 <em>dependencies</em> 里添加如下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件里）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.ongres.scram<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件里）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'com.ongres.scram:client:2.1'</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nSCRAM-SHA-256-PLUS（在Postgresql 11中加入）当前版本客户端暂不支持。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_queries\"><a class=\"anchor\" href=\"#_running_queries\"></a>执行查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您不需要事务或者只是执行一个单次查询操作，您可以直接在连接池里执行查询；\n连接池会使用某一条连接执行并给您返回结果。\n下边是如何执行一个简单的查询的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>预查询</h3>\n<div class=\"paragraph\">\n<p>执行预查询也是一样的操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>SQL字符通过位置引用实际的参数，并使用数据库的语法 `$1`, `$2`, etc…​</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id=$1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>查询相关的方法为 <em>SELECT</em> 类型的操作提供了异步的 <code><a href=\"../../apidocs/io/vertx/sqlclient/RowSet.html\">RowSet</a></code> 实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT first_name, last_name FROM users\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者 <em>UPDATE</em>/<em>INSERT</em> 类型的查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO users (first_name, last_name) VALUES ($1, $2)\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>),  ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Row对象（<code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code>）可以让您通过索引位置获取相应的数据</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者通过名称</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-string\">\"first_name\"</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端在此处没有做特殊处理，无论您的SQL文本时什么，列名都将使用数据库表中的名称标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以直接访问得到多种类型</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String firstName = row.getString(<span class=\"hljs-string\">\"first_name\"</span>);\nBoolean male = row.getBoolean(<span class=\"hljs-string\">\"male\"</span>);\nInteger age = row.getInteger(<span class=\"hljs-string\">\"age\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用缓存过的预处理语句去执行一次性的预查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connectOptions.setCachePreparedStatements(<span class=\"hljs-keyword\">true</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = $1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以创建 <code>PreparedStatement</code> 并自主地管理它的生命周期。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sqlConnection\n  .prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = $1\"</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      PreparedStatement preparedStatement = ar.result();\n      preparedStatement.query()\n        .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n            System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n            preparedStatement.close();\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar2.cause().getMessage());\n          }\n        });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batches\"><a class=\"anchor\" href=\"#_batches\"></a>批处理</h3>\n<div class=\"paragraph\">\n<p>您可以在预查询中执行批处理操作</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;Tuple&gt; batch = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>, <span class=\"hljs-string\">\"Julien Viet\"</span>));\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"emad\"</span>, <span class=\"hljs-string\">\"Emad Alblueshi\"</span>));\n\n<span class=\"hljs-comment\">// Execute the prepared batch</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO USERS (id, name) VALUES ($1, $2)\"</span>)\n  .executeBatch(batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// Process rows</span>\n    RowSet&lt;Row&gt; rows = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Batch failed \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 'RETURNING' 从查询里拿到生成的key：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO color (color_name) VALUES ($1), ($2), ($3) RETURNING color_id\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"white\"</span>, <span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"generated key: \"</span> + row.getInteger(<span class=\"hljs-string\">\"color_id\"</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_connections\"><a class=\"anchor\" href=\"#_using_connections\"></a>使用连接</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>获取一条连接</h3>\n<div class=\"paragraph\">\n<p>当您要执行查询（无事务）操作时，您可以创建一条或者从连接池里拿到一条连接。\n请注意在从拿到连接到将连接释放回连接池这之间的连接状态，服务端可能由于某些原因比如空闲时间超时，而关闭这条连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .getConnection()\n  .compose(connection -&gt;\n    connection\n      .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ($1, $2)\"</span>)\n      .executeBatch(Arrays.asList(\n        Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>),\n        Tuple.of(<span class=\"hljs-string\">\"Emad\"</span>, <span class=\"hljs-string\">\"Alblueshi\"</span>)\n      ))\n      .compose(res -&gt; connection\n        <span class=\"hljs-comment\">// Do something with rows</span>\n        .query(<span class=\"hljs-string\">\"SELECT COUNT(*) FROM Users\"</span>)\n        .execute()\n        .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n      .eventually(v -&gt; connection.close())\n  ).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Insert users, now the number of users is \"</span> + count);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以通过连接对象创建预查询:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection\n  .prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>)\n  .compose(pq -&gt;\n    pq.query()\n      .execute(Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>))\n      .eventually(v -&gt; pq.close())\n  ).onSuccess(rows -&gt; {\n  <span class=\"hljs-comment\">// All rows</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_connection_api\"><a class=\"anchor\" href=\"#_simplified_connection_api\"></a>简化的连接API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withConnection-java.util.function.Function-io.vertx.core.Handler-\">withConnection</a></code>\n并以当前连接要执行的操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这样会从连接池里拿到一条连接，并使用当前连接执行目标操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种方式需要返回一个future对象来表示操作结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>当这个future操作完成后，当前连接会被释放会连接池同时您也可能拿到最终的执行结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withConnection(connection -&gt;\n  connection\n    .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ($1, $2)\"</span>)\n    .executeBatch(Arrays.asList(\n      Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>),\n      Tuple.of(<span class=\"hljs-string\">\"Emad\"</span>, <span class=\"hljs-string\">\"Alblueshi\"</span>)\n    ))\n    .compose(res -&gt; connection\n      <span class=\"hljs-comment\">// Do something with rows</span>\n      .query(<span class=\"hljs-string\">\"SELECT COUNT(*) FROM Users\"</span>)\n      .execute()\n      .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Insert users, now the number of users is \"</span> + count);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_transactions\"><a class=\"anchor\" href=\"#_using_transactions\"></a>使用事务</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_transactions_with_connections\"><a class=\"anchor\" href=\"#_transactions_with_connections\"></a>连接中使用事务操作</h3>\n<div class=\"paragraph\">\n<p>您可以使用SQL语法 <code>BEGIN</code>/<code>COMMIT</code>/<code>ROLLBACK</code> 来执行事务操作，同时您必须使用\n<code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 并自己管理当前连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者您也可以使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 的事务API：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection()\n  <span class=\"hljs-comment\">// Transaction must use a connection</span>\n  .onSuccess(conn -&gt; {\n  <span class=\"hljs-comment\">// Begin the transaction</span>\n  conn.begin()\n    .compose(tx -&gt; conn\n      <span class=\"hljs-comment\">// Various statements</span>\n      .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n      .execute()\n      .compose(res2 -&gt; conn\n        .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\"</span>)\n        .execute())\n      <span class=\"hljs-comment\">// Commit the transaction</span>\n      .compose(res3 -&gt; tx.commit()))\n    <span class=\"hljs-comment\">// Return the connection to the pool</span>\n    .eventually(v -&gt; conn.close())\n    .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction succeeded\"</span>))\n    .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction failed: \"</span> + err.getMessage()));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当数据库服务端返回当前事务已失败（比如常见的 <em>current transaction is aborted, commands ignored until end of transaction block</em>）\n，事务已回滚和 <code><a href=\"../../apidocs/io/vertx/sqlclient/Transaction.html#completion--\">completion</a></code> 方法的返回值future返回了\n<code><a href=\"../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html\">TransactionRollbackException</a></code> 异常时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">tx.completion()\n  .onFailure(err -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Transaction failed =&gt; rolled back\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_transaction_api\"><a class=\"anchor\" href=\"#_simplified_transaction_api\"></a>简化版事务API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withTransaction-java.util.function.Function-io.vertx.core.Handler-\">withTransaction</a></code> 方法\n并传递待执行的事务操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将会从连接池里拿到一条连接，开启事务并调用待执行操作，配合客户端一起执行该事务范围内\n的所有操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>待执行操作需要返回一个future来表示可能产生的结果：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当future成功时，客户端提交该事务</p>\n</li>\n<li>\n<p>当future失败时，客户端回滚该事务</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>事务操作完成后，连接会被释放回连接池，并且可以获取到最终的操作结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withTransaction(client -&gt; client\n  .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n  .execute()\n  .flatMap(res -&gt; client\n    .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\"</span>)\n    .execute()\n    <span class=\"hljs-comment\">// Map to a message result</span>\n    .map(<span class=\"hljs-string\">\"Users inserted\"</span>)))\n  .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction succeeded\"</span>))\n  .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction failed: \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cursors_and_streaming\"><a class=\"anchor\" href=\"#_cursors_and_streaming\"></a>游标和流式操作</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下预查询操作会拉去所有的行记录，您可以使用\n<code><a href=\"../../apidocs/io/vertx/sqlclient/Cursor.html\">游标</a></code> 来控制您想要读取的行数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>, ar0 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar0.succeeded()) {\n    PreparedStatement pq = ar0.result();\n\n    <span class=\"hljs-comment\">// Cursors require to run within a transaction</span>\n    connection.begin(ar1 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n        Transaction tx = ar1.result();\n\n        <span class=\"hljs-comment\">// Create a cursor</span>\n        Cursor cursor = pq.cursor(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>));\n\n        <span class=\"hljs-comment\">// Read 50 rows</span>\n        cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n\n            <span class=\"hljs-comment\">// Check for more ?</span>\n            <span class=\"hljs-keyword\">if</span> (cursor.hasMore()) {\n              <span class=\"hljs-comment\">// Repeat the process...</span>\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">// No more rows - commit the transaction</span>\n              tx.commit();\n            }\n          }\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>游标释放时需要同时执行关闭操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n    <span class=\"hljs-comment\">// Close the cursor</span>\n    cursor.close();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>stream API也可以用于游标，尤其是在Rx版的客户端，可能更为方便。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>, ar0 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar0.succeeded()) {\n    PreparedStatement pq = ar0.result();\n\n    <span class=\"hljs-comment\">// Streams require to run within a transaction</span>\n    connection.begin(ar1 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n        Transaction tx = ar1.result();\n\n        <span class=\"hljs-comment\">// Fetch 50 rows at a time</span>\n        RowStream&lt;Row&gt; stream = pq.createStream(<span class=\"hljs-number\">50</span>, Tuple.of(<span class=\"hljs-string\">\"julien\"</span>));\n\n        <span class=\"hljs-comment\">// Use the stream</span>\n        stream.exceptionHandler(err -&gt; {\n          System.out.println(<span class=\"hljs-string\">\"Error: \"</span> + err.getMessage());\n        });\n        stream.endHandler(v -&gt; {\n          tx.commit();\n          System.out.println(<span class=\"hljs-string\">\"End of stream\"</span>);\n        });\n        stream.handler(row -&gt; {\n          System.out.println(<span class=\"hljs-string\">\"User: \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上边的stream会批量读取 <code>50</code> 行并同时将其转换为流，当这些行记录被传递给处理器时，\n会以此类推地读取下一批的 <code>50</code> 行记录。</p>\n</div>\n<div class=\"paragraph\">\n<p>stream支持重启或暂停，已经加载到的行记录将会被保留在内存里直到被传递给处理器，此时\n游标也将终止遍历。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nPostreSQL会在事务结束后销毁游标，因而游标API应该在事务内使用，\n否则您将可能收到 <code>34000</code> PostgreSQL错误码。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>跟踪查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当Vert.x启用tracing功能时，SQL客户端可以跟踪查询的执行情况。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端会上报下列这些 <em>client</em> spans：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> 操作名称</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>db.user</code> ：数据库用户名</p>\n</li>\n<li>\n<p><code>db.instance</code> ：数据库实例</p>\n</li>\n<li>\n<p><code>db.statement</code> ：SQL语句</p>\n</li>\n<li>\n<p><code>db.type</code> ：<em>sql</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认的 tracing 策略时 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>，客户端\n在一个活跃trace里只创建一个span。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnectOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 方法来调整tracing策略，\n例如您可以设置为 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code>，\n客户端将始终上报span：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_postgresql_type_mapping\"><a class=\"anchor\" href=\"#_postgresql_type_mapping\"></a>PostgreSQL 类型映射</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当前版本客户端支持下列的PostgreSQL类型</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>BOOLEAN (<code>java.lang.Boolean</code>)</p>\n</li>\n<li>\n<p>INT2 (<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>INT4 (<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>INT8 (<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>FLOAT4 (<code>java.lang.Float</code>)</p>\n</li>\n<li>\n<p>FLOAT8 (<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>CHAR (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>VARCHAR (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>TEXT (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>ENUM (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>NAME (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>SERIAL2 (<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>SERIAL4 (<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>SERIAL8 (<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>NUMERIC (<code>io.vertx.sqlclient.data.Numeric</code>)</p>\n</li>\n<li>\n<p>UUID (<code>java.util.UUID</code>)</p>\n</li>\n<li>\n<p>DATE (<code>java.time.LocalDate</code>)</p>\n</li>\n<li>\n<p>TIME (<code>java.time.LocalTime</code>)</p>\n</li>\n<li>\n<p>TIMETZ (<code>java.time.OffsetTime</code>)</p>\n</li>\n<li>\n<p>TIMESTAMP (<code>java.time.LocalDateTime</code>)</p>\n</li>\n<li>\n<p>TIMESTAMPTZ (<code>java.time.OffsetDateTime</code>)</p>\n</li>\n<li>\n<p>INTERVAL (<code>io.vertx.pgclient.data.Interval</code>)</p>\n</li>\n<li>\n<p>BYTEA (<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n<li>\n<p>JSON (<code>io.vertx.core.json.JsonObject</code>, <code>io.vertx.core.json.JsonArray</code>, <code>Number</code>, <code>Boolean</code>, <code>String</code>, <code>io.vertx.sqlclient.Tuple#JSON_NULL</code>)</p>\n</li>\n<li>\n<p>JSONB (<code>io.vertx.core.json.JsonObject</code>, <code>io.vertx.core.json.JsonArray</code>, <code>Number</code>, <code>Boolean</code>, <code>String</code>, <code>io.vertx.sqlclient.Tuple#JSON_NULL</code>)</p>\n</li>\n<li>\n<p>POINT (<code>io.vertx.pgclient.data.Point</code>)</p>\n</li>\n<li>\n<p>LINE (<code>io.vertx.pgclient.data.Line</code>)</p>\n</li>\n<li>\n<p>LSEG (<code>io.vertx.pgclient.data.LineSegment</code>)</p>\n</li>\n<li>\n<p>BOX (<code>io.vertx.pgclient.data.Box</code>)</p>\n</li>\n<li>\n<p>PATH (<code>io.vertx.pgclient.data.Path</code>)</p>\n</li>\n<li>\n<p>POLYGON (<code>io.vertx.pgclient.data.Polygon</code>)</p>\n</li>\n<li>\n<p>CIRCLE (<code>io.vertx.pgclient.data.Circle</code>)</p>\n</li>\n<li>\n<p>TSVECTOR (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>TSQUERY (<code>java.lang.String</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Tuple（元组）在解码时使用上述类型映射关系存储解码出的值，并且在合法的条件下可以动态转换为实际类型的值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .query(<span class=\"hljs-string\">\"SELECT 1::BIGINT \\\"VAL\\\"\"</span>)\n  .execute(ar -&gt; {\n  RowSet&lt;Row&gt; rowSet = ar.result();\n  Row row = rowSet.iterator().next();\n\n  <span class=\"hljs-comment\">// Stored as java.lang.Long</span>\n  Object value = row.getValue(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-comment\">// Convert to java.lang.Integer</span>\n  Integer intValue = row.getInteger(<span class=\"hljs-number\">0</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Tuple（元组）编码时使用上述关系作为类型间的映射关系，除非类型为数字，在这种情况下将会使用 <code>java.lang.Number</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .query(<span class=\"hljs-string\">\"SELECT 1::BIGINT \\\"VAL\\\"\"</span>)\n  .execute(ar -&gt; {\n  RowSet&lt;Row&gt; rowSet = ar.result();\n  Row row = rowSet.iterator().next();\n\n  <span class=\"hljs-comment\">// Stored as java.lang.Long</span>\n  Object value = row.getValue(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-comment\">// Convert to java.lang.Integer</span>\n  Integer intValue = row.getInteger(<span class=\"hljs-number\">0</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上述类型的数组形式也是支持的。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_json\"><a class=\"anchor\" href=\"#_handling_json\"></a>JSON</h3>\n<div class=\"paragraph\">\n<p>PostgreSQL的 <code>JSON</code> 和 <code>JSONB</code>  用下列的java类型表示：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>String</code></p>\n</li>\n<li>\n<p><code>Number</code></p>\n</li>\n<li>\n<p><code>Boolean</code></p>\n</li>\n<li>\n<p><code>io.vertx.core.json.JsonObject</code></p>\n</li>\n<li>\n<p><code>io.vertx.core.json.JsonArray</code></p>\n</li>\n<li>\n<p><code>io.vertx.sqlclient.Tuple#JSON_NULL</code> for representing the JSON null literal</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Tuple tuple = Tuple.of(\n  Tuple.JSON_NULL,\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>),\n  <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-comment\">// Retrieving json</span>\nObject value = tuple.getValue(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Expect JSON_NULL</span>\n\n<span class=\"hljs-comment\">//</span>\nvalue = tuple.get(JsonObject<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 1)</span>; <span class=\"hljs-comment\">// Expect JSON object</span>\n\n<span class=\"hljs-comment\">//</span>\nvalue = tuple.get(Integer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 2)</span>; <span class=\"hljs-comment\">// Expect 3</span>\nvalue = tuple.getInteger(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// Expect 3</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_numeric\"><a class=\"anchor\" href=\"#_handling_numeric\"></a>数字类型（Numeric）</h3>\n<div class=\"paragraph\">\n<p>java的 <code><a href=\"../../apidocs/io/vertx/sqlclient/data/Numeric.html\">Numeric</a></code> 用来表示PostgreSQL的 <code>NUMERIC</code> 类型。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Numeric numeric = row.get(Numeric<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 0)</span>;\n<span class=\"hljs-keyword\">if</span> (numeric.isNaN()) {\n  <span class=\"hljs-comment\">// Handle NaN</span>\n} <span class=\"hljs-keyword\">else</span> {\n  BigDecimal value = numeric.bigDecimalValue();\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_arrays\"><a class=\"anchor\" href=\"#_handling_arrays\"></a>数组</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>数组可以用在 <code><a href=\"../../apidocs/io/vertx/sqlclient/Tuple.html\">Tuple</a></code> 和 <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Tuple tuple = Tuple.of(<span class=\"hljs-keyword\">new</span> String[]{ <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"tuple\"</span>, <span class=\"hljs-string\">\"with\"</span>, <span class=\"hljs-string\">\"arrays\"</span> });\n\n<span class=\"hljs-comment\">// Add a string array to the tuple</span>\ntuple.addArrayOfString(<span class=\"hljs-keyword\">new</span> String[]{<span class=\"hljs-string\">\"another\"</span>, <span class=\"hljs-string\">\"array\"</span>});\n\n<span class=\"hljs-comment\">// Get the first array of string</span>\nString[] array = tuple.getArrayOfStrings(<span class=\"hljs-number\">0</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_datetime_infinity\"><a class=\"anchor\" href=\"#_handling_datetime_infinity\"></a>日期/时间类型（Date/Time）的最值</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>PostgreSQL定义了几个特殊的值用来表示这些最值。</p>\n</div>\n<div class=\"paragraph\">\n<p>相应类型的最大/最小值由这些常量 <a href=\"https://www.postgresql.org/docs/9.0/datatype-datetime.html\">特殊值</a> 表示。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>OffsetDateTime.MAX</code>/OffsetDateTime.MIN`</p>\n</li>\n<li>\n<p><code>LocalDateTime.MAX</code>/LocalDateTime.MIN`</p>\n</li>\n<li>\n<p><code>LocalDate.MAX</code>/LocalDate.MIN`</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT 'infinity'::DATE \\\"LocalDate\\\"\"</span>)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      Row row = ar.result().iterator().next();\n      System.out.println(row.getLocalDate(<span class=\"hljs-string\">\"LocalDate\"</span>).equals(LocalDate.MAX));\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_custom_types\"><a class=\"anchor\" href=\"#_handling_custom_types\"></a>自定义类型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>发送和从Postgres接收的自定义类型都由字符串来表示。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以读取PostgreSQL并以字符串的形式得到自定义的类型值</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT address, (address).city FROM address_book WHERE id=$1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-number\">3</span>),  ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"Full Address \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\", City \"</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以向PostgreSQL写入字符串</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO address_book (id, address) VALUES ($1, $2)\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">\"('Anytown', 'Second Ave', false)\"</span>),  ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_text_search\"><a class=\"anchor\" href=\"#_handling_text_search\"></a>文本检索</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>文本检索使用的是java的 <code>String</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT to_tsvector( $1 ) @@ to_tsquery( $2 )\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"fat cats ate fat rats\"</span>, <span class=\"hljs-string\">\"fat &amp; rat\"</span>),  ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"Match : \"</span> + row.getBoolean(<span class=\"hljs-number\">0</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>tsvector</code> 和 <code>tsquery</code> 可以使用java的 <code>String</code> 类型来从数据库中获取</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT to_tsvector( $1 ), to_tsquery( $2 )\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"fat cats ate fat rats\"</span>, <span class=\"hljs-string\">\"fat &amp; rat\"</span>),  ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"Vector : \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\", query : \"</span>+row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_enumerated_types\"><a class=\"anchor\" href=\"#_handling_enumerated_types\"></a>枚举类型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>PostgreSQL的 <a href=\"https://www.postgresql.org/docs/9.1/datatype-enum.html\">枚举类型</a> 被映射为java的字符串。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO colors VALUES ($2)\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"red\"</span>),  res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_java_enum_types\"><a class=\"anchor\" href=\"#_using_java_enum_types\"></a>使用Java枚举类型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以将Java的 <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html\">枚举类型</a>\n映射为下列这些列类型：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Strings (VARCHAR, TEXT)</p>\n</li>\n<li>\n<p>PosgreSQL enumerated types</p>\n</li>\n<li>\n<p>Numbers (INT2, INT4, INT8)</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO colors VALUES ($1)\"</span>)\n  .execute(Tuple.of(Color.red))\n  .flatMap(res -&gt;\n    client\n      .preparedQuery(<span class=\"hljs-string\">\"SELECT color FROM colors\"</span>)\n      .execute()\n  ).onComplete(res -&gt; {\n    <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n      RowSet&lt;Row&gt; rows = res.result();\n      <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n        System.out.println(row.get(Color<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, \"<span class=\"hljs-title\">color</span>\"))</span>;\n      }\n    }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>String and PostgreSQL enumerated types 对应Java枚举类的 <code>name()</code> 方法的返回值。</p>\n</div>\n<div class=\"paragraph\">\n<p>Numbers类型对应Java枚举类的 <code>ordinal()</code> 方法的返回值。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector式查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以将Java collector与查询API结合使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, Map&lt;Long, String&gt;&gt; collector = Collectors.toMap(\n  row -&gt; row.getLong(<span class=\"hljs-string\">\"id\"</span>),\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    SqlResult&lt;Map&lt;Long, String&gt;&gt; result = ar.result();\n\n    <span class=\"hljs-comment\">// Get the map created by the collector</span>\n    Map&lt;Long, String&gt; map = result.value();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + map);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>collector式查询的结果集处理过程中不能再拿到 <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> 的引用，因为\npg客户端在处理collector时，只会用一个row用于处理整个集合。</p>\n</div>\n<div class=\"paragraph\">\n<p>Java的 <code>Collectors</code> 类提供了很多很有趣的预定义的collector，比如您可以很容易\n从row集合里得到一个字符串：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, String&gt; collector = Collectors.mapping(\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>),\n  Collectors.joining(<span class=\"hljs-string\">\",\"</span>, <span class=\"hljs-string\">\"(\"</span>, <span class=\"hljs-string\">\")\"</span>)\n);\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>).collecting(collector).execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;String&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the string created by the collector</span>\n      String list = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + list);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pubsub\"><a class=\"anchor\" href=\"#_pubsub\"></a>发布/订阅</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>PostgreSQL支持发布/订阅式的通信方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以设置一个 <code><a href=\"../../apidocs/io/vertx/pgclient/PgConnection.html#notificationHandler-io.vertx.core.Handler-\">notificationHandler</a></code> 用于\n接收PostgreSQL的通知消息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.notificationHandler(notification -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Received \"</span> + notification.getPayload() + <span class=\"hljs-string\">\" on channel \"</span> + notification.getChannel());\n});\n\nconnection\n  .query(<span class=\"hljs-string\">\"LISTEN some-channel\"</span>)\n  .execute(ar -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Subscribed to channel\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>PgSubscriber (<code><a href=\"../../apidocs/io/vertx/pgclient/pubsub/PgSubscriber.html\">PgSubscriber</a></code>) 是一种用作\n处理单条连接上的订阅的通道（channel）管理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgSubscriber subscriber = PgSubscriber.subscriber(vertx, <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n);\n\n<span class=\"hljs-comment\">// You can set the channel before connect</span>\nsubscriber.channel(<span class=\"hljs-string\">\"channel1\"</span>).handler(payload -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Received \"</span> + payload);\n});\n\nsubscriber.connect(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    <span class=\"hljs-comment\">// Or you can set the channel after connect</span>\n    subscriber.channel(<span class=\"hljs-string\">\"channel2\"</span>).handler(payload -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"Received \"</span> + payload);\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>channel（通道）方法的参数即通道名称（接收端）需要和PostgreSQL发送通知时的通道名称保持一致。\n注意这里和SQL中的通道名称的形式不同，在 <code><a href=\"../../apidocs/io/vertx/pgclient/pubsub/PgSubscriber.html\">PgSubscriber</a></code>\n内部会把待提交的通道名称预处理为带引号的形式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgSubscriber subscriber = PgSubscriber.subscriber(vertx, <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n);\n\nsubscriber.connect(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-comment\">// Complex channel name - name in PostgreSQL requires a quoted ID</span>\n      subscriber.channel(<span class=\"hljs-string\">\"Complex.Channel.Name\"</span>).handler(payload -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"Received \"</span> + payload);\n      });\n      subscriber.channel(<span class=\"hljs-string\">\"Complex.Channel.Name\"</span>).subscribeHandler(subscribed -&gt; {\n        subscriber.actualConnection()\n          .query(<span class=\"hljs-string\">\"NOTIFY \\\"Complex.Channel.Name\\\", 'msg'\"</span>)\n          .execute(notified -&gt; {\n            System.out.println(<span class=\"hljs-string\">\"Notified \\\"Complex.Channel.Name\\\"\"</span>);\n          });\n      });\n\n      <span class=\"hljs-comment\">// PostgreSQL simple ID's are forced lower-case</span>\n      subscriber.channel(<span class=\"hljs-string\">\"simple_channel\"</span>).handler(payload -&gt; {\n          System.out.println(<span class=\"hljs-string\">\"Received \"</span> + payload);\n      });\n      subscriber.channel(<span class=\"hljs-string\">\"simple_channel\"</span>).subscribeHandler(subscribed -&gt; {\n        <span class=\"hljs-comment\">// The following simple channel identifier is forced to lower case</span>\n        subscriber.actualConnection()\n          .query(<span class=\"hljs-string\">\"NOTIFY Simple_CHANNEL, 'msg'\"</span>)\n          .execute(notified -&gt; {\n            System.out.println(<span class=\"hljs-string\">\"Notified simple_channel\"</span>);\n          });\n      });\n\n      <span class=\"hljs-comment\">// The following channel name is longer than the current</span>\n      <span class=\"hljs-comment\">// (NAMEDATALEN = 64) - 1 == 63 character limit and will be truncated</span>\n      subscriber.channel(<span class=\"hljs-string\">\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbb\"</span>)\n        .handler(payload -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"Received \"</span> + payload);\n      });\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以自定义一个方法来实现重连，该方法的参数为 <code>retries</code> （重试次数），\n返回值为 <code>amountOfTime</code>（重试间隔）：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当 <code>amountOfTime &lt; 0</code>: 不重试，并关闭订阅</p>\n</li>\n<li>\n<p>当 <code>amountOfTime = 0</code>: 立即重试</p>\n</li>\n<li>\n<p>当 <code>amountOfTime &gt; 0</code>: 在 <code>amountOfTime</code> 毫秒之后发起重试</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgSubscriber subscriber = PgSubscriber.subscriber(vertx, <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n);\n\n<span class=\"hljs-comment\">// Reconnect at most 10 times after 100 ms each</span>\nsubscriber.reconnectPolicy(retries -&gt; {\n  <span class=\"hljs-keyword\">if</span> (retries &lt; <span class=\"hljs-number\">10</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100L</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1L</span>;\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认的策略是不重连。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cancelling_request\"><a class=\"anchor\" href=\"#_cancelling_request\"></a>取消请求</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>PostgreSQL 支持取消正在运行的请求. 您可以使用 <code><a href=\"../../apidocs/io/vertx/pgclient/PgConnection.html#cancelRequest-io.vertx.core.Handler-\">cancelRequest</a></code> 正在运行的请求. 取消请求的操作在执行时将和PostgreSQL服务端新建一条连接、执行取消请求、关闭这条连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection\n  .query(<span class=\"hljs-string\">\"SELECT pg_sleep(20)\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// imagine this is a long query and is still running</span>\n    System.out.println(<span class=\"hljs-string\">\"Query success\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// the server will abort the current query after cancelling request</span>\n    System.out.println(<span class=\"hljs-string\">\"Failed to query due to \"</span> + ar.cause().getMessage());\n  }\n});\nconnection.cancelRequest(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Cancelling request has been sent\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failed to send cancelling request\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"quoteblock\">\n<blockquote>\n<div class=\"paragraph\">\n<p>取消请求可能不会起作用——如果请求到达时，服务端已经处理完了当前查询请求，此时取消操作不会起作用。反之，取消请求得以执行，目标命令执行提前终止并返回一条错误消息。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\">\n<p>更多详细信息可以在这里找到 <a href=\"https://www.postgresql.org/docs/11/protocol-flow.html#id-1.10.5.7.9\">official documentation</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_ssltls\"><a class=\"anchor\" href=\"#_using_ssltls\"></a>使用 SSL/TLS</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为客户端连接添加SSL的操作，您可以参考Vert.x的\n<code>NetClient</code> 的 <code><a href=\"../../apidocs/io/vertx/pgclient/PgConnectOptions.html\">PgConnectOptions</a></code> 配置操作。\n当前版本客户端支持全部的PostgreSql <a href=\"https://www.postgresql.org/docs/current/libpq-ssl.html#LIBPQ-SSL-PROTECTION\">SSL模式</a>配置，您可以通过 <code>sslmode</code> 配置它们。客户端默认不启用SSL模式。\n<code>ssl</code> 参数仅作为一种设置 <code>sslmode</code> 的快捷方式。 <code>setSsl(true)</code> 等价于 <code>setSslMode(VERIFY_CA)</code>，<code>setSsl(false)</code> 等价于 <code>setSslMode(DISABLE)</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PgConnectOptions options = <span class=\"hljs-keyword\">new</span> PgConnectOptions()\n  .setPort(<span class=\"hljs-number\">5432</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n  .setSslMode(SslMode.VERIFY_CA)\n  .setPemTrustOptions(<span class=\"hljs-keyword\">new</span> PemTrustOptions().addCertPath(<span class=\"hljs-string\">\"/path/to/cert.pem\"</span>));\n\nPgConnection.connect(vertx, options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Connected with SSL</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Could not connect \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多详细信息可以在这里找到 <a href=\"http://vertx.io/docs/vertx-core/java/#ssl\">Vert.x documentation</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_a_proxy\"><a class=\"anchor\" href=\"#_using_a_proxy\"></a>使用代理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以配置客户端使用HTTP/1.x 连接，SOCKS4a 或 SOCKS5 代理。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多信息可以在这里找到 <a href=\"http://vertx.io/docs/vertx-core/java/#_using_a_proxy_for_client_connections\">Vert.x documentation</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_2_api\"><a class=\"anchor\" href=\"#_rxjava_2_api\"></a>RxJava 2 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Rx风格的API支持 RxJava 1 and RxJava 2，下边的例子使用的是 RxJava 2。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;RowSet&lt;Row&gt;&gt; single = pool.query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>).rxExecute();\n\n<span class=\"hljs-comment\">// Execute the query</span>\nsingle.subscribe(result -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n}, err -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + err.getMessage());\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection\"><a class=\"anchor\" href=\"#_connection\"></a>连接</h3>\n<div class=\"paragraph\">\n<p>简化版的连接API可以让您很容易地使用connection对象，<code>withConnection</code>\n方法会从连接池里获取到一条连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Maybe&lt;RowSet&lt;Row&gt;&gt; maybe = pool.rxWithConnection((Function&lt;SqlConnection, Maybe&lt;RowSet&lt;Row&gt;&gt;&gt;) conn -&gt;\n  conn\n    .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n    .rxExecute()\n    .flatMap(result -&gt; conn\n      .query(<span class=\"hljs-string\">\"SELECT * FROM Users\"</span>)\n      .rxExecute())\n    .toMaybe());\n\nmaybe.subscribe(rows -&gt; {\n  <span class=\"hljs-comment\">// Success</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// Failed</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_transaction\"><a class=\"anchor\" href=\"#_transaction\"></a>事务</h3>\n<div class=\"paragraph\">\n<p>简化版的事务API可以让您很容易地编写异步事务处理流，<code>withTransaction</code>\n方法会为您启动和提交事务：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Completable completable = pool.rxWithTransaction((Function&lt;SqlConnection, Maybe&lt;RowSet&lt;Row&gt;&gt;&gt;) conn -&gt;\n  conn\n    .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n    .rxExecute()\n    .flatMap(result -&gt; conn\n      .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\"</span>)\n      .rxExecute())\n    .toMaybe())\n  .ignoreElement();\n\ncompletable.subscribe(() -&gt; {\n  <span class=\"hljs-comment\">// Transaction succeeded</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// Transaction failed</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_streaming\"><a class=\"anchor\" href=\"#_streaming\"></a>流式操作</h3>\n<div class=\"paragraph\">\n<p>RxJava 2 支持 <code>Observable</code> 和 <code>Flowable</code> 类型，这些类型可以从 <code><a href=\"../../apidocs/io/vertx/reactivex/sqlclient/PreparedQuery.html\">PreparedQuery</a></code>\n产生的 <code><a href=\"../../apidocs/io/vertx/reactivex/sqlclient/RowStream.html\">RowStream</a></code>\n里获取到：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Row&gt; observable = pool.rxGetConnection().flatMapObservable(conn -&gt; conn\n  .rxBegin()\n  .flatMapObservable(tx -&gt;\n    conn\n      .rxPrepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>)\n      .flatMapObservable(preparedQuery -&gt; {\n        <span class=\"hljs-comment\">// Fetch 50 rows at a time</span>\n        RowStream&lt;Row&gt; stream = preparedQuery.createStream(<span class=\"hljs-number\">50</span>, Tuple.of(<span class=\"hljs-string\">\"julien\"</span>));\n        <span class=\"hljs-keyword\">return</span> stream.toObservable();\n      })\n      .doAfterTerminate(tx::commit)));\n\n<span class=\"hljs-comment\">// Then subscribe</span>\nobservable.subscribe(row -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"User: \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n}, err -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Error: \"</span> + err.getMessage());\n}, () -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"End of stream\"</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>下边是使用 <code>Flowable</code> 的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Row&gt; flowable = pool.rxGetConnection().flatMapPublisher(conn -&gt; conn\n  .rxBegin()\n  .flatMapPublisher(tx -&gt;\n    conn\n      .rxPrepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>)\n      .flatMapPublisher(preparedQuery -&gt; {\n        <span class=\"hljs-comment\">// Fetch 50 rows at a time</span>\n        RowStream&lt;Row&gt; stream = preparedQuery.createStream(<span class=\"hljs-number\">50</span>, Tuple.of(<span class=\"hljs-string\">\"julien\"</span>));\n        <span class=\"hljs-keyword\">return</span> stream.toFlowable();\n      })\n      .doAfterTerminate(tx::commit)));\n\n<span class=\"hljs-comment\">// Then subscribe</span>\nflowable.subscribe(<span class=\"hljs-keyword\">new</span> Subscriber&lt;Row&gt;() {\n\n  <span class=\"hljs-keyword\">private</span> Subscription sub;\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onSubscribe</span><span class=\"hljs-params\">(Subscription subscription)</span> </span>{\n    sub = subscription;\n    subscription.request(<span class=\"hljs-number\">1</span>);\n  }\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(Row row)</span> </span>{\n    sub.request(<span class=\"hljs-number\">1</span>);\n    System.out.println(<span class=\"hljs-string\">\"User: \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n  }\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable err)</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"Error: \"</span> + err.getMessage());\n  }\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onComplete</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">\"End of stream\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}