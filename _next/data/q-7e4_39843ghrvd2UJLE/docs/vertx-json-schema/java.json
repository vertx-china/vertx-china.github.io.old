{"pageProps":{"slug":"vertx-json-schema/java","title":"Vert.x Json Schema","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_json_schema\">使用 Vert.x Json Schema</a></li>\n<li><a href=\"#_concepts\">相关概念</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_schema\">Schema</a></li>\n<li><a href=\"#_schemaparser_schemarouter\">SchemaParser 和 SchemaRouter</a></li>\n</ul>\n</li>\n<li><a href=\"#_parse_a_schema\">解析schema</a></li>\n<li><a href=\"#_validate\">校验</a></li>\n<li><a href=\"#_apply_default_values\">设置默认值</a></li>\n<li><a href=\"#_adding_custom_formats\">自定义格式</a></li>\n<li><a href=\"#_adding_custom_keywords\">自定义关键词</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_synchronous_keywords\">同步关键词</a></li>\n<li><a href=\"#_asynchronous_keywords\">异步关键词</a></li>\n</ul>\n</li>\n<li><a href=\"#_building_your_schemas_from_code\">用代码来构建schema</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_the_schema\">创建schema</a></li>\n<li><a href=\"#_using_the_keywords\">使用关键词</a></li>\n<li><a href=\"#_defining_the_schema_structure\">定义schema的结构</a></li>\n<li><a href=\"#_ref_and_aliases\"><code>$ref</code> 和 别名</a></li>\n<li><a href=\"#_using_the_schema\">使用schema</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Json Schema</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Json Schema组件提供了一个异步可扩展的 <a href=\"https://json-schema.org/\">Json Schema</a> 规范实现。\n你可以使用 Json Schema 去校验每一个json结构的数据。这个组件提供以下特性：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>实现了 <a href=\"https://tools.ietf.org/html/draft-handrews-json-schema-validation-02\">Json Schema draft2019-09</a></p>\n</li>\n<li>\n<p>实现了 <a href=\"https://tools.ietf.org/html/draft-handrews-json-schema-validation-01\">Json Schema draft-7</a></p>\n</li>\n<li>\n<p>实现了 <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#schemaObject\">OpenAPI 3 dialect</a>.</p>\n</li>\n<li>\n<p>非阻塞的 <code>$ref</code> 引用和缓存</p>\n</li>\n<li>\n<p>使用 <code><a href=\"../../apidocs/io/vertx/core/json/pointer/JsonPointer.html\">JsonPointer</a></code> 检索缓存</p>\n</li>\n<li>\n<p>支持同步和异步校验</p>\n</li>\n<li>\n<p>支持校验树的扩展，允许添加自定义关键词和自定义格式条件</p>\n</li>\n<li>\n<p>通过DSL来构建schemas</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_json_schema\"><a class=\"anchor\" href=\"#_using_vert_x_json_schema\"></a>使用 Vert.x Json Schema</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了使用 Vert.x Json Schema ，需要在构建配置文件中添加如下 <em>依赖</em>：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-json-schema<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-json-schema:4.0.2'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_concepts\"><a class=\"anchor\" href=\"#_concepts\"></a>相关概念</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_schema\"><a class=\"anchor\" href=\"#_schema\"></a>Schema</h3>\n<div class=\"paragraph\">\n<p>每一个schema都可以解析成 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html\">Schema</a></code> 实例，而schema是一个由 <code><a href=\"../../apidocs/io/vertx/json/schema/common/Validator.html\">Validator</a></code> 对象组成的树，树中的每一个元素都包含了必要的校验逻辑。\n这种校验具有 <em>快速失败</em> 的特性：一旦遇到校验错误，校验就会直接失败而不再继续。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_schemaparser_schemarouter\"><a class=\"anchor\" href=\"#_schemaparser_schemarouter\"></a>SchemaParser 和 SchemaRouter</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/json/schema/SchemaParser.html\">SchemaParser</a></code> 组件负责将json数据结构的schema解析成 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html\">Schema</a></code> 实例。\n<code><a href=\"../../apidocs/io/vertx/json/schema/SchemaRouter.html\">SchemaRouter</a></code> 组件负责处理schema解析后的缓存以及相关的 <code>$ref</code> 引用。\n当处理 <code>$ref</code> 的引用或者使用 <code><a href=\"../../apidocs/io/vertx/json/schema/SchemaParser.html\">SchemaParser</a></code> 解析新的schema时，这个schema就会被缓存到相应的 <code><a href=\"../../apidocs/io/vertx/json/schema/SchemaRouter.html\">SchemaRouter</a></code> 中去。\n<code><a href=\"../../apidocs/io/vertx/json/schema/SchemaParser.html\">SchemaParser</a></code> 可以进行扩展并且支持自定义关键词和自定义格式。</p>\n</div>\n<div class=\"paragraph\">\n<p>当前可用的 <code><a href=\"../../apidocs/io/vertx/json/schema/SchemaParser.html\">SchemaParser</a></code> 有：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/json/schema/draft201909/Draft201909SchemaParser.html\">Draft201909SchemaParser</a></code> for Json Schema Draft 2019-09</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/json/schema/draft7/Draft7SchemaParser.html\">Draft7SchemaParser</a></code> for Json Schema Draft 7</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/json/schema/openapi3/OpenAPI3SchemaParser.html\">OpenAPI3SchemaParser</a></code> for OpenAPI 3 dialect</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_parse_a_schema\"><a class=\"anchor\" href=\"#_parse_a_schema\"></a>解析schema</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要开始解析schema，首先你需要一个能匹配你的schema <em>方言</em> 的 schema router 和 schema parser。\n以实例化一个 <em>draft 2019-09</em> 的 schema parser 为例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SchemaRouter schemaRouter = SchemaRouter.create(vertx, <span class=\"hljs-keyword\">new</span> SchemaRouterOptions());\nSchemaParser schemaParser = SchemaParser.createDraft201909SchemaParser(schemaRouter);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于不同的 <code>SchemaParser</code> ， 你可以复用同一个 <code>SchemaRouter</code> 实例；而且还可以使用同一个 <code>SchemaParser</code> 来解析不同的 <code>Schema</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>现在你可以解析schema了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Schema schema = parser.parse(object, schemaPointer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>解析schema时，必须要指定一个 <strong>schema pointer</strong> ，这个 pointer 是定位 schema 的唯一标识。\n如果你没有指定 schema pointer，那么 <code>SchemaParser</code> 默认会生成一个。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Schema schema = parser.parse(object);\nschema.getScope(); <span class=\"hljs-comment\">// 获取schema的生成作用域 (schema pointer)</span></code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>需要注意的是，当使用 <code>$ref</code> 引用schema或者处理相关的引用时，schema pointer 是必须的，\n如果你从文件系统中加载schema并且使用其引用时， <strong>必须提供正确的pointer</strong> ，\n否则 <code>SchemaRouter</code> 将不能处理本地文件系统的 <code>$ref</code>。</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_validate\"><a class=\"anchor\" href=\"#_validate\"></a>校验</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>一个schema可以有两种状态：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>同步状态: 校验树支持同步校验，你可以分别使用 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html#validateSync-java.lang.Object-\">validateSync</a></code> 和 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-\">validateAsync</a></code> 来校验你的json。</p>\n</li>\n<li>\n<p>异步状态：校验树存在一个或多个分支时需要使用异步校验，你必须使用 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-\">validateAsync</a></code> 方法来校验json，如果你使用 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html#validateSync-java.lang.Object-\">validateSync</a></code> 来校验则会抛出 <code><a href=\"../../apidocs/io/vertx/json/schema/NoSyncValidationException.html\">NoSyncValidationException</a></code> 异常。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在异步状态下校验 schema：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">schema.validateAsync(json).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 校验成功</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 校验失败</span>\n    ar.cause(); <span class=\"hljs-comment\">// 包含校验的异常情况</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在同步状态下校验schema：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">try</span> {\n  schema.validateSync(json);\n  <span class=\"hljs-comment\">// 校验成功</span>\n} <span class=\"hljs-keyword\">catch</span> (ValidationException e) {\n  <span class=\"hljs-comment\">// 校验失败</span>\n} <span class=\"hljs-keyword\">catch</span> (NoSyncValidationException e) {\n  <span class=\"hljs-comment\">// 必须使用异步校验，不能使用同步校验</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你可以使用 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html#isSync--\">isSync</a></code> 方法来获取schema的当前状态。\nschema可以实时切换状态，比如，如果你有一个schema使用 <code>$ref</code> 引用了外部的schema，\n此时它处于异步状态，在第一次校验之后，外部schema被缓存了，这时schema将会切换到同步状态。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>如果schema在同步状态下使用 <code><a href=\"../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-\">validateAsync</a></code> 方法来校验，\n这个schema将会在返回的 <code>Future</code> 中同步包含校验的结果，从而避免了不必要的异步计算和内存占用。</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_apply_default_values\"><a class=\"anchor\" href=\"#_apply_default_values\"></a>设置默认值</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>你可以通过 <code>JsonObject</code> 和 <code>JsonArray</code> 来设置默认值</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">schema.applyDefaultValues(jsonObject);\n<span class=\"hljs-comment\">// 或</span>\nschema.applyDefaultValues(jsonArray);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个方法将改变所提供的Json结构的内部状态。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_adding_custom_formats\"><a class=\"anchor\" href=\"#_adding_custom_formats\"></a>自定义格式</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>你可以在解析schemas之前使用校验关键字 <code>format</code> 来自定义数据格式。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">parser.withStringFormatValidator(<span class=\"hljs-string\">\"firstUppercase\"</span>, str -&gt; Character.isUpperCase(str.charAt(<span class=\"hljs-number\">0</span>)));\n\nJsonObject mySchema = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"format\"</span>, <span class=\"hljs-string\">\"firstUppercase\"</span>);\nSchema schema = parser.parse(mySchema);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_adding_custom_keywords\"><a class=\"anchor\" href=\"#_adding_custom_keywords\"></a>自定义关键词</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>每当你想要添加一个新的关键词类型时，你必须要实现 <code><a href=\"../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html\">ValidatorFactory</a></code> ，\n然后使用 <code><a href=\"../../apidocs/io/vertx/json/schema/SchemaParser.html#withValidatorFactory-io.vertx.json.schema.common.ValidatorFactory-\">withValidatorFactory</a></code> 提供一个实例给 <code>SchemaParser</code>。\n当解析开始时，<code>SchemaParser</code> 将会调用每一个注册的工厂的 <code><a href=\"../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html#canConsumeSchema-io.vertx.core.json.JsonObject-\">canConsumeSchema</a></code> 方法。\n如果工厂可以使用这个schema，那么就会调用 <code><a href=\"../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html#createValidator-io.vertx.core.json.JsonObject-io.vertx.core.json.pointer.JsonPointer-io.vertx.json.schema.common.SchemaParserInternal-io.vertx.json.schema.common.MutableStateValidator-\">createValidator</a></code> 方法。\n这个方法返回一个执行校验的 <code><a href=\"../../apidocs/io/vertx/json/schema/common/Validator.html\">Validator</a></code> 对象实例，\n如果在 <code>Validator</code> 初始化过程中发生错误，将会抛出 <code><a href=\"../../apidocs/io/vertx/json/schema/SchemaException.html\">SchemaException</a></code> 异常。</p>\n</div>\n<div class=\"paragraph\">\n<p>你可以自定义以下三种类型的关键词：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>总是同步校验输入的关键词</p>\n</li>\n<li>\n<p>总是异步校验输入的关键词</p>\n</li>\n<li>\n<p>可变状态的关键词</p>\n</li>\n</ul>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_synchronous_keywords\"><a class=\"anchor\" href=\"#_synchronous_keywords\"></a>同步关键词</h3>\n<div class=\"paragraph\">\n<p>同步校验器必须要实现 <code><a href=\"../../apidocs/io/vertx/json/schema/common/SyncValidator.html\">SyncValidator</a></code> 接口。\n在下面的例子中，我们自定义一个关键词，这个关键词需要校验json对象中的属性数值是否符合给定的多个预设值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">`link:../../apidocs/examples/PropertiesMultipleOfValidator.html[PropertiesMultipleOfValidator]`</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在定义了关键词校验器之后，我们就可以定义工厂了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">`link:../../apidocs/examples/PropertiesMultipleOfValidatorFactory.html[PropertiesMultipleOfValidatorFactory]`</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在我们可以挂载这个新的校验工厂：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">parser.withValidatorFactory(<span class=\"hljs-keyword\">new</span> PropertiesMultipleOfValidatorFactory());\n\nJsonObject mySchema = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"propertiesMultipleOf\"</span>, <span class=\"hljs-number\">2</span>);\nSchema schema = parser.parse(mySchema);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_asynchronous_keywords\"><a class=\"anchor\" href=\"#_asynchronous_keywords\"></a>异步关键词</h3>\n<div class=\"paragraph\">\n<p>同步校验器必须要实现 <code><a href=\"../../apidocs/io/vertx/json/schema/common/AsyncValidator.html\">AsyncValidator</a></code> 接口。\n在这个例子中，我添加了一个关键词，这个关键词从Vert.x Event bus中检索一个枚举值</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">`link:../../apidocs/examples/AsyncEnumValidator.html[AsyncEnumValidator]`</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在定义了关键字校验器之后，我们就可以定义工厂了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">`link:../../apidocs/examples/AsyncEnumValidatorFactory.html[AsyncEnumValidatorFactory]`</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在我们可以挂载这个新的校验工厂：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">parser.withValidatorFactory(<span class=\"hljs-keyword\">new</span> AsyncEnumValidatorFactory(vertx));\n\nJsonObject mySchema = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"asyncEnum\"</span>, <span class=\"hljs-string\">\"enums.myapplication\"</span>);\nSchema schema = parser.parse(mySchema);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_building_your_schemas_from_code\"><a class=\"anchor\" href=\"#_building_your_schemas_from_code\"></a>用代码来构建schema</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果你想要使用代码来构建schema，你可以使用附带的DSL。目前只有Draft-7支持这个特性。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先，通过静态导入（import static） <code><a href=\"../../apidocs/io/vertx/json/schema/draft7/dsl/Schemas.html\">Schemas</a></code> 和 <code><a href=\"../../apidocs/io/vertx/json/schema/draft7/dsl/Keywords.html\">Keywords</a></code> 。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_the_schema\"><a class=\"anchor\" href=\"#_creating_the_schema\"></a>创建schema</h3>\n<div class=\"paragraph\">\n<p>在 <code><a href=\"../../apidocs/io/vertx/json/schema/draft7/dsl/Schemas.html\">Schemas</a></code> 内部提供了schema创建的静态方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SchemaBuilder intSchemaBuilder = intSchema();\nSchemaBuilder objectSchemaBuilder = objectSchema();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_the_keywords\"><a class=\"anchor\" href=\"#_using_the_keywords\"></a>使用关键词</h3>\n<div class=\"paragraph\">\n<p>对于每一个schema，你是否可以使用 <code><a href=\"../../apidocs/io/vertx/json/schema/draft7/dsl/Keywords.html\">Keywords</a></code> 方法来构建关键词，\n这取决于schema的类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">stringSchema()\n  .with(format(StringFormat.DATETIME));\narraySchema()\n  .with(maxItems(<span class=\"hljs-number\">10</span>));\nschema() <span class=\"hljs-comment\">// 生成同时接收数组和整数的schema</span>\n  .with(type(SchemaType.ARRAY, SchemaType.INT));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_defining_the_schema_structure\"><a class=\"anchor\" href=\"#_defining_the_schema_structure\"></a>定义schema的结构</h3>\n<div class=\"paragraph\">\n<p>根据你创建的schema，你可以定义结构。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用属性schema和其他属性schema来创建一个对象类型的schema：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">objectSchema()\n  .requiredProperty(<span class=\"hljs-string\">\"name\"</span>, stringSchema())\n  .requiredProperty(<span class=\"hljs-string\">\"age\"</span>, intSchema())\n  .additionalProperties(stringSchema());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>创建一个数组类型的schema：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">arraySchema()\n  .items(stringSchema());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>创建元组类型的schema：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">tupleSchema()\n  .item(stringSchema()) <span class=\"hljs-comment\">// 第一个元素</span>\n  .item(intSchema()) <span class=\"hljs-comment\">// 第二个元素</span>\n  .item(booleanSchema()); <span class=\"hljs-comment\">// 第三个元素</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_ref_and_aliases\"><a class=\"anchor\" href=\"#_ref_and_aliases\"></a><code>$ref</code> 和 别名</h3>\n<div class=\"paragraph\">\n<p>你可以使用 <code><a href=\"../../apidocs/io/vertx/json/schema/common/dsl/Schemas.html#ref-io.vertx.core.json.pointer.JsonPointer-\">Schemas.ref</a></code> 方法来添加一个 <code>$ref</code> schema。\n通过 <code><a href=\"../../apidocs/io/vertx/json/schema/common/dsl/SchemaBuilder.html#id-io.vertx.core.json.pointer.JsonPointer-\">id</a></code> 来指定对应schema的 <code>$id</code> 关键词。</p>\n</div>\n<div class=\"paragraph\">\n<p>你也可以使用别名来引用通过dsl定义的schema。你可以使用 <code><a href=\"../../apidocs/io/vertx/json/schema/common/dsl/SchemaBuilder.html#alias-java.lang.String-\">alias</a></code> 来为一个schema设置别名。\n这样你就可以使用 <code><a href=\"../../apidocs/io/vertx/json/schema/common/dsl/Schemas.html#refToAlias-java.lang.String-\">Schemas.refToAlias</a></code> 来根据别名引用schema。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">intSchema()\n  .alias(<span class=\"hljs-string\">\"myInt\"</span>);\n\nobjectSchema()\n  .requiredProperty(<span class=\"hljs-string\">\"anInteger\"</span>, refToAlias(<span class=\"hljs-string\">\"myInt\"</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_the_schema\"><a class=\"anchor\" href=\"#_using_the_schema\"></a>使用schema</h3>\n<div class=\"paragraph\">\n<p>在定义好schama后，你可以调用 <code><a href=\"../../apidocs/io/vertx/json/schema/common/dsl/SchemaBuilder.html#build-io.vertx.json.schema.SchemaParser-\">build</a></code> 方法来解析和使用这个schema：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Schema schema = objectSchema()\n  .requiredProperty(<span class=\"hljs-string\">\"name\"</span>, stringSchema())\n  .requiredProperty(<span class=\"hljs-string\">\"age\"</span>, intSchema())\n  .additionalProperties(stringSchema())\n  .build(parser);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}