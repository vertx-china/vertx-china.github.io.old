{"pageProps":{"slug":"4.0.0/vertx-amqp-client/java","title":"Vert.x AMQP Client","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_amqp_client\">使用 Vert.x AMQP 客户端</a></li>\n<li><a href=\"#_creating_an_amqp_client\">创建 AMQP 客户端</a></li>\n<li><a href=\"#_establishing_a_connection\">建立连接</a></li>\n<li><a href=\"#_creating_a_receiver\">创建receiver</a></li>\n<li><a href=\"#_creating_a_sender\">创建 sender</a></li>\n<li><a href=\"#_implementing_request_reply\">实现 request-reply</a></li>\n<li><a href=\"#_closing_the_client\">关闭客户端</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x AMQP Client</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x AMQP 客户端可以与 <a href=\"https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol\">AMQP 1.0</a>\nbroker 和 router 互通。他可以做到如下事情：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>连接一个 AMQP 的 broker 或 router - 支持 SASL 和 TLS 连接</p>\n</li>\n<li>\n<p>消费 queue 或 topic 当中的消息</p>\n</li>\n<li>\n<p>向 queue 或 topic 中发送消息</p>\n</li>\n<li>\n<p>发送消息后检查ACK</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>AMQP 1.0 协议支持持久订阅、持久化、安全保障、会话、复杂路由&#8230;&#8203;&#8230;&#8203; 更多\n该协议的细节详见 <a href=\"https://www.amqp.org/\">AMQP homepage</a> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x AMQP 客户端基于 Vert.x Proton 实现。如果您需要更细粒度的控制，我们建议您\n直接使用 <a href=\"https://github.com/vert-x3/vertx-proton\">Vert.x Proton</a></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_amqp_client\"><a class=\"anchor\" href=\"#_using_vert_x_amqp_client\"></a>使用 Vert.x AMQP 客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-amqp-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-amqp-client:4.0.0'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_an_amqp_client\"><a class=\"anchor\" href=\"#_creating_an_amqp_client\"></a>创建 AMQP 客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>一旦您在 <em>CLASSPATH</em> 中添加该客户端，您可以按如下实例化 <code><a href=\"../../apidocs/io/vertx/amqp/AmqpClient.html\">AmqpClient</a></code>\n对象</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">AmqpClientOptions options = <span class=\"hljs-keyword\">new</span> AmqpClientOptions()\n  .setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n  .setPort(<span class=\"hljs-number\">5672</span>)\n  .setUsername(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n<span class=\"hljs-comment\">// 用内部Vert.x实例创建客户端</span>\nAmqpClient client1 = AmqpClient.create(options);\n\n<span class=\"hljs-comment\">// 显式使用Vert.x实例</span>\nAmqpClient client2 = AmqpClient.create(vertx, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>创建  <code><a href=\"../../apidocs/io/vertx/amqp/AmqpClient.html\">AmqpClient</a></code> 对象有两个方法。您可以显式的传一个Vert.x 实例，\n如果您正在 Vert.x应用或 Vert.x Verticle内，请用此方式；否则您可以省略传Vert.x参数，\n当客户端关闭时，有一个内部的Vert.x对象会被创建/关闭。</p>\n</div>\n<div class=\"paragraph\">\n<p>要创建 <code><a href=\"../../apidocs/io/vertx/amqp/AmqpClient.html\">AmqpClient</a></code> ，您需要传 <code><a href=\"../../apidocs/io/vertx/amqp/AmqpClientOptions.html\">AmqpClientOptions</a></code> 参数。\n这个options参数包含了 broker 和 router 的位置信息，认证信息等&#8230;&#8203;..\n用options参数可以配置AMQP客户端的许多方面。\n注意：您也可以用这些options来控制底层的 Proton client 。</p>\n</div>\n<div class=\"paragraph\">\n<p>也可以从系统参数或者环境变量来配置 host、port、username、password：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Host：系统参数： <code>amqp-client-host</code> ，环境变量： <code>AMQP_CLIENT_HOST</code> （强制必填项）</p>\n</li>\n<li>\n<p>Port：系统参数： <code>amqp-client-port</code> ，环境变量： <code>AMQP_CLIENT_PORT</code> （默认为5672）</p>\n</li>\n<li>\n<p>Username：系统参数： <code>amqp-client-username</code> ，环境变量： <code>AMQP_CLIENT_USERNAME</code></p>\n</li>\n<li>\n<p>Password：系统参数： <code>amqp-client-password</code> ，环境变量： <code>AMQP_CLIENT_PASSWORD</code> （默认为5672）</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_establishing_a_connection\"><a class=\"anchor\" href=\"#_establishing_a_connection\"></a>建立连接</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>一旦您创建了一个客户端，您需要显式地连接远程服务。\n这可用 <code>connect</code> 方法实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.connect(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.failed()) {\n    System.out.println(<span class=\"hljs-string\">\"Unable to connect to the broker\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Connection succeeded\"</span>);\n    AmqpConnection connection = ar.result();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦 <code>连接</code> 建立成功或失败，则相应处理器会被调用。值得注意的是 <code>连接</code> 用于建立receiver和sender。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_receiver\"><a class=\"anchor\" href=\"#_creating_a_receiver\"></a>创建receiver</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>receiver 用于接收消息。AMQP receiver 可以用如下两种方式获取：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.createReceiver(<span class=\"hljs-string\">\"my-queue\"</span>,\n  done -&gt; {\n    <span class=\"hljs-keyword\">if</span> (done.failed()) {\n      System.out.println(<span class=\"hljs-string\">\"Unable to create receiver\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      AmqpReceiver receiver = done.result();\n      receiver.handler(msg -&gt; {\n        <span class=\"hljs-comment\">// 每次接收到消息就被调用</span>\n        System.out.println(<span class=\"hljs-string\">\"Received \"</span> + msg.bodyAsString());\n      });\n    }\n  }\n);\n\nconnection.createReceiver(<span class=\"hljs-string\">\"my-queue\"</span>,\n  done -&gt; {\n    <span class=\"hljs-keyword\">if</span> (done.failed()) {\n      System.out.println(<span class=\"hljs-string\">\"Unable to create receiver\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      AmqpReceiver receiver = done.result();\n      receiver\n        .exceptionHandler(t -&gt; {\n          <span class=\"hljs-comment\">// 抛出异常</span>\n        })\n        .handler(msg -&gt; {\n          <span class=\"hljs-comment\">// 关联消息处理器</span>\n        });\n    }\n  }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这两种方式的主要区别在于 <em>何时</em> 关联消息处理器。第一种方式\n直接设置处理器，并且立即开始接收消息；第二种方式中，\n处理器在连接创建完成之后被人工关联。这样，您可以获得更多控制权并添加其他的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 completion handler 中传入的 receiver 可以作为Stream来使用。所以您可以暂停、恢复\n消息的接收。背压协议（back-pressure protocol）由\n<a href=\"http://docs.oasis-open.org/amqp/core/v1.0/csprd02/amqp-core-transport-v1.0-csprd02.html#doc-flow-control\">AMQP credits</a> 实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>接收到的消息是 <code><a href=\"../../apidocs/io/vertx/amqp/AmqpMessage.html\">AmqpMessage</a></code> 实例。这些实例是不可变（immutable）的，\n并且支持访问大多数AMQP元数据。请查看\n<a href=\"http://docs.oasis-open.org/amqp/core/v1.0/amqp-core-messaging-v1.0.html#type-properties\">properties</a> 列表作参考。注意：\n要从从消息体中获取 JSON object 或 JSON array ，那么作为AMQP <em>数据</em> 的值则是必须的。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以用客户端直接创建 receiver ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.createReceiver(<span class=\"hljs-string\">\"my-queue\"</span>\n  ,\n  done -&gt; {\n    <span class=\"hljs-keyword\">if</span> (done.failed()) {\n      System.out.println(<span class=\"hljs-string\">\"Unable to create receiver\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      AmqpReceiver receiver = done.result();\n      receiver.handler(msg -&gt; {\n        <span class=\"hljs-comment\">// 每次接收消息时都被调用</span>\n        System.out.println(<span class=\"hljs-string\">\"Received \"</span> + msg.bodyAsString());\n      });\n    }\n  }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个示例中，连接是自动创建的。您可以用\n<code><a href=\"../../apidocs/io/vertx/amqp/AmqpReceiver.html#connection--\">connection</a></code> 方法获取它。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，消息自动发送ACK响应，您可以用\n<code><a href=\"../../apidocs/io/vertx/amqp/AmqpReceiverOptions.html#setAutoAcknowledgement-boolean-\">setAutoAcknowledgement</a></code> 来禁用这个此操作。然后您则需要用如下方法\n显式的发送ACK：\n* <code><a href=\"../../apidocs/io/vertx/amqp/AmqpMessage.html#accepted--\">accepted</a></code>\n* <code><a href=\"../../apidocs/io/vertx/amqp/AmqpMessage.html#rejected--\">rejected</a></code>\n* <code><a href=\"../../apidocs/io/vertx/amqp/AmqpMessage.html#released--\">released</a></code></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_sender\"><a class=\"anchor\" href=\"#_creating_a_sender\"></a>创建 sender</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>sender可以将消息发送到 queue 和 topic 当中。您可以通过如下方式获取到 sender：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.createSender(<span class=\"hljs-string\">\"my-queue\"</span>, done -&gt; {\n  <span class=\"hljs-keyword\">if</span> (done.failed()) {\n    System.out.println(<span class=\"hljs-string\">\"Unable to create a sender\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    AmqpSender result = done.result();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦您获取了 AMQP sender，您就可以创建消息。\n因为 <code><a href=\"../../apidocs/io/vertx/amqp/AmqpMessage.html\">AmqpMessage</a></code> 是不可变（immutable）的，所以要用 <code><a href=\"../../apidocs/io/vertx/amqp/AmqpMessageBuilder.html\">AmqpMessageBuilder</a></code> 类来执行创建操作。\n以下是一些例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">AmqpMessageBuilder builder = AmqpMessage.create();\n\n<span class=\"hljs-comment\">// 一条普通的消息</span>\nAmqpMessage m1 = builder.withBody(<span class=\"hljs-string\">\"hello\"</span>).build();\n\n<span class=\"hljs-comment\">// 指定了地址的消息</span>\nAmqpMessage m2 = builder.withBody(<span class=\"hljs-string\">\"hello\"</span>).address(<span class=\"hljs-string\">\"another-queue\"</span>).build();\n\n<span class=\"hljs-comment\">// 带有JSON消息体、元数据、TTL的消息</span>\nAmqpMessage m3 = builder\n  .withJsonObjectAsBody(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"message\"</span>, <span class=\"hljs-string\">\"hello\"</span>))\n  .subject(<span class=\"hljs-string\">\"subject\"</span>)\n  .ttl(<span class=\"hljs-number\">10000</span>)\n  .applicationProperties(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"prop1\"</span>, <span class=\"hljs-string\">\"value1\"</span>))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在您创建sender和消息之后，您可以用如下方法发送消息：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/amqp/AmqpSender.html#send-io.vertx.amqp.AmqpMessage-\">send</a></code> - 发送消息</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/amqp/AmqpSender.html#sendWithAck-io.vertx.amqp.AmqpMessage-io.vertx.core.Handler-\">sendWithAck</a></code> - 发送消息并监控其ACK</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>以下是最简单的发消息方式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sender.send(AmqpMessage.create().withBody(<span class=\"hljs-string\">\"hello\"</span>).build());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>发送消息时，您可以监控其ACK</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sender.sendWithAck(AmqpMessage.create().withBody(<span class=\"hljs-string\">\"hello\"</span>).build(), acked -&gt; {\n  <span class=\"hljs-keyword\">if</span> (acked.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Message accepted\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Message not accepted\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意：如果传输状态为 <code>ACCEPTED</code> ，那么就视为该消息已收到ACK。\n其他情况则视为未收到ACK（详细的信息可以从回传的 cause 中获得）。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/amqp/AmqpSender.html\">AmqpSender</a></code> 可以用作 write stream。流的控制是用 AMQP credits 实现的</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以用客户端直接生成sender：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.createSender(<span class=\"hljs-string\">\"my-queue\"</span>, maybeSender -&gt; {\n  <span class=\"hljs-comment\">//...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个示例中，连接是自动建立的。您可以用\n<code><a href=\"../../apidocs/io/vertx/amqp/AmqpSender.html#connection--\">connection</a></code> 获取它。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_implementing_request_reply\"><a class=\"anchor\" href=\"#_implementing_request_reply\"></a>实现 request-reply</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要实现 request-reply ，您可以用动态receiver和匿名sender。动态receiver\n不关联于用户创建的address，但broker提供这个address。匿名sender也不和指定的address关联，\n它要求所有的消息都包含一个address。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下便展示了如何实现 request-reply：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.createAnonymousSender(responseSender -&gt; {\n  <span class=\"hljs-comment\">// 获取匿名sender用于响应消息</span>\n  <span class=\"hljs-comment\">// 注册 main receiver:</span>\n  connection.createReceiver(<span class=\"hljs-string\">\"my-queue\"</span>, done -&gt; {\n    <span class=\"hljs-keyword\">if</span> (done.failed()) {\n      System.out.println(<span class=\"hljs-string\">\"Unable to create receiver\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      AmqpReceiver receiver = done.result();\n      receiver.handler(msg -&gt; {\n        <span class=\"hljs-comment\">// 获取到了消息，响应之</span>\n        responseSender.result().send(AmqpMessage.create()\n          .address(msg.replyTo())\n          .correlationId(msg.id()) <span class=\"hljs-comment\">// 发送消息id作为关联的id</span>\n          .withBody(<span class=\"hljs-string\">\"my response to your request\"</span>)\n          .build()\n        );\n      });\n    }\n  });\n});\n\n<span class=\"hljs-comment\">// sender端（发送请求并等待接收响应）</span>\nconnection.createDynamicReceiver(replyReceiver -&gt; {\n  <span class=\"hljs-comment\">// 获取receiver，address由broker提供</span>\n  String replyToAddress = replyReceiver.result().address();\n\n  <span class=\"hljs-comment\">// 关联处理器用于接收响应</span>\n  replyReceiver.result().handler(msg -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"Got the reply! \"</span> + msg.bodyAsString());\n  });\n\n  <span class=\"hljs-comment\">// 创建sender并发送消息：</span>\n  connection.createSender(<span class=\"hljs-string\">\"my-queue\"</span>, sender -&gt; {\n    sender.result().send(AmqpMessage.create()\n      .replyTo(replyToAddress)\n      .id(<span class=\"hljs-string\">\"my-message-id\"</span>)\n      .withBody(<span class=\"hljs-string\">\"This is my request\"</span>).build());\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>要响应一个消息，就要将它回应到指定的address。另外，用 <code>message id</code> 作为 <code>correlation id</code> 是一个好的做法，\n这样响应的接收者可以将响应与请求相关联。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_closing_the_client\"><a class=\"anchor\" href=\"#_closing_the_client\"></a>关闭客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>一旦您创建了recever或sender的连接，那么您需要用 <code>close</code> 方法关闭他们。\n即关闭连接以及所有相关的reciever和sender。</p>\n</div>\n<div class=\"paragraph\">\n<p>一旦客户端不再使用了，您就必须关闭它。这同时会关闭所有连接，\n最终关闭receiver和sender。</p>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}