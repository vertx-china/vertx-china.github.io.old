{"pageProps":{"slug":"4.0.0/vertx-redis-client/java","title":"Vert.x-redis","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_redis\">使用 Vert.x-Redis</a></li>\n<li><a href=\"#_connecting_to_redis\">连接到 Redis</a></li>\n<li><a href=\"#_connection_string\">连接字符串</a></li>\n<li><a href=\"#_running_commands\">执行命令</a></li>\n<li><a href=\"#_high_availability_mode\">高可用模式</a></li>\n<li><a href=\"#_cluster_mode\">集群模式</a></li>\n<li><a href=\"#_pubsub_mode\">发布/订阅模式</a></li>\n<li><a href=\"#_domain_sockets\">域套接字</a></li>\n<li><a href=\"#_connection_pooling\">连接池</a></li>\n<li><a href=\"#_implementing_reconnect_on_error\">出错时重连</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x-redis</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-redis 是与 Vert.x 一起使用的 Redis 客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>该模块允许在 Redis 中保存、查询、搜索和删除数据。Redis 是一个开源的、先进的键值存储数据库。\n它通常被称为数据结构服务器，因为 Redis 的键可以存储字符串、散列、列表、集合和排序集合。\n要使用此模块，您的网络上必须运行一个 Redis 服务器实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>Redis 有着丰富的 API，可以分成以下几组：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>集群 Cluster - 与集群管理相关的命令, 使用这些命令需要注意 redis server 版本 &gt;=3.0.0 。</p>\n</li>\n<li>\n<p>连接 Connection - 切换数据库，连接，断开连接以及身份认证的命令。</p>\n</li>\n<li>\n<p>哈希 Hashes - 对哈希进行操作的命令。</p>\n</li>\n<li>\n<p>基数统计 HyperLogLog - 对可重复集合中统计不重复元素的命令。</p>\n</li>\n<li>\n<p>键 Keys - 使用 key 相关的命令。</p>\n</li>\n<li>\n<p>列表 List - 使用 list 相关的命令。</p>\n</li>\n<li>\n<p>发布/订阅 Pub/Sub - 创建队列和发布/订阅客户端的命令。</p>\n</li>\n<li>\n<p>脚本 Scripting - 在 Redis 中运行 Lua 脚本的命令。</p>\n</li>\n<li>\n<p>服务器 Server - 管理和获取服务器配置的命令。</p>\n</li>\n<li>\n<p>集合 Sets - 处理无序集合的命令。</p>\n</li>\n<li>\n<p>有序集合 Sorted Sets - 处理有序集合的命令。</p>\n</li>\n<li>\n<p>字符串 Strings - 处理字符串的命令。</p>\n</li>\n<li>\n<p>事务 Transactions - 处理事务生命周期的命令。</p>\n</li>\n<li>\n<p>流 Streams - 处理流的命令。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_redis\"><a class=\"anchor\" href=\"#_using_vert_x_redis\"></a>使用 Vert.x-Redis</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用 Vert.x Redis 客户端，请将以下依赖项添加到项目的 <em>dependencies</em> 中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-redis-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-redis-client:4.0.0'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_redis\"><a class=\"anchor\" href=\"#_connecting_to_redis\"></a>连接到 Redis</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Redis 客户端可以在三种模式下操作：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>简易客户端 (大多数用户需要的)。</p>\n</li>\n<li>\n<p>哨兵 (在高可用模式下使用 Redis)。</p>\n</li>\n<li>\n<p>集群 (在集群模式下使用 Redis)。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>连接方式由 Redis 接口的工厂方法决定。无论客户端是哪种模式，\n都可以通过 <code><a href=\"../../apidocs/io/vertx/redis/client/RedisOptions.html\">RedisOptions</a></code> 数据对象来配置。\n默认情况下，一些配置项按下面的值初始化：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>netClientOptions</code>: 默认为 <code>TcpKeepAlive: true</code>, <code>TcpNoDelay: true</code></p>\n</li>\n<li>\n<p><code>endpoint</code>: 默认为 <code>redis://localhost:6379</code></p>\n</li>\n<li>\n<p><code>masterName</code>: 默认为 <code>mymaster</code></p>\n</li>\n<li>\n<p><code>role</code>: 默认为 <code>MASTER</code></p>\n</li>\n<li>\n<p><code>useReplicas</code>: 默认为 <code>NEVER</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>用以下代码获得连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx)\n  .connect()\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// 使用 connection</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>配置中包含 <code>password</code> 且/或 <code>select</code> 数据库，\n在成功建立连接后，这两个命令会自动执行。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(\n  vertx,\n  <span class=\"hljs-comment\">// 客户端处理 REDIS URLs。</span>\n  <span class=\"hljs-comment\">// 规范的数据库URL，密码是 URL 授权的密码字段。</span>\n  <span class=\"hljs-string\">\"redis://:abracadabra@localhost:6379/1\"</span>)\n  .connect()\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// use the connection</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connection_string\"><a class=\"anchor\" href=\"#_connection_string\"></a>连接字符串</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>客户端会识别表达式上的地址：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>redis://[:password@]host[:port][/db-number]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>unix://[:password@]/domain/docker.sock[?select=db-number]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当指定密码或数据库时，这些命令会在连接启动时执行。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_commands\"><a class=\"anchor\" href=\"#_running_commands\"></a>执行命令</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Redis 客户端已连接到服务器，现在可以使用此模块执行所有命令。\n例如，该模块提供了一个简洁的 API 来执行命令，而不需要自己手写命令。\n如果想要获取键的值，可以这样做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RedisAPI redis = RedisAPI.api(client);\n\nredis\n  .get(<span class=\"hljs-string\">\"mykey\"</span>)\n  .onSuccess(value -&gt; {\n    <span class=\"hljs-comment\">// do something...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>返回的对象是泛型类型，它允许从基本的 redis 类型转换为您的编程语言类型。\n例如，如果返回对象类型为`INTEGER`，则可以通过任意数值基本类型获取该值，如 <code>int</code>、<code>long</code> 等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者，可以执行更复杂的任务，例如将返回的值作为迭代器处理：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (response.type() == ResponseType.MULTI) {\n  <span class=\"hljs-keyword\">for</span> (Response item : response) {\n    <span class=\"hljs-comment\">// do something with item...</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_high_availability_mode\"><a class=\"anchor\" href=\"#_high_availability_mode\"></a>高可用模式</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在高可用性模式下使用，创建连接的过程非常相似：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> RedisOptions()\n    .setType(RedisClientType.SENTINEL)\n    .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:5000\"</span>)\n    .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:5001\"</span>)\n    .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:5002\"</span>)\n    .setMasterName(<span class=\"hljs-string\">\"sentinel7000\"</span>)\n    .setRole(RedisRole.MASTER))\n  .connect()\n  .onSuccess(conn -&gt; {\n    conn.send(Request.cmd(Command.INFO))\n      .onSuccess(info -&gt; {\n        <span class=\"hljs-comment\">// do something...</span>\n      });\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>需要注意的是，在此模式下，将建立额外连接到服务器。\n客户端将在后台监听哨兵的事件。当哨兵通知我们切换了主机时，\n就会向客户端发送一个异常，您可以决定下一步做什么。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cluster_mode\"><a class=\"anchor\" href=\"#_cluster_mode\"></a>集群模式</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在集群模式下使用，创建连接的过程也非常相似：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">final</span> RedisOptions options = <span class=\"hljs-keyword\">new</span> RedisOptions()\n  .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:7000\"</span>)\n  .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:7001\"</span>)\n  .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:7002\"</span>)\n  .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:7003\"</span>)\n  .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:7004\"</span>)\n  .addConnectionString(<span class=\"hljs-string\">\"redis://127.0.0.1:7005\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，需要配置一个或多个集群成员。\n此成员列表用于向集群请求当前配置，这意味着列表中不可用的成员将被跳过。</p>\n</div>\n<div class=\"paragraph\">\n<p>在集群模式下将建立到每个节点的连接。\n在执行命令时需要特别小心，建议阅读Redis手册以了解集群如何工作。\n在此模式下操作的客户端会尽量识别执行的命令使用哪个槽（slot），以便在正确的节点上执行它。\n如果出现无法识别的情况，最好在随机节点上运行该命令。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pubsub_mode\"><a class=\"anchor\" href=\"#_pubsub_mode\"></a>发布/订阅模式</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Redis 支持队列和发布/订阅模式。\n在此模式下操作时，当一连接调用订阅模式，则它不能用于运行除退出该模式之外的其他命令。</p>\n</div>\n<div class=\"paragraph\">\n<p>要启动订阅者，需要执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx, <span class=\"hljs-keyword\">new</span> RedisOptions())\n  .connect()\n  .onSuccess(conn -&gt; {\n    conn.handler(message -&gt; {\n      <span class=\"hljs-comment\">// do whatever you need to do with your message</span>\n    });\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>其他位置的代码将消息发布到队列：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">redis.send(Request.cmd(Command.PUBLISH).arg(<span class=\"hljs-string\">\"channel1\"</span>).arg(<span class=\"hljs-string\">\"Hello World!\"</span>))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// published!</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意: <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code>, <code>PUNSUBSCRIBE</code> 这些命令返回值是 <code>void</code>.\n这意味着成功的结果是 <code>null</code>，而不是响应的实例。所有消息都通过客户端上的 handler 进行路由。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_domain_sockets\"><a class=\"anchor\" href=\"#_domain_sockets\"></a>域套接字</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>大部分例子展示连接到 TCP 套接字，但也可以用 Redis 连接到 UNIX 域套接字。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx, <span class=\"hljs-string\">\"unix:///tmp/redis.sock\"</span>)\n  .connect()\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// so something...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意，高可用模式和集群模式报告的服务器地址始终位于 TCP 地址上，而不是域套接字上。\n这是 Redis 的原因而不是客户端的原因，因此混合使用是不行的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connection_pooling\"><a class=\"anchor\" href=\"#_connection_pooling\"></a>连接池</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>所有的客户端都有一个连接池。默认配置连接池大小为 1，这意味着操作和单个连接一样。连接池有四个可调项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>maxPoolSize</code> 最大连接数 (默认为 <code>6</code>)</p>\n</li>\n<li>\n<p><code>maxPoolWaiting</code> 在队列上获取连接的最大等待处理程序数 (默认值为 <code>24</code>)</p>\n</li>\n<li>\n<p><code>poolCleanerInterval</code> 清除连接的时间间隔 默认为 <code>-1</code> (禁用)</p>\n</li>\n<li>\n<p><code>poolRecycleTimeout</code> 连接池中打开的连接保持等待到关闭的超时时间 (默认 <code>15_000</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>连接池非常有用，无需自己管理连接，例如，您只需要：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx, <span class=\"hljs-string\">\"redis://localhost:7006\"</span>)\n  .send(Request.cmd(Command.PING))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// Should have received a pong...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>需要注意的是，连接不需要手动获取或者归还，所有连接都由连接池处理。\n但是超过 1 个尝试从连接池中获取连接的并发请求可能会出现一些可伸缩性问题。\n为了克服这个问题，我们需要对连接池进行调优。\n常见的配置是将连接池的最大大小设置为可用CPU核心数，并允许排队从连接池里面获取连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> RedisOptions()\n    .setConnectionString(<span class=\"hljs-string\">\"redis://localhost:7006\"</span>)\n    <span class=\"hljs-comment\">// 允许最多有 8 个连接到 redis</span>\n    .setMaxPoolSize(<span class=\"hljs-number\">8</span>)\n    <span class=\"hljs-comment\">// 允许 32 个连接请求排队等待连接可用</span>\n    .setMaxWaitingHandlers(<span class=\"hljs-number\">32</span>))\n  .send(Request.cmd(Command.PING))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// Should have received a pong...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意：连接池不支持 <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code>, <code>PUNSUBSCRIBE</code> 这些命令。\n因为这些命令将修改连接的操作方式，而且连接不能重复使用。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_implementing_reconnect_on_error\"><a class=\"anchor\" href=\"#_implementing_reconnect_on_error\"></a>出错时重连</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>虽然连接池非常有用，但为了提高性能，连接不应自动管理，而应该由您控制。\n因此您需要处理连接恢复、错误处理和重新连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>典型的情况是，每当发生错误时，用户都希望重新连接到服务器。\n自动重新连接不是 Redis 客户端的一部分，因为它将强制执行可能不符合用户预期的行为，例如：</p>\n</div>\n<div class=\"paragraph\">\n<p>1.如何处理当前执行的请求？\n2.是否调用异常处理程序？\n3.如果重试也将失败，该怎么办？\n4.是否应恢复以前的状态（数据库、身份验证、订阅）？\n5.等等等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了给用户充分的灵活性，我们决定不应由客户端执行。\n但是，对于超时的简单重新连接可以按如下方式实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedisVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractVerticle</span> </span>{\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MAX_RECONNECT_RETRIES = <span class=\"hljs-number\">16</span>;\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> RedisOptions options = <span class=\"hljs-keyword\">new</span> RedisOptions();\n  <span class=\"hljs-keyword\">private</span> RedisConnection client;\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n    createRedisClient()\n      .onSuccess(conn -&gt; {\n        <span class=\"hljs-comment\">// 连接到 redis!</span>\n      });\n  }\n\n  <span class=\"hljs-comment\">/**\n   * 当连接中出现异常时，将创建一个 Redis客 户端并设置重新连接处理程序。\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Future&lt;RedisConnection&gt; <span class=\"hljs-title\">createRedisClient</span><span class=\"hljs-params\">()</span> </span>{\n    Promise&lt;RedisConnection&gt; promise = Promise.promise();\n\n    Redis.createClient(vertx, options)\n      .connect()\n      .onSuccess(conn -&gt; {\n        <span class=\"hljs-comment\">// 确保客户端在报错时重连</span>\n        conn.exceptionHandler(e -&gt; {\n          <span class=\"hljs-comment\">// 有无法恢复错误时尝试重连</span>\n          attemptReconnect(<span class=\"hljs-number\">0</span>);\n        });\n        <span class=\"hljs-comment\">// 进一步处理</span>\n        promise.complete(conn);\n      });\n\n    <span class=\"hljs-keyword\">return</span> promise.future();\n  }\n\n  <span class=\"hljs-comment\">/**\n   * 尝试重新连接次数最多到 MAX_RECONNECT_RETRIES 次\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">attemptReconnect</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> retry)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (retry &gt; MAX_RECONNECT_RETRIES) {\n      <span class=\"hljs-comment\">// 现在应该停下来，因为我们无能为力。</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 最长回退重试 10240 ms</span>\n      <span class=\"hljs-keyword\">long</span> backoff = (<span class=\"hljs-keyword\">long</span>) (Math.pow(<span class=\"hljs-number\">2</span>, Math.min(retry, <span class=\"hljs-number\">10</span>)) * <span class=\"hljs-number\">10</span>);\n\n      vertx.setTimer(backoff, timer -&gt; {\n        createRedisClient()\n          .onFailure(t -&gt; attemptReconnect(retry + <span class=\"hljs-number\">1</span>));\n      });\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在本例中，客户端对象将在重新连接时被替换，应用程序将重试最多 16 次，回退时间最长可达 1280 ms。\n通过弃用旧客户端，我们可以确保所有没有处理的响应都被抛弃。</p>\n</div>\n<div class=\"paragraph\">\n<p>需要注意，重新连接将创建一个新的连接对象，因此不会每次都缓存和执行这些对象的引用。</p>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}