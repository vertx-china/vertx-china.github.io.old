{"pageProps":{"slug":"4.0.0/vertx-circuit-breaker/java","title":"Vert.x Circuit Breaker","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_the_vert_x_circuit_breaker\">准备工作</a></li>\n<li><a href=\"#_using_the_circuit_breaker\">使用熔断器</a></li>\n<li><a href=\"#_retries\">重试</a></li>\n<li><a href=\"#_callbacks\">回调</a></li>\n<li><a href=\"#_event_bus_notification\">事件总线通知</a></li>\n<li><a href=\"#_the_half_open_state\">半开状态</a></li>\n<li><a href=\"#_reported_exceptions\">异常</a></li>\n<li><a href=\"#_pushing_circuit_breaker_metrics_to_the_hystrix_dashboard\">将熔断器指标推送到Hystrix看板（Dashboard）</a></li>\n<li><a href=\"#_using_netflix_hystrix\">使用 Netflix Hystrix</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Circuit Breaker</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Circuit Breaker 是Vert.x 熔断 <em>模式</em> 的实现。\n它用来追踪故障，当失败次数达到阈值时 <em>触发熔断</em> ，并提供可选择的失败回退。</p>\n</div>\n<div class=\"paragraph\">\n<p>支持以下故障:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>在 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code> 内记录的失败</p>\n</li>\n<li>\n<p>代码里主动抛出异常</p>\n</li>\n<li>\n<p>没有完成的 <code>Future</code>（即超时）。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>熔断器要旨是保障其操作是非阻塞且异步的，\n以受益于Vert.x 执行模型。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_vert_x_circuit_breaker\"><a class=\"anchor\" href=\"#_using_the_vert_x_circuit_breaker\"></a>准备工作</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用Vert.x Circuit Breaker之前，\n你必须在你的项目中添加如下  <em>依赖</em> ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-circuit-breaker<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-circuit-breaker:4.0.0'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_circuit_breaker\"><a class=\"anchor\" href=\"#_using_the_circuit_breaker\"></a>使用熔断器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用熔断器需要按以下步骤进行：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>创建一个熔断器，并配置成你所需要的超时，最大故障次数等参数</p>\n</li>\n<li>\n<p>使用熔断器执行代码</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p><strong>重要！！！</strong> 熔断器应该是稳定的单例，而不是每次使用就重新创建它。推荐将该单例存放在某个领域中。</p>\n</div>\n<div class=\"paragraph\">\n<p>例子:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CircuitBreaker breaker = CircuitBreaker.create(<span class=\"hljs-string\">\"my-circuit-breaker\"</span>, vertx,\n    <span class=\"hljs-keyword\">new</span> CircuitBreakerOptions()\n        .setMaxFailures(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 最大失败数</span>\n        .setTimeout(<span class=\"hljs-number\">2000</span>) <span class=\"hljs-comment\">// 超时时间</span>\n        .setFallbackOnFailure(<span class=\"hljs-keyword\">true</span>) <span class=\"hljs-comment\">// 失败后是否调用回退函数（fallback）</span>\n        .setResetTimeout(<span class=\"hljs-number\">10000</span>) <span class=\"hljs-comment\">// 在开启状态下，尝试重试之前所需时间</span>\n);\n\n<span class=\"hljs-comment\">// ---</span>\n<span class=\"hljs-comment\">// 将熔断器存放在某个领域中并像如下方式使用</span>\n<span class=\"hljs-comment\">// ---</span>\n\nbreaker.execute(promise -&gt; {\n  <span class=\"hljs-comment\">// 在熔断器中执行的代码</span>\n  <span class=\"hljs-comment\">// 这里的代码可以成功或者失败，</span>\n  <span class=\"hljs-comment\">// 如果该 promise 在这里被标记为失败，熔断器将自增失败数</span>\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-comment\">// 处理结果.</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>execute代码块接收 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code>\n对象参数，以标识该操作以及结果的失败或成功。\n例如:在下面的例子中，\n对应的结果就是REST调用的输出：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CircuitBreaker breaker = CircuitBreaker.create(<span class=\"hljs-string\">\"my-circuit-breaker\"</span>, vertx,\n    <span class=\"hljs-keyword\">new</span> CircuitBreakerOptions().setMaxFailures(<span class=\"hljs-number\">5</span>).setTimeout(<span class=\"hljs-number\">2000</span>)\n);\n\n<span class=\"hljs-comment\">// ---</span>\n<span class=\"hljs-comment\">// Store the circuit breaker in a field and access it as follows</span>\n<span class=\"hljs-comment\">// ---</span>\n\nbreaker.&lt;String&gt;execute(promise -&gt; {\n  vertx.createHttpClient().request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/\"</span>)\n    .compose(req -&gt; req\n      .send()\n      .compose(resp -&gt; {\n        <span class=\"hljs-keyword\">if</span> (resp.statusCode() != <span class=\"hljs-number\">200</span>) {\n          <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"HTTP error\"</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-keyword\">return</span> resp.body().map(Buffer::toString);\n        }\n      })).onComplete(promise);\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-comment\">// 处理结果</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>操作的结果以下面的方式提供:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>调用 <code>execute</code> 方法时,返回 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code></p>\n</li>\n<li>\n<p>调用 <code>executeAndReport</code> 方法时,提供 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code> 参数</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>也可以增加一个可选参数,用于熔断时进行失败回退（fallback）:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CircuitBreaker breaker = CircuitBreaker.create(<span class=\"hljs-string\">\"my-circuit-breaker\"</span>, vertx,\n    <span class=\"hljs-keyword\">new</span> CircuitBreakerOptions().setMaxFailures(<span class=\"hljs-number\">5</span>).setTimeout(<span class=\"hljs-number\">2000</span>)\n);\n\n<span class=\"hljs-comment\">// ---</span>\n<span class=\"hljs-comment\">// 熔断器会临时存储该次运行结果,用于熔断判断</span>\n<span class=\"hljs-comment\">// ---</span>\n\nbreaker.executeWithFallback(\n    promise -&gt; {\n      vertx.createHttpClient().request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/\"</span>)\n        .compose(req -&gt; req\n          .send()\n          .compose(resp -&gt; {\n            <span class=\"hljs-keyword\">if</span> (resp.statusCode() != <span class=\"hljs-number\">200</span>) {\n              <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"HTTP error\"</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-keyword\">return</span> resp.body().map(Buffer::toString);\n            }\n          })).onComplete(promise);\n      }, v -&gt; {\n      <span class=\"hljs-comment\">// 当熔断器熔断时,返回Hello</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello\"</span>;\n    })\n    .onComplete(ar -&gt; {\n        <span class=\"hljs-comment\">// 处理结果</span>\n    });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>每当熔断器熔断的时候,都会调用失败回退（fallback），也可以调用\n<code><a href=\"../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#isFallbackOnFailure--\">isFallbackOnFailure</a></code> 方法开启失败回退。\n当回退函数被成功设置之后，回退函数将会接收 <code><a href=\"../../apidocs/java/lang/Throwable.html\">Throwable</a></code> 对象为参数并返回预期类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过 <code><a href=\"../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html\">CircuitBreaker</a></code> 直接设置失败回退方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CircuitBreaker breaker = CircuitBreaker.create(<span class=\"hljs-string\">\"my-circuit-breaker\"</span>, vertx,\n    <span class=\"hljs-keyword\">new</span> CircuitBreakerOptions().setMaxFailures(<span class=\"hljs-number\">5</span>).setTimeout(<span class=\"hljs-number\">2000</span>)\n).fallback(v -&gt; {\n  <span class=\"hljs-comment\">//  当熔断器熔断时将调用此处代码</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\n});\n\nbreaker.&lt;String&gt;execute(\n    promise -&gt; {\n      vertx.createHttpClient().request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/\"</span>)\n        .compose(req -&gt; req\n          .send()\n          .compose(resp -&gt; {\n            <span class=\"hljs-keyword\">if</span> (resp.statusCode() != <span class=\"hljs-number\">200</span>) {\n              <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"HTTP error\"</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-keyword\">return</span> resp.body().map(Buffer::toString);\n            }\n          })).onComplete(promise);\n    });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_retries\"><a class=\"anchor\" href=\"#_retries\"></a>重试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>还可以通过 <code><a href=\"../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setMaxRetries-int-\">setMaxRetries</a></code>.\n设置重试次数,如设置大于0的数值，失败的情况下会重试，直到重试次数等于该数值，如果其中一次重试成功，\n那么会跳过剩下的重试。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>注意</strong> 如您设置最大重试次数 <code>maxRetries</code> 为 2，那么您的代码在失败的情况将会执行3次，分别为初次请求，\n以及 2 次重试。</p>\n</div>\n<div class=\"paragraph\">\n<p>在默认情况下超时时间（timeout）和重试次数（retries）为0，那么将会无延时地一直请求下去，这会导致调用服务负载增加\n并导致服务恢复时间延长。所以为了减少这种情况，建议设置延时以及重试次数。\n方法 <code><a href=\"../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#retryPolicy-java.util.function.Function-\">retryPolicy</a></code>\n用于设置重试策略。该方法接收一个Function&lt;Integer,Long&gt;的函数体（传入参数为重试次数，返回具体超时时间，单位：毫秒），\n允许用户定制更加复杂的延时策略，例如：带抖动的延时补偿。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面是设置了重试策略的例子，重试超时时间与重试时间呈线指数增长。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CircuitBreaker breaker = CircuitBreaker.create(<span class=\"hljs-string\">\"my-circuit-breaker\"</span>, vertx,\n  <span class=\"hljs-keyword\">new</span> CircuitBreakerOptions().setMaxFailures(<span class=\"hljs-number\">5</span>).setMaxRetries(<span class=\"hljs-number\">5</span>).setTimeout(<span class=\"hljs-number\">2000</span>)\n).openHandler(v -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Circuit opened\"</span>);\n}).closeHandler(v -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Circuit closed\"</span>);\n}).retryPolicy(retryCount -&gt; retryCount * <span class=\"hljs-number\">100L</span>);\n\nbreaker.&lt;String&gt;execute(\n  promise -&gt; {\n    vertx.createHttpClient().request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/\"</span>)\n      .compose(req -&gt; req\n        .send()\n        .compose(resp -&gt; {\n          <span class=\"hljs-keyword\">if</span> (resp.statusCode() != <span class=\"hljs-number\">200</span>) {\n            <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"HTTP error\"</span>);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> resp.body().map(Buffer::toString);\n          }\n        })).onComplete(promise);\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_callbacks\"><a class=\"anchor\" href=\"#_callbacks\"></a>回调</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以配置熔断开启或关闭时的回调函数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CircuitBreaker breaker = CircuitBreaker.create(<span class=\"hljs-string\">\"my-circuit-breaker\"</span>, vertx,\n    <span class=\"hljs-keyword\">new</span> CircuitBreakerOptions().setMaxFailures(<span class=\"hljs-number\">5</span>).setTimeout(<span class=\"hljs-number\">2000</span>)\n).openHandler(v -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Circuit opened\"</span>);\n}).closeHandler(v -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Circuit closed\"</span>);\n});\n\nbreaker.&lt;String&gt;execute(\n    promise -&gt; {\n      vertx.createHttpClient().request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/\"</span>)\n        .compose(req -&gt; req\n          .send()\n          .compose(resp -&gt; {\n            <span class=\"hljs-keyword\">if</span> (resp.statusCode() != <span class=\"hljs-number\">200</span>) {\n              <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"HTTP error\"</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-keyword\">return</span> resp.body().map(Buffer::toString);\n            }\n          })).onComplete(promise);\n    });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当熔断器决定尝试复位的时候（ half-open 状态），我们也可以注册 <code><a href=\"../../apidocs/io/vertx/circuitbreaker/CircuitBreaker.html#halfOpenHandler-io.vertx.core.Handler-\">halfOpenHandler</a></code> 的回调从而得到回调通知。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_event_bus_notification\"><a class=\"anchor\" href=\"#_event_bus_notification\"></a>事件总线通知</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>每当熔断器发生状态改变的时候,熔断器都会在事件总线上推送通知，总线通默认地址为：<code>vertx.circuit-breaker</code>。\n当然这个也是可以配置的，调用方法\n<code><a href=\"../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setNotificationAddress-java.lang.String-\">setNotificationAddress</a></code>. If <code>null</code> is\n你可以设置总线通知地址。如果设置为 <code>null</code> 那么总线通知将被禁用。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个总线通知都会包含一个 Json Object对象，该对象包括以下字段：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>state</code> : 熔断器最新的状态（<code>OPEN</code>, <code>CLOSED</code>, <code>HALF_OPEN</code>）</p>\n</li>\n<li>\n<p><code>name</code> : 熔断器的名称</p>\n</li>\n<li>\n<p><code>failures</code> : 错误次数</p>\n</li>\n<li>\n<p><code>node</code> : 节点标识 (如果事件总线并非运行在集群模式中，那么该值为：<code>local</code>)</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_half_open_state\"><a class=\"anchor\" href=\"#_the_half_open_state\"></a>半开状态</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当熔断器处于开路状态时，对其调用会立即失败，不会执行实际操作。经过适当的时间 (通过\n<code><a href=\"../../apidocs/io/vertx/circuitbreaker/CircuitBreakerOptions.html#setResetTimeout-long-\">setResetTimeout</a></code> 配置）,\n熔断器决定是否恢复状态，此时进入半开启状态（half-open state）。在这种状态下，\n允许下一次熔断器的调用实际调用如果成功，熔断器将复位并返回到关闭状态，\n回归正常的模式；但是如果这次调用失败，则熔断器返回到熔断状态，直到下次半开状态。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reported_exceptions\"><a class=\"anchor\" href=\"#_reported_exceptions\"></a>异常</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>回退函数将会接收到：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当熔断器开启时，会抛出 <code><a href=\"../../apidocs/io/vertx/circuitbreaker/OpenCircuitException.html\">OpenCircuitException</a></code></p>\n</li>\n<li>\n<p>当操作超时，会抛出 <code><a href=\"../../apidocs/io/vertx/circuitbreaker/TimeoutException.html\">TimeoutException</a></code></p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pushing_circuit_breaker_metrics_to_the_hystrix_dashboard\"><a class=\"anchor\" href=\"#_pushing_circuit_breaker_metrics_to_the_hystrix_dashboard\"></a>将熔断器指标推送到Hystrix看板（Dashboard）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Netflix Hystrix带有一个看板（dashboard），用于显示熔断器的当前状态。 Vert.x 熔断器可以发布其指标（metric），以供Hystrix 仪表板使用。 Hystrix 仪表板需要一个发送指标的SSE流，\n此流由 <code><a href=\"../../apidocs/io/vertx/circuitbreaker/HystrixMetricHandler.html\">HystrixMetricHandler</a></code>\n该 Vert.x Web 处理器所提供：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CircuitBreaker breaker = CircuitBreaker.create(<span class=\"hljs-string\">\"my-circuit-breaker\"</span>, vertx);\nCircuitBreaker breaker2 = CircuitBreaker.create(<span class=\"hljs-string\">\"my-second-circuit-breaker\"</span>, vertx);\n\n<span class=\"hljs-comment\">// 创建 Vert.x Web 路由</span>\nRouter router = Router.router(vertx);\n<span class=\"hljs-comment\">// 注册指标Handler</span>\nrouter.get(<span class=\"hljs-string\">\"/hystrix-metrics\"</span>).handler(HystrixMetricHandler.create(vertx));\n\n<span class=\"hljs-comment\">// / 创建HTTP服务器，并分配路由</span>\nvertx.createHttpServer()\n  .requestHandler(router)\n  .listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在Hystrix 看板, 配置 stream url 地址,例如: <code><a href=\"http://localhost:8080/metrics\" class=\"bare\">http://localhost:8080/metrics</a></code>. 现在就可以获取Vert.x的熔断器指标了。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>注意</strong>：这些指标量是由 Vert.x Web Handler 使用 Event Bus 事件通知收集。\n如您不想使用默认的通知地址，请在创建的时候设置。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_netflix_hystrix\"><a class=\"anchor\" href=\"#_using_netflix_hystrix\"></a>使用 Netflix Hystrix</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/Netflix/Hystrix\">Hystrix</a> 提供了熔断器模式的实现。可以在Vert.x中使用Hystrix提供的熔断器或组合使用。\n本节介绍在Vert.x应用程序中使用Hystrix的技巧。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先，您需要将Hystrix添加到你的依赖中。\n详细信息请参阅Hystrix页面。然后，您需要使用 Command 隔离“受保护的”调用。\n您可以这样执行之：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HystrixCommand&lt;String&gt; someCommand = getSomeCommandInstance();\nString result = someCommand.execute();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>但是，代码执行是阻塞的，所以需要使用 <code>executeBlocking</code> 方法执行，\n或在Worker Verticle中调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HystrixCommand&lt;String&gt; someCommand = getSomeCommandInstance();\nvertx.&lt;String&gt;executeBlocking(\nfuture -&gt; future.complete(someCommand.execute()),\nar -&gt; {\n<span class=\"hljs-comment\">// 回到Event Loop线程中</span>\nString result = ar.result();\n}\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果你使用了Hystrix异步方法, 对应回调函数是不会在Vert.x的线程中执行的,因此我们必须在执行前保持上下的引用,\n（使用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--\">getOrCreateContext</a></code> 方法），\n执行\n<code><a href=\"../../apidocs/io/vertx/core/Vertx.html#runOnContext-io.vertx.core.Handler-\">runOnContext</a></code> 方法将当前线程切换回Event Loop线程。\n不这样做的话，您将失去Vert.x异步模型的优势，并且必须自行管理线程同步和执行顺序：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.runOnContext(v -&gt; {\n    Context context = vertx.getOrCreateContext();\n    HystrixCommand&lt;String&gt; command = getSomeCommandInstance();\n    command.observe().subscribe(result -&gt; {\n        context.runOnContext(v2 -&gt; {\n            <span class=\"hljs-comment\">// 回到Vert.x Context下(Event Loop线程或Worker线程)</span>\n            String r = result;\n        });\n    });\n});</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}