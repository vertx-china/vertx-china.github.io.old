{"pageProps":{"slug":"vertx-web/java","title":"Vert.x-Web","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_web\">使用 Vert.x Web</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_development_mode\">开发模式</a></li>\n</ul>\n</li>\n<li><a href=\"#_re_cap_on_vert_x_core_http_servers\">回顾 Vert.x Core 的 HTTP 服务端</a></li>\n<li><a href=\"#_basic_vert_x_web_concepts\">Vert.x Web 的基本概念</a></li>\n<li><a href=\"#_handling_requests_and_calling_the_next_handler\">处理请求并调用下一个处理器</a></li>\n<li><a href=\"#_simple_responses\">简单的响应</a></li>\n<li><a href=\"#_using_blocking_handlers\">使用阻塞式处理器</a></li>\n<li><a href=\"#_routing_by_exact_path\">基于精确路径的路由</a></li>\n<li><a href=\"#_routing_by_paths_that_begin_with_something\">基于路径前缀的路由</a></li>\n<li><a href=\"#_capturing_path_parameters\">捕捉路径参数</a></li>\n<li><a href=\"#_routing_with_regular_expressions\">基于正则表达式的路由</a></li>\n<li><a href=\"#_capturing_path_parameters_with_regular_expressions\">通过正则表达式捕捉路径参数</a></li>\n<li><a href=\"#_using_named_capture_groups\">使用命名的捕捉组</a></li>\n<li><a href=\"#_routing_by_http_method\">基于 HTTP 方法的路由</a></li>\n<li><a href=\"#_route_order\">Route order</a></li>\n<li><a href=\"#_routing_based_on_mime_type_of_request\">Routing based on MIME type of request</a></li>\n<li><a href=\"#_routing_based_on_mime_types_acceptable_by_the_client\">Routing based on MIME types acceptable by the client</a></li>\n<li><a href=\"#_routing_based_on_virtualhost\">Routing based on VirtualHost</a></li>\n<li><a href=\"#_combining_routing_criteria\">Combining routing criteria</a></li>\n<li><a href=\"#_enabling_and_disabling_routes\">Enabling and disabling routes</a></li>\n<li><a href=\"#_forward_support\">Forward Support</a></li>\n<li><a href=\"#_context_data\">Context data</a></li>\n<li><a href=\"#_helper_functions\">Helper functions</a></li>\n<li><a href=\"#_reroute\">Reroute</a></li>\n<li><a href=\"#_sub_routers\">Sub-routers</a></li>\n<li><a href=\"#_localization\">Localization</a></li>\n<li><a href=\"#_route_match_failures\">Route match failures</a></li>\n<li><a href=\"#_error_handling\">Error handling</a></li>\n<li><a href=\"#_request_body_handling\">Request body handling</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_the_request_body\">Getting the request body</a></li>\n<li><a href=\"#_limiting_body_size\">Limiting body size</a></li>\n<li><a href=\"#_merging_form_attributes\">Merging form attributes</a></li>\n<li><a href=\"#_handling_file_uploads\">Handling file uploads</a></li>\n</ul>\n</li>\n<li><a href=\"#_handling_cookies\">Handling cookies</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_manipulating_cookies\">Manipulating cookies</a></li>\n</ul>\n</li>\n<li><a href=\"#_handling_sessions\">Handling sessions</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_session_stores\">Session stores</a></li>\n<li><a href=\"#_creating_the_session_handler\">Creating the session handler</a></li>\n<li><a href=\"#_using_the_session\">Using the session</a></li>\n<li><a href=\"#_session_timeout\">Session timeout</a></li>\n</ul>\n</li>\n<li><a href=\"#_authentication_authorization\">Authentication / authorization</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_an_authentication_handler\">Creating an Authentication handler</a></li>\n<li><a href=\"#_handling_authentication_in_your_application\">Handling authentication in your application</a></li>\n<li><a href=\"#_http_basic_authentication\">HTTP Basic Authentication</a></li>\n<li><a href=\"#_redirect_authentication_handler\">Redirect authentication handler</a></li>\n<li><a href=\"#_jwt_authentication\">JWT authentication</a></li>\n<li><a href=\"#_configuring_authorization\">Configuring authorization</a></li>\n<li><a href=\"#_chaining_multiple_authentication_handlers\">Chaining multiple authentication handlers</a></li>\n</ul>\n</li>\n<li><a href=\"#_serving_static_resources\">Serving static resources</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_configuring_caching\">Configuring caching</a></li>\n<li><a href=\"#_configuring_the_index_page\">Configuring the index page</a></li>\n<li><a href=\"#_changing_the_web_root\">Changing the web root</a></li>\n<li><a href=\"#_serving_hidden_files\">Serving hidden files</a></li>\n<li><a href=\"#_directory_listing\">Directory listing</a></li>\n<li><a href=\"#_disabling_file_caching_on_disk\">Disabling file caching on disk</a></li>\n</ul>\n</li>\n<li><a href=\"#_cors_handling\">CORS handling</a></li>\n<li><a href=\"#_multi_tenant\">Multi Tenant</a></li>\n<li><a href=\"#_templates\">模板</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_mvel_template_engine\">MVEL 模版引擎</a></li>\n<li><a href=\"#_jade_template_engine\">Jade 模版引擎（译者注：Jade 已更名为 Pug)</a></li>\n<li><a href=\"#_handlebars_template_engine\">Handlebars 模板引擎</a></li>\n<li><a href=\"#_thymeleaf_template_engine\">Thymeleaf 模板引擎</a></li>\n<li><a href=\"#_apache_freemarker_template_engine\">Apache FreeMarker 模版引擎</a></li>\n<li><a href=\"#_pebble_template_engine\">Pebble 模版引擎</a></li>\n<li><a href=\"#_rocker_template_engine\">Rocker 模版引擎</a></li>\n<li><a href=\"#_httl_template_engine\">HTTL 模版引擎</a></li>\n<li><a href=\"#_rythm_template_engine\">Rythm 模版引擎</a></li>\n<li><a href=\"#_caching\">缓存</a></li>\n</ul>\n</li>\n<li><a href=\"#_error_handler\">错误处理器</a></li>\n<li><a href=\"#_request_logger\">请求日志</a></li>\n<li><a href=\"#_serving_favicons\">提供网页图标</a></li>\n<li><a href=\"#_timeout_handler\">超时处理器</a></li>\n<li><a href=\"#_response_time_handler\">响应时间处理器</a></li>\n<li><a href=\"#_content_type_handler\">内容类型（Content type）处理器</a></li>\n<li><a href=\"#_sockjs\">SockJS</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_sockjs_handler\">SockJS 处理器</a></li>\n<li><a href=\"#_handling_sockjs_sockets\">处理 SockJS 套接字</a></li>\n<li><a href=\"#_the_client_side\">客户端</a></li>\n<li><a href=\"#_configuring_the_sockjs_handler\">配置 SockJS 处理器</a></li>\n<li><a href=\"#_writing_to_a_sockjs_socket_over_the_event_bus\">通过 event bus 写入 SockJS 套接字</a></li>\n</ul>\n</li>\n<li><a href=\"#_sockjs_event_bus_bridge\">SockJS 桥接 Event Bus</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_securing_the_bridge\">守护连接桥</a></li>\n<li><a href=\"#_requiring_authorization_for_messages\">消息授权</a></li>\n<li><a href=\"#_handling_event_bus_bridge_events\">Handling event bus bridge events</a></li>\n</ul>\n</li>\n<li><a href=\"#_csrf_cross_site_request_forgery\">CSRF Cross Site Request Forgery</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_ajax\">Using AJAX</a></li>\n</ul>\n</li>\n<li><a href=\"#_hsts_handler\">HSTS Handler</a></li>\n<li><a href=\"#_csp_handler\">CSP Handler</a></li>\n<li><a href=\"#_xframe_handler\">XFrame Handler</a></li>\n<li><a href=\"#_oauth2authhandler_handler\">OAuth2AuthHandler Handler</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_a_real_world_example\">A real world example</a></li>\n<li><a href=\"#_mixing_oauth2_and_jwt\">Mixing OAuth2 and JWT</a></li>\n<li><a href=\"#_webauthn\">WebAuthn</a></li>\n<li><a href=\"#_handling_http_method_overriding\">Handling HTTP Method overriding</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x-Web</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web是基于Vert.x的，用于构建Web应用程序的一系列构建模块。 可以将其视为一把构建现代的，可扩展的Web应用的瑞士军刀。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Core 提供了一系列相对底层的功能用于操作HTTP，对于一部分应用是足够的。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 基于 Vert.x Core 提供了一系列更丰富的功能，以便更容易地开发实际的 Web 应用。</p>\n</div>\n<div class=\"paragraph\">\n<p>它继承了 Vert.x 2.x 里的 <a href=\"http://pmlopes.github.io/yoke/\">Yoke</a> 的特点，灵感来自于 Node.js 的框架 <a href=\"http://expressjs.com/\">Express</a> 和 Ruby 的框架 <a href=\"http://www.sinatrarb.com/\">Sinatra</a> 等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 的设计是强大的，非侵入式的, 并且是完全可插拔的。您可以只使用您需要的部分。 Vert.x Web 不是一个容器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 Vert.x Web 来构建经典的服务端 Web 应用， RESTful 应用， 实时的（服务端推送)Web 应用, 或任何您所能想到的 Web 应用类型。应用类型的选择取决于您的喜好，而不是 Vert.x Web。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web is a great fit for writing RESTful HTTP micro-services, but we don’t force you to write apps like that。\nVert.x Web 非常适合编写 RESTful HTTP 微服务，<strong> 但我们不强制 </strong> 您必须把应用实现成这样。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 的一部分关键特性有：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>路由(基于方法,路径等)</p>\n</li>\n<li>\n<p>基于正则表达式的路径匹配</p>\n</li>\n<li>\n<p>从路径中提取参数</p>\n</li>\n<li>\n<p>内容协商</p>\n</li>\n<li>\n<p>处理消息体</p>\n</li>\n<li>\n<p>消息体的长度限制</p>\n</li>\n<li>\n<p>Multipart 表单</p>\n</li>\n<li>\n<p>Multipart 文件上传</p>\n</li>\n<li>\n<p>子路由</p>\n</li>\n<li>\n<p>支持本地会话和集群会话</p>\n</li>\n<li>\n<p>支持 CORS(跨域资源共享)</p>\n</li>\n<li>\n<p>错误页面处理器</p>\n</li>\n<li>\n<p>HTTP基本/摘要认证</p>\n</li>\n<li>\n<p>基于重定向的认证</p>\n</li>\n<li>\n<p>授权处理器</p>\n</li>\n<li>\n<p>基于 JWT 的授权</p>\n</li>\n<li>\n<p>用户/角色/权限授权</p>\n</li>\n<li>\n<p>网页图标处理器</p>\n</li>\n<li>\n<p>支持服务端模板渲染，包括以下开箱即用的模板引擎:</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Handlebars</p>\n</li>\n<li>\n<p>Jade</p>\n</li>\n<li>\n<p>MVEL</p>\n</li>\n<li>\n<p>Thymeleaf</p>\n</li>\n<li>\n<p>Apache FreeMarker</p>\n</li>\n<li>\n<p>Pebble</p>\n</li>\n<li>\n<p>Rocker</p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>响应时间处理器</p>\n</li>\n<li>\n<p>静态文件服务，包括缓存逻辑以及目录监听</p>\n</li>\n<li>\n<p>支持请求超时</p>\n</li>\n<li>\n<p>支持 SockJS</p>\n</li>\n<li>\n<p>桥接 Event-bus</p>\n</li>\n<li>\n<p>CSRF 跨域请求伪造</p>\n</li>\n<li>\n<p>虚拟主机</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 的大部分特性是使用Handler实现的， 而且您随时可以实现您自己的处理器。我们预计随着时间的推移会有更多的处理器被实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们会在本手册里讨论所有上述的特性。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_web\"><a class=\"anchor\" href=\"#_using_vert_x_web\"></a>使用 Vert.x Web</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在使用 Vert.x Web 之前，需要为您的构建工具在描述文件中添加  <em>dependencies</em> 依赖项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件中)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-web:4.0.2'</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_development_mode\"><a class=\"anchor\" href=\"#_development_mode\"></a>开发模式</h3>\n<div class=\"paragraph\">\n<p>Vert.x Web 默认使用生产模式。\n您可以通过设置 <code>dev</code> 值到下面的其中一个来切换开发模式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>VERTXWEB_ENVIRONMENT</code> 环境变量，或</p>\n</li>\n<li>\n<p><code>vertxweb.environment</code> 系统属性</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在开发模式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>模板引擎缓存被禁用</p>\n</li>\n<li>\n<p><code>ErrorHandler</code> 不显示异常详细信息</p>\n</li>\n<li>\n<p><code>StaticHandler</code> 不处理缓存头</p>\n</li>\n<li>\n<p>GraphQL开发工具被禁用</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_re_cap_on_vert_x_core_http_servers\"><a class=\"anchor\" href=\"#_re_cap_on_vert_x_core_http_servers\"></a>回顾 Vert.x Core 的 HTTP 服务端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web 使用并暴露了 Vert.x Core 的 API，所以熟悉基于 Vert.x Core 编写 HTTP 服务端的基本概念是很有价值的。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x core HTTP文档对此进行了详细介绍。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个用 Vert.x core 编写的 Hello World Web服务。暂不涉及Vert.x-Web：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer();\n\nserver.requestHandler(request -&gt; {\n\n  <span class=\"hljs-comment\">// 所有的请求都会调用这个处理器处理</span>\n  HttpServerResponse response = request.response();\n  response.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>);\n\n  <span class=\"hljs-comment\">// 写入响应并结束处理</span>\n  response.end(<span class=\"hljs-string\">\"Hello World!\"</span>);\n});\n\nserver.listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们创建了一个 HTTP 服务器实例，并设置了一个请求处理器。所有的请求都会调用这个处理器处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>当请求到达时，我们设置响应的 Content Type 为 <code>text/plain</code> ， 并写入了 <code>Hello World!</code> 然后结束了处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>之后，我们告诉服务器监听 <code>8080</code> 端口(默认的主机名是 <code>localhost</code> )。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以执行这段代码，并打开浏览器访问 <code><a href=\"http://localhost:8080\" class=\"bare\">http://localhost:8080</a></code> 来验证它是否如预期一样工作。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_basic_vert_x_web_concepts\"><a class=\"anchor\" href=\"#_basic_vert_x_web_concepts\"></a>Vert.x Web 的基本概念</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>高屋建瓴 (Here&#8217;s the 10000 foot view)：</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">路由器 Router</a></code> 是 Vert.x Web 的核心概念之一。 它是一个维护了零或多个\n<code><a href=\"../../apidocs/io/vertx/ext/web/Route.html\">路由 Routes</a></code> 的对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个 router 接收 HTTP 请求，并查找首个匹配该请求的route, 然后将请求传递给这个route</p>\n</div>\n<div class=\"paragraph\">\n<p><code>Route</code> 可以持有一个与之关联的 <em>handler</em> 用于接收请求。 您可以通过这个处理器对请求 <em>做一些事情</em>, 然后结束响应或者把请求传递给下一个匹配的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一个简单的路由示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer server = vertx.createHttpServer();\n\nRouter router = Router.router(vertx);\n\nrouter.route().handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有的请求都会调用这个处理器处理</span>\n  HttpServerResponse response = ctx.response();\n  response.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>);\n\n  <span class=\"hljs-comment\">// 写入响应并结束处理</span>\n  response.end(<span class=\"hljs-string\">\"Hello World from Vert.x-Web!\"</span>);\n});\n\nserver.requestHandler(router).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它做了和上文使用 Vert.x Core 实现的 hello world HTTP 服务基本相同的事情，只是这一次换成了 Vert.x Web。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们像以前一样创建一个HTTP服务器，然后我们创建一个 router。当我们完成这些之后,我们创建一个简单的没有匹配条件的 rout，它能够匹配 <em>全部</em> 到来的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>然后，我们为该路由指定一个处理器。该处理器将处理所有到来的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>传递给处理器的对象是 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> - 它包含标准的 Vert.x <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html\">HttpServerResponse</a></code>\n还有其他各种有用的东西，让使用Vert.x-Web变得更加简单。</p>\n</div>\n<div class=\"paragraph\">\n<p>处理器调用的参数是一个 <a href=\"http://vertx.io/docs/apidocs/io/vertx/ext/web/RoutingContext.html\"> <code>RoutingContext</code> </a> 对象。 它不仅包含了 Vert.x 中标准的 <a href=\"http://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerRequest.html\"> <code>HttpServerRequest</code> </a> 和\n<a href=\"http://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerResponse.html\"> <code>HttpServerResponse</code> </a>，还包含了各种用于简化 Vert.x Web 使用的东西。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个被路由的请求， 都有一个唯一的路由上下文实例， 并将这个实例传递给该请求的所有处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>当我们建立了处理器之后，我们设置 HTTP 服务器的请求处理器，使所有的请求都通过 <code><a href=\"../../apidocs/io/vertx/core/Handler。html#handle-java.lang.Object-\">handle</a></code> 处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些是最基本的，下面我们来看一下更多的细节：</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_requests_and_calling_the_next_handler\"><a class=\"anchor\" href=\"#_handling_requests_and_calling_the_next_handler\"></a>处理请求并调用下一个处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当 Vert.x Web 决定路由一个请求到匹配的route，它会调用对应处理器并将一个 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 实例传递给它. route可以具有不同的处理器， 您可以叠加使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route。html#handler-io.vertx.core.Handler-\">handler</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>如果您不在处理器里结束这个响应，您需要调用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\">next</a></code> 方法让其他匹配的 route 来处理请求(如果有)。</p>\n</div>\n<div class=\"paragraph\">\n<p>您不需要在处理器执行完毕时调用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\">next</a></code> 。 您可以在之后需要的时间点调用它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route(<span class=\"hljs-string\">\"/some/path/\"</span>);\nroute.handler(ctx -&gt; {\n\n  HttpServerResponse response = ctx.response();\n  <span class=\"hljs-comment\">// 开启分块响应，因为我们将在执行其他处理器时添加数据</span>\n  <span class=\"hljs-comment\">// 仅当有多个处理器输出时</span>\n  response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\n  response.write(<span class=\"hljs-string\">\"route1\\n\"</span>);\n\n  <span class=\"hljs-comment\">// 延迟5秒后调用下一匹配route</span>\n  ctx.vertx().setTimer(<span class=\"hljs-number\">5000</span>, tid -&gt; ctx.next());\n});\n\nroute.handler(ctx -&gt; {\n\n  HttpServerResponse response = ctx.response();\n  response.write(<span class=\"hljs-string\">\"route2\\n\"</span>);\n\n  <span class=\"hljs-comment\">// 延迟5秒后调用下一匹配route</span>\n  ctx.vertx().setTimer(<span class=\"hljs-number\">5000</span>, tid -&gt; ctx.next());\n});\n\nroute.handler(ctx -&gt; {\n\n  HttpServerResponse response = ctx.response();\n  response.write(<span class=\"hljs-string\">\"route3\"</span>);\n\n  <span class=\"hljs-comment\">// 现在结束响应</span>\n  ctx.response().end();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述的例子中， <code>route1</code> 向响应里写入了数据， 5秒之后 <code>route2</code> 向响应里写入了数据，再5秒之后 <code>route3</code> 向响应里写入了数据并结束了响应。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n所有发生的这些没有线程阻塞。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_simple_responses\"><a class=\"anchor\" href=\"#_simple_responses\"></a>简单的响应</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>处理器非常强大， 因为它们允许您构建非常复杂的应用程序。 为了保证简单的响应，例如直接从vert.x API返回异步响应，router 包含一个快捷的处理器：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>响应返回JSON。</p>\n</li>\n<li>\n<p>如果处理过程中发生错误，一个适当的错误会返回。</p>\n</li>\n<li>\n<p>如果序列化JSON中发生错误，一个适当的错误会返回。</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/some/path\"</span>)\n  <span class=\"hljs-comment\">// 这个处理器将保证这个响应会被序列化成json</span>\n  <span class=\"hljs-comment\">// content type被设置成 \"application/json\"</span>\n  .respond(\n    ctx -&gt; Future.succeededFuture(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"world\"</span>)));\n\nrouter\n  .get(<span class=\"hljs-string\">\"/some/path\"</span>)\n  <span class=\"hljs-comment\">// 这个处理器将保证这个Pojo会被序列化成json</span>\n  <span class=\"hljs-comment\">// content type被设置成 \"application/json\"</span>\n  .respond(\n    ctx -&gt; Future.succeededFuture(<span class=\"hljs-keyword\">new</span> Pojo()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>不过， 如果提供的函数支持调用 <code>write</code> 或 <code>end</code> ， 您还可以将其用于非JSON响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/some/path\"</span>)\n  .respond(\n    ctx -&gt; ctx\n      .response()\n        .putHeader(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>)\n        .end(<span class=\"hljs-string\">\"hello world!\"</span>));\n\nrouter\n  .get(<span class=\"hljs-string\">\"/some/path\"</span>)\n  <span class=\"hljs-comment\">// 在这种情况下，处理器确保连接被终止</span>\n  .respond(\n    ctx -&gt; ctx\n      .response()\n        .setChunked(<span class=\"hljs-keyword\">true</span>)\n        .write(<span class=\"hljs-string\">\"Write some text...\"</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_blocking_handlers\"><a class=\"anchor\" href=\"#_using_blocking_handlers\"></a>使用阻塞式处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>某些时候您可能需要在处理器里执行一些需要阻塞 Event Loop 的操作，比如调用某个传统的阻塞式 API 或者执行密集计算。</p>\n</div>\n<div class=\"paragraph\">\n<p>您不能在普通的处理器里执行这些操作， 因此我们提供了将route设置成阻塞式处理器的功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>阻塞式处理器和普通处理器很像， 区别是 Vert.x 会使用 Worker Pool 中的线程而不是 Event Loop 线程来处理请求。\n您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-\">blockingHandler</a></code>\n方法来建立阻塞式处理器。 以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().blockingHandler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 执行某些同步的耗时操作</span>\n  service.doSomethingThatBlocks();\n\n  <span class=\"hljs-comment\">// 调用下一个处理器</span>\n  ctx.next();\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，在同一个 Context (例如同一个 Verticle 实例) 上执行的所有阻塞式处理器是顺序的， 也就意味着只有一个处理器执行完了才会继续执行下一个。 如果您不关心执行的顺序，并且不介意阻塞式处理器以并行的方式执行， 您可以在使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-boolean-\">blockingHandler</a></code> 时，设置阻塞式处理器的 <code>ordered</code> 为 false。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果您需要在一个阻塞处理器中处理一个 multipart 类型的表单数据，您需要首先使用一个非阻塞的处理器来调用 <code>setExpectMultipart(true)</code> 。以下是例子：\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.post(<span class=\"hljs-string\">\"/some/endpoint\"</span>).handler(ctx -&gt; {\n  ctx.request().setExpectMultipart(<span class=\"hljs-keyword\">true</span>);\n  ctx.next();\n}).blockingHandler(ctx -&gt; {\n  <span class=\"hljs-comment\">// ... 执行某些阻塞操作</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_by_exact_path\"><a class=\"anchor\" href=\"#_routing_by_exact_path\"></a>基于精确路径的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>可以将 <code>Route</code> 设置为根据需要所匹配的 URI。在这种情况下它只会匹配路径一致的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>在下面这个例子中，处理器会被路径为 <code>/some/path/</code> 的请求调用。我们会忽略结尾的 <code>/</code> ， 所以路径 <code>/some/path</code> 或者 <code>/some/path//</code> 的请求也是匹配的</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route().path(<span class=\"hljs-string\">\"/some/path/\"</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器会被以下路径的请求调用：</span>\n\n  <span class=\"hljs-comment\">// `/some/path/`</span>\n  <span class=\"hljs-comment\">// `/some/path//`</span>\n  <span class=\"hljs-comment\">//</span>\n  <span class=\"hljs-comment\">// 但不包括:</span>\n  <span class=\"hljs-comment\">// `/some/path` 路径末尾的斜线会被严格限制</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir`</span>\n});\n\n<span class=\"hljs-comment\">// 路径结尾没有斜线的不会被严格限制</span>\n<span class=\"hljs-comment\">// 这意味着结尾的斜线是可选的</span>\n<span class=\"hljs-comment\">// 无论怎样都会匹配</span>\nRoute route2 = router.route().path(<span class=\"hljs-string\">\"/some/path\"</span>);\n\nroute2.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器会被以下路径的请求调用：</span>\n\n  <span class=\"hljs-comment\">// `/some/path`</span>\n  <span class=\"hljs-comment\">// `/some/path/`</span>\n  <span class=\"hljs-comment\">// `/some/path//`</span>\n  <span class=\"hljs-comment\">//</span>\n  <span class=\"hljs-comment\">// 但不包括:</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir`</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_by_paths_that_begin_with_something\"><a class=\"anchor\" href=\"#_routing_by_paths_that_begin_with_something\"></a>基于路径前缀的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您经常需要为所有以某些路径开始的请求设置 <code>Route</code> 。 您可以使用正则表达式来实现， 但更简单的方式是在声明 <code>Route</code> 的路径时使用一个 <code>*</code> 作为结尾。</p>\n</div>\n<div class=\"paragraph\">\n<p>在下面的例子中处理器会匹配所有 URI 以 <code>/some/path</code> 开头的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如 <code>/some/path/foo.html</code> 和 <code>/some/path/otherdir/blah.css</code> 都会匹配。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route().path(<span class=\"hljs-string\">\"/some/path/*\"</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器处理会被所有以 `/some/path/` 开头的请求调用， 例如：</span>\n\n  <span class=\"hljs-comment\">// `/some/path/`</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir`</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir/blah.html`</span>\n  <span class=\"hljs-comment\">//</span>\n  <span class=\"hljs-comment\">// 但不包括:</span>\n  <span class=\"hljs-comment\">// `/some/path` 这个路径被限制因为以斜线结尾</span>\n  <span class=\"hljs-comment\">// `/some/bath`</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以在创建 <code>Route</code> 的时候指定任意的路径：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route(<span class=\"hljs-string\">\"/some/path/*\"</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器的调用规则和上面的例子一样</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_capturing_path_parameters\"><a class=\"anchor\" href=\"#_capturing_path_parameters\"></a>捕捉路径参数</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>可以通过占位符声明路径参数并在处理请求时通过 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#pathParam-java.lang.String-\">pathParam</a></code> 。 方法获取</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一个例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(HttpMethod.POST, <span class=\"hljs-string\">\"/catalogue/products/:productType/:productID/\"</span>)\n  .handler(ctx -&gt; {\n\n    String productType = ctx.pathParam(<span class=\"hljs-string\">\"productType\"</span>);\n    String productID = ctx.pathParam(<span class=\"hljs-string\">\"productID\"</span>);\n\n    <span class=\"hljs-comment\">// 执行某些操作...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>占位符由 <code>:</code> 和参数名构成. 参数名由字母， 数字和下划线构成。</p>\n</div>\n<div class=\"paragraph\">\n<p>在上面的例子中， 如果一个 POST 请求的路径为  <code>/catalogue/products/tools/drill123/</code> ， 那么会匹配这个 <code>Route</code> ， 并且会接收参数 <code>productType</code> 的值为 <code>tools</code> ，参数 <code>productID</code> 的值为 <code>drill123</code> 。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n您也可以将 * 捕获为路径参数 * 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_with_regular_expressions\"><a class=\"anchor\" href=\"#_routing_with_regular_expressions\"></a>基于正则表达式的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>同样也可用正则表达式匹配路由的 URI 路径。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route().pathRegex(<span class=\"hljs-string\">\".*foo\"</span>);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 以下路径的请求都会调用这个处理器：</span>\n\n  <span class=\"hljs-comment\">// /some/path/foo</span>\n  <span class=\"hljs-comment\">// /foo</span>\n  <span class=\"hljs-comment\">// /foo/bar/wibble/foo</span>\n  <span class=\"hljs-comment\">// /bar/foo</span>\n\n  <span class=\"hljs-comment\">// 但不包括：</span>\n  <span class=\"hljs-comment\">// /bar/wibble</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者在创建 route 时指定正则表达式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.routeWithRegex(<span class=\"hljs-string\">\".*foo\"</span>);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 这个路由器的调用规则和上面的例子一样</span>\n\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_capturing_path_parameters_with_regular_expressions\"><a class=\"anchor\" href=\"#_capturing_path_parameters_with_regular_expressions\"></a>通过正则表达式捕捉路径参数</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您也可以通过正则表达式声明捕捉路径参数，以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.routeWithRegex(<span class=\"hljs-string\">\".*foo\"</span>);\n\n<span class=\"hljs-comment\">// 这个正则表达式可以匹配路径类似于：</span>\n<span class=\"hljs-comment\">// `/foo/bar` 的请求</span>\n<span class=\"hljs-comment\">// `foo` 可以通过参数 param0 获取，`bar` 可以通过参数 param1 获取</span>\nroute.pathRegex(<span class=\"hljs-string\">\"\\\\/([^\\\\/]+)\\\\/([^\\\\/]+)\"</span>).handler(ctx -&gt; {\n\n  String productType = ctx.pathParam(<span class=\"hljs-string\">\"param0\"</span>);\n  String productID = ctx.pathParam(<span class=\"hljs-string\">\"param1\"</span>);\n\n  <span class=\"hljs-comment\">// 执行某些操作……</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述的例子中，如果一个请求的路径为 <code>/tools/drill123/</code>，那么会匹配这个 <code>route</code>，\n并且会接收到参数 <code>productType</code> 的值为 <code>tools</code>，参数 <code>productID</code> 的值为 <code>drill123</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>捕捉（译者注：这里指的是捕捉参数这一行为）在正则表达式中用捕捉组表示（即用圆括号括住捕捉）</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_named_capture_groups\"><a class=\"anchor\" href=\"#_using_named_capture_groups\"></a>使用命名的捕捉组</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用序号参数名在某些场景下可能会比较麻烦。\n亦可在正则表达式路径中使用命名的捕捉组。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .routeWithRegex(<span class=\"hljs-string\">\"\\\\/(?&lt;productType&gt;[^\\\\/]+)\\\\/(?&lt;productID&gt;[^\\\\/]+)\"</span>)\n  .handler(ctx -&gt; {\n\n    String productType = ctx.pathParam(<span class=\"hljs-string\">\"productType\"</span>);\n    String productID = ctx.pathParam(<span class=\"hljs-string\">\"productID\"</span>);\n\n    <span class=\"hljs-comment\">// 执行某些操作……</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述的例子中，命名捕捉组将路径参数映射到同名的捕捉组中。</p>\n</div>\n<div class=\"paragraph\">\n<p>此外，您仍可以使用普通捕捉组访问组参数（例如：<code>params0, params1&#8230;&#8203;</code>）</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_by_http_method\"><a class=\"anchor\" href=\"#_routing_by_http_method\"></a>基于 HTTP 方法的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Route 默认会匹配所有的 HTTP 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您只想让 route 匹配特定的 HTTP 方法，那么您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-\">method</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route().method(HttpMethod.POST);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有的 POST 请求都会调用这个处理器</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者您可以在创建 Route 时和路径一起指定：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route(HttpMethod.POST, <span class=\"hljs-string\">\"/some/path/\"</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 所有路径为 `/some/path/`</span>\n  <span class=\"hljs-comment\">// 的 POST 请求都会调用这个处理器</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您想让 Route 指定 HTTP 方法，您也可以使用对应的 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#get--\">get</a></code>，\n<code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#post--\">post</a></code> 以及 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#put--\">put</a></code> 等方法。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get().handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有 GET 请求都会调用这个处理器</span>\n\n});\n\nrouter.get(<span class=\"hljs-string\">\"/some/path/\"</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有路径以 `/some/path/` 开始的</span>\n  <span class=\"hljs-comment\">// GET 请求都会调用这个处理器</span>\n\n});\n\nrouter.getWithRegex(<span class=\"hljs-string\">\".*foo\"</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有路径以 `foo` 结尾的</span>\n  <span class=\"hljs-comment\">// GET 请求都会调用这个处理器</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您想要让 route 匹配不止一个 HTTP 方法，\n您可多次调用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-\">method</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route().method(HttpMethod.POST).method(HttpMethod.PUT);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有 GET 或 POST 请求都会调用这个处理器</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您的应用程序需要自定义 HTTP 动词，例如，在一个 <code>基于Web的分布式编写和版本控制（WebDAV）</code> 服务器中，\n您可这样自定义动词：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.route()\n  .method(HttpMethod.valueOf(<span class=\"hljs-string\">\"MKCOL\"</span>))\n  .handler(ctx -&gt; {\n    <span class=\"hljs-comment\">// 所有 MKCOL 请求都会调用这个处理器</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n请务必留意，像 rerouting 等特性不接受自定义 http 方法，\n这些操作在检测到自定义动词时将会使用 <code>OTHER</code> 值以替代自定义名。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_route_order\"><a class=\"anchor\" href=\"#_route_order\"></a>Route order</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>By default routes are matched in the order they are added to the router.</p>\n</div>\n<div class=\"paragraph\">\n<p>When a request arrives the router will step through each route and check if it matches, if it matches then\nthe handler for that route will be called.</p>\n</div>\n<div class=\"paragraph\">\n<p>If the handler subsequently calls <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\">next</a></code> the handler for the next\nmatching route (if any) will be called. And so on.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example to illustrate this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(<span class=\"hljs-string\">\"/some/path/\"</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n    <span class=\"hljs-comment\">// enable chunked responses because we will be adding data as</span>\n    <span class=\"hljs-comment\">// we execute over other handlers. This is only required once and</span>\n    <span class=\"hljs-comment\">// only if several handlers do output.</span>\n    response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\n    response.write(<span class=\"hljs-string\">\"route1\\n\"</span>);\n\n    <span class=\"hljs-comment\">// Now call the next matching route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">\"/some/path/\"</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(<span class=\"hljs-string\">\"route2\\n\"</span>);\n\n    <span class=\"hljs-comment\">// Now call the next matching route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">\"/some/path/\"</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(<span class=\"hljs-string\">\"route3\"</span>);\n\n    <span class=\"hljs-comment\">// Now end the response</span>\n    ctx.response().end();\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the above example the response will contain:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>route1\nroute2\nroute3</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As the routes have been called in that order for any request that starts with <code>/some/path</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want to override the default ordering for routes, you can do so using <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#order-int-\">order</a></code>,\nspecifying an integer value.</p>\n</div>\n<div class=\"paragraph\">\n<p>Routes are assigned an order at creation time corresponding to the order in which they were added to the router, with\nthe first route numbered <code>0</code>, the second route numbered <code>1</code>, and so on.</p>\n</div>\n<div class=\"paragraph\">\n<p>By specifying an order for the route you can override the default ordering. Order can also be negative, e.g. if you\nwant to ensure a route is evaluated before route number <code>0</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Let&#8217;s change the ordering of route2 so it runs before route1:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(<span class=\"hljs-string\">\"/some/path/\"</span>)\n  .order(<span class=\"hljs-number\">1</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(<span class=\"hljs-string\">\"route1\\n\"</span>);\n\n    <span class=\"hljs-comment\">// Now call the next matching route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">\"/some/path/\"</span>)\n  .order(<span class=\"hljs-number\">0</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n    <span class=\"hljs-comment\">// enable chunked responses because we will be adding data as</span>\n    <span class=\"hljs-comment\">// we execute over other handlers. This is only required once and</span>\n    <span class=\"hljs-comment\">// only if several handlers do output.</span>\n    response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\n    response.write(<span class=\"hljs-string\">\"route2\\n\"</span>);\n\n    <span class=\"hljs-comment\">// Now call the next matching route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">\"/some/path/\"</span>)\n  .order(<span class=\"hljs-number\">2</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.write(<span class=\"hljs-string\">\"route3\"</span>);\n\n    <span class=\"hljs-comment\">// Now end the response</span>\n    ctx.response().end();\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>then the response will now contain:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>route2\nroute1\nroute3</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If two matching routes have the same value of order, then they will be called in the order they were added.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also specify that a route is handled last, with <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#last--\">last</a></code></p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nRoute order can be specified only before you configure an handler!\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_based_on_mime_type_of_request\"><a class=\"anchor\" href=\"#_routing_based_on_mime_type_of_request\"></a>Routing based on MIME type of request</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can specify that a route will match against matching request MIME types using <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-\">consumes</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>In this case, the request will contain a <code>content-type</code> header specifying the MIME type of the request body.\nThis will be matched against the value specified in <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-\">consumes</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Basically, <code>consumes</code> is describing which MIME types the handler can <em>consume</em>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Matching can be done on exact MIME type matches:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">\"text/html\"</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// This handler will be called for any request with</span>\n    <span class=\"hljs-comment\">// content-type header set to `text/html`</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Multiple exact matches can also be specified:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">\"text/html\"</span>)\n  .consumes(<span class=\"hljs-string\">\"text/plain\"</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// This handler will be called for any request with</span>\n    <span class=\"hljs-comment\">// content-type header set to `text/html` or `text/plain`.</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Matching on wildcards for the sub-type is supported:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">\"text/*\"</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// This handler will be called for any request</span>\n    <span class=\"hljs-comment\">// with top level type `text` e.g. content-type</span>\n    <span class=\"hljs-comment\">// header set to `text/html` or `text/plain`</span>\n    <span class=\"hljs-comment\">// will both match</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And you can also match on the top level type</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">\"*/json\"</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// This handler will be called for any request with sub-type json</span>\n    <span class=\"hljs-comment\">// e.g. content-type header set to `text/json` or</span>\n    <span class=\"hljs-comment\">// `application/json` will both match</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t specify a <code>/</code> in the consumers, it will assume you meant the sub-type.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_based_on_mime_types_acceptable_by_the_client\"><a class=\"anchor\" href=\"#_routing_based_on_mime_types_acceptable_by_the_client\"></a>Routing based on MIME types acceptable by the client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The HTTP <code>accept</code> header is used to signify which MIME types of the response are acceptable to the client.</p>\n</div>\n<div class=\"paragraph\">\n<p>An <code>accept</code> header can have multiple MIME types separated by &#8216;,&#8217;.</p>\n</div>\n<div class=\"paragraph\">\n<p>MIME types can also have a <code>q</code> value appended to them* which signifies a weighting to apply if more than one\nresponse MIME type is available matching the accept header. The q value is a number between 0 and 1.0.\nIf omitted it defaults to 1.0.</p>\n</div>\n<div class=\"paragraph\">\n<p>For example, the following <code>accept</code> header signifies the client will accept a MIME type of only <code>text/plain</code>:</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: text/plain</p>\n</div>\n<div class=\"paragraph\">\n<p>With the following the client will accept <code>text/plain</code> or <code>text/html</code> with no preference.</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: text/plain, text/html</p>\n</div>\n<div class=\"paragraph\">\n<p>With the following the client will accept <code>text/plain</code> or <code>text/html</code> but prefers <code>text/html</code> as it has a higher\n<code>q</code> value (the default value is q=1.0)</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: text/plain; q=0.9, text/html</p>\n</div>\n<div class=\"paragraph\">\n<p>If the server can provide both text/plain and text/html it should provide the text/html in this case.</p>\n</div>\n<div class=\"paragraph\">\n<p>By using <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#produces-java.lang.String-\">produces</a></code> you define which MIME type(s) the route produces, e.g. the\nfollowing handler produces a response with MIME type <code>application/json</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .produces(<span class=\"hljs-string\">\"application/json\"</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n    response.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>);\n    response.end(someJSON);\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In this case the route will match with any request with an <code>accept</code> header that matches <code>application/json</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here are some examples of <code>accept</code> headers that will match:</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: application/json\nAccept: application/*\nAccept: application/json, text/html\nAccept: application/json;q=0.7, text/html;q=0.8, text/plain</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also mark your route as producing more than one MIME type. If this is the case, then you use\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--\">getAcceptableContentType</a></code> to find out the actual MIME type that\nwas accepted.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .produces(<span class=\"hljs-string\">\"application/json\"</span>)\n  .produces(<span class=\"hljs-string\">\"text/html\"</span>)\n  .handler(ctx -&gt; {\n\n    HttpServerResponse response = ctx.response();\n\n    <span class=\"hljs-comment\">// Get the actual MIME type acceptable</span>\n    String acceptableContentType = ctx.getAcceptableContentType();\n\n    response.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, acceptableContentType);\n    response.end(whatever);\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the above example, if you sent a request with the following <code>accept</code> header:</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: application/json; q=0.7, text/html</p>\n</div>\n<div class=\"paragraph\">\n<p>Then the route would match and <code>acceptableContentType</code> would contain <code>text/html</code> as both are\nacceptable but that has a higher <code>q</code> value.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_based_on_virtualhost\"><a class=\"anchor\" href=\"#_routing_based_on_virtualhost\"></a>Routing based on VirtualHost</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can configure that a <code>Route</code> will match against the request hostname.</p>\n</div>\n<div class=\"paragraph\">\n<p>Request are checked against the <code>Host</code> header to a match and patterns allow the usage of <code><strong></code> wildcards, as for\nexample <code></strong>.vertx.io</code> or fully domain names as <code>www.vertx.io</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().virtualHost(<span class=\"hljs-string\">\"*.vertx.io\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do something if the request is for *.vertx.io</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_combining_routing_criteria\"><a class=\"anchor\" href=\"#_combining_routing_criteria\"></a>Combining routing criteria</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can combine all the above routing criteria in many different ways, for example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(HttpMethod.PUT, <span class=\"hljs-string\">\"myapi/orders\"</span>)\n  .consumes(<span class=\"hljs-string\">\"application/json\"</span>)\n  .produces(<span class=\"hljs-string\">\"application/json\"</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// This would be match for any PUT method to paths starting</span>\n    <span class=\"hljs-comment\">// with \"myapi/orders\" with a content-type of \"application/json\"</span>\n    <span class=\"hljs-comment\">// and an accept header matching \"application/json\"</span>\n\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_enabling_and_disabling_routes\"><a class=\"anchor\" href=\"#_enabling_and_disabling_routes\"></a>Enabling and disabling routes</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can disable a route with <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#disable--\">disable</a></code>. A disabled route will be ignored when matching.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can re-enable a disabled route with <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#enable--\">enable</a></code></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_forward_support\"><a class=\"anchor\" href=\"#_forward_support\"></a>Forward Support</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Your application may be behind a proxy server, <code>HAProxy</code> for example. When working under this setup accessing the\nclient connection details will not properly return the expected results. For example the client host ip address will\nbe the proxy server ip address, not the client&#8217;s one.</p>\n</div>\n<div class=\"paragraph\">\n<p>In order to get the right connection information, a special header <code>Forward</code> has been standardized to include the right\ninformation. However this standard is not very old, so many proxies out there have been using other headers that usually\nstart with the prefix: <code>X-Forward</code>. Vert.x web allows the usage and parsing of these headers but not by default.</p>\n</div>\n<div class=\"paragraph\">\n<p>The reason why these headers are disabled by default is to prevent malicious applications to forge their origin and hide\nwhere they are really coming from.</p>\n</div>\n<div class=\"paragraph\">\n<p>As previously mentioned forward is disabled by default, to enable you should use:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.allowForward(AllowForwardHeaders.FORWARD);\n\n<span class=\"hljs-comment\">// we can now allow forward header parsing</span>\n<span class=\"hljs-comment\">// and in this case only the \"X-Forward\" headers will be considered</span>\nrouter.allowForward(AllowForwardHeaders.X_FORWARD);\n\n<span class=\"hljs-comment\">// we can now allow forward header parsing</span>\n<span class=\"hljs-comment\">// and in this case both the \"Forward\" header and \"X-Forward\" headers</span>\n<span class=\"hljs-comment\">// will be considered, yet the values from \"Forward\" take precedence</span>\n<span class=\"hljs-comment\">// this means if case of a conflict (2 headers for the same value)</span>\n<span class=\"hljs-comment\">// the \"Forward\" value will be taken and the \"X-Forward\" ignored.</span>\nrouter.allowForward(AllowForwardHeaders.ALL);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Same rule applies to explicitly disable the parsing of the headers:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.allowForward(AllowForwardHeaders.NONE);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>To read more about the format of the header format, please consult:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://tools.ietf.org/html/rfc7239#section-4\" class=\"bare\">https://tools.ietf.org/html/rfc7239#section-4</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded\" class=\"bare\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Behind the scenes, what this feature does is changing the following values of your connection (either HTTP or WebSocket):</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>protocol</p>\n</li>\n<li>\n<p>host name</p>\n</li>\n<li>\n<p>host port</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_context_data\"><a class=\"anchor\" href=\"#_context_data\"></a>Context data</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can use the context data in the <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> to maintain any data that you\nwant to share between handlers for the lifetime of the request.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example where one handler sets some data in the context data and a subsequent handler retrieves it:</p>\n</div>\n<div class=\"paragraph\">\n<p>You can use the <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#put-java.lang.String-java.lang.Object-\">put</a></code> to put any object, and\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#get-java.lang.String-\">get</a></code> to retrieve any object from the context data.</p>\n</div>\n<div class=\"paragraph\">\n<p>A request sent to path <code>/some/path/other</code> will match both routes.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">\"/some/path\"</span>).handler(ctx -&gt; {\n\n  ctx.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>);\n  ctx.next();\n\n});\n\nrouter.get(<span class=\"hljs-string\">\"/some/path/other\"</span>).handler(ctx -&gt; {\n\n  String bar = ctx.get(<span class=\"hljs-string\">\"foo\"</span>);\n  <span class=\"hljs-comment\">// Do something with bar</span>\n  ctx.response().end();\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Alternatively you can access the entire context data map with <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#data--\">data</a></code>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_helper_functions\"><a class=\"anchor\" href=\"#_helper_functions\"></a>Helper functions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>While the routing context will allow you to access the underlying request and response objects, sometimes it will be\nmore productive if a few shortcuts would be present to help with common tasks. A few helpers are present in the context\nto facilitate with this task.</p>\n</div>\n<div class=\"paragraph\">\n<p>Serve an \"attachment\", an attachment is a response that will trigger the browser to open the response on the OS\napplication configured to handle a specific mime type. Imagine you&#8217;re generating a PDF:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx\n  .attachment(<span class=\"hljs-string\">\"weekly-report.pdf\"</span>)\n  .end(pdfBuffer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Perform a redirect to a different page or host. One example is to redirect to an HTTPS variant of the application:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.redirect(<span class=\"hljs-string\">\"https://securesite.com/\"</span>);\n\n<span class=\"hljs-comment\">// there is a special handling for the target \"back\".</span>\n<span class=\"hljs-comment\">// In this case the redirect would send the user to the</span>\n<span class=\"hljs-comment\">// referrer url or \"/\" if there's no referrer.</span>\n\nctx.redirect(<span class=\"hljs-string\">\"back\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Send a JSON response to the client:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.json(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"vert.x\"</span>));\n<span class=\"hljs-comment\">// also applies to arrays</span>\nctx.json(<span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">\"vertx\"</span>).add(<span class=\"hljs-string\">\"web\"</span>));\n<span class=\"hljs-comment\">// or any object that will be converted according</span>\n<span class=\"hljs-comment\">// to the json encoder available at runtime.</span>\nctx.json(someObject);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Simple content type check:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.is(<span class=\"hljs-string\">\"html\"</span>); <span class=\"hljs-comment\">// =&gt; true</span>\nctx.is(<span class=\"hljs-string\">\"text/html\"</span>); <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// When Content-Type is application/json</span>\nctx.is(<span class=\"hljs-string\">\"application/json\"</span>); <span class=\"hljs-comment\">// =&gt; true</span>\nctx.is(<span class=\"hljs-string\">\"html\"</span>); <span class=\"hljs-comment\">// =&gt; false</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Verify if a request is \"fresh\" with respect to the cache headers and the current values of last modified/ etag.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.lastModified(<span class=\"hljs-string\">\"Wed, 13 Jul 2011 18:30:00 GMT\"</span>);\n<span class=\"hljs-comment\">// this will now be used to verify the freshness of the request</span>\n<span class=\"hljs-keyword\">if</span> (ctx.isFresh()) {\n  <span class=\"hljs-comment\">// client cache value is fresh perhaps we</span>\n  <span class=\"hljs-comment\">// can stop and return 304?</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And a few other simple self explanatory shortcuts:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.etag(<span class=\"hljs-string\">\"W/123456789\"</span>);\n\n<span class=\"hljs-comment\">// set the last modified value</span>\nctx.lastModified(<span class=\"hljs-string\">\"Wed, 13 Jul 2011 18:30:00 GMT\"</span>);\n\n<span class=\"hljs-comment\">// quickly end</span>\nctx.end();\nctx.end(<span class=\"hljs-string\">\"body\"</span>);\nctx.end(buffer);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reroute\"><a class=\"anchor\" href=\"#_reroute\"></a>Reroute</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Until now all routing mechanism allow you to handle your requests in a sequential way, however there might be times\nwhere you will want to go back. Since the context does not expose any information about the previous or next handler,\nmostly because this information is dynamic there is a way to restart the whole routing from the start of the current\nRouter.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">\"/some/path\"</span>).handler(ctx -&gt; {\n\n  ctx.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>);\n  ctx.next();\n\n});\n\nrouter\n  .get(<span class=\"hljs-string\">\"/some/path/B\"</span>)\n  .handler(ctx -&gt; ctx.response().end());\n\nrouter\n  .get(<span class=\"hljs-string\">\"/some/path\"</span>)\n  .handler(ctx -&gt; ctx.reroute(<span class=\"hljs-string\">\"/some/path/B\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>So from the code you can see that if a request arrives at <code>/some/path</code> if first add a value to the context, then\nmoves to the next handler that re routes the request to <code>/some/path/B</code> which terminates the request.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can reroute based on a new path or based on a new path and method. Note however that rerouting based on method\nmight introduce security issues since for example a usually safe GET request can become a DELETE.</p>\n</div>\n<div class=\"paragraph\">\n<p>Reroute is also allowed on the failure handler, however due to the nature of re router when called the current status\ncode and failure reason are reset. In order the rerouted handler should generate the correct status code if needed,\nfor example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">\"/my-pretty-notfound-handler\"</span>).handler(ctx -&gt; ctx.response()\n  .setStatusCode(<span class=\"hljs-number\">404</span>)\n  .end(<span class=\"hljs-string\">\"NOT FOUND fancy html here!!!\"</span>));\n\nrouter.get().failureHandler(ctx -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ctx.statusCode() == <span class=\"hljs-number\">404</span>) {\n    ctx.reroute(<span class=\"hljs-string\">\"/my-pretty-notfound-handler\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    ctx.next();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It should be clear that reroute works on <code>paths</code>, so if you need to preserve and or add state across reroutes, one\nshould use the <code>RoutingContext</code> object. For example you want to reroute to a new path with a extra parameter:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">\"/final-target\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// continue from here...</span>\n});\n\n<span class=\"hljs-comment\">// (Will reroute to /final-target including the query string)</span>\nrouter.get().handler(ctx -&gt; ctx.reroute(<span class=\"hljs-string\">\"/final-target?variable=value\"</span>));\n\n<span class=\"hljs-comment\">// A safer way would be to add the variable to the context</span>\nrouter.get().handler(ctx -&gt; ctx\n  .put(<span class=\"hljs-string\">\"variable\"</span>, <span class=\"hljs-string\">\"value\"</span>)\n  .reroute(<span class=\"hljs-string\">\"/final-target\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Reroute will re-parse the query params too. Be aware that previously query params will be discarded. The method\nwill also silently discard and ignore any html fragment from the path. This is to keep the semantics of reroute\nconsistent between a regular request and a re route.</p>\n</div>\n<div class=\"paragraph\">\n<p>If more information is required to be passed to the new request, it should use the context that is preserved all the\nlifetime of the HTTP transaction.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sub_routers\"><a class=\"anchor\" href=\"#_sub_routers\"></a>Sub-routers</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Sometimes if you have a lot of handlers it can make sense to split them up into multiple routers. This is also useful\nif you want to reuse a set of handlers in a different application, rooted at a different path root.</p>\n</div>\n<div class=\"paragraph\">\n<p>To do this you can mount a router at a <em>mount point</em> in another router. The router that is mounted is called a\n<em>sub-router</em>. Sub routers can mount other sub routers so you can have several levels of sub-routers if you like.</p>\n</div>\n<div class=\"paragraph\">\n<p>Let&#8217;s look at a simple example of a sub-router mounted with another router.</p>\n</div>\n<div class=\"paragraph\">\n<p>This sub-router will maintain the set of handlers that corresponds to a simple fictional REST API. We will mount that on another\nrouter. The full implementation of the REST API is not shown.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s the sub-router:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router restAPI = Router.router(vertx);\n\nrestAPI.get(<span class=\"hljs-string\">\"/products/:productID\"</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// TODO Handle the lookup of the product....</span>\n  ctx.response().write(productJSON);\n\n});\n\nrestAPI.put(<span class=\"hljs-string\">\"/products/:productID\"</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// TODO Add a new product...</span>\n  ctx.response().end();\n\n});\n\nrestAPI.delete(<span class=\"hljs-string\">\"/products/:productID\"</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// TODO delete the product...</span>\n  ctx.response().end();\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If this router was used as a top level router, then GET/PUT/DELETE requests to urls like <code>/products/product1234</code>\nwould invoke the  API.</p>\n</div>\n<div class=\"paragraph\">\n<p>However, let&#8217;s say we already have a web-site as described by another router:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router mainRouter = Router.router(vertx);\n\n<span class=\"hljs-comment\">// Handle static resources</span>\nmainRouter.route(<span class=\"hljs-string\">\"/static/*\"</span>).handler(myStaticHandler);\n\nmainRouter.route(<span class=\"hljs-string\">\".*\\\\.templ\"</span>).handler(myTemplateHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>We can now mount the sub router on the main router, against a mount point, in this case <code>/productsAPI</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mainRouter.mountSubRouter(<span class=\"hljs-string\">\"/productsAPI\"</span>, restAPI);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This means the REST API is now accessible via paths like: <code>/productsAPI/products/product1234</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>There are a couple of rules that must be fulfilled before sub routers can be used:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>The route path must end with a wild card</p>\n</li>\n<li>\n<p>Parameters are allowed but full regex patterns not</p>\n</li>\n<li>\n<p>Only 1 handler can be registered before or after this call (but they can on a new route object for the same path)</p>\n</li>\n<li>\n<p>Only 1 router per path object</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Validation happens at the time the router is added to the http server. This means that you cannot get any validation\nerror during the build time because of the dynamic nature of sub routers. They depend on the context to be validated.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_localization\"><a class=\"anchor\" href=\"#_localization\"></a>Localization</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web parses the <code>Accept-Language</code> header and provides some helper methods to identify which is the preferred\nlocale for a client or the sorted list of preferred locales by quality.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.get(<span class=\"hljs-string\">\"/localized\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// although it might seem strange by running a loop with a switch we</span>\n  <span class=\"hljs-comment\">// make sure that the locale order of preference is preserved when</span>\n  <span class=\"hljs-comment\">// replying in the users language.</span>\n  <span class=\"hljs-keyword\">for</span> (LanguageHeader language : ctx.acceptableLanguages()) {\n    <span class=\"hljs-keyword\">switch</span> (language.tag()) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"en\"</span>:\n        ctx.response().end(<span class=\"hljs-string\">\"Hello!\"</span>);\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"fr\"</span>:\n        ctx.response().end(<span class=\"hljs-string\">\"Bonjour!\"</span>);\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"pt\"</span>:\n        ctx.response().end(<span class=\"hljs-string\">\"Olá!\"</span>);\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"es\"</span>:\n        ctx.response().end(<span class=\"hljs-string\">\"Hola!\"</span>);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n  }\n  <span class=\"hljs-comment\">// we do not know the user language so lets just inform that back:</span>\n  ctx.response().end(<span class=\"hljs-string\">\"Sorry we don't speak: \"</span> + ctx.preferredLanguage());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The main method <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#acceptableLanguages--\">acceptableLanguages</a></code> will return the ordered list of locales the\nuser understands, if you&#8217;re only interested in the user prefered locale then the helper:\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#preferredLanguage--\">preferredLanguage</a></code> will return the 1st element of the list or <code>null</code> if no\nlocale was provided by the user.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_route_match_failures\"><a class=\"anchor\" href=\"#_route_match_failures\"></a>Route match failures</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>If no routes match for any particular request, Vert.x-Web will signal an error depending on match failure:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>404 If no route matches the path</p>\n</li>\n<li>\n<p>405 If a route matches the path but don&#8217;t match the HTTP Method</p>\n</li>\n<li>\n<p>406 If a route matches the path and the method but It can&#8217;t provide a response with a content type matching <code>Accept</code> header</p>\n</li>\n<li>\n<p>415 If a route matches the path and the method but It can&#8217;t accept the <code>Content-type</code></p>\n</li>\n<li>\n<p>400 If a route matches the path and the method but It can&#8217;t accept an empty body</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>You can manually manage those failures using <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_error_handling\"><a class=\"anchor\" href=\"#_error_handling\"></a>Error handling</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>As well as setting handlers to handle requests you can also set handlers to handle failures in routing.</p>\n</div>\n<div class=\"paragraph\">\n<p>Failure handlers are used with the exact same route matching criteria that you use with normal handlers.</p>\n</div>\n<div class=\"paragraph\">\n<p>For example you can provide a failure handler that will only handle failures on certain paths, or for certain HTTP methods.</p>\n</div>\n<div class=\"paragraph\">\n<p>This allows you to set different failure handlers for different parts of your application.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example failure handler that will only be called for failure that occur when routing to GET requests\nto paths that start with <code>/somepath/</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route = router.get(<span class=\"hljs-string\">\"/somepath/*\"</span>);\n\nroute.failureHandler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// This will be called for failures that occur</span>\n  <span class=\"hljs-comment\">// when routing requests to paths starting with</span>\n  <span class=\"hljs-comment\">// '/somepath/'</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Failure routing will occur if a handler throws an exception, or if a handler calls\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#fail-int-\">fail</a></code> specifying an HTTP status code to deliberately signal a failure.</p>\n</div>\n<div class=\"paragraph\">\n<p>If an exception is caught from a handler this will result in a failure with status code <code>500</code> being signalled.</p>\n</div>\n<div class=\"paragraph\">\n<p>When handling the failure, the failure handler is passed the routing context which also allows the failure or failure code\nto be retrieved so the failure handler can use that to generate a failure response.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Route route1 = router.get(<span class=\"hljs-string\">\"/somepath/path1/\"</span>);\n\nroute1.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// Let's say this throws a RuntimeException</span>\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">\"something happened!\"</span>);\n\n});\n\nRoute route2 = router.get(<span class=\"hljs-string\">\"/somepath/path2\"</span>);\n\nroute2.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// This one deliberately fails the request passing in the status code</span>\n  <span class=\"hljs-comment\">// E.g. 403 - Forbidden</span>\n  ctx.fail(<span class=\"hljs-number\">403</span>);\n\n});\n\n<span class=\"hljs-comment\">// Define a failure handler</span>\n<span class=\"hljs-comment\">// This will get called for any failures in the above handlers</span>\nRoute route3 = router.get(<span class=\"hljs-string\">\"/somepath/*\"</span>);\n\nroute3.failureHandler(failureRoutingContext -&gt; {\n\n  <span class=\"hljs-keyword\">int</span> statusCode = failureRoutingContext.statusCode();\n\n  <span class=\"hljs-comment\">// Status code will be 500 for the RuntimeException</span>\n  <span class=\"hljs-comment\">// or 403 for the other failure</span>\n  HttpServerResponse response = failureRoutingContext.response();\n  response.setStatusCode(statusCode).end(<span class=\"hljs-string\">\"Sorry! Not today\"</span>);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For the eventuality that an error occurs when running the error handler related usage of not allowed characters in\nstatus message header, then the original status message will be changed to the default message from the error code.\nThis is a tradeoff to keep the semantics of the HTTP protocol working instead of abruptly creash and close the socket\nwithout properly completing the protocol.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_request_body_handling\"><a class=\"anchor\" href=\"#_request_body_handling\"></a>Request body handling</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> allows you to retrieve request bodies, limit body sizes and handle\nfile uploads.</p>\n</div>\n<div class=\"paragraph\">\n<p>You should make sure a body handler is on a matching route for any requests that require this functionality.</p>\n</div>\n<div class=\"paragraph\">\n<p>The usage of this handler requires that it is installed as soon as possible in the router since it needs\nto install handlers to consume the HTTP request body and this must be done before executing any async call.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(BodyHandler.create());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If an async call is required before, the <code>HttpServerRequest</code> should be paused and then resumed so that the request\nevents are not delivered until the body handler is ready to process them.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(ctx -&gt; {\n\n  HttpServerRequest request = ctx.request();\n\n  <span class=\"hljs-comment\">// Pause the request</span>\n  request.pause();\n\n  someAsyncCall(result -&gt; {\n\n    <span class=\"hljs-comment\">// Resume the request</span>\n    request.resume();\n\n    <span class=\"hljs-comment\">// And continue processing</span>\n    ctx.next();\n  });\n});\n\n<span class=\"hljs-comment\">// This body handler will be called for all routes</span>\nrouter.route().handler(BodyHandler.create());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nUploads can be a source of DDoS attacks, in order to reduce the attack surface, it is recommended to\nset sensible limits on <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-\">setBodyLimit</a></code> (e.g.: 10mb for general uploads or\n100kb for JSON).\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_getting_the_request_body\"><a class=\"anchor\" href=\"#_getting_the_request_body\"></a>Getting the request body</h3>\n<div class=\"paragraph\">\n<p>If you know the request body is JSON, then you can use <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsJson-int-\">getBodyAsJson</a></code>,\nif you know it&#8217;s a string you can use <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsString--\">getBodyAsString</a></code>, or to\nretrieve it as a buffer use <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBody--\">getBody</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_limiting_body_size\"><a class=\"anchor\" href=\"#_limiting_body_size\"></a>Limiting body size</h3>\n<div class=\"paragraph\">\n<p>To limit the size of a request body, create the body handler then use <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-\">setBodyLimit</a></code>\nto specifying the maximum body size, in bytes. This is useful to avoid running out of memory with very large bodies.</p>\n</div>\n<div class=\"paragraph\">\n<p>If an attempt to send a body greater than the maximum size is made, an HTTP status code of 413 - <code>Request Entity Too Large</code>,\nwill be sent.</p>\n</div>\n<div class=\"paragraph\">\n<p>There is no body limit by default.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_merging_form_attributes\"><a class=\"anchor\" href=\"#_merging_form_attributes\"></a>Merging form attributes</h3>\n<div class=\"paragraph\">\n<p>By default, the body handler will merge any form attributes into the request parameters. If you don&#8217;t want this behaviour\nyou can use disable it with <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setMergeFormAttributes-boolean-\">setMergeFormAttributes</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_file_uploads\"><a class=\"anchor\" href=\"#_handling_file_uploads\"></a>Handling file uploads</h3>\n<div class=\"paragraph\">\n<p>Body handler is also used to handle multi-part file uploads.</p>\n</div>\n<div class=\"paragraph\">\n<p>If a body handler is on a matching route for the request, any file uploads will be automatically streamed to the\nuploads directory, which is <code>file-uploads</code> by default.</p>\n</div>\n<div class=\"paragraph\">\n<p>Each file will be given an automatically generated file name, and the file uploads will be available on the routing\ncontext with <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#fileUploads--\">fileUploads</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(BodyHandler.create());\n\nrouter.post(<span class=\"hljs-string\">\"/some/path/uploads\"</span>).handler(ctx -&gt; {\n\n  Set&lt;FileUpload&gt; uploads = ctx.fileUploads();\n  <span class=\"hljs-comment\">// Do something with uploads....</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Each file upload is described by a <code><a href=\"../../apidocs/io/vertx/ext/web/FileUpload.html\">FileUpload</a></code> instance, which allows various properties\nsuch as the name, file-name and size to be accessed.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_cookies\"><a class=\"anchor\" href=\"#_handling_cookies\"></a>Handling cookies</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web has out of the box cookies support.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_manipulating_cookies\"><a class=\"anchor\" href=\"#_manipulating_cookies\"></a>Manipulating cookies</h3>\n<div class=\"paragraph\">\n<p>You use <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getCookie-java.lang.String-\">getCookie</a></code> to retrieve\na cookie by name, or use <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#cookieMap--\">cookieMap</a></code> to retrieve the entire set.</p>\n</div>\n<div class=\"paragraph\">\n<p>To remove a cookie, use <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#removeCookie-java.lang.String-\">removeCookie</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To add a cookie use <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#addCookie-io.vertx.core.http.Cookie-\">addCookie</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The set of cookies will be written back in the response automatically when the response headers are written so the\nbrowser can store them.</p>\n</div>\n<div class=\"paragraph\">\n<p>Cookies are described by instances of <code><a href=\"../../apidocs/io/vertx/core/http/Cookie.html\">Cookie</a></code>. This allows you to retrieve the name,\nvalue, domain, path and other normal cookie properties.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example of querying and adding cookies:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Cookie someCookie = ctx.getCookie(<span class=\"hljs-string\">\"mycookie\"</span>);\nString cookieValue = someCookie.getValue();\n\n<span class=\"hljs-comment\">// Do something with cookie...</span>\n\n<span class=\"hljs-comment\">// Add a cookie - this will get written back in the response automatically</span>\nctx.addCookie(Cookie.cookie(<span class=\"hljs-string\">\"othercookie\"</span>, <span class=\"hljs-string\">\"somevalue\"</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_sessions\"><a class=\"anchor\" href=\"#_handling_sessions\"></a>Handling sessions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web provides out of the box support for sessions.</p>\n</div>\n<div class=\"paragraph\">\n<p>Sessions last between HTTP requests for the length of a browser session and give you a place where you can add\nsession-scope information, such as a shopping basket.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web uses session cookies to identify a session. The session cookie is temporary and will be deleted by your browser\nwhen it&#8217;s closed.</p>\n</div>\n<div class=\"paragraph\">\n<p>We don&#8217;t put the actual data of your session in the session cookie - the cookie simply uses an identifier to look-up\nthe actual session on the server. The identifier is a random UUID generated using a secure random, so it should\nbe effectively unguessable.</p>\n</div>\n<div class=\"paragraph\">\n<p>Cookies are passed across the wire in HTTP requests and responses so it&#8217;s always wise to make sure you are using\nHTTPS when sessions are being used. Vert.x will warn you if you attempt to use sessions over straight HTTP.</p>\n</div>\n<div class=\"paragraph\">\n<p>To enable sessions in your application you must have a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/SessionHandler.html\">SessionHandler</a></code>\non a matching route before your application logic.</p>\n</div>\n<div class=\"paragraph\">\n<p>The session handler handles the creation of session cookies and the lookup of the session so you don&#8217;t have to do\nthat yourself.</p>\n</div>\n<div class=\"paragraph\">\n<p>Sessions data is saved to a session store automatically after the response headers have been sent to the client.\nBut note that, with this mechanism, there is no guarantee the data is fully persisted before the client receives the response.\nThere are occasions though when this guarantee is needed.\nIn this case you can force a flush.\nThis will disable the automatic saving process, unless the flushing operation failed.\nThis allows to control the state before completing the response like:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ChainAuthHandler chain =\n  ChainAuthHandler.any()\n    .add(authNHandlerA)\n    .add(ChainAuthHandler.all()\n      .add(authNHandlerB)\n      .add(authNHandlerC));\n\n<span class=\"hljs-comment\">// secure your route</span>\nrouter.route(<span class=\"hljs-string\">\"/secure/resource\"</span>).handler(chain);\n<span class=\"hljs-comment\">// your app</span>\nrouter.route(<span class=\"hljs-string\">\"/secure/resource\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do something...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Session Handler state by default uses a cookie to store session ID. Session ID is a unique string, used to\nrecognize individual visitor between visits. But, if client&#8217;s web browser doesn&#8217;t support cookies or visitor has\ndisabled cookies in web browser&#8217;s settings, we can&#8217;t store session id on client&#8217;s machine. In this case, new session\nwill be created for every request. This behavior is useless because we can&#8217;t remember information for certain visitor\nbetween two requests. We can say that, by default, sessions can&#8217;t work if browser doesn&#8217;t support cookies.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web supports sessions without cookies, known as \"cookieless\" sessions. As an alternative, Vert.x Web can embed\nsession id inside of page URL. On this way, all page links will contain session id string. When visitor clicks on some\nof these links, it will read session id from page URL, so we don&#8217;t need cookies support to have functional sessions.</p>\n</div>\n<div class=\"paragraph\">\n<p>To enable cookieless sessions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .handler(SessionHandler.create(store).setCookieless(<span class=\"hljs-keyword\">true</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is important to know that in this mode the session ID should be passed by the application to the end user, usually by\nrendering it on the HTML page or script. There are some important rules. The session id is identified by the following\npattern on the path <code>/optional/path/prefix/'('sessionId')'/path/suffix</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>As an example, given the path: <code><a href=\"http://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/\" class=\"bare\">http://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/</a></code> the session Id will\nbe: <code>3abhbgwjg33aqrt3uat2kh4d</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Main security problem when working with sessions is a possibility that malicious user will find out others' session id.\nIf two users share same session id, they share same session variables too and website is considering them as one\nvisitor. This could be a security risk if session is used for any private or sensitive data, or to allow access to\nrestricted areas of web site. When cookies are used, session id can be protected using SSL and by marking a cookie as\nsecure. But, in case of cookieless session, session id is part of URL and is much more vulnerable.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_session_stores\"><a class=\"anchor\" href=\"#_session_stores\"></a>Session stores</h3>\n<div class=\"paragraph\">\n<p>To create a session handler you need to have a session store instance. The session store is the object that\nholds the actual sessions for your application.</p>\n</div>\n<div class=\"paragraph\">\n<p>The session store is responsible for holding a secure pseudo random number generator in order to guarantee secure session\nids. This PRNG is independent of the store which means that given a session id from store A one cannot derive the\nsession id of store B since they have different seeds and states.</p>\n</div>\n<div class=\"paragraph\">\n<p>By default this PRNG uses a mixed mode, blocking for seeding, non blocking for generating. The PRNG will also reseed\nevery 5 minutes with 64bits of new entropy. However this can all be configured using the system properties:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>io.vertx.ext.auth.prng.algorithm e.g.: SHA1PRNG</p>\n</li>\n<li>\n<p>io.vertx.ext.auth.prng.seed.interval e.g.: 1000 (every second)</p>\n</li>\n<li>\n<p>io.vertx.ext.auth.prng.seed.bits e.g.: 128</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Most users should not need to configure these values unless if you notice that the performance of your application is\nbeing affected by the PRNG algorithm.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web comes with two session store implementations out of the box, and you can also write your own if you prefer.</p>\n</div>\n<div class=\"paragraph\">\n<p>The implementations are expected to follow the <code>ServiceLoader</code> conventions and all stores that are available at runtime\nfrom the classpath will be exposed. When more than 1 implementations are available the first one that can be\ninstantiated and configured with success becomes the default. If none is available, then the default depends on the mode\nVert.x was created. If cluster mode is available the the clustered session store is the default otherwise the local\nstorage is the default.</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_local_session_store\"><a class=\"anchor\" href=\"#_local_session_store\"></a>Local session store</h4>\n<div class=\"paragraph\">\n<p>With this store, sessions are stored locally in memory and only available in this instance.</p>\n</div>\n<div class=\"paragraph\">\n<p>This store is appropriate if you have just a single Vert.x instance of you are using sticky sessions in your application\nand have configured your load balancer to always route HTTP requests to the same Vert.x instance.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you can&#8217;t ensure your requests will all terminate on the same server then don&#8217;t use this store as your\nrequests might end up on a server which doesn&#8217;t know about your session.</p>\n</div>\n<div class=\"paragraph\">\n<p>Local session stores are implemented by using a shared local map, and have a reaper which clears out expired sessions.</p>\n</div>\n<div class=\"paragraph\">\n<p>The reaper interval can be configured with a json message with the key: <code>reaperInterval</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here are some examples of creating a local <code><a href=\"../../apidocs/io/vertx/ext/web/sstore/SessionStore.html\">SessionStore</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SessionStore store1 = LocalSessionStore.create(vertx);\n\n<span class=\"hljs-comment\">// Create a local session store specifying the local shared map name to use</span>\n<span class=\"hljs-comment\">// This might be useful if you have more than one application in the same</span>\n<span class=\"hljs-comment\">// Vert.x instance and want to use different maps for different applications</span>\nSessionStore store2 = LocalSessionStore.create(\n  vertx,\n  <span class=\"hljs-string\">\"myapp3.sessionmap\"</span>);\n\n<span class=\"hljs-comment\">// Create a local session store specifying the local shared map name to use and</span>\n<span class=\"hljs-comment\">// setting the reaper interval for expired sessions to 10 seconds</span>\nSessionStore store3 = LocalSessionStore.create(\n  vertx,\n  <span class=\"hljs-string\">\"myapp3.sessionmap\"</span>,\n  <span class=\"hljs-number\">10000</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_clustered_session_store\"><a class=\"anchor\" href=\"#_clustered_session_store\"></a>Clustered session store</h4>\n<div class=\"paragraph\">\n<p>With this store, sessions are stored in a distributed map which is accessible across the Vert.x cluster.</p>\n</div>\n<div class=\"paragraph\">\n<p>This store is appropriate if you&#8217;re <em>not</em> using sticky sessions, i.e. your load balancer is distributing different\nrequests from the same browser to different servers.</p>\n</div>\n<div class=\"paragraph\">\n<p>Your session is accessible from any node in the cluster using this store.</p>\n</div>\n<div class=\"paragraph\">\n<p>To you use a clustered session store you should make sure your Vert.x instance is clustered.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here are some examples of creating a clustered <code><a href=\"../../apidocs/io/vertx/ext/web/sstore/SessionStore.html\">SessionStore</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx.clusteredVertx(<span class=\"hljs-keyword\">new</span> VertxOptions(), res -&gt; {\n\n  Vertx vertx = res.result();\n\n  <span class=\"hljs-comment\">// Create a clustered session store using defaults</span>\n  SessionStore store1 = ClusteredSessionStore.create(vertx);\n\n  <span class=\"hljs-comment\">// Create a clustered session store specifying the distributed map name to use</span>\n  <span class=\"hljs-comment\">// This might be useful if you have more than one application in the cluster</span>\n  <span class=\"hljs-comment\">// and want to use different maps for different applications</span>\n  SessionStore store2 = ClusteredSessionStore.create(\n    vertx,\n    <span class=\"hljs-string\">\"myclusteredapp3.sessionmap\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_other_stores\"><a class=\"anchor\" href=\"#_other_stores\"></a>Other stores</h4>\n<div class=\"paragraph\">\n<p>Other stores are also available, these stores can be used by importing the correct jar\nto the project. One example of such stores is the cookie store. This store has the advantage\nthat it requires no backend or server side state, which can be useful it some situations\n<strong>BUT</strong> all session data will be sent back to the client in the Cookie, so if you need to store\nprivate information this should not be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>This store is appropriate if you&#8217;re using sticky sessions, i.e. your load balancer is\ndistributing different requests from the same browser to different servers.</p>\n</div>\n<div class=\"paragraph\">\n<p>As the session is stored in the Cookie, this means sessions survive server crashes too.</p>\n</div>\n<div class=\"paragraph\">\n<p>A second known implementation is the Redis session store. This store works just like the normal cluster store, however\njust like it&#8217;s name suggests, it uses a redis backend to keep the session data centralized.</p>\n</div>\n<div class=\"paragraph\">\n<p>These stores are available with the coordinates:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>groupId: <code>io.vertx</code></p>\n</li>\n<li>\n<p>artifactId: <code>vertx-web-sstore-{cookie|redis}</code></p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_the_session_handler\"><a class=\"anchor\" href=\"#_creating_the_session_handler\"></a>Creating the session handler</h3>\n<div class=\"paragraph\">\n<p>Once you&#8217;ve created a session store you can create a session handler, and add it to a route. You should make sure\nyour session handler is routed to before your application handlers.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\n<span class=\"hljs-comment\">// Create a clustered session store using defaults</span>\nSessionStore store = ClusteredSessionStore.create(vertx);\n\nSessionHandler sessionHandler = SessionHandler.create(store);\n\n<span class=\"hljs-comment\">// the session handler controls the cookie used for the session</span>\n<span class=\"hljs-comment\">// this includes configuring, for example, the same site policy</span>\n<span class=\"hljs-comment\">// like this, for strict same site policy.</span>\nsessionHandler.setCookieSameSite(CookieSameSite.STRICT);\n\n<span class=\"hljs-comment\">// Make sure all requests are routed through the session handler too</span>\nrouter.route().handler(sessionHandler);\n\n<span class=\"hljs-comment\">// Now your application handlers</span>\nrouter.route(<span class=\"hljs-string\">\"/somepath/blah/\"</span>).handler(ctx -&gt; {\n\n  Session session = ctx.session();\n  session.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>);\n  <span class=\"hljs-comment\">// etc</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The session handler will ensure that your session is automatically looked up (or created if no session exists)\nfrom the session store and set on the routing context before it gets to your application handlers.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_the_session\"><a class=\"anchor\" href=\"#_using_the_session\"></a>Using the session</h3>\n<div class=\"paragraph\">\n<p>In your handlers you can access the session instance with <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#session--\">session</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You put data into the session with <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#put-java.lang.String-java.lang.Object-\">put</a></code>,\nyou get data from the session with <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#get-java.lang.String-\">get</a></code>, and you remove\ndata from the session with <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#remove-java.lang.String-\">remove</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The keys for items in the session are always strings. The values can be any type for a local session store, and for\na clustered session store they can be any basic type, or <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code>, <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code>,\n<code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> or a serializable object, as the values have to serialized across the cluster.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example of manipulating session data:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(sessionHandler);\n\n<span class=\"hljs-comment\">// Now your application handlers</span>\nrouter.route(<span class=\"hljs-string\">\"/somepath/blah\"</span>).handler(ctx -&gt; {\n\n  Session session = ctx.session();\n\n  <span class=\"hljs-comment\">// Put some data from the session</span>\n  session.put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>);\n\n  <span class=\"hljs-comment\">// Retrieve some data from a session</span>\n  <span class=\"hljs-keyword\">int</span> age = session.get(<span class=\"hljs-string\">\"age\"</span>);\n\n  <span class=\"hljs-comment\">// Remove some data from a session</span>\n  JsonObject obj = session.remove(<span class=\"hljs-string\">\"myobj\"</span>);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Sessions are automatically written back to the store after after responses are complete.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can manually destroy a session using <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#destroy--\">destroy</a></code>. This will remove the session\nfrom the context and the session store. Note that if there is no session a new one will be automatically created\nfor the next request from the browser that&#8217;s routed through the session handler.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_session_timeout\"><a class=\"anchor\" href=\"#_session_timeout\"></a>Session timeout</h3>\n<div class=\"paragraph\">\n<p>Sessions will be automatically timed out if they are not accessed for a time greater than the timeout period. When\na session is timed out, it is removed from the store.</p>\n</div>\n<div class=\"paragraph\">\n<p>Sessions are automatically marked as accessed when a request arrives and the session is looked up and and when the\nresponse is complete and the session is stored back in the store.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also use <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#setAccessed--\">setAccessed</a></code> to manually mark a session as accessed.</p>\n</div>\n<div class=\"paragraph\">\n<p>The session timeout can be configured when creating the session handler. Default timeout is 30 minutes.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authentication_authorization\"><a class=\"anchor\" href=\"#_authentication_authorization\"></a>Authentication / authorization</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x comes with some out-of-the-box handlers for handling both authentication and authorization. In vert.x web\nthe meanings for the 2 words are:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><strong>Authentication</strong> - Tells who the user is</p>\n</li>\n<li>\n<p><strong>Authorization</strong> - Tells what the user is allowed to do</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>While <strong>Authentication</strong> is tightened to a well known protocol, e.g.:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>HTTP Basic Authentication</p>\n</li>\n<li>\n<p>HTTP Digest Authentication</p>\n</li>\n<li>\n<p>OAuth2 Authentication</p>\n</li>\n<li>\n<p>&#8230;&#8203;</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><strong>Authorization</strong> in vert.x is quite generic and can be used regardless of the prior. Yet it is also possible and a valid\nuse case to use the same provider module for both cases.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_an_authentication_handler\"><a class=\"anchor\" href=\"#_creating_an_authentication_handler\"></a>Creating an Authentication handler</h3>\n<div class=\"paragraph\">\n<p>To create an auth handler you need an instance of <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code>.\nAuthentication provider is used for authentication of users. Vert.x provides several authentication provider instances\nout of the box in the vertx-auth project. For full information on auth providers and how to use and configure them\nplease consult the auth documentation.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s a simple example of creating a basic auth handler given an auth provider.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\nAuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_authentication_in_your_application\"><a class=\"anchor\" href=\"#_handling_authentication_in_your_application\"></a>Handling authentication in your application</h3>\n<div class=\"paragraph\">\n<p>Let&#8217;s say you want all requests to paths that start with <code>/private/</code> to be subject to authentication. To do that you\nmake sure your authentication handler is before your application handlers on those paths:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\nAuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);\n\n<span class=\"hljs-comment\">// All requests to paths starting with '/private/' will be protected</span>\nrouter.route(<span class=\"hljs-string\">\"/private/*\"</span>).handler(basicAuthHandler);\n\nrouter.route(<span class=\"hljs-string\">\"/someotherpath\"</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// This will be public access - no login required</span>\n\n});\n\nrouter.route(<span class=\"hljs-string\">\"/private/somepath\"</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// This will require a login</span>\n\n  <span class=\"hljs-comment\">// This will have the value true</span>\n  <span class=\"hljs-keyword\">boolean</span> isAuthenticated = ctx.user() != <span class=\"hljs-keyword\">null</span>;\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If the authentication handler has successfully authenticated the user it will inject a <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html\">User</a></code>\nobject into the <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> so it&#8217;s available in your handlers with:\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#user--\">user</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want your User object to be stored in the session so it&#8217;s available between requests so you don&#8217;t have to\nauthenticate on each request, then you should make sure you have a session handler before the authentication handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Once you have your user object you can also programmatically use the methods on it to authorize the user.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want to cause the user to be logged out you can call <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#clearUser--\">clearUser</a></code>\non the routing context.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_basic_authentication\"><a class=\"anchor\" href=\"#_http_basic_authentication\"></a>HTTP Basic Authentication</h3>\n<div class=\"paragraph\">\n<p><a href=\"http://en.wikipedia.org/wiki/Basic_access_authentication\">HTTP Basic Authentication</a> is a simple means of authentication\nthat can be appropriate for simple applications.</p>\n</div>\n<div class=\"paragraph\">\n<p>With basic authentication, credentials are sent unencrypted across the wire in HTTP headers so it&#8217;s essential that you\nserve your application using HTTPS not HTTP.</p>\n</div>\n<div class=\"paragraph\">\n<p>With basic authentication, if a user requests a resource that requires authentication, the basic auth handler will send\nback a <code>401</code> response with the header <code>WWW-Authenticate</code> set. This prompts the browser to show a log-in dialogue and\nprompt the user to enter their username and password.</p>\n</div>\n<div class=\"paragraph\">\n<p>The request is made to the resource again, this time with the <code>Authorization</code> header set, containing the username\nand password encoded in Base64.</p>\n</div>\n<div class=\"paragraph\">\n<p>When the basic auth handler receives this information, it calls the configured <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code>\nwith the username and password to authenticate the user. If the authentication is successful then the routing of the\nrequest is allowed to continue to the application handlers, otherwise a <code>403</code> response is returned to signify that\naccess is denied.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_redirect_authentication_handler\"><a class=\"anchor\" href=\"#_redirect_authentication_handler\"></a>Redirect authentication handler</h3>\n<div class=\"paragraph\">\n<p>With redirect authentication handling the user is redirected to towards a login page in the case they are trying to\naccess a protected resource and they are not logged in.</p>\n</div>\n<div class=\"paragraph\">\n<p>The user then fills in the login form and submits it. This is handled by the server which authenticates\nthe user and, if authenticated redirects the user back to the original resource.</p>\n</div>\n<div class=\"paragraph\">\n<p>To use redirect auth you configure an instance of <code><a href=\"../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html\">RedirectAuthHandler</a></code> instead of a\nbasic authentication handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>You will also need to setup handlers to serve your actual login page, and a handler to handle the actual login itself.\nTo handle the login we provide a prebuilt handler <code><a href=\"../../apidocs/io/vertx/ext/web/handler/FormLoginHandler.html\">FormLoginHandler</a></code> for the purpose.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example of a simple app, using a redirect auth handler on the default redirect url <code>/loginpage</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\n<span class=\"hljs-comment\">// All requests to paths starting with '/private/' will be protected</span>\nrouter\n  .route(<span class=\"hljs-string\">\"/private/*\"</span>)\n  .handler(RedirectAuthHandler.create(authProvider));\n\n<span class=\"hljs-comment\">// Handle the actual login</span>\n<span class=\"hljs-comment\">// One of your pages must POST form login data</span>\nrouter.post(<span class=\"hljs-string\">\"/login\"</span>).handler(FormLoginHandler.create(authProvider));\n\n<span class=\"hljs-comment\">// Set a static server to serve static resources, e.g. the login page</span>\nrouter.route().handler(StaticHandler.create());\n\nrouter\n  .route(<span class=\"hljs-string\">\"/someotherpath\"</span>)\n  .handler(ctx -&gt; {\n    <span class=\"hljs-comment\">// This will be public access - no login required</span>\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">\"/private/somepath\"</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// This will require a login</span>\n\n    <span class=\"hljs-comment\">// This will have the value true</span>\n    <span class=\"hljs-keyword\">boolean</span> isAuthenticated = ctx.user() != <span class=\"hljs-keyword\">null</span>;\n\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_jwt_authentication\"><a class=\"anchor\" href=\"#_jwt_authentication\"></a>JWT authentication</h3>\n<div class=\"paragraph\">\n<p>With JWT authentication resources can be protected by means of permissions and users without enough rights are denied\naccess. You need to add the <code>io.vertx:vertx-auth-jwt:4.0.2</code> dependency to use <code>JWTAuthProvider</code></p>\n</div>\n<div class=\"paragraph\">\n<p>To use this handler there are 2 steps involved:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Setup an handler to issue tokens (or rely on a 3rd party)</p>\n</li>\n<li>\n<p>Setup the handler to filter the requests</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Please note that these 2 handlers should be only available on HTTPS, not doing so allows sniffing the tokens in\ntransit which leads to session hijacking attacks.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example on how to issue tokens:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\nJWTAuthOptions authConfig = <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> KeyStoreOptions()\n    .setType(<span class=\"hljs-string\">\"jceks\"</span>)\n    .setPath(<span class=\"hljs-string\">\"keystore.jceks\"</span>)\n    .setPassword(<span class=\"hljs-string\">\"secret\"</span>));\n\nJWTAuth jwt = JWTAuth.create(vertx, authConfig);\n\nrouter.route(<span class=\"hljs-string\">\"/login\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// this is an example, authentication should be done with another provider...</span>\n  <span class=\"hljs-keyword\">if</span> (\n    <span class=\"hljs-string\">\"paulo\"</span>.equals(ctx.request().getParam(<span class=\"hljs-string\">\"username\"</span>)) &amp;&amp;\n      <span class=\"hljs-string\">\"secret\"</span>.equals(ctx.request().getParam(<span class=\"hljs-string\">\"password\"</span>))) {\n    ctx.response()\n      .end(jwt.generateToken(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"sub\"</span>, <span class=\"hljs-string\">\"paulo\"</span>)));\n  } <span class=\"hljs-keyword\">else</span> {\n    ctx.fail(<span class=\"hljs-number\">401</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Now that your client has a token all it is required is that <strong>for all</strong> consequent request the HTTP header\n<code>Authorization</code> is filled with: <code>Bearer &lt;token&gt;</code> e.g.:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\nJWTAuthOptions authConfig = <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> KeyStoreOptions()\n    .setType(<span class=\"hljs-string\">\"jceks\"</span>)\n    .setPath(<span class=\"hljs-string\">\"keystore.jceks\"</span>)\n    .setPassword(<span class=\"hljs-string\">\"secret\"</span>));\n\nJWTAuth authProvider = JWTAuth.create(vertx, authConfig);\n\nrouter.route(<span class=\"hljs-string\">\"/protected/*\"</span>).handler(JWTAuthHandler.create(authProvider));\n\nrouter.route(<span class=\"hljs-string\">\"/protected/somepage\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// some handle code...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>JWT allows you to add any information you like to the token itself. By doing this there is no state in the server\nwhich allows you to scale your applications without need for clustered session data. In order to add data to the\ntoken, during the creation of the token just add data to the JsonObject parameter:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuthOptions authConfig = <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> KeyStoreOptions()\n    .setType(<span class=\"hljs-string\">\"jceks\"</span>)\n    .setPath(<span class=\"hljs-string\">\"keystore.jceks\"</span>)\n    .setPassword(<span class=\"hljs-string\">\"secret\"</span>));\n\nJWTAuth authProvider = JWTAuth.create(vertx, authConfig);\n\nauthProvider\n  .generateToken(\n    <span class=\"hljs-keyword\">new</span> JsonObject()\n      .put(<span class=\"hljs-string\">\"sub\"</span>, <span class=\"hljs-string\">\"paulo\"</span>)\n      .put(<span class=\"hljs-string\">\"someKey\"</span>, <span class=\"hljs-string\">\"some value\"</span>),\n    <span class=\"hljs-keyword\">new</span> JWTOptions());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And the same when consuming:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;RoutingContext&gt; handler = ctx -&gt; {\n  String theSubject = ctx.user().principal().getString(<span class=\"hljs-string\">\"sub\"</span>);\n  String someKey = ctx.user().principal().getString(<span class=\"hljs-string\">\"someKey\"</span>);\n};</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_authorization\"><a class=\"anchor\" href=\"#_configuring_authorization\"></a>Configuring authorization</h3>\n<div class=\"paragraph\">\n<p>Until now all examples were covering authentication. Authorization is the next logical step when dealing with user.\nWhile authentication was really specific to the protocol, <strong>authorization</strong> is independent, all information is extracted\nfrom the <code>User</code> object.</p>\n</div>\n<div class=\"paragraph\">\n<p>Before this is possible there is a need to load the authorizations to this same object. In order to do this the\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthorizationHandler.html\">AuthorizationHandler</a></code> should be used. An authorization handler will load all known\nauthorizations from a given <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(\n  <span class=\"hljs-comment\">// create the handler that will perform the attestation</span>\n  AuthorizationHandler.create(\n    <span class=\"hljs-comment\">// what to attest</span>\n    PermissionBasedAuthorization.create(<span class=\"hljs-string\">\"can-do-work\"</span>))\n    <span class=\"hljs-comment\">// where to lookup the authorizations for the user</span>\n    .addAuthorizationProvider(authProvider));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The lookup can be performed on more than 1 source, just keep adding <code>addAuthorizationProvider(provider)</code> to the handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example of configuring an app so that different authorities are required for different parts of the\napp. Note that the meaning of the authorities is determined by the underlying auth provider that you use. E.g. some\nmay support a role/permission based model but others might use another model.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">\"/listproducts/*\"</span>).handler(\n  <span class=\"hljs-comment\">// create the handler that will perform the attestation</span>\n  AuthorizationHandler.create(\n    <span class=\"hljs-comment\">// what to attest</span>\n    PermissionBasedAuthorization.create(<span class=\"hljs-string\">\"list_products\"</span>))\n    <span class=\"hljs-comment\">// where to lookup the authorizations for the user</span>\n    .addAuthorizationProvider(authProvider));\n\n<span class=\"hljs-comment\">// Only \"admin\" has access to /private/settings</span>\nrouter.route(<span class=\"hljs-string\">\"/private/settings/*\"</span>).handler(\n  <span class=\"hljs-comment\">// create the handler that will perform the attestation</span>\n  AuthorizationHandler.create(\n    <span class=\"hljs-comment\">// what to attest</span>\n    RoleBasedAuthorization.create(<span class=\"hljs-string\">\"admin\"</span>))\n    .addAuthorizationProvider(authProvider));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_chaining_multiple_authentication_handlers\"><a class=\"anchor\" href=\"#_chaining_multiple_authentication_handlers\"></a>Chaining multiple authentication handlers</h3>\n<div class=\"paragraph\">\n<p>There are times when you want to support multiple authentication mechanisms in a single application. For this you can\nuse the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ChainAuthHandler.html\">ChainAuthHandler</a></code>. The chain auth handler will attempt to perform\nauthentication on a chain of handlers.</p>\n</div>\n<div class=\"paragraph\">\n<p>It is important to know that some handlers require specific providers, for example:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/handler/JWTAuthHandler.html\">JWTAuthHandler</a></code> requires <code><a href=\"../../apidocs/io/vertx/ext/auth/jwt/JWTAuth.html\">JWTAuth</a></code>.</p>\n</li>\n<li>\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/handler/DigestAuthHandler.html\">DigestAuthHandler</a></code> requires <code><a href=\"../../apidocs/io/vertx/ext/auth/htdigest/HtdigestAuth.html\">HtdigestAuth</a></code>.</p>\n</li>\n<li>\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/handler/OAuth2AuthHandler.html\">OAuth2AuthHandler</a></code> requires <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/OAuth2Auth.html\">OAuth2Auth</a></code>.</p>\n</li>\n<li>\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/handler/WebAuthnHandler.html\">WebAuthnHandler</a></code> requires <code><a href=\"../../apidocs/io/vertx/ext/auth/webauthn/WebAuthn.html\">WebAuthn</a></code>.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>So it is not expected that the providers will be shared across all handlers. There are cases where one can share the\nprovider across handlers, for example:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BasicAuthHandler.html\">BasicAuthHandler</a></code> can take any provider.</p>\n</li>\n<li>\n<p>The <code><a href=\"../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html\">RedirectAuthHandler</a></code> can take any provider.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>So say that you want to create an application that accepts both <code>HTTP Basic Authentication</code> and <code>Form Redirect</code>. You\nwould start configuring your chain as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ChainAuthHandler chain = ChainAuthHandler.any();\n\n<span class=\"hljs-comment\">// add http basic auth handler to the chain</span>\nchain.add(BasicAuthHandler.create(provider));\n<span class=\"hljs-comment\">// add form redirect auth handler to the chain</span>\nchain.add(RedirectAuthHandler.create(provider));\n\n<span class=\"hljs-comment\">// secure your route</span>\nrouter.route(<span class=\"hljs-string\">\"/secure/resource\"</span>).handler(chain);\n<span class=\"hljs-comment\">// your app</span>\nrouter.route(<span class=\"hljs-string\">\"/secure/resource\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do something...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>So when a user makes a request without a <code>Authorization</code> header, this means that the chain will fail to authenticate\nwith the basic auth handler and will attempt to authenticate with the redirect handler. Since the redirect handler\nalways redirects you will be sent to the login form that you configured in that handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Like the normal routing in vertx-web, auth chaning is a sequence, so if you would prefer to fallback to your browser\nasking for the user credentials using HTTP Basic authentication instead of the redirect all you need to to is reverse\nthe order of appending to the chain.</p>\n</div>\n<div class=\"paragraph\">\n<p>Now assume that you make a request where you provide the header <code>Authorization</code> with the value <code>Basic [token]</code>. In\nthis case the basic auth handler will attempt to authenticate and if it is sucessful the chain will stop and\nvertx-web will continue to process your handlers. If the token is not valid, for example bad username/password, then\nthe chain will continue to the following entry. In this specific case the redirect auth handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Complex chaining is also possible, for example, building logic sequences such as: <code>HandlerA</code> OR (<code>HandlerB</code> AND <code>HandlerC</code>).</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ChainAuthHandler chain =\n  ChainAuthHandler.any()\n    .add(authNHandlerA)\n    .add(ChainAuthHandler.all()\n      .add(authNHandlerB)\n      .add(authNHandlerC));\n\n<span class=\"hljs-comment\">// secure your route</span>\nrouter.route(<span class=\"hljs-string\">\"/secure/resource\"</span>).handler(chain);\n<span class=\"hljs-comment\">// your app</span>\nrouter.route(<span class=\"hljs-string\">\"/secure/resource\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do something...</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_serving_static_resources\"><a class=\"anchor\" href=\"#_serving_static_resources\"></a>Serving static resources</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web comes with an out of the box handler for serving static web resources so you can write static web servers\nvery easily.</p>\n</div>\n<div class=\"paragraph\">\n<p>To serve static resources such as <code>.html</code>, <code>.css</code>, <code>.js</code> or any other static resource, you use an instance of\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html\">StaticHandler</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Any requests to paths handled by the static handler will result in files being served from a directory on the file system\nor from the classpath. The default static file directory is <code>webroot</code> but this can be configured.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the following example all requests to paths starting with <code>/static/</code> will get served from the directory <code>webroot</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">\"/static/*\"</span>).handler(StaticHandler.create());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For example, if there was a request with path <code>/static/css/mystyles.css</code> the static serve will look for a file in the\ndirectory <code>webroot/css/mystyle.css</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>It will also look for a file on the classpath called <code>webroot/css/mystyle.css</code>. This means you can package up all your\nstatic resources into a jar file (or fatjar) and distribute them like that.</p>\n</div>\n<div class=\"paragraph\">\n<p>When Vert.x finds a resource on the classpath for the first time it extracts it and caches it in a temporary directory\non disk so it doesn&#8217;t have to do this each time.</p>\n</div>\n<div class=\"paragraph\">\n<p>The handler will handle range aware requests. When a client makes a request to a static resource, the handler will\nnotify that it can handle range aware request by stating the unit on the <code>Accept-Ranges</code> header. Further requests\nthat contain the <code>Range</code> header with the correct unit and start and end indexes will then receive partial responses\nwith the correct <code>Content-Range</code> header.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_caching\"><a class=\"anchor\" href=\"#_configuring_caching\"></a>Configuring caching</h3>\n<div class=\"paragraph\">\n<p>By default the static handler will set cache headers to enable browsers to effectively cache files.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web sets the headers <code>cache-control</code>,<code>last-modified</code>, and <code>date</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p><code>cache-control</code> is set to <code>max-age=86400</code> by default. This corresponds to one day. This can be configured with\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxAgeSeconds-long-\">setMaxAgeSeconds</a></code> if required.</p>\n</div>\n<div class=\"paragraph\">\n<p>If a browser sends a GET or a HEAD request with an <code>if-modified-since</code> header and the resource has not been modified\nsince that date, a <code>304</code> status is returned which tells the browser to use its locally cached resource.</p>\n</div>\n<div class=\"paragraph\">\n<p>If handling of cache headers is not required, it can be disabled with <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCachingEnabled-boolean-\">setCachingEnabled</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>When cache handling is enabled Vert.x-Web will cache the last modified date of resources in memory, this avoids a disk hit\nto check the actual last modified date every time.</p>\n</div>\n<div class=\"paragraph\">\n<p>Entries in the cache have an expiry time, and after that time, the file on disk will be checked again and the cache\nentry updated.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you know that your files never change on disk, then the cache entry will effectively never expire. This is the\ndefault.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you know that your files might change on disk when the server is running then you can set files read only to false with\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setFilesReadOnly-boolean-\">setFilesReadOnly</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To enable the maximum number of entries that can be cached in memory at any one time you can use\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxCacheSize-int-\">setMaxCacheSize</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To configure the expiry time of cache entries you can use <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCacheEntryTimeout-long-\">setCacheEntryTimeout</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_the_index_page\"><a class=\"anchor\" href=\"#_configuring_the_index_page\"></a>Configuring the index page</h3>\n<div class=\"paragraph\">\n<p>Any requests to the root path <code>/</code> will cause the index page to be served. By default the index page is <code>index.html</code>.\nThis can be configured with <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIndexPage-java.lang.String-\">setIndexPage</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_changing_the_web_root\"><a class=\"anchor\" href=\"#_changing_the_web_root\"></a>Changing the web root</h3>\n<div class=\"paragraph\">\n<p>By default static resources will be served from the directory <code>webroot</code>. To configure this use\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setWebRoot-java.lang.String-\">setWebRoot</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_serving_hidden_files\"><a class=\"anchor\" href=\"#_serving_hidden_files\"></a>Serving hidden files</h3>\n<div class=\"paragraph\">\n<p>By default the serve will serve hidden files (files starting with <code>.</code>).</p>\n</div>\n<div class=\"paragraph\">\n<p>If you do not want hidden files to be served you can configure it with <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIncludeHidden-boolean-\">setIncludeHidden</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_directory_listing\"><a class=\"anchor\" href=\"#_directory_listing\"></a>Directory listing</h3>\n<div class=\"paragraph\">\n<p>The server can also perform directory listing. By default directory listing is disabled. To enabled it use\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryListing-boolean-\">setDirectoryListing</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>When directory listing is enabled the content returned depends on the content type in the <code>accept</code> header.</p>\n</div>\n<div class=\"paragraph\">\n<p>For <code>text/html</code> directory listing, the template used to render the directory listing page can be configured with\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryTemplate-java.lang.String-\">setDirectoryTemplate</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_disabling_file_caching_on_disk\"><a class=\"anchor\" href=\"#_disabling_file_caching_on_disk\"></a>Disabling file caching on disk</h3>\n<div class=\"paragraph\">\n<p>By default, Vert.x will cache files that are served from the classpath into a file on disk in a sub-directory of a\ndirectory called <code>.vertx</code> in the current working directory. This is mainly useful when deploying services as\nfatjars in production where serving a file from the classpath every time can be slow.</p>\n</div>\n<div class=\"paragraph\">\n<p>In development this can cause a problem, as if you update your static content while the server is running, the\ncached file will be served not the updated file.</p>\n</div>\n<div class=\"paragraph\">\n<p>To disable file caching you can provide your vert.x options the property <code>fileResolverCachingEnabled</code> to <code>false</code>. For\nbackwards compatibility it will also default that value to the system property <code>vertx.disableFileCaching</code>. E.g. you\ncould set up a run configuration in your IDE to set this when running your main class.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cors_handling\"><a class=\"anchor\" href=\"#_cors_handling\"></a>CORS handling</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">Cross Origin Resource Sharing</a> is a safe mechanism for\nallowing resources to be requested from one domain and served from another.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web includes a handler <code><a href=\"../../apidocs/io/vertx/ext/web/handler/CorsHandler.html\">CorsHandler</a></code> that handles the CORS protocol for you.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .handler(\n    CorsHandler.create(<span class=\"hljs-string\">\"vertx\\\\.io\"</span>)\n      .allowedMethod(HttpMethod.GET));\n\nrouter.route().handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// Your app handlers</span>\n\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_multi_tenant\"><a class=\"anchor\" href=\"#_multi_tenant\"></a>Multi Tenant</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>There are cases where your application needs to handle more than just 1 tenant. In this case a helper handler is\nprovided that simplifies setting up the application.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the case the tenant is identified by a HTTP header, say for example <code>X-Tenant</code>, then creating the handler is as\nsimple as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(MultiTenantHandler.create(<span class=\"hljs-string\">\"X-Tenant\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You now should register what handler should be executed for the given tenant:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultiTenantHandler.create(<span class=\"hljs-string\">\"X-Tenant\"</span>)\n  .addTenantHandler(<span class=\"hljs-string\">\"tenant-A\"</span>, ctx -&gt; {\n    <span class=\"hljs-comment\">// do something for tenant A...</span>\n  })\n  .addTenantHandler(<span class=\"hljs-string\">\"tenant-B\"</span>, ctx -&gt; {\n    <span class=\"hljs-comment\">// do something for tenant B...</span>\n  })\n  <span class=\"hljs-comment\">// optionally</span>\n  .addDefaultHandler(ctx -&gt; {\n    <span class=\"hljs-comment\">// do something when no tenant matches...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is useful for security situations:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OAuth2Auth gitHubAuthProvider = GithubAuth\n  .create(vertx, <span class=\"hljs-string\">\"CLIENT_ID\"</span>, <span class=\"hljs-string\">\"CLIENT_SECRET\"</span>);\n\n<span class=\"hljs-comment\">// create a oauth2 handler on our running server</span>\n<span class=\"hljs-comment\">// the second argument is the full url to the callback</span>\n<span class=\"hljs-comment\">// as you entered in your provider management console.</span>\nOAuth2AuthHandler githubOAuth2 = OAuth2AuthHandler.create(\n  vertx,\n  gitHubAuthProvider,\n  <span class=\"hljs-string\">\"https://myserver.com/github-callback\"</span>);\n\n<span class=\"hljs-comment\">// setup the callback handler for receiving the GitHub callback</span>\ngithubOAuth2.setupCallback(router.route());\n\n<span class=\"hljs-comment\">// create an OAuth2 provider, clientID and clientSecret</span>\n<span class=\"hljs-comment\">// should be requested to Google</span>\nOAuth2Auth googleAuthProvider = OAuth2Auth.create(vertx, <span class=\"hljs-keyword\">new</span> OAuth2Options()\n  .setClientID(<span class=\"hljs-string\">\"CLIENT_ID\"</span>)\n  .setClientSecret(<span class=\"hljs-string\">\"CLIENT_SECRET\"</span>)\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setSite(<span class=\"hljs-string\">\"https://accounts.google.com\"</span>)\n  .setTokenPath(<span class=\"hljs-string\">\"https://www.googleapis.com/oauth2/v3/token\"</span>)\n  .setAuthorizationPath(<span class=\"hljs-string\">\"/o/oauth2/auth\"</span>));\n\n<span class=\"hljs-comment\">// create a oauth2 handler on our domain: \"http://localhost:8080\"</span>\nOAuth2AuthHandler googleOAuth2 = OAuth2AuthHandler.create(\n  vertx,\n  googleAuthProvider,\n  <span class=\"hljs-string\">\"https://myserver.com/google-callback\"</span>);\n\n<span class=\"hljs-comment\">// setup the callback handler for receiving the Google callback</span>\ngoogleOAuth2.setupCallback(router.route());\n\n<span class=\"hljs-comment\">// At this point the 2 callbacks endpoints are registered:</span>\n\n<span class=\"hljs-comment\">// /github-callback -&gt; handle github Oauth2 callbacks</span>\n<span class=\"hljs-comment\">// /google-callback -&gt; handle google Oauth2 callbacks</span>\n\n<span class=\"hljs-comment\">// As the callbacks are made by the IdPs there's no header</span>\n<span class=\"hljs-comment\">// to identify the source, hence the need of custom URLs</span>\n\n<span class=\"hljs-comment\">// However for out Application we can control it so later</span>\n<span class=\"hljs-comment\">// we can add the right handler for the right tenant</span>\n\nrouter.route().handler(\n  MultiTenantHandler.create(<span class=\"hljs-string\">\"X-Tenant\"</span>)\n    <span class=\"hljs-comment\">// tenants using github should go this way:</span>\n    .addTenantHandler(<span class=\"hljs-string\">\"github\"</span>, githubOAuth2)\n    <span class=\"hljs-comment\">// tenants using google should go this way:</span>\n    .addTenantHandler(<span class=\"hljs-string\">\"google\"</span>, googleOAuth2)\n    <span class=\"hljs-comment\">// all other should be forbidden</span>\n    .addDefaultHandler(ctx -&gt; ctx.fail(<span class=\"hljs-number\">401</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The tenant id can be read at any moment from the context, for example to decide which resource to load, or which\ndatabase to connect to:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// the default key is \"tenant\" as defined in</span>\n  <span class=\"hljs-comment\">// MultiTenantHandler.TENANT but this value can be</span>\n  <span class=\"hljs-comment\">// modified at creation time in the factory method</span>\n  String tenant = ctx.get(MultiTenantHandler.TENANT);\n\n  <span class=\"hljs-keyword\">switch</span>(tenant) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"google\"</span>:\n      <span class=\"hljs-comment\">// do something for google users</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"github\"</span>:\n      <span class=\"hljs-comment\">// so something for github users</span>\n      <span class=\"hljs-keyword\">break</span>;\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Multi tenant is a powerful handler that will allow applications to live side by side, however it provides no sandboxing\nfor execution. It should not be used as isolation as wrongly written applications may leak state across tenants.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_templates\"><a class=\"anchor\" href=\"#_templates\"></a>模板</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web 为若干流行的模板引擎提供了开箱即用的支持，通过这种方式来提供生成动态页面的能力。\n您也可以很容易地添加您自己的实现。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html\">TemplateEngine</a></code> 定义了使用模板引擎的接口。\n当渲染模板时会调用 <code><a href=\"../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html#render-io.vertx.core.json.JsonObject-java.lang.String-io.vertx.core.Handler-\">render</a></code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>最简单的使用模板的方式不是直接调用模板引擎，而是使用模板处理器\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/TemplateHandler.html\">TemplateHandler</a></code> 。\n这个处理器会根据 HTTP 请求的路径来调用模板引擎。</p>\n</div>\n<div class=\"paragraph\">\n<p>缺省情况下，模板处理器会在 <code>templates</code> 目录中查找模板文件。这是可以配置的。</p>\n</div>\n<div class=\"paragraph\">\n<p>该处理器会返回渲染的结果，并默认设置 Content-Type 消息头为 <code>text/html</code> 。这也是可以配置的。</p>\n</div>\n<div class=\"paragraph\">\n<p>您需要在创建模板处理器时提供您想要使用的模板引擎实例。\nVert.x Web 并未嵌入模板引擎的实现，您需要配置项目来访问它们。\nVert.x Web 提供了每一种模板引擎的配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">TemplateEngine engine = HandlebarsTemplateEngine.create();\nTemplateHandler handler = TemplateHandler.create(engine);\n\n<span class=\"hljs-comment\">// 这会将所有以 `/dynamic` 开头的 GET 请求路由到模板处理器上</span>\n<span class=\"hljs-comment\">// 例如 /dynamic/graph.hbs 会查找模板 /templates/graph.hbs</span>\nrouter.get(<span class=\"hljs-string\">\"/dynamic/*\"</span>).handler(handler);\n\n<span class=\"hljs-comment\">// 将所有以 `.hbs` 结尾的 GET 请求路由到模板处理器上</span>\nrouter.getWithRegex(<span class=\"hljs-string\">\".+\\\\.hbs\"</span>).handler(handler);</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mvel_template_engine\"><a class=\"anchor\" href=\"#_mvel_template_engine\"></a>MVEL 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 MVEL 模板引擎：\n<code>io.vertx:vertx-web-templ-mvel:4.0.2</code>。 并通过此方法以创建 MVEL 模板引擎实例：\n<code>io.vertx.ext.web.templ.mvel.MVELTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 MVEL 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.templ</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 MVEL 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>The request path is @{context.request().path()}\n\nThe variable 'foo' from the session is @{context.session().get('foo')}\n\nThe value 'bar' from the context data is @{context.get('bar')}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 MVEL 模板，\n请参考 <a href=\"http://mvel.codehaus.org/MVEL+2.0+Templating+Guide\">MVEL 模板文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_jade_template_engine\"><a class=\"anchor\" href=\"#_jade_template_engine\"></a>Jade 模版引擎（译者注：Jade 已更名为 Pug)</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Jade 模板引擎：\n<code>io.vertx:vertx-web-templ-jade:4.0.2</code>。 并通过此方法以创建 Jade 模板引擎实例：\n<code>io.vertx.ext.web.templ.jade.JadeTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Jade 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.jade</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Jade 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>!!! 5\nhtml\n head\n   title= context.get('foo') + context.request().path()\n body</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Jade 模板，\n请参考 <a href=\"https://github.com/neuland/jade4j\">Jade4j 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handlebars_template_engine\"><a class=\"anchor\" href=\"#_handlebars_template_engine\"></a>Handlebars 模板引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Handlebars 模板引擎：\n<code>io.vertx:vertx-web-templ-handlebars:4.0.2</code>。 并通过此方法以创建 Handlebars 模板引擎实例：\n<code>io.vertx.ext.web.templ.handlebars.HandlebarsTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Handlebars 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.hbs</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>Handlebars 不允许在模板中随意地调用对象的方法，\n因此我们不能像对待其他模板引擎一样将RoutingContext传递到引擎里并让模板来识别它。</p>\n</div>\n<div class=\"paragraph\">\n<p>替代方案是，可以使用模版中的上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#data--\">data</a></code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您要访问某些RoutingContext里不存在的信息，\n比如请求的路径、请求参数或者会话等，您需要在模板处理器执行之前将他们添加到上下文data里，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">TemplateHandler handler = TemplateHandler.create(engine);\n\nrouter.get(<span class=\"hljs-string\">\"/dynamic\"</span>).handler(ctx -&gt; {\n\n  ctx.put(<span class=\"hljs-string\">\"request_path\"</span>, ctx.request().path());\n  ctx.put(<span class=\"hljs-string\">\"session_data\"</span>, ctx.session().data());\n\n  ctx.next();\n});\n\nrouter.get(<span class=\"hljs-string\">\"/dynamic/\"</span>).handler(handler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Handlebars 模板，\n请参考 <a href=\"https://github.com/jknack/handlebars.java\">Handlebars Java 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_thymeleaf_template_engine\"><a class=\"anchor\" href=\"#_thymeleaf_template_engine\"></a>Thymeleaf 模板引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Thymeleaf 模板引擎：\n<code>io.vertx:vertx-web-templ-thymeleaf:4.0.2</code>。 并通过此方法以创建 Thymeleaf 模板引擎实例：\n<code>io.vertx.ext.web.templ.thymeleaf.ThymeleafTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Thymeleaf 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.html</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Thymeleaf 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\n&lt;p th:text=\"${context.get('foo')}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.get('bar')}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.normalizedPath()}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().get('param1')}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().get('param2')}\"&gt;&lt;/p&gt;\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Thymeleaf 模板，\n请参考 <a href=\"http://www.thymeleaf.org/\">Thymeleaf 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_apache_freemarker_template_engine\"><a class=\"anchor\" href=\"#_apache_freemarker_template_engine\"></a>Apache FreeMarker 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Apache FreeMarker ：\n<code>io.vertx:vertx-web-templ-freemarker:4.0.2</code>。 并通过此方法以创建 Apache FreeMarker 模板引擎实例：\n<code>io.vertx.ext.web.templ.Engine#create()</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Apache FreeMarker 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.ftl</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Apache FreeMarker 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\n&lt;p th:text=\"${context.foo}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.bar}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.normalizedPath()}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().param1}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().param2}\"&gt;&lt;/p&gt;\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Apache FreeMarker 模板，\n请参考 <a href=\"http://www.freemarker.org/\">Apache FreeMarker 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_pebble_template_engine\"><a class=\"anchor\" href=\"#_pebble_template_engine\"></a>Pebble 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Pebble ：\n<code>io.vertx:vertx-web-templ-pebble:4.0.2</code>。 并通过此方法以创建 Pebble 模板引擎实例：\n<code>io.vertx.ext.web.templ.pebble.PebbleTemplateEngine#create(vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Pebble 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.ped</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Pebble 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\n&lt;p th:text=\"{{context.foo}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.bar}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.normalizedPath()}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.request().params().param1}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.request().params().param2}}\"&gt;&lt;/p&gt;\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Pebble 模板，\n请参考 <a href=\"http://www.mitchellbosecke.com/pebble/home/\">Pebble 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rocker_template_engine\"><a class=\"anchor\" href=\"#_rocker_template_engine\"></a>Rocker 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Rocker：<code>io.vertx:vertx-web-templ-rocker:4.0.2</code>。\n并通过此方法以创建 Rocker 模板引擎实例：<code>io.vertx.ext.web.templ.rocker#create()</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>Rocker会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。\n假定已知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\")\n .put(\"context\", new JsonObject().put(\"path\", \"/foo/bar\"));\n\nengine.render(context, \"somedir/TestRockerTemplate2\", render -&gt; {\n // (...)\n});\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>那么相对应的模版文件 <code>somedir/TestRockerTemplate2.rocker.html</code> 可写作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>@import io.vertx.core.json.JsonObject\n@args (JsonObject context, String foo, String bar)\nHello @foo and @bar\nRequest path is @context.getString(\"path\")</pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_httl_template_engine\"><a class=\"anchor\" href=\"#_httl_template_engine\"></a>HTTL 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 HTTL ：\n<code>io.vertx:vertx-web-templ-httl:4.0.2</code>。 并通过此方法以创建 HTTL 模板引擎实例：\n<code>io.vertx.ext.web.templ.httl.HTTLTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 HTTL 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.httl</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTL会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。\n假定已知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\nTemplateEngine engine = HTTLTemplateEngine.create(vertx);\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\");\n\nengine.render(context, \"somedir/test-httl-template1.httl\", render -&gt; {\n // (...)\n});\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>那么相对应的模版文件 <code>somedir/test-httl-template1.httl</code> 可写作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>&lt;!-- #set(String foo, String bar) --&gt;\nHello ${foo} and ${bar}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 HTTL 模板，\n请参考 <a href=\"https://httl.github.io/en/\">HTTL 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rythm_template_engine\"><a class=\"anchor\" href=\"#_rythm_template_engine\"></a>Rythm 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Rythm ：\n<code>io.vertx:vertx-web-templ-rythm:4.0.2</code>。 并通过此方法以创建 Rythm 模板引擎实例：\n<code>io.vertx.ext.web.templ.rythm.RythmTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Rythm 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.html</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>Rythm会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。\n假定已知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\nTemplateEngine engine = RythmTemplateEngine.create(vertx);\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\");\n\nengine.render(context, \"somedir/test-rythm-template1.html\", render -&gt; {\n // (...)\n});\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>那么相对应的模版文件 <code>somedir/test-rythm-template1.httl</code> 可写作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>&lt;!-- #set(String foo, String bar) --&gt;\nHello @foo and @bar</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 HTTL 模板，请参考 <a href=\"http://www.rythmengine.org/\">RythmEngine 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_caching\"><a class=\"anchor\" href=\"#_caching\"></a>缓存</h3>\n<div class=\"paragraph\">\n<p>许多引擎支持将编译好的模版存入缓存。该缓存存放在Vert.x的可分享的数据local map里。\n这样引擎便可在多个verticle中安全高效地使用该缓存。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_disabling_caching\"><a class=\"anchor\" href=\"#_disabling_caching\"></a>禁用缓存</h4>\n<div class=\"paragraph\">\n<p>在开发时，为了让每一次请求可以读取最新的模板，您可能希望禁用模板的缓存。\n您可通过设置系统变量：<code>vertxweb.environment</code> 或环境变量\n<code>VERTXWEB_ENVIRONMENT</code> 为 <code>dev</code> 或 <code>development</code> 将其禁用。缓存默认是启用的。</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_error_handler\"><a class=\"anchor\" href=\"#_error_handler\"></a>错误处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可使用模版处理器自行渲染错误页面，\n但是Vert.x-Web同样为您提供了开箱即用且“好看的”错误处理器，可为您渲染错误页面。</p>\n</div>\n<div class=\"paragraph\">\n<p>该处理器是 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ErrorHandler.html\">ErrorHandler</a></code>。\n要使用该错误处理器，仅需要将其设置为您希望覆盖的错误路径的失败处理器即可（译者注：例如router.route(\"/*\").failureHandler(ErrorHandler.create(vertx))）。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_request_logger\"><a class=\"anchor\" href=\"#_request_logger\"></a>请求日志</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web通过内置处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/LoggerHandler.html\">LoggerHandler</a></code> 来记录请求日志。\n您需在挂载任何可能导致 <code>RoutingContext</code> 失败的处理器之前挂载该处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，请求日志将会被记录到Vert.x logger中，亦可通过更改配置使用JUL logging, log4j 或 SLF4J记录。</p>\n</div>\n<div class=\"paragraph\">\n<p>详见 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/LoggerFormat.html\">LoggerFormat</a></code>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_serving_favicons\"><a class=\"anchor\" href=\"#_serving_favicons\"></a>提供网页图标</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web通过内置处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/FaviconHandler.html\">FaviconHandler</a></code> 以提供网页图标。</p>\n</div>\n<div class=\"paragraph\">\n<p>图标可以指定为文件系统上的某个路径，否则 Vert.x Web 默认会在 classpath 上寻找名为 <code>favicon.ico</code> 的文件。\n这意味着您可以将图标打包到包含您应用的 jar 包里。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_timeout_handler\"><a class=\"anchor\" href=\"#_timeout_handler\"></a>超时处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web内置一个超时处理器以处理超时请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>可通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/TimeoutHandler.html\">TimeoutHandler</a></code> 配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果一个请求超时，则会给客户端返回一个 503 的响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面的例子设置了一个超时处理器。对于所有以 <code>/foo</code> 路径开头的请求，\n都会在执行时间超过 5 秒之后自动超时。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">\"/foo/\"</span>).handler(TimeoutHandler.create(<span class=\"hljs-number\">5000</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_response_time_handler\"><a class=\"anchor\" href=\"#_response_time_handler\"></a>响应时间处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>该处理器会将从接收到请求到写入响应的消息头之间的毫秒数写入到响应的 <code>x-response-time</code> 里，\n例如：</p>\n</div>\n<div class=\"paragraph\">\n<p>x-response-time: 1456ms</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_content_type_handler\"><a class=\"anchor\" href=\"#_content_type_handler\"></a>内容类型（Content type）处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>ResponseContentTypeHandler</code> 会自动设置响应的 <code>Content-Type</code> 消息头。\n假设我们要构建一个 RESTful 的 Web 应用，我们需要在所有处理器里设置消息类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/api/books\"</span>)\n  .produces(<span class=\"hljs-string\">\"application/json\"</span>)\n  .handler(ctx -&gt; findBooks()\n    .onSuccess(books -&gt; ctx.response()\n      .putHeader(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>)\n      .end(toJson(books))).onFailure(ctx::fail));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>随着 API 接口数量的增长，设置内容类型会变得很麻烦。\n可以通过在相应的 Route 上添加 <code>ResponseContentTypeHandler</code> 来避免这个问题：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">\"/api/*\"</span>).handler(ResponseContentTypeHandler.create());\nrouter\n  .get(<span class=\"hljs-string\">\"/api/books\"</span>)\n  .produces(<span class=\"hljs-string\">\"application/json\"</span>)\n  .handler(ctx -&gt; findBooks()\n    .onSuccess(books -&gt; ctx.response()\n      .end(toJson(books))).onFailure(ctx::fail));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>处理器会通过 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--\">getAcceptableContentType</a></code> 方法来选择适当的内容类型。\n因此，您可以很容易地使用同一个处理器以提供不同类型的数据：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">\"/api/*\"</span>).handler(ResponseContentTypeHandler.create());\n\nrouter\n  .get(<span class=\"hljs-string\">\"/api/books\"</span>)\n  .produces(<span class=\"hljs-string\">\"text/xml\"</span>)\n  .produces(<span class=\"hljs-string\">\"application/json\"</span>)\n  .handler(ctx -&gt; findBooks()\n    .onSuccess(books -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ctx.getAcceptableContentType().equals(<span class=\"hljs-string\">\"text/xml\"</span>)) {\n        ctx.response().end(toXML(books));\n      } <span class=\"hljs-keyword\">else</span> {\n        ctx.response().end(toJson(books));\n      }\n    })\n    .onFailure(ctx::fail));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sockjs\"><a class=\"anchor\" href=\"#_sockjs\"></a>SockJS</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>SockJS 是一个客户端的 JavaScript 库以及协议，它提供了类似 WebSocket 的接口以方便您与 SockJS 服务器创建连接，\n而无需您关心浏览器或网络是否允许真正的 WebSocket。</p>\n</div>\n<div class=\"paragraph\">\n<p>它提供了若干不同的传输方式，\n并在运行时根据浏览器和网络的兼容性来选择使用哪种传输方式处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>然而这一切对您而言是透明的，您只需要简单地使用类似 WebSocket 的接口 <em>即可</em>。</p>\n</div>\n<div class=\"paragraph\">\n<p>请参阅 <a href=\"https://github.com/sockjs/sockjs-client\"> SockJS 网站</a>以获取更多关于SockJS的信息。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sockjs_handler\"><a class=\"anchor\" href=\"#_sockjs_handler\"></a>SockJS 处理器</h3>\n<div class=\"paragraph\">\n<p>Vert.x 提供了一个开箱即用的处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\">SockJSHandler</a></code>\n以便您在 Vert.x-Web 应用中使用 SockJS。</p>\n</div>\n<div class=\"paragraph\">\n<p>您需要通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#create-io.vertx.core.Vertx-\">SockJSHandler.create</a></code> 方法为每一个 SockJS 的应用创建处理器。\n您也可以在创建处理器时通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\">SockJSHandlerOptions</a></code>\n对象来指定配置选项。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\nSockJSHandlerOptions options = <span class=\"hljs-keyword\">new</span> SockJSHandlerOptions()\n  .setHeartbeatInterval(<span class=\"hljs-number\">2000</span>);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_sockjs_sockets\"><a class=\"anchor\" href=\"#_handling_sockjs_sockets\"></a>处理 SockJS 套接字</h3>\n<div class=\"paragraph\">\n<p>您可以在服务器端设置一个 SockJS 处理器，\n这个处理器会在客户端创建连接时被调用：</p>\n</div>\n<div class=\"paragraph\">\n<p>传递给处理器的是 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html\">SockJSSocket</a></code> 对象。\n这是一个类似套接字的接口，您可以像使用 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 或\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html\">WebSocket</a></code> 那样通过它来读写数据。它实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 接口，因此您可以将它套用（pump）到其他读写流上。\n若 SockJS 连接使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#routingContext--\">routingContext</a></code> 加载，\n那么便可在手动管理会话（session）时访问 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code>。\n由此您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webSession--\">webSession</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webUser--\">webUser</a></code> 管理用户和会话。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面的例子中的 SockJS 处理器直接使用了它读取到的数据进行回写：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\nSockJSHandlerOptions options = <span class=\"hljs-keyword\">new</span> SockJSHandlerOptions()\n  .setHeartbeatInterval(<span class=\"hljs-number\">2000</span>);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);\n\nrouter.mountSubRouter(<span class=\"hljs-string\">\"/myapp\"</span>, sockJSHandler.socketHandler(sockJSSocket -&gt; {\n\n  <span class=\"hljs-comment\">// 将数据回写</span>\n  sockJSSocket.handler(sockJSSocket::write);\n\n}));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_client_side\"><a class=\"anchor\" href=\"#_the_client_side\"></a>客户端</h3>\n<div class=\"paragraph\">\n<p>在客户端 JavaScript 环境里您需要通过 SockJS 的客户端库来建立连接。\n这是SockJS 客户端的地址 <a href=\"https://www.npmjs.com/package/sockjs-client\">https://www.npmjs.com/package/sockjs-client</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可直接在捆绑软件或构建工具中直接引用它。\n或者您想在 <code>HTML</code> 文档中直接使用 <code>CDN</code> 版本，那么首先需要引入 sockjs 的依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n ...\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>完整的使用细节可参阅 <a href=\"https://github.com/sockjs/sockjs-client\">SockJS 网站</a>，\n但简而言之可像这样使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-js\" data-lang=\"js\"><span class=\"hljs-keyword\">var</span> sock = <span class=\"hljs-keyword\">new</span> SockJS(<span class=\"hljs-string\">'http://mydomain.com/myapp'</span>);\n\nsock.onopen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'open'</span>);\n};\n\nsock.onmessage = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'message'</span>, e.data);\n};\n\nsock.onevent = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event, message</span>) </span>{\n <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'event: %o, message:%o'</span>, event, message);\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 为了标记消息已被处理了</span>\n};\n\nsock.onunhandled = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>) </span>{\n <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'this message has no address:'</span>, json);\n};\n\nsock.onclose = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'close'</span>);\n};\n\nsock.send(<span class=\"hljs-string\">'test'</span>);\n\nsock.close();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_the_sockjs_handler\"><a class=\"anchor\" href=\"#_configuring_the_sockjs_handler\"></a>配置 SockJS 处理器</h3>\n<div class=\"paragraph\">\n<p>可使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\">SockJSHandlerOptions</a></code> 为处理器配置各种选项。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_to_a_sockjs_socket_over_the_event_bus\"><a class=\"anchor\" href=\"#_writing_to_a_sockjs_socket_over_the_event_bus\"></a>通过 event bus 写入 SockJS 套接字</h3>\n<div class=\"paragraph\">\n<p>在创建 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html\">SockJSSocket</a></code> 的时候，可为其注册一个 event bus 上的事件处理器。\n该处理器的地址就是 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#writeHandlerID--\">writeHandlerID</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，不允许注册事件处理器。\n需要通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\">SockJSHandlerOptions</a></code> 以启用该设置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\nSockJSHandlerOptions options = <span class=\"hljs-keyword\">new</span> SockJSHandlerOptions().setRegisterWriteHandler(<span class=\"hljs-keyword\">true</span>);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx, options);\n\nrouter.mountSubRouter(<span class=\"hljs-string\">\"/myapp\"</span>, sockJSHandler.socketHandler(sockJSSocket -&gt; {\n\n  <span class=\"hljs-comment\">// 获取 writeHandlerID 并将其存放 (例如放在本地 map 里)</span>\n  String writeHandlerID = sockJSSocket.writeHandlerID();\n\n}));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n默认情况下，处理器仅在本地注册。\n集群可通过配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html#setLocalWriteHandler-boolean-\">setLocalWriteHandler</a></code> 为false启用。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>随后将数据写入 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code> 便可发送给 SockJS 套接字。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">eventBus.send(writeHandlerID, Buffer.buffer(<span class=\"hljs-string\">\"foo\"</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sockjs_event_bus_bridge\"><a class=\"anchor\" href=\"#_sockjs_event_bus_bridge\"></a>SockJS 桥接 Event Bus</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web 提供了一个内置的被称为事件总线桥（event bus bridge）的 SockJS 套接字处理器。\n该处理器有效地将服务器端的 Vert.x 的事件总线延伸到客户端的 JavaScript 运行环境里。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将创建一个分布式的事件总线。\n该 event bus 不仅可以在服务器端多个 Vert.x 实例中使用，还可以通过运行在浏览器里的 JavaScript 访问。</p>\n</div>\n<div class=\"paragraph\">\n<p>由此，我们可以建立起一个连接多个浏览器和服务器群的庞大的分布式 event bus。\n浏览器只需与服务器集群建立连接，无需每次都与固定的某个服务器建立连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些是通过 Vert.x 提供的一个简单的客户端 JavaScript 库 <code>vertx-eventbus.js</code> 来实现的。\n它提供了一系列与服务器端的 Vert.x event-bus 极为类似的 API。\n通过这些 API 您可以发送或发布消息，或注册处理器来接收消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>该 JavaScript 库使用了 JavaScript 的 SockJS 客户端，与另外一端的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\">SockJS 处理器</a></code> 建立起 SockJS 连接，\n并将事件总线上的流量通过管道（tunnel）传送至该客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个特殊的 SockJS 套接字处理器因此被安装到 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\">SockJS 处理器</a></code> 上，\n而该处理器将会处理 SockJS 的数据，并将建立起与服务器端的事件总线的连接桥。</p>\n</div>\n<div class=\"paragraph\">\n<p>启用该连接桥您只需要在\nSockJS 处理器中调用\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-\">bridge</a></code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = <span class=\"hljs-keyword\">new</span> SockJSBridgeOptions();\n<span class=\"hljs-comment\">// 将连接桥挂载到路由器上</span>\nrouter.mountSubRouter(<span class=\"hljs-string\">\"/eventbus\"</span>, sockJSHandler.bridge(options));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在客户端的 JavaScript 中，您可以使用 <a href=\"http://npmjs.com/package/@vertx/eventbus-bridge-client.js\">@vertx/eventbus-bridge-client.js</a>\n库以创建跟事件总线的连接，并以此发送和接收消息。 该库可在 <a href=\"http://npmjs.com/package/@vertx/eventbus-bridge-client.js\">NPM</a> 上找到。\n您可直接在捆绑软件或构建工具中直接引用它，但同时它亦可以在 CDN 中使用\n（就像之前的 sockJS 例子）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">'https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js'</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\n<span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> EventBus(<span class=\"hljs-string\">'http://localhost:8080/eventbus'</span>);\n\neb.onopen = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n\n <span class=\"hljs-comment\">// 设置一个处理器以接收消息</span>\n eb.registerHandler(<span class=\"hljs-string\">'some-address'</span>, (error, message) =&gt; {\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'received a message: '</span> + <span class=\"hljs-built_in\">JSON</span>.stringify(message));\n });\n\n <span class=\"hljs-comment\">// 发送消息</span>\n eb.send(<span class=\"hljs-string\">'some-address'</span>, {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'tim'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">587</span>});\n\n}\n\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该例子中首先创建了一个 event bus 实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> EventBus(<span class=\"hljs-string\">'http://localhost:8080/eventbus'</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>构造器中的参数是连接 event bus 的URI。\n因为我们建立的连接桥是以 <code>eventbus</code> 为前缀，所以我们将会成功建立连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>您在连接开启之前无法做任何事。当连接开启时 <code>onopen</code> 处理器将会被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>连接桥支持自动重连，可设置延迟和退避选项。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> EventBus(<span class=\"hljs-string\">'http://localhost:8080/eventbus'</span>);\neb.enableReconnect(<span class=\"hljs-literal\">true</span>);\neb.onopen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{}; <span class=\"hljs-comment\">// 在此处设立处理器，每次建立连接或重连时候调用</span>\neb.onreconnect = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{}; <span class=\"hljs-comment\">// 可选，仅在重连时被调用</span>\n\n<span class=\"hljs-comment\">// 或者，传入一个 options 对象</span>\n<span class=\"hljs-keyword\">var</span> options = {\n   <span class=\"hljs-attr\">vertxbus_reconnect_attempts_max</span>: <span class=\"hljs-literal\">Infinity</span>, <span class=\"hljs-comment\">// 重连尝试最多次数</span>\n   <span class=\"hljs-attr\">vertxbus_reconnect_delay_min</span>: <span class=\"hljs-number\">1000</span>, <span class=\"hljs-comment\">// 在第一次尝试重连之前的初始延迟（单位为毫秒）</span>\n   <span class=\"hljs-attr\">vertxbus_reconnect_delay_max</span>: <span class=\"hljs-number\">5000</span>, <span class=\"hljs-comment\">// 尝试重连之间的最大延迟（单位为毫秒）</span>\n   <span class=\"hljs-attr\">vertxbus_reconnect_exponent</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// 指数退避因子</span>\n   <span class=\"hljs-attr\">vertxbus_randomization_factor</span>: <span class=\"hljs-number\">0.5</span> <span class=\"hljs-comment\">// 介于0和1之间的随机因子</span>\n};\n\n<span class=\"hljs-keyword\">var</span> eb2 = <span class=\"hljs-keyword\">new</span> EventBus(<span class=\"hljs-string\">'http://localhost:8080/eventbus'</span>, options);\neb2.enableReconnect(<span class=\"hljs-literal\">true</span>);\n<span class=\"hljs-comment\">// 创建处理器……</span></code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_securing_the_bridge\"><a class=\"anchor\" href=\"#_securing_the_bridge\"></a>守护连接桥</h3>\n<div class=\"paragraph\">\n<p>如果您像上面的例子一样建立连接桥但未开启守护机制，此时您试图通过该桥发送消息，\n您会发现消息神秘地失踪了。发生了什么？</p>\n</div>\n<div class=\"paragraph\">\n<p>对于大多数的应用，您恐怕不希望客户端的 JavaScript\n代码可以发送任何消息到任意服务端处理器或其他所有浏览器上。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您可能在事件总线上注册了一个服务，用于访问或删除数据。\n我们并不希望出现恶意的行为或有害的客户端能够利用该服务删除数据库中所有的数据！</p>\n</div>\n<div class=\"paragraph\">\n<p>此外，我们恐怕也不希望任意一个客户端都能监听任意一个事件总线地址。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了解决这个问题，SockJs连接桥默认会拒绝所有的消息。\n您需要告诉连接桥哪些消息是可以通过的。（例外情况是，所有的回复消息都是可以通过的）。</p>\n</div>\n<div class=\"paragraph\">\n<p>换句话说，连接桥的行为就像是配置了缺省策略为 <em>全部拒绝</em> 策略的防火墙。</p>\n</div>\n<div class=\"paragraph\">\n<p>为连接桥配置哪些消息可以通过是很简单的一件事。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过调用连接桥时传入的\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSBridgeOptions.html\">SockJSBridgeOptions</a></code> 来配置 <em>匹配</em> 规则以指定哪些输入和输出的流量是允许通过的。</p>\n</div>\n<div class=\"paragraph\">\n<p>每一个匹配规则对应一个 <code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html\">PermittedOptions</a></code> 对象：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddress-java.lang.String-\">setAddress</a></code></dt>\n<dd>\n<p>该配置规则精确地定义了消息可以被发送到哪些地址。\n如您需要通过精确地址来控制消息的话，使用该选项。</p>\n</dd>\n<dt class=\"hdlist1\"><code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddressRegex-java.lang.String-\">setAddressRegex</a></code></dt>\n<dd>\n<p>该配置规则通过正则表达式来定义消息可以被发送到哪些地址。如您需要通过正则表达式来控制消息的话，请使用这个选项。\n如果指定了 <code>address</code> ，则该选项会被忽略。</p>\n</dd>\n<dt class=\"hdlist1\"><code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setMatch-io.vertx.core.json.JsonObject-\">setMatch</a></code></dt>\n<dd>\n<p>该配置规则通过消息的结构来控制消息是否可被发送。该配置中定义的每一个字段必须在消息中存在，且值一致。\n目前仅适用于 JSON 格式的消息。</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>对于一个 <em>输入</em> 的消息（例如通过客户端 JavaScript 发送到服务器）\n当消息抵达时，Vert.x Web 会检查每一条输入许可。如果存在匹配规则，则消息可以通过。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于一个 <em>输出</em> 的消息（例如通过服务器端发送给客户端 JavaScript）\n当消息发送时，Vert.x Web 会检查每一条输出许可。如果存在匹配，则消息可以通过。</p>\n</div>\n<div class=\"paragraph\">\n<p>实际的匹配过程如下：</p>\n</div>\n<div class=\"paragraph\">\n<p>如果指定了 <code>address</code> 字段，并且消息的目标地址与 <code>address</code> <em>精确</em> 匹配，\n则匹配成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果没有指定 <code>address</code> 但指定了 <code>addressRegex</code> 字段，并且消息的目标地址匹配了 <code>address_re</code> 里的正则表达式，\n则匹配成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果指定了 <code>match</code> 字段，则消息的结构也必须匹配。\n消息需包含有 match 对象中的所有键值对，方能匹配成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\n\n\n<span class=\"hljs-comment\">// 允许客户端向地址 `demo.orderMgr` 发送消息</span>\nPermittedOptions inboundPermitted1 = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddress(<span class=\"hljs-string\">\"demo.orderMgr\"</span>);\n\n<span class=\"hljs-comment\">// 允许客户端向地址 `demo.persistor` 发送</span>\n<span class=\"hljs-comment\">// 包含有 `action` 的值为 `find`、</span>\n<span class=\"hljs-comment\">// `collecton` 的值为 `albums` 的消息。</span>\nPermittedOptions inboundPermitted2 = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddress(<span class=\"hljs-string\">\"demo.persistor\"</span>)\n  .setMatch(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"action\"</span>, <span class=\"hljs-string\">\"find\"</span>)\n    .put(<span class=\"hljs-string\">\"collection\"</span>, <span class=\"hljs-string\">\"albums\"</span>));\n\n<span class=\"hljs-comment\">// 允许 `wibble` 值为 `foo` 的消息。</span>\nPermittedOptions inboundPermitted3 = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setMatch(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"wibble\"</span>, <span class=\"hljs-string\">\"foo\"</span>));\n\n<span class=\"hljs-comment\">// 让我们定义 服务端 -&gt; 客户端 发送消息匹配规则</span>\n\n<span class=\"hljs-comment\">// 允许向客户端发送地址为 `ticker.mystock` 的消息</span>\nPermittedOptions outboundPermitted1 = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddress(<span class=\"hljs-string\">\"ticker.mystock\"</span>);\n\n<span class=\"hljs-comment\">// 允许向客户端发送地址以 `news.` 开头的消息</span>\n<span class=\"hljs-comment\">//（例如 news.europe, news.usa, 等）</span>\nPermittedOptions outboundPermitted2 = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddressRegex(<span class=\"hljs-string\">\"news\\\\..+\"</span>);\n\n<span class=\"hljs-comment\">// 让我们定义 客户端 -&gt; 客户端 发送消息匹配规则</span>\nSockJSBridgeOptions options = <span class=\"hljs-keyword\">new</span> SockJSBridgeOptions().\n  addInboundPermitted(inboundPermitted1).\n  addInboundPermitted(inboundPermitted1).\n  addInboundPermitted(inboundPermitted3).\n  addOutboundPermitted(outboundPermitted1).\n  addOutboundPermitted(outboundPermitted2);\n\n<span class=\"hljs-comment\">// 将连接桥挂载到路由器上</span>\nrouter.mountSubRouter(<span class=\"hljs-string\">\"/eventbus\"</span>, sockJSHandler.bridge(options));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_requiring_authorization_for_messages\"><a class=\"anchor\" href=\"#_requiring_authorization_for_messages\"></a>消息授权</h3>\n<div class=\"paragraph\">\n<p>连接桥可使用 Vert.x Web 的授权功能以配置消息的访问权限，\n同时支持输入和输出的消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，您可通过向上文所述的匹配规则中加入额外的字段\n以指定匹配需要哪些权限。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过 <code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setRequiredAuthority-java.lang.String-\">setRequiredAuthority</a></code>\n方法来指定对于登录用户，需要具有哪些权限才允许访问这个消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PermittedOptions inboundPermitted = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddress(<span class=\"hljs-string\">\"demo.orderService\"</span>);\n\n<span class=\"hljs-comment\">// 仅限用户已登录并且拥有权限 `place_orders`</span>\ninboundPermitted.setRequiredAuthority(<span class=\"hljs-string\">\"place_orders\"</span>);\n\nSockJSBridgeOptions options = <span class=\"hljs-keyword\">new</span> SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>用户需要登录，并被授权才能够访问消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>因此，您需要配置一个 Vert.x 认证处理器来处理登录和授权。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\n<span class=\"hljs-comment\">// 允许客户端向 `demo.orderService` 发送消息</span>\nPermittedOptions inboundPermitted = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddress(<span class=\"hljs-string\">\"demo.orderService\"</span>);\n\n<span class=\"hljs-comment\">// 仅限用户已登录并且拥有权限 `place_orders`</span>\ninboundPermitted.setRequiredAuthority(<span class=\"hljs-string\">\"place_orders\"</span>);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\n\n<span class=\"hljs-comment\">// 设置基础认证处理器：</span>\n\nrouter.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\nAuthenticationHandler basicAuthHandler = BasicAuthHandler.create(authProvider);\n\nrouter.route(<span class=\"hljs-string\">\"/eventbus/*\"</span>).handler(basicAuthHandler);\n\n<span class=\"hljs-comment\">// 将连接桥挂载到路由器上</span>\nrouter.mountSubRouter(\n  <span class=\"hljs-string\">\"/eventbus\"</span>,\n  sockJSHandler.bridge(<span class=\"hljs-keyword\">new</span> SockJSBridgeOptions()\n    .addInboundPermitted(inboundPermitted)));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_event_bus_bridge_events\"><a class=\"anchor\" href=\"#_handling_event_bus_bridge_events\"></a>Handling event bus bridge events</h3>\n<div class=\"paragraph\">\n<p>If you want to be notified when an event occurs on the bridge you can provide a handler when calling\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-io.vertx.core.Handler-\">bridge</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Whenever an event occurs on the bridge it will be passed to the handler. The event is described by an instance of\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/BridgeEvent.html\">BridgeEvent</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The event can be one of the following types:</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">SOCKET_CREATED</dt>\n<dd>\n<p>This event will occur when a new SockJS socket is created.</p>\n</dd>\n<dt class=\"hdlist1\">SOCKET_IDLE</dt>\n<dd>\n<p>This event will occur when SockJS socket is on idle for longer period of time than initially configured.</p>\n</dd>\n<dt class=\"hdlist1\">SOCKET_PING</dt>\n<dd>\n<p>This event will occur when the last ping timestamp is updated for the SockJS socket.</p>\n</dd>\n<dt class=\"hdlist1\">SOCKET_CLOSED</dt>\n<dd>\n<p>This event will occur when a SockJS socket is closed.</p>\n</dd>\n<dt class=\"hdlist1\">SEND</dt>\n<dd>\n<p>This event will occur when a message is attempted to be sent from the client to the server.</p>\n</dd>\n<dt class=\"hdlist1\">PUBLISH</dt>\n<dd>\n<p>This event will occur when a message is attempted to be published from the client to the server.</p>\n</dd>\n<dt class=\"hdlist1\">RECEIVE</dt>\n<dd>\n<p>This event will occur when a message is attempted to be delivered from the server to the client.</p>\n</dd>\n<dt class=\"hdlist1\">REGISTER</dt>\n<dd>\n<p>This event will occur when a client attempts to register a handler.</p>\n</dd>\n<dt class=\"hdlist1\">UNREGISTER</dt>\n<dd>\n<p>This event will occur when a client attempts to unregister a handler.</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>The event enables you to retrieve the type using <code><a href=\"../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#type--\">type</a></code> and\ninspect the raw message of the event using <code><a href=\"../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#getRawMessage--\">getRawMessage</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The raw message is a JSON object with the following structure:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{\n \"type\": \"send\"|\"publish\"|\"receive\"|\"register\"|\"unregister\",\n \"address\": the event bus address being sent/published/registered/unregistered\n \"body\": the body of the message\n}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The event is also an instance of <code><a href=\"../../apidocs/io/vertx/core/Promise.html\">Promise</a></code>. When you are finished handling the event you can\ncomplete the promise with <code>true</code> to enable further processing.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t want the event to be processed you can complete the promise with <code>false</code>. This is a useful feature that\nenables you to do your own filtering on messages passing through the bridge, or perhaps apply some fine grained\nauthorization or metrics.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example where we reject all messages flowing through the bridge if they contain the word \"Armadillos\".</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\n<span class=\"hljs-comment\">// Let through any messages sent to 'demo.orderMgr' from the client</span>\nPermittedOptions inboundPermitted = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddress(<span class=\"hljs-string\">\"demo.someService\"</span>);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = <span class=\"hljs-keyword\">new</span> SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted);\n\n<span class=\"hljs-comment\">// mount the bridge on the router</span>\nrouter\n  .mountSubRouter(<span class=\"hljs-string\">\"/eventbus\"</span>, sockJSHandler\n    .bridge(options, be -&gt; {\n      <span class=\"hljs-keyword\">if</span> (be.type() == BridgeEventType.PUBLISH ||\n        be.type() == BridgeEventType.RECEIVE) {\n\n        <span class=\"hljs-keyword\">if</span> (be.getRawMessage().getString(<span class=\"hljs-string\">\"body\"</span>).equals(<span class=\"hljs-string\">\"armadillos\"</span>)) {\n          <span class=\"hljs-comment\">// Reject it</span>\n          be.complete(<span class=\"hljs-keyword\">false</span>);\n          <span class=\"hljs-keyword\">return</span>;\n        }\n      }\n      be.complete(<span class=\"hljs-keyword\">true</span>);\n    }));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example how to configure and handle SOCKET_IDLE bridge event type.\nNotice <code>setPingTimeout(5000)</code> which says that if ping message doesn&#8217;t arrive from client within 5 seconds\nthen the SOCKET_IDLE bridge event would be triggered.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\n<span class=\"hljs-comment\">// Initialize SockJS handler</span>\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = <span class=\"hljs-keyword\">new</span> SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted)\n  .setPingTimeout(<span class=\"hljs-number\">5000</span>);\n\n<span class=\"hljs-comment\">// mount the bridge on the router</span>\nrouter\n  .mountSubRouter(<span class=\"hljs-string\">\"/eventbus\"</span>, sockJSHandler.bridge(options, be -&gt; {\n    <span class=\"hljs-keyword\">if</span> (be.type() == BridgeEventType.SOCKET_IDLE) {\n      <span class=\"hljs-comment\">// Do some custom handling...</span>\n    }\n\n    be.complete(<span class=\"hljs-keyword\">true</span>);\n  }));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In client side JavaScript you use the 'vertx-eventbus.js` library to create connections to the event bus and to send and receive messages:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">'https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js'</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\n<span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> EventBus(<span class=\"hljs-string\">'http://localhost:8080/eventbus'</span>, {<span class=\"hljs-string\">\"vertxbus_ping_interval\"</span>: <span class=\"hljs-number\">300000</span>}); <span class=\"hljs-comment\">// sends ping every 5 minutes.</span>\n\neb.onopen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n\n<span class=\"hljs-comment\">// set a handler to receive a message</span>\neb.registerHandler(<span class=\"hljs-string\">'some-address'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error, message</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'received a message: '</span> + <span class=\"hljs-built_in\">JSON</span>.stringify(message));\n});\n\n<span class=\"hljs-comment\">// send a message</span>\neb.send(<span class=\"hljs-string\">'some-address'</span>, {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'tim'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">587</span>});\n}\n\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The first thing the example does is to create a instance of the event bus</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> EventBus(<span class=\"hljs-string\">'http://localhost:8080/eventbus'</span>, {<span class=\"hljs-string\">\"vertxbus_ping_interval\"</span>: <span class=\"hljs-number\">300000</span>});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The 2nd parameter to the constructor tells the sockjs library to send ping message every 5 minutes. since the server\nwas configured to expect ping every 5 seconds &#8594; <code>SOCKET_IDLE</code> would be triggered on the server.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also amend the raw message, e.g. change the body. For messages that are flowing in from the client you can\nalso add headers to the message, here&#8217;s an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\n\n<span class=\"hljs-comment\">// Let through any messages sent to 'demo.orderService' from the client</span>\nPermittedOptions inboundPermitted = <span class=\"hljs-keyword\">new</span> PermittedOptions()\n  .setAddress(<span class=\"hljs-string\">\"demo.orderService\"</span>);\n\nSockJSHandler sockJSHandler = SockJSHandler.create(vertx);\nSockJSBridgeOptions options = <span class=\"hljs-keyword\">new</span> SockJSBridgeOptions()\n  .addInboundPermitted(inboundPermitted);\n\n<span class=\"hljs-comment\">// mount the bridge on the router</span>\nrouter.mountSubRouter(\n  <span class=\"hljs-string\">\"/eventbus\"</span>,\n  sockJSHandler.bridge(options, be -&gt; {\n    <span class=\"hljs-keyword\">if</span> (\n      be.type() == BridgeEventType.PUBLISH ||\n        be.type() == BridgeEventType.SEND) {\n\n      <span class=\"hljs-comment\">// Add some headers</span>\n      JsonObject headers = <span class=\"hljs-keyword\">new</span> JsonObject()\n        .put(<span class=\"hljs-string\">\"header1\"</span>, <span class=\"hljs-string\">\"val\"</span>)\n        .put(<span class=\"hljs-string\">\"header2\"</span>, <span class=\"hljs-string\">\"val2\"</span>);\n\n      JsonObject rawMessage = be.getRawMessage();\n      rawMessage.put(<span class=\"hljs-string\">\"headers\"</span>, headers);\n      be.setRawMessage(rawMessage);\n    }\n    be.complete(<span class=\"hljs-keyword\">true</span>);\n  }));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_csrf_cross_site_request_forgery\"><a class=\"anchor\" href=\"#_csrf_cross_site_request_forgery\"></a>CSRF Cross Site Request Forgery</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>CSRF or sometimes also known as XSRF is a technique by which an unauthorized site can gain your user&#8217;s private data.\nVert.x-Web includes a handler <code><a href=\"../../apidocs/io/vertx/ext/web/handler/CSRFHandler.html\">CSRFHandler</a></code> that you can use to prevent cross site\nrequest forgery requests.</p>\n</div>\n<div class=\"paragraph\">\n<p>On each get request under this handler a cookie is added to the response with a unique token. Clients are then\nexpected to return this token back in a header. Since cookies are sent it is required that the cookie handler is also\npresent on the router.</p>\n</div>\n<div class=\"paragraph\">\n<p>When developing non single page applications that rely on the User-Agent to perform the <code>POST</code> action, Headers cannot\nbe specified on HTML Forms. In order to solve this problem the header value will also be checked if and only if no\nheader was present in the Form attributes under the same name as the header, e.g.:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"/submit\"</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"POST\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"hidden\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"X-XSRF-TOKEN\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"abracadabra\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is the responsibility of the user to fill in the right value for the form field. Users who prefer to use an HTML\nonly solution can fill this value by fetching the the token value from the routing context under the key <code>X-XSRF-TOKEN</code>\nor the header name they have chosen during the instantiation of the <code>CSRFHandler</code> object.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(CSRFHandler.create(vertx, <span class=\"hljs-string\">\"abracadabra\"</span>));\nrouter.route().handler(ctx -&gt; {\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Note that this handler is session aware. If there is a session available the form parameter or header might be omited\nduring the <code>POST</code> action as it will be read from the session. This also implies that tokens will only be regenerated\non session upgrades.</p>\n</div>\n<div class=\"paragraph\">\n<p>Note, for extra security users are advised to rotate the key that signs the tokens. This can be done online by replacing\nthe handler, or by restarting the application with a new configuration. Clickjacking could still affect applications. If\nthis is a critical application consider setting the header: <code>X-Frame-Options</code> as described in:\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\" class=\"bare\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options</a></p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_ajax\"><a class=\"anchor\" href=\"#_using_ajax\"></a>Using AJAX</h3>\n<div class=\"paragraph\">\n<p>When accessing protected routes via ajax both the csrf token will need to be passed in the request. Typically this is\ndone using a request header, as adding a request header can typically be done at a central location easily without\npayload modification.</p>\n</div>\n<div class=\"paragraph\">\n<p>The CSRF token is obtained from the server side context under the key <code>X-XSRF-TOKEN</code> (unless you specified a different\nname). This token needs to be exposed to the client-side, typically by including it in the initial page content. One\npossibility is to store it in an HTML &lt;meta&gt; tag, where value can then be retrieved at the time of the request by\nJavaScript.</p>\n</div>\n<div class=\"paragraph\">\n<p>The following can be included in your view (handlebar example below):</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"csrf-token\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"${X-XSRF-TOKEN}\"</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The following is an example of using the Fetch API to post to the /process route with the CSRF token from the &lt;meta&gt;\ntag on the page:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-js\" data-lang=\"js\"><span class=\"hljs-comment\">// Read the CSRF token from the &lt;meta&gt; tag</span>\n<span class=\"hljs-keyword\">var</span> token = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'meta[name=\"csrf-token\"]'</span>).getAttribute(<span class=\"hljs-string\">'content'</span>)\n\n<span class=\"hljs-comment\">// Make a request using the Fetch API</span>\nfetch(<span class=\"hljs-string\">'/process'</span>, {\n <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">'same-origin'</span>, <span class=\"hljs-comment\">// &lt;-- includes cookies in the request</span>\n <span class=\"hljs-attr\">headers</span>: {\n   <span class=\"hljs-string\">'X-XSRF-TOKEN'</span>: token <span class=\"hljs-comment\">// &lt;-- is the csrf token as a header</span>\n },\n <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>,\n <span class=\"hljs-attr\">body</span>: {\n   <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'value'</span>\n }\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_hsts_handler\"><a class=\"anchor\" href=\"#_hsts_handler\"></a>HSTS Handler</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>HTTP Strict Transport Security (HSTS) is a web security policy mechanism that helps to protect websites against\nman-in-the-middle attacks such as protocol downgrade attacks and cookie hijacking. It allows web servers to declare that\nweb browsers (or other complying user agents) should automatically interact with it using only HTTPS connections, which\nprovide Transport Layer Security (TLS/SSL), unlike the insecure HTTP used alone. HSTS is an IETF standards track\nprotocol and is specified in RFC 6797.</p>\n</div>\n<div class=\"paragraph\">\n<p>This handler will configure the correct header for your application in a single step:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(HSTSHandler.create());</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_csp_handler\"><a class=\"anchor\" href=\"#_csp_handler\"></a>CSP Handler</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of\nattacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from\ndata theft to site defacement to distribution of malware.</p>\n</div>\n<div class=\"paragraph\">\n<p>CSP is designed to be fully backward compatible. Browsers that don&#8217;t support it still work with servers that\nimplement it, and vice-versa: browsers that don&#8217;t support CSP simply ignore it, functioning as usual, defaulting to\nthe standard same-origin policy for web content. If the site doesn&#8217;t offer the CSP header, browsers likewise use the\nstandard same-origin policy.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(\n  CSPHandler.create()\n    .addDirective(<span class=\"hljs-string\">\"default-src\"</span>, <span class=\"hljs-string\">\"*.trusted.com\"</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_xframe_handler\"><a class=\"anchor\" href=\"#_xframe_handler\"></a>XFrame Handler</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code>X-Frame-Options</code> HTTP response header can be used to indicate whether or not a browser should be allowed to render\na page in a <code>frame</code>, <code>iframe</code>, <code>embed</code> or <code>object</code>. Sites can use this to avoid click-jacking attacks, by ensuring that\ntheir content is not embedded into other sites.</p>\n</div>\n<div class=\"paragraph\">\n<p>The added security is provided only if the user accessing the document is using a browser that supports\n<code>X-Frame-Options</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you specify <code>DENY</code>, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to\ndo so will fail when loaded from the same site. On the other hand, if you specify <code>SAMEORIGIN</code>, you can still use the\npage in a frame as long as the site including it in a frame is the same as the one serving the page.</p>\n</div>\n<div class=\"paragraph\">\n<p>This handler will configure the correct header for your application in a single step:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(XFrameHandler.create(XFrameHandler.DENY));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_oauth2authhandler_handler\"><a class=\"anchor\" href=\"#_oauth2authhandler_handler\"></a>OAuth2AuthHandler Handler</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code>OAuth2AuthHandler</code> allows quick setup of secure routes using the OAuth2 protocol. This handler simplifies the\nauthCode flow. An example of using it to protect some resource and authenticate with GitHub can be implemented as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OAuth2Auth authProvider = GithubAuth\n  .create(vertx, <span class=\"hljs-string\">\"CLIENT_ID\"</span>, <span class=\"hljs-string\">\"CLIENT_SECRET\"</span>);\n\n<span class=\"hljs-comment\">// create a oauth2 handler on our running server</span>\n<span class=\"hljs-comment\">// the second argument is the full url to the</span>\n<span class=\"hljs-comment\">// callback as you entered in your provider management console.</span>\nOAuth2AuthHandler oauth2 = OAuth2AuthHandler\n  .create(vertx, authProvider, <span class=\"hljs-string\">\"https://myserver.com/callback\"</span>);\n\n<span class=\"hljs-comment\">// setup the callback handler for receiving the GitHub callback</span>\noauth2.setupCallback(router.route());\n\n<span class=\"hljs-comment\">// protect everything under /protected</span>\nrouter.route(<span class=\"hljs-string\">\"/protected/*\"</span>).handler(oauth2);\n<span class=\"hljs-comment\">// mount some handler under the protected zone</span>\nrouter\n  .route(<span class=\"hljs-string\">\"/protected/somepage\"</span>)\n  .handler(ctx -&gt; ctx.response().end(<span class=\"hljs-string\">\"Welcome to the protected resource!\"</span>));\n\n<span class=\"hljs-comment\">// welcome page</span>\nrouter\n  .get(<span class=\"hljs-string\">\"/\"</span>)\n  .handler(ctx -&gt; ctx.response()\n    .putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/html\"</span>)\n    .end(<span class=\"hljs-string\">\"Hello&lt;br&gt;&lt;a href=\\\"/protected/somepage\\\"&gt;Protected by Github&lt;/a&gt;\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The OAuth2AuthHandler will setup a proper callback OAuth2 handler so the user does not need to deal with validation\nof the authority server response. It is quite important to know that authority server responses are only valid once,\nthis means that if a client issues a reload of the callback URL it will be asserted as a invalid request since the\nvalidation will fail.</p>\n</div>\n<div class=\"paragraph\">\n<p>A rule of thumb is once a valid callback is executed issue a client side redirect to a protected resource. This\nredirect should also create a session cookie (or other session mechanism) so the user is not required to authenticate\nfor every request.</p>\n</div>\n<div class=\"paragraph\">\n<p>Due to the nature of OAuth2 spec there are slight changes required in order to use other OAuth2 providers but\nvertx-auth provides you with many out of the box implementations:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Azure Active Directory <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/AzureADAuth.html\">AzureADAuth</a></code></p>\n</li>\n<li>\n<p>Box.com <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/BoxAuth.html\">BoxAuth</a></code></p>\n</li>\n<li>\n<p>Dropbox <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/DropboxAuth.html\">DropboxAuth</a></code></p>\n</li>\n<li>\n<p>Facebook <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FacebookAuth.html\">FacebookAuth</a></code></p>\n</li>\n<li>\n<p>Foursquare <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FoursquareAuth.html\">FoursquareAuth</a></code></p>\n</li>\n<li>\n<p>Github <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GithubAuth.html\">GithubAuth</a></code></p>\n</li>\n<li>\n<p>Google <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GoogleAuth.html\">GoogleAuth</a></code></p>\n</li>\n<li>\n<p>Instagram <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/InstagramAuth.html\">InstagramAuth</a></code></p>\n</li>\n<li>\n<p>Keycloak <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/KeycloakAuth.html\">KeycloakAuth</a></code></p>\n</li>\n<li>\n<p>LinkedIn <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/LinkedInAuth.html\">LinkedInAuth</a></code></p>\n</li>\n<li>\n<p>Mailchimp <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/MailchimpAuth.html\">MailchimpAuth</a></code></p>\n</li>\n<li>\n<p>Salesforce <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SalesforceAuth.html\">SalesforceAuth</a></code></p>\n</li>\n<li>\n<p>Shopify <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/ShopifyAuth.html\">ShopifyAuth</a></code></p>\n</li>\n<li>\n<p>Soundcloud <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SoundcloudAuth.html\">SoundcloudAuth</a></code></p>\n</li>\n<li>\n<p>Stripe <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/StripeAuth.html\">StripeAuth</a></code></p>\n</li>\n<li>\n<p>Twitter <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/TwitterAuth.html\">TwitterAuth</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>However if you&#8217;re using an unlisted provider you can still do it using the base API like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OAuth2Auth authProvider = OAuth2Auth.create(vertx, <span class=\"hljs-keyword\">new</span> OAuth2Options()\n  .setClientID(<span class=\"hljs-string\">\"CLIENT_ID\"</span>)\n  .setClientSecret(<span class=\"hljs-string\">\"CLIENT_SECRET\"</span>)\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setSite(<span class=\"hljs-string\">\"https://accounts.google.com\"</span>)\n  .setTokenPath(<span class=\"hljs-string\">\"https://www.googleapis.com/oauth2/v3/token\"</span>)\n  .setAuthorizationPath(<span class=\"hljs-string\">\"/o/oauth2/auth\"</span>));\n\n<span class=\"hljs-comment\">// create a oauth2 handler on our domain: \"http://localhost:8080\"</span>\nOAuth2AuthHandler oauth2 = OAuth2AuthHandler\n  .create(vertx, authProvider, <span class=\"hljs-string\">\"http://localhost:8080\"</span>);\n\n<span class=\"hljs-comment\">// these are the scopes</span>\noauth2.withScope(<span class=\"hljs-string\">\"profile\"</span>);\n\n<span class=\"hljs-comment\">// setup the callback handler for receiving the Google callback</span>\noauth2.setupCallback(router.get(<span class=\"hljs-string\">\"/callback\"</span>));\n\n<span class=\"hljs-comment\">// protect everything under /protected</span>\nrouter.route(<span class=\"hljs-string\">\"/protected/*\"</span>).handler(oauth2);\n<span class=\"hljs-comment\">// mount some handler under the protected zone</span>\nrouter\n  .route(<span class=\"hljs-string\">\"/protected/somepage\"</span>)\n  .handler(ctx -&gt; ctx.response().end(<span class=\"hljs-string\">\"Welcome to the protected resource!\"</span>));\n\n<span class=\"hljs-comment\">// welcome page</span>\nrouter\n  .get(<span class=\"hljs-string\">\"/\"</span>)\n  .handler(ctx -&gt; ctx.response()\n    .putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"text/html\"</span>)\n    .end(<span class=\"hljs-string\">\"Hello&lt;br&gt;&lt;a href=\\\"/protected/somepage\\\"&gt;Protected by Google&lt;/a&gt;\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You will need to provide all the details of your provider manually but the end result is the same.</p>\n</div>\n<div class=\"paragraph\">\n<p>The handler will pin your application the the configured callback url. The usage is simple as providing the handler\na route instance and all setup will be done for you. In a typical use case your provider will ask you what is the\ncallback url to your application, your then enter a url like: <code><a href=\"https://myserver.com/callback\" class=\"bare\">https://myserver.com/callback</a></code>. This is the second\nargument to the handler now you just need to set it up. To make it easier to the end user all you need to do is call\nthe setupCallback method.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is how you pin your handler to the server <code><a href=\"https://myserver.com:8447/callback\" class=\"bare\">https://myserver.com:8447/callback</a></code>. Note that the port number is not\nmandatory for the default values, 80 for http, 443 for https.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OAuth2AuthHandler oauth2 = OAuth2AuthHandler\n  .create(vertx, provider, <span class=\"hljs-string\">\"https://myserver.com:8447/callback\"</span>);\n\n<span class=\"hljs-comment\">// now allow the handler to setup the callback url for you</span>\noauth2.setupCallback(router.route());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the example the route object is created inline by <code>Router.route()</code> however if you want to have full control of the\norder the handler is called (for example you want it to be called as soon as possible in the chain) you can always\ncreate the route object before and pass it as a reference to this method.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_a_real_world_example\"><a class=\"anchor\" href=\"#_a_real_world_example\"></a>A real world example</h3>\n<div class=\"paragraph\">\n<p>Up to now you have learned how to use the Oauth2 Handler however you will notice that for each request you will need\nto authenticate. This is because the handler has no state and there was no state management applied in the examples.</p>\n</div>\n<div class=\"paragraph\">\n<p>Although having no state is recommended for API facing endpoints, for example, using JWT (we will cover those later)\nfor user facing endpoinst we can keep the authentication result stored in the session. For this to work we would\nneed an application like the following snippet:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OAuth2Auth authProvider =\n  GithubAuth\n    .create(vertx, <span class=\"hljs-string\">\"CLIENTID\"</span>, <span class=\"hljs-string\">\"CLIENT SECRET\"</span>);\n<span class=\"hljs-comment\">// We need a user session handler too to make sure</span>\n<span class=\"hljs-comment\">// the user is stored in the session between requests</span>\nrouter.route()\n  .handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n<span class=\"hljs-comment\">// we now protect the resource under the path \"/protected\"</span>\nrouter.route(<span class=\"hljs-string\">\"/protected\"</span>).handler(\n  OAuth2AuthHandler.create(vertx, authProvider)\n    <span class=\"hljs-comment\">// we now configure the oauth2 handler, it will</span>\n    <span class=\"hljs-comment\">// setup the callback handler</span>\n    <span class=\"hljs-comment\">// as expected by your oauth2 provider.</span>\n    .setupCallback(router.route(<span class=\"hljs-string\">\"/callback\"</span>))\n    <span class=\"hljs-comment\">// for this resource we require that users have</span>\n    <span class=\"hljs-comment\">// the authority to retrieve the user emails</span>\n    .withScope(<span class=\"hljs-string\">\"user:email\"</span>)\n);\n<span class=\"hljs-comment\">// Entry point to the application, this will render</span>\n<span class=\"hljs-comment\">// a custom template.</span>\nrouter.get(<span class=\"hljs-string\">\"/\"</span>).handler(ctx -&gt; ctx.response()\n  .putHeader(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"text/html\"</span>)\n  .end(\n    <span class=\"hljs-string\">\"&lt;html&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"  &lt;body&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"    &lt;p&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"      Well, hello there!\\n\"</span> +\n      <span class=\"hljs-string\">\"    &lt;/p&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"    &lt;p&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"      We're going to the protected resource, if there is no\\n\"</span> +\n      <span class=\"hljs-string\">\"      user in the session we will talk to the GitHub API. Ready?\\n\"</span> +\n      <span class=\"hljs-string\">\"      &lt;a href=\\\"/protected\\\"&gt;Click here&lt;/a&gt; to begin!&lt;/a&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"    &lt;/p&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"    &lt;p&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"      &lt;b&gt;If that link doesn't work&lt;/b&gt;, remember to provide your\\n\"</span> +\n      <span class=\"hljs-string\">\"      own &lt;a href=\\\"https://github.com/settings/applications/new\\\"&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"      Client ID&lt;/a&gt;!\\n\"</span> +\n      <span class=\"hljs-string\">\"    &lt;/p&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"  &lt;/body&gt;\\n\"</span> +\n      <span class=\"hljs-string\">\"&lt;/html&gt;\"</span>));\n<span class=\"hljs-comment\">// The protected resource</span>\nrouter.get(<span class=\"hljs-string\">\"/protected\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// at this moment your user object should contain the info</span>\n  <span class=\"hljs-comment\">// from the Oauth2 response, since this is a protected resource</span>\n  <span class=\"hljs-comment\">// as specified above in the handler config the user object is never null</span>\n  User user = ctx.user();\n  <span class=\"hljs-comment\">// just dump it to the client for demo purposes</span>\n  ctx.response().end(user.toString());\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mixing_oauth2_and_jwt\"><a class=\"anchor\" href=\"#_mixing_oauth2_and_jwt\"></a>Mixing OAuth2 and JWT</h3>\n<div class=\"paragraph\">\n<p>Some providers use JWT tokens as access tokens, this is a feature of <a href=\"https://tools.ietf.org/html/rfc6750\">RFC6750</a>\nand can be quite useful when one wants to mix client based authentication and API authorization. For example say that\nyou have a application that provides some protected HTML documents but you also want it to be available for API&#8217;s to\nconsume. In this case an API cannot easily perform the redirect handshake required by OAuth2 but can use a Token\nprovided before hand.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is handled automatically by the handler as long as the provider is configured to support JWTs.</p>\n</div>\n<div class=\"paragraph\">\n<p>In real life this means that your API&#8217;s can access your protected resources using the header <code>Authorization</code> with the\nvalue <code>Bearer BASE64_ACCESS_TOKEN</code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_webauthn\"><a class=\"anchor\" href=\"#_webauthn\"></a>WebAuthn</h3>\n<div class=\"paragraph\">\n<p>Our online existence relies on an outdated and fragile idea of passwords. The password is what lies between a malicious\nuser and your bank account or social media accounts. Passwords are hard to maintain; it&#8217;s hard to store them on the\nserver (passwords get stolen). They&#8217;re hard to memorize, or not tell to others (phishing attacks).</p>\n</div>\n<div class=\"paragraph\">\n<p>But there&#8217;s a better way! A passwordless world, and it is a standard by W3C and FIDO Alliance running on your browser.</p>\n</div>\n<div class=\"paragraph\">\n<p>WebAuthn is an API that allows servers to register and authenticate users using public-key cryptography instead of a\npassword, an API that uses cryptography in a user-accessible way with the help of an authentication device, for example\na yubikey token, or your mobile phone.</p>\n</div>\n<div class=\"paragraph\">\n<p>The protocol requires at least the first callback to be mounted on the router:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><code>/webauthn/response</code> the callback used to perform all the validations</p>\n</li>\n<li>\n<p><code>/webauthn/login</code> the endpoint to allow users to start the login flow (optional, but without it it won&#8217;t be able to login)</p>\n</li>\n<li>\n<p><code>/webauthn/register</code> the endpoint to allow users to register a new identificator (optional, if the data is already stored this endpoint is not needed)</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>An example of a protected application is:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebAuthn webAuthn = WebAuthn.create(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> WebAuthnOptions()\n    .setRelyingParty(<span class=\"hljs-keyword\">new</span> RelyingParty().setName(<span class=\"hljs-string\">\"Vert.x WebAuthN Demo\"</span>))\n    <span class=\"hljs-comment\">// What kind of authentication do you want? do you care?</span>\n    <span class=\"hljs-comment\">// # security keys</span>\n    .setAuthenticatorAttachment(AuthenticatorAttachment.CROSS_PLATFORM)\n    <span class=\"hljs-comment\">// # fingerprint</span>\n    .setAuthenticatorAttachment(AuthenticatorAttachment.PLATFORM)\n    .setUserVerification(UserVerification.REQUIRED))\n  <span class=\"hljs-comment\">// where to load the credentials from?</span>\n  .authenticatorFetcher(fetcher)\n  <span class=\"hljs-comment\">// update the state of an authenticator</span>\n  .authenticatorUpdater(updater);\n\n<span class=\"hljs-comment\">// parse the BODY</span>\nrouter.post()\n  .handler(BodyHandler.create());\n<span class=\"hljs-comment\">// add a session handler</span>\nrouter.route()\n  .handler(SessionHandler\n    .create(LocalSessionStore.create(vertx)));\n\n<span class=\"hljs-comment\">// security handler</span>\nWebAuthnHandler webAuthNHandler = WebAuthnHandler.create(webAuthn)\n  .setOrigin(<span class=\"hljs-string\">\"https://192.168.178.74.xip.io:8443\"</span>)\n  <span class=\"hljs-comment\">// required callback</span>\n  .setupCallback(router.post(<span class=\"hljs-string\">\"/webauthn/response\"</span>))\n  <span class=\"hljs-comment\">// optional register callback</span>\n  .setupCredentialsCreateCallback(router.post(<span class=\"hljs-string\">\"/webauthn/register\"</span>))\n  <span class=\"hljs-comment\">// optional login callback</span>\n  .setupCredentialsGetCallback(router.post(<span class=\"hljs-string\">\"/webauthn/login\"</span>));\n\n<span class=\"hljs-comment\">// secure the remaining routes</span>\nrouter.route().handler(webAuthNHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The application is not secure on the backend side but there is some code needed to be performed on the client side. A bit\nof boilerplate is required, take these 2 functions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-comment\">/**\n* Converts PublicKeyCredential into serialised JSON\n* <span class=\"hljs-doctag\">@param  <span class=\"hljs-type\">{Object}</span> <span class=\"hljs-variable\">pubKeyCred</span></span>\n* <span class=\"hljs-doctag\">@return <span class=\"hljs-type\">{Object}</span>            </span>- JSON encoded publicKeyCredential\n*/</span>\n<span class=\"hljs-keyword\">var</span> publicKeyCredentialToJSON = <span class=\"hljs-function\">(<span class=\"hljs-params\">pubKeyCred</span>) =&gt;</span> {\n <span class=\"hljs-keyword\">if</span> (pubKeyCred <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>) {\n   <span class=\"hljs-keyword\">let</span> arr = [];\n   <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> pubKeyCred) { arr.push(publicKeyCredentialToJSON(i)) }\n\n   <span class=\"hljs-keyword\">return</span> arr\n }\n\n <span class=\"hljs-keyword\">if</span> (pubKeyCred <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">ArrayBuffer</span>) {\n   <span class=\"hljs-keyword\">return</span> base64url.encode(pubKeyCred)\n }\n\n <span class=\"hljs-keyword\">if</span> (pubKeyCred <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span>) {\n   <span class=\"hljs-keyword\">let</span> obj = {};\n\n   <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> pubKeyCred) {\n     obj[key] = publicKeyCredentialToJSON(pubKeyCred[key])\n   }\n\n   <span class=\"hljs-keyword\">return</span> obj\n }\n\n <span class=\"hljs-keyword\">return</span> pubKeyCred\n};\n\n<span class=\"hljs-comment\">/**\n* Generate secure random buffer\n* @param  {Number} len - Length of the buffer (default 32 bytes)\n* @return {Uint8Array} - random string\n*/</span>\n<span class=\"hljs-keyword\">var</span> generateRandomBuffer = <span class=\"hljs-function\">(<span class=\"hljs-params\">len</span>) =&gt;</span> {\n len = len || <span class=\"hljs-number\">32</span>;\n\n <span class=\"hljs-keyword\">let</span> randomBuffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8Array</span>(len);\n <span class=\"hljs-built_in\">window</span>.crypto.getRandomValues(randomBuffer);\n\n <span class=\"hljs-keyword\">return</span> randomBuffer\n};\n\n<span class=\"hljs-comment\">/**\n* Decodes arrayBuffer required fields.\n*/</span>\n<span class=\"hljs-keyword\">var</span> preformatMakeCredReq = <span class=\"hljs-function\">(<span class=\"hljs-params\">makeCredReq</span>) =&gt;</span> {\n makeCredReq.challenge = base64url.decode(makeCredReq.challenge);\n makeCredReq.user.id = base64url.decode(makeCredReq.user.id);\n\n <span class=\"hljs-keyword\">return</span> makeCredReq\n};\n\n<span class=\"hljs-comment\">/**\n* Decodes arrayBuffer required fields.\n*/</span>\n<span class=\"hljs-keyword\">var</span> preformatGetAssertReq = <span class=\"hljs-function\">(<span class=\"hljs-params\">getAssert</span>) =&gt;</span> {\n getAssert.challenge = base64url.decode(getAssert.challenge);\n\n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> allowCred <span class=\"hljs-keyword\">of</span> getAssert.allowCredentials) {\n   allowCred.id = base64url.decode(allowCred.id)\n }\n\n <span class=\"hljs-keyword\">return</span> getAssert\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>These functions will help you with the interaction with the server. Nothing more. Let&#8217;s start by login in a user:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-comment\">// using the functions defined before...</span>\ngetGetAssertionChallenge({<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'your-user-name'</span>})\n.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// base64 must be decoded to a JavaScript Buffer</span>\n <span class=\"hljs-keyword\">let</span> publicKey = preformatGetAssertReq(response);\n <span class=\"hljs-comment\">// the response is then passed to the browser</span>\n <span class=\"hljs-comment\">// to generate an assertion by interacting with your token/phone/etc...</span>\n <span class=\"hljs-keyword\">return</span> navigator.credentials.get({publicKey})\n})\n.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// convert response buffers to base64 and json</span>\n <span class=\"hljs-keyword\">let</span> getAssertionResponse = publicKeyCredentialToJSON(response);\n <span class=\"hljs-comment\">// send information to server</span>\n <span class=\"hljs-keyword\">return</span> sendWebAuthnResponse(getAssertionResponse)\n})\n.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// success!</span>\n alert(<span class=\"hljs-string\">'Login success'</span>)\n})\n.catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> alert(error));\n\n<span class=\"hljs-comment\">// utility functions</span>\n\n<span class=\"hljs-keyword\">let</span> sendWebAuthnResponse = <span class=\"hljs-function\">(<span class=\"hljs-params\">body</span>) =&gt;</span> {\n <span class=\"hljs-keyword\">return</span> fetch(<span class=\"hljs-string\">'/webauthn/response'</span>, {\n   <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>,\n   <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">'include'</span>,\n   <span class=\"hljs-attr\">headers</span>: {\n     <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span>\n   },\n   <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(body)\n })\n   .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">if</span> (!response.ok) {\n       <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Server responded with error: <span class=\"hljs-subst\">${response.statusText}</span>`</span>);\n     }\n     <span class=\"hljs-keyword\">return</span> response;\n   })\n};\n\n<span class=\"hljs-keyword\">let</span> getGetAssertionChallenge = <span class=\"hljs-function\">(<span class=\"hljs-params\">formBody</span>) =&gt;</span> {\n <span class=\"hljs-keyword\">return</span> fetch(<span class=\"hljs-string\">'/webauthn/login'</span>, {\n   <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>,\n   <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">'include'</span>,\n   <span class=\"hljs-attr\">headers</span>: {\n     <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span>\n   },\n   <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(formBody)\n })\n   .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">if</span> (!response.ok) {\n       <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Server responded with error: <span class=\"hljs-subst\">${response.statusText}</span>`</span>);\n     }\n     <span class=\"hljs-keyword\">return</span> response;\n   })\n   .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> response.json())\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The example above already covered 66% of the API, 2 out fo 3 endpoints where covered. The final endpoint is the user\nregistration. User registration is the process of enrolling a new key into the server credential store and map to a user,\nand of course on the client side a private key was created and associated with the server but this key never left the\nhardware token or your phone security chip.</p>\n</div>\n<div class=\"paragraph\">\n<p>To register a user and reusing most of the functions already defined above:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-comment\">/* Handle for register form submission */</span>\ngetMakeCredentialsChallenge({<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'myalias'</span>, <span class=\"hljs-attr\">displayName</span>: <span class=\"hljs-string\">'Paulo Lopes'</span>})\n.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// convert challenge &amp; id to buffer and perform register</span>\n <span class=\"hljs-keyword\">let</span> publicKey = preformatMakeCredReq(response);\n <span class=\"hljs-comment\">// create a new secure key pair</span>\n <span class=\"hljs-keyword\">return</span> navigator.credentials.create({publicKey})\n})\n.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// convert response from buffer to json</span>\n <span class=\"hljs-keyword\">let</span> makeCredResponse = <span class=\"hljs-built_in\">window</span>.publicKeyCredentialToJSON(response);\n <span class=\"hljs-comment\">// send to server to confirm the user</span>\n <span class=\"hljs-keyword\">return</span> sendWebAuthnResponse(makeCredResponse)\n})\n.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n alert(<span class=\"hljs-string\">'Registration completed'</span>)\n})\n.catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> alert(error));\n\n<span class=\"hljs-comment\">// utility functions</span>\n\n<span class=\"hljs-keyword\">let</span> getMakeCredentialsChallenge = <span class=\"hljs-function\">(<span class=\"hljs-params\">formBody</span>) =&gt;</span> {\n <span class=\"hljs-keyword\">return</span> fetch(<span class=\"hljs-string\">'/webauthn/register'</span>, {\n   <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>,\n   <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">'include'</span>,\n   <span class=\"hljs-attr\">headers</span>: {\n     <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span>\n   },\n   <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(formBody)\n })\n   .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">if</span> (!response.ok) {\n       <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Server responded with error: <span class=\"hljs-subst\">${response.statusText}</span>`</span>);\n     }\n     <span class=\"hljs-keyword\">return</span> response;\n   })\n   .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> response.json())\n};</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nDue to the secure nature of the API browsers will not allow you to use this API on plain text HTTP. All requests\nmust go over HTTPS.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nWebAuthN requires HTTPS with a working TLS certificate, you can use self signed certiticates too during\ndevelopment.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_http_method_overriding\"><a class=\"anchor\" href=\"#_handling_http_method_overriding\"></a>Handling HTTP Method overriding</h3>\n<div class=\"paragraph\">\n<p>Many companies and other services impose limitations to the REST HTTP methods they allow to the outside world. Some are lax by allowing any method, most are restricted by allowing only a small-but-decent set and some only allow GET and POST. The reasons for such restritions varies: browser or client limitations or a really strict corporate firewalls. Web services with only GET and POST does not express well the REST ideology. PUT, DELETE, OPTIONS, among others are quite useful to specify what do to to a resource. To deal with it, it was created the X-HTTP-METHOD-OVERRIDE HTTP header as a workaround.</p>\n</div>\n<div class=\"paragraph\">\n<p>By sending a request with GET/POST and which method the request should truly process inside the X-HTTP-METHOD-OVERRIDE HTTP header, the server should recognize the header and redirect to the appropriate method.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x allows one to do so, simply by:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(MethodOverrideHandler.create());\n\nrouter.route(HttpMethod.GET, <span class=\"hljs-string\">\"/\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do GET stuff...</span>\n});\n\nrouter.route(HttpMethod.POST, <span class=\"hljs-string\">\"/\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do POST stuff...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Since it will redirect the request, it is wise to avoid firing request handlers unnecessarily, so it is better to add the MethodOverrideHandler as the first handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Also, a word of caution: THIS MIGHT BECOME AN ATTACK VECTOR FOR ILL-INTENTIONED PEOPLE!</p>\n</div>\n<div class=\"paragraph\">\n<p>To mitigate such a problem, the MethodOverrideHandler comes with a Safe-Downgrade Policy by default. This policy says that the method contained in X-HTTP-METHOD-OVERRIDE can override the original one if:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>the overriding method is idempotent; or</p>\n</li>\n<li>\n<p>the overriding method is safe and the method to be overrided is NOT idempotent; or</p>\n</li>\n<li>\n<p>the method to be overrided is not safe.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Although we do NOT recommend, Vert.x will not force you to anything. If it is your desire to allow any overriding, then:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(MethodOverrideHandler.create(<span class=\"hljs-keyword\">false</span>));\n\nrouter.route(HttpMethod.GET, <span class=\"hljs-string\">\"/\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do GET stuff...</span>\n});\n\nrouter.route(HttpMethod.POST, <span class=\"hljs-string\">\"/\"</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do POST stuff...</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}