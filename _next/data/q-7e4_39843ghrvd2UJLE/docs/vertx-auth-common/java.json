{"pageProps":{"slug":"vertx-auth-common/java","title":"通用认证和授权","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_basic_concepts\">基本概念</a></li>\n<li><a href=\"#_authentication\">认证（Authentication）</a></li>\n<li><a href=\"#_authorization\">授权（Authorization）</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_listing_authorizations\">列出授权</a></li>\n<li><a href=\"#_the_user_principal_and_attributes\">用户主体和属性</a></li>\n</ul>\n</li>\n<li><a href=\"#_creating_your_own_authentication_or_authorization_provider_implementation\">创建自定义的身份认证或授权提供程序</a></li>\n<li><a href=\"#_pseudo_random_number_generator\">伪随机数生成器（PRNG）</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_sharing_pseudo_random_number_generator\">共享伪随机数生成器</a></li>\n</ul>\n</li>\n<li><a href=\"#_working_with_keys\">使用密钥</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_json_web_keys\">JSON Web Keys（JWK）</a></li>\n</ul>\n</li>\n<li><a href=\"#_chaining_authentication_providers\">链接多个身份验证提供程序</a></li>\n</ul>\n</div>","contents":"<h1 id=\"_common_authentication_and_authorization\">通用认证和授权</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>该Vert.x组件提供了用于身份验证和授权的接口，\n这些接口可以从Vert.x应用程序中使用，并且可以由其他提供程序支持。</p>\n</div>\n<div class=\"paragraph\">\n<p>vertx-web同样也使用了Vert.x auth来处理其身份验证和授权。</p>\n</div>\n<div class=\"paragraph\">\n<p>要使用这个项目，在构建描述的 <em>dependencies</em> 部分添加以下依赖项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在 <code>pom.xml</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-auth-common<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在 <code>build.gradle</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-auth-common:4.0.2'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_basic_concepts\"><a class=\"anchor\" href=\"#_basic_concepts\"></a>基本概念</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><em>(Authentication)认证</em> 是指验证用户的身份。</p>\n</div>\n<div class=\"paragraph\">\n<p><em>(Authorization)授权</em> 是指验证用户是否有权执行特定任务。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了支持多种授权模型以及保持其灵活性, 所有的授权操作都在\n<code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/Authorization.html\">Authorization</a></code> 上进行。</p>\n</div>\n<div class=\"paragraph\">\n<p>在某些情况下，一个授权可能代表一种权限，\n比如，访问所有打印机或某个打印机的权限。\n在其他情况下，授权可能是一个角色（Role）（例如：<code>admin</code>，<code>manager</code> 等）。\n为了提供少量实现，可以使用下面这些工厂方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/RoleBasedAuthorization.html\">RoleBasedAuthorization</a></code> 基于角色（Role）的授权。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/PermissionBasedAuthorization.html\">PermissionBasedAuthorization</a></code> 基于权限（Permission）的授权。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/WildcardPermissionBasedAuthorization.html\">WildcardPermissionBasedAuthorization</a></code> 以通配符匹配的基于角色的授权。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AndAuthorization.html\">AndAuthorization</a></code> 逻辑授权。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/OrAuthorization.html\">OrAuthorization</a></code> 逻辑授权。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/NotAuthorization.html\">NotAuthorization</a></code> 逻辑授权。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这组授权代表任何类型的授权，例如：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>基于角色的授权</p>\n</li>\n<li>\n<p>基于权限的授权</p>\n</li>\n<li>\n<p>逻辑授权（与，或，非）</p>\n</li>\n<li>\n<p>基于时间的授权（即：允许访问该月的最后5天，从上午8点到上午10点，依此类推）</p>\n</li>\n<li>\n<p>基于上下文的授权（即：如果IP地址为&#8217;xxx.xxx.xxx.xxx'，则允许访问）</p>\n</li>\n<li>\n<p>基于自定义的授权（即：基于特定于应用程序的脚本或硬编码代码）</p>\n</li>\n<li>\n<p>等等</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>要找到你期望的特定 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code> 实现，\n请查阅该身份验证提供程序的文档。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authentication\"><a class=\"anchor\" href=\"#_authentication\"></a>认证（Authentication）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要对用户进行身份认证，请使用 <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html#authenticate-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">authenticate</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>第一个参数是一个JSON对象，其中包含身份验证信息。实际包含的内容取决于具体的实现方式。\n对于基于用户名/密码的简单身份验证，它可能包含以下内容：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{\n \"username\": \"tim\"\n \"password\": \"mypassword\"\n}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于基于JWT token或OAuth bearer token的实现，它可能包含token信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>身份验证是异步进行的，并且结果会通过参数中提供的handler传递给用户。\n异步结果包含一个 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html\">User</a></code> 实例，\n该实例代表已认证的用户。</p>\n</div>\n<div class=\"paragraph\">\n<p>上述得到的认证用户对象不包含该对象被授权的授权信息或上下文。\n授权与身份认证分离的原因是，\n身份认证和授权是两个区分的操作，不需要在同一程序上执行。\n一个简单的示例是，使用 <code>OAuth2.0</code> 进行身份认证的用户可以使用 <code>JWT</code> 授权提供者为给定的权限匹配令牌，\n但其他情况也适用，例如使用 <code>LDAP</code> 进行身份认证和使用 <code>MongoDB</code> 进行授权。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个使用简单的用户名/密码实现对用户进行身份验证的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject authInfo = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">\"username\"</span>, <span class=\"hljs-string\">\"tim\"</span>).put(<span class=\"hljs-string\">\"password\"</span>, <span class=\"hljs-string\">\"mypassword\"</span>);\n\nauthProvider.authenticate(authInfo)\n  .onSuccess(user -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"User \"</span> + user.principal() + <span class=\"hljs-string\">\" is now authenticated\"</span>);\n  })\n  .onFailure(Throwable::printStackTrace);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authorization\"><a class=\"anchor\" href=\"#_authorization\"></a>授权（Authorization）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当你得到一个 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html\">User</a></code> 实例后，你可以调用其 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html#authorizations--\">authorizations</a></code> 方法来获取其授权。\n一个新创建的用户不会包含授权。你可以直接在 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html\">User</a></code> 上添加授权或者通过 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code> 来添加。</p>\n</div>\n<div class=\"paragraph\">\n<p>上面所有的结果都是在handler中异步返回的。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个通过 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code> 添加授权的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">authorizationProvider.getAuthorizations(user)\n  .onSuccess(done -&gt; {\n  <span class=\"hljs-comment\">// cache is populated, perform query</span>\n  <span class=\"hljs-keyword\">if</span> (PermissionBasedAuthorization.create(<span class=\"hljs-string\">\"printer1234\"</span>).match(user)) {\n    System.out.println(<span class=\"hljs-string\">\"User has the authority\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"User does not have the authority\"</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以及另一个基于角色的授权示例，\n该模型使用了接口 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/RoleBasedAuthorization.html\">RoleBasedAuthorization</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意，如上所述，\n授权字符串的解释方式完全由基础实现决定，Vert.x在此不做任何假设。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_listing_authorizations\"><a class=\"anchor\" href=\"#_listing_authorizations\"></a>列出授权</h3>\n<div class=\"paragraph\">\n<p>用户对象拥有一个授权列表，因此随后的调用应检查它是否具有相同的授权，\n这可以避免对底层授权提供者执行另一次IO操作来加载授权。</p>\n</div>\n<div class=\"paragraph\">\n<p>要清除授权列表，您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/Authorizations.html#clear--\">clear</a></code> 。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_user_principal_and_attributes\"><a class=\"anchor\" href=\"#_the_user_principal_and_attributes\"></a>用户主体和属性</h3>\n<div class=\"paragraph\">\n<p>您可以使用获得与已认证用户相对应的 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html#principal--\">主体（principal）</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>返回的内容取决于具体的底层实现。主体映射是用于创建的源数据用户实例。属性是额外的属性，在实例创建的过程中 <strong>不会</strong> 提供，\n但是它们是以处理用户数据的结果出现的。\n区别就在于有确保处理的主体不会修改或重写现有数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了简化用法，可以使用两种方法在两个源上查找和读取值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (user.containsKey(<span class=\"hljs-string\">\"sub\"</span>)) {\n  <span class=\"hljs-comment\">// the check will first assert that the attributes contain</span>\n  <span class=\"hljs-comment\">// the given key and if not assert that the principal contains</span>\n  <span class=\"hljs-comment\">// the given key</span>\n\n  <span class=\"hljs-comment\">// just like the check before the get will follow the same</span>\n  <span class=\"hljs-comment\">// rules to retrieve the data, first \"attributes\" then \"principal\"</span>\n  String sub = user.get(<span class=\"hljs-string\">\"sub\"</span>);\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_your_own_authentication_or_authorization_provider_implementation\"><a class=\"anchor\" href=\"#_creating_your_own_authentication_or_authorization_provider_implementation\"></a>创建自定义的身份认证或授权提供程序</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果希望创建自己的身份验证提供程序，则应实现一个或两个接口：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>用户工厂方法可以使用给定的 <code>principal</code> JSON内容创建一个 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html\">User</a></code> 对象。\n第二个参数 <code>attributes</code> 是可选的，它可以提供额外的元数据供以后使用。\n以下属性是一个示例：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>exp</code> - Expires at in seconds.</p>\n</li>\n<li>\n<p><code>iat</code> - Issued at in seconds.</p>\n</li>\n<li>\n<p><code>nbf</code> - Not before in seconds.</p>\n</li>\n<li>\n<p><code>leeway</code> - clock drift leeway in seconds.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>前3个控制 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html#expired--\">expired</a></code>\n方法如何计算用户的过期时间，\n最后一个可以用于在计算过期时间时允许事件偏移补偿。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pseudo_random_number_generator\"><a class=\"anchor\" href=\"#_pseudo_random_number_generator\"></a>伪随机数生成器（PRNG）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>由于来自Java的Secure Random会在从系统获取熵的过程中阻塞，\n因此我们提供了它的简单封装，可以使用该封装，而不会阻塞事件循环。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，此PRNG使用混合模式，播种（seeding）过程是阻塞的，生成过程是非阻塞的。\n同时，每5分钟PRNG也将重新设置新的64位的熵。但是，所有这些都可以使用系统属性进行配置：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>io.vertx.ext.auth.prng.algorithm 示例: SHA1PRNG</p>\n</li>\n<li>\n<p>io.vertx.ext.auth.prng.seed.interval 示例: 1000 (每秒)</p>\n</li>\n<li>\n<p>io.vertx.ext.auth.prng.seed.bits 示例: 128</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>除非你注意到应用程序的性能受到PRNG算法的影响，\n否则大多数用户都不需要配置这些值。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sharing_pseudo_random_number_generator\"><a class=\"anchor\" href=\"#_sharing_pseudo_random_number_generator\"></a>共享伪随机数生成器</h3>\n<div class=\"paragraph\">\n<p>由于伪随机数生成器对象的资源昂贵，它们消耗系统熵，这是一种稀缺资源，\n因此明智的做法是在所有处理程序之间共享PRNG。为了做到这一点并使它适用于Vert.x支持的所有语言，您应该查看\n <code><a href=\"../../apidocs/io/vertx/ext/auth/VertxContextPRNG.html\">VertxContextPRNG</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>此接口使得用户对PRNG的生命周期管理变得轻松，并确保可以在所有应用程序中复用它，\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String token = VertxContextPRNG.current(vertx).nextString(<span class=\"hljs-number\">32</span>);\n<span class=\"hljs-comment\">// Generate a secure random integer</span>\n<span class=\"hljs-keyword\">int</span> randomInt = VertxContextPRNG.current(vertx).nextInt();</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_working_with_keys\"><a class=\"anchor\" href=\"#_working_with_keys\"></a>使用密钥</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在处理安全性时，您需要加载安全密钥。\n安全密钥有多种格式和标准，这使其成为一项非常复杂的任务。\n为了简化开发人员方面的工作，此模块包含2个抽象类：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/KeyStoreOptions.html\">KeyStoreOptions</a></code> JVM keystore通用格式。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/PubSecKeyOptions.html\">PubSecKeyOptions</a></code> PEM通用格式。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>要加载本地密钥库模块，应提供一个options对象，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">KeyStoreOptions options = <span class=\"hljs-keyword\">new</span> KeyStoreOptions()\n  .setPath(<span class=\"hljs-string\">\"/path/to/keystore/file\"</span>)\n  .setType(<span class=\"hljs-string\">\"pkcs8\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"keystore-password\"</span>)\n  .putPasswordProtection(<span class=\"hljs-string\">\"key-alias\"</span>, <span class=\"hljs-string\">\"alias-password\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该类型非常重要，因为它随所使用的JVM版本而异。\nJava 9之前的默认值是特定于JVM的默认值 <code>jks</code> ，而之后 <code>pkcs12</code> 是通用标准。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>pkcs12</code> 即使不需要 <code>keytool</code> 命令，也可以将非JVM密钥库密钥导入到文件中，\n例如，可以通过以下方式实现 <code>OpenSSL</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl pkcs12 -export -in mykeycertificate.pem -out mykeystore.pkcs12 -name myAlias -noiter -nomaciter</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上面的命令会将现有的pem文件转换为pkcs12密钥库，并将给定的密钥使用 <code>myAlias</code> 命名。\n <code>-noiter -nomaciter</code> 为了使文件与JVM加载程序兼容，需要额外的参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>要加载 <code>PEM</code> 文件，您应该注意一些限制。\n默认的JVM类仅支持 <code>PKCS8</code> 格式的密钥 ，因此，如果您有其他PEM文件，则需要使用以下方式转换 <code>OpenSSL</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl pkcs8 -topk8 -inform PEM -in private.pem -out private_key.pem -nocrypt</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在此之后，使用这样的文件很简单：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">PubSecKeyOptions options = <span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n  .setAlgorithm(<span class=\"hljs-string\">\"RS256\"</span>)\n  .setBuffer(\n    vertx.fileSystem()\n      .readFileBlocking(<span class=\"hljs-string\">\"/path/to/pem/file\"</span>)\n      .toString());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>PEM文件是常见且易于使用的，但不受密码保护，因此可以轻松嗅探私钥。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_web_keys\"><a class=\"anchor\" href=\"#_json_web_keys\"></a>JSON Web Keys（JWK）</h3>\n<div class=\"paragraph\">\n<p>JWK是OpenID connect和JWT提供程序使用的标准。它们用JSON对象表示密钥。\n通常这些JSON文档由Google，Microsoft等身份提供商服务器提供，\n但是您也可以使用在线应用程序 &lt;a href=\"https://mkjwk.org/\"&gt;<a href=\"https://mkjwk.org&lt;/a&gt\" class=\"bare\">https://mkjwk.org&lt;/a&gt</a>; 来生成自己的密钥。\n要想离线体验，还可以使用该工具： &lt;a href=\"https://connect2id.com/products/nimbus-jose-jwt/generator\"&gt;<a href=\"https://connect2id.com/products/nimbus-jose-jwt/generator&lt;/a&gt\" class=\"bare\">https://connect2id.com/products/nimbus-jose-jwt/generator&lt;/a&gt</a>; 。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_chaining_authentication_providers\"><a class=\"anchor\" href=\"#_chaining_authentication_providers\"></a>链接多个身份验证提供程序</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在某些情况下，支持链接多个身份验证提供程序可能会很有意思，例如，在LDAP或属性文件上查找用户。\n这可以用 <code><a href=\"../../apidocs/io/vertx/ext/auth/ChainAuth.html\">ChainAuth</a></code> 来实现。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ChainAuth.any()\n  .add(ldapAuthProvider)\n  .add(propertiesAuthProvider);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>执行 <strong>全部</strong> 匹配也是可以的，例如，必须在LDAP和属性上匹配用户：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ChainAuth.all()\n  .add(ldapAuthProvider)\n  .add(propertiesAuthProvider);</code></pre>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}