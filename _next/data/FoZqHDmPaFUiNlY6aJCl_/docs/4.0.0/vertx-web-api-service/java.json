{"pageProps":{"slug":"4.0.0/vertx-web-api-service/java","title":"Vert.x Web API 服务","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_api_service\">使用Vert.x API服务</a></li>\n<li><a href=\"#_proxy_an_http_request_to_a_web_api_service\">代理一个HTTP请求 到一个Web API服务</a></li>\n<li><a href=\"#_define_your_web_api_service_interface\">定义您的Web API 服务接口</a></li>\n<li><a href=\"#_implement_your_web_api_service\">实现您自己的Web API服务</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_the_servicerequest_data_object\"><code>ServiceRequest</code> 数据对象</a></li>\n<li><a href=\"#_the_serviceresponse_data_object\"><code>ServiceResponse</code> 数据对象</a></li>\n</ul>\n</li>\n<li><a href=\"#_expose_your_web_api_service\">暴露您的Web API 服务</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Web API 服务</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web API 服务通过事件总线帮助您处理HTTP请求</p>\n</div>\n<div class=\"paragraph\">\n<p>事件总线提供了一些重要特性，例如：负载均衡、通过不同Vert.x实例分发请求。\n我们建议您参阅 <a href=\"https://vertx.io/docs/vertx-core/java/#event_bus\">事件总线文档</a> 以了解更多信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个模块提供给您创建Web API 服务的能力，即一个事件总线消息消费者(基于与 <a href=\"https://vertx.io/docs/vertx-service-proxy/java/\">Vert.x service proxy</a> 同样的概念 )\n然后它提供一个处理器来代理访问这些服务的请求。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_api_service\"><a class=\"anchor\" href=\"#_using_vert_x_api_service\"></a>使用Vert.x API服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了使用Vert.x API 服务，需要添加如下依赖</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-codegen<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>processor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-api-service<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle &lt; 5 (在您的 <code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-codegen:4.0.0:processor'</span>\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-api-service:4.0.0'</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle &gt;= 5 (在您的 <code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n annotationProcessor <span class=\"hljs-string\">'io.vertx:vertx-codegen:4.0.0:processor'</span>\n annotationProcessor <span class=\"hljs-string\">'io.vertx:vertx-web-api-service:4.0.0'</span>\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-api-service:4.0.0'</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您需要引入 <code>vertx-codegen</code> 来从被注解修饰的接口中生成代码。\n如果您只需要 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/RouteToEBServiceHandler.html\">RouteToEBServiceHandler</a></code> ，那么您不需要 <code>vertx-codegen</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您希望用不同语言来调用接口，那么您需要添加 <em>语言</em> 依赖，譬如：\n为groovy语言添加 <code>vertx-lang-groovy</code> 依赖。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_proxy_an_http_request_to_a_web_api_service\"><a class=\"anchor\" href=\"#_proxy_an_http_request_to_a_web_api_service\"></a>代理一个HTTP请求 到一个Web API服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/RouteToEBServiceHandler.html\">RouteToEBServiceHandler</a></code> 来代理发送到事件总线的请求。\n这个处理器从 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html\">ServiceRequest</a></code> 内的 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 提取一些信息，并以 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceResponse.html\">ServiceResponse</a></code> 作为响应对象。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/hello\"</span>)\n  .handler(validationHandler)\n  .handler(\n    RouteToEBServiceHandler\n      .build(eventBus, <span class=\"hljs-string\">\"greeters.myapplication\"</span>, <span class=\"hljs-string\">\"hello\"</span>)\n  );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以定义 <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html\">DeliveryOptions</a></code> ，每次通过事件总线发送消息的时候会使用该选项：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">\"/hello\"</span>)\n  .handler(validationHandler)\n  .handler(\n    RouteToEBServiceHandler\n      .build(eventBus, <span class=\"hljs-string\">\"greeters.myapplication\"</span>, <span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-keyword\">new</span> DeliveryOptions().setSendTimeout(<span class=\"hljs-number\">1000</span>))\n  );</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n在挂载 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/RouteToEBServiceHandler.html\">RouteToEBServiceHandler</a></code> 的时候，您 <strong>必须</strong> 同时挂载一个 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/ValidationHandler.html\">ValidationHandler</a></code> ，该验证处理器提取了请求中的参数。否则，不会发送任何请求参数。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_define_your_web_api_service_interface\"><a class=\"anchor\" href=\"#_define_your_web_api_service_interface\"></a>定义您的Web API 服务接口</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在更进一步之前，我们建议您去查阅 <a href=\"https://vertx.io/docs/vertx-service-proxy/java/\">Service Proxy documentation</a></p>\n</div>\n<div class=\"paragraph\">\n<p>假设我们已经在 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code> 中定义了如下两个不同的路由：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">\"/api/transactions\"</span>)\n  .handler(\n    ValidationHandlerBuilder.create(schemaParser)\n      .queryParameter(optionalParam(<span class=\"hljs-string\">\"from\"</span>, stringSchema()))\n      .queryParameter(optionalParam(<span class=\"hljs-string\">\"to\"</span>, stringSchema()))\n      .build()\n  ).handler(\n    RouteToEBServiceHandler.build(eventBus, <span class=\"hljs-string\">\"transactions.myapplication\"</span>, <span class=\"hljs-string\">\"getTransactionsList\"</span>)\n  );\nrouter.post(<span class=\"hljs-string\">\"/api/transactions\"</span>)\n  .handler(\n    ValidationHandlerBuilder.create(schemaParser)\n      .body(json(objectSchema()))\n      .build()\n  ).handler(\n    RouteToEBServiceHandler.build(eventBus, <span class=\"hljs-string\">\"transactions.myapplication\"</span>, <span class=\"hljs-string\">\"putTransaction\"</span>)\n  );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>GET /api/transactions</code> 获取这样两个可选参数 <code>from</code> 和 <code>to</code> 。<code>POST /api/transactions</code> 从请求体获取一个 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>现在我们可以构建用于处理那些终端（endpoint）的 <strong>TransactionService</strong> 接口。对于各个终端您在构建 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/RouteToEBServiceHandler.html\">RouteToEBServiceHandler</a></code> 时需要写入一个方法，该方法名与指定的 <code>action</code> 相关联。\n对于方法参数，有如下几个规则：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>最后一个参数的类型必须是 <code>Handler&lt;AsyncResult&lt;ServiceResponse&gt;&gt;</code></p>\n</li>\n<li>\n<p>第二个到最后一个参数必须存在 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html\">ServiceRequest</a></code> 类型</p>\n</li>\n<li>\n<p>所有参数从第一个、第二个到最后一个（不含）会被自动从 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/RequestParameters.html\">RequestParameters</a></code> 中按照类型解析出来，但是他们需要遵循 <a href=\"https://vertx.io/docs/vertx-service-proxy/java/#_restrictions_for_service_interface\">service proxy restrictions</a> 。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>一个请求参数仅通过名称（name）区分，而且特殊的 <code>body</code> 方法参数名称用于从请求中解析出请求体。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@WebApiServiceGen</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">TransactionService</span> </span>{\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getTransactionsList</span><span class=\"hljs-params\">(String from, String to, ServiceRequest context, Handler&lt;AsyncResult&lt;ServiceResponse&gt;&gt; resultHandler)</span></span>;\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">putTransaction</span><span class=\"hljs-params\">(JsonObject body, ServiceRequest context, Handler&lt;AsyncResult&lt;ServiceResponse&gt;&gt; resultHandler)</span></span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您从 <code>TransactionService#getTransactionsList</code> 方法中接收到一个请求，自动生成的服务处理器会从 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html\">ServiceRequest</a></code> 自动解析出 <code>from</code> 和 <code>to</code> 参数（如果存在）</p>\n</div>\n<div class=\"paragraph\">\n<p>服务处理器也有自动转换 <code>JsonObject</code> 为Vert.x 数据对象的能力，例如，如果您有一个满足上述json schema的 <code>Transaction</code> 数据对象，您可以像如下重写 <code>putTransaction</code> 方法签名：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">putTransaction</span><span class=\"hljs-params\">(Transaction body, ServiceRequest context, Handler&lt;AsyncResult&lt;ServiceResponse&gt;&gt; resultHandler)</span></span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/RequestParameter.html\">RequestParameter</a></code> 来提取参数，如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">putTransaction</span><span class=\"hljs-params\">(RequestParameter body, ServiceRequest context, Handler&lt;AsyncResult&lt;ServiceResponse&gt;&gt; resultHandler)</span></span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们建议用 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/RequestParameter.html\">RequestParameter</a></code> 类型来提取以json shcema（allOf/anyOf/oneOf/not）定义的参数，因为提取参数可能产生未定义的行为。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_implement_your_web_api_service\"><a class=\"anchor\" href=\"#_implement_your_web_api_service\"></a>实现您自己的Web API服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>现在您可以实现您自己的服务。切记 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html\">ServiceRequest</a></code> 对象包含了请求头以及请求参数的映射。</p>\n</div>\n<div class=\"paragraph\">\n<p>要写一个请求 您必须调用包含了 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceResponse.html\">ServiceResponse</a></code> 的 <code>resultHandler</code>\n创建一个 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceResponse.html\">ServiceResponse</a></code> 实例，您可以用一些方便的方法，比如 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceResponse.html#completedWithJson-io.vertx.core.buffer.Buffer-\">ServiceResponse.completedWithJson</a></code> 或者 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceResponse.html#completedWithPlainText-io.vertx.core.buffer.Buffer-\">ServiceResponse.completedWithPlainText</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>例如 <code>TransactionService#getTransactionsList</code> 的实现看起来如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">resultHandler.handle(\n  Future.succeededFuture(\n    ServiceResponse.completedWithJson(<span class=\"hljs-keyword\">new</span> JsonArray())\n  )\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或当请求失败时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">resultHandler.handle(\n  Future.failedFuture(\n    <span class=\"hljs-keyword\">new</span> HttpStatusException(<span class=\"hljs-number\">555</span>, <span class=\"hljs-string\">\"Something bad happened\"</span>)\n  )\n);</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_servicerequest_data_object\"><a class=\"anchor\" href=\"#_the_servicerequest_data_object\"></a><code>ServiceRequest</code> 数据对象</h3>\n<div class=\"paragraph\">\n<p><code>ServiceRequest</code> 是一个 <em>可序列化</em> 的 <code>RoutingContext</code> ，但是 它并不包含 <code>RoutingContext</code> 的所有数据。它将如下数据转送到您的服务：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html#getHeaders--\">getHeaders</a></code> ： 请求头</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html#getParams--\">getParams</a></code> ：包含 <code>routingContext.get(\"parsedParameters\")</code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html#getUser--\">getUser</a></code>: Contains <code>routingContext.user().principal()</code> 如果没有用户被认证，则返回null</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/api/service/ServiceRequest.html#getExtra--\">getExtra</a></code> ：包含额外的可配置的 payload</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/api/service/RouteToEBServiceHandler.html#extraPayloadMapper-java.util.function.Function-\">extraPayloadMapper</a></code> 配置一个lambda表达式来构建额外的 payload</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_serviceresponse_data_object\"><a class=\"anchor\" href=\"#_the_serviceresponse_data_object\"></a><code>ServiceResponse</code> 数据对象</h3>\n<div class=\"paragraph\">\n<p><code>ServiceResponse</code> 由如下元素组成：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>响应头</p>\n</li>\n<li>\n<p>状态码/状态信息</p>\n</li>\n<li>\n<p>作为payload的请求体。如果您不设置payload或者设置为null，则不会发送响应体。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_expose_your_web_api_service\"><a class=\"anchor\" href=\"#_expose_your_web_api_service\"></a>暴露您的Web API 服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>现在您可以将服务注册到事件总线上：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">TransactionService transactionService = <span class=\"hljs-keyword\">new</span> TransactionServiceImpl();\n\n<span class=\"hljs-comment\">// Mount the service on the event bus</span>\nServiceBinder transactionServiceBinder = <span class=\"hljs-keyword\">new</span> ServiceBinder(vertx);\ntransactionServiceBinder\n  .setAddress(<span class=\"hljs-string\">\"transactions.myapplication\"</span>)\n  .register(TransactionService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">transactionService</span>)</span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于暴露服务的方法 更多信息请参考 <a href=\"https://vertx.io/docs/vertx-service-proxy/java/#_exposing_your_service\">Vert.x service proxy documentation</a></p>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}