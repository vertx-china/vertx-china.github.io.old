{"pageProps":{"slug":"4.0.0/vertx-camel-bridge/java","title":"Vert.x Camel 桥接（Bridge）","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vertx_camel_bridge\">使用 vertx-camel-bridge</a></li>\n<li><a href=\"#_bridge_configuration\">配置桥接</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_inbound_mapping\">入站映射</a></li>\n<li><a href=\"#_outbound_mapping\">出站映射</a></li>\n</ul>\n</li>\n<li><a href=\"#_stopping_the_bridge\">停止桥接</a></li>\n<li><a href=\"#_exchanging_custom_object\">交换自定义对象</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Camel 桥接（Bridge）</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Apache Camel (<a href=\"http://camel.apache.org\" class=\"bare\">http://camel.apache.org</a>) 是一个开源的Java框架，\n它致力于让开发人员更简单的集成和更方便的使用。此桥接允许 Vert.x 程序与 Camel 端点进行交互:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>向 Camel 发送消息。</p>\n</li>\n<li>\n<p>接收来自 Camel 的消息。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>此桥接依赖于 Vert.x 的事件总线（Event Bus，后面统一称 <code>事件总线</code>），并将事件总线地址与 Camel 端点进行关联。</p>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n此组件不是 <em>多语言</em> 的，因为它依赖的 Camel 中的某些类只能在Java中使用。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vertx_camel_bridge\"><a class=\"anchor\" href=\"#_using_vertx_camel_bridge\"></a>使用 vertx-camel-bridge</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用 Vert.x Camel 桥接请将以下依赖项添加到您的\n<em>依赖</em> 中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （ 在 <code>pom.xml</code> 文件中 ）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-camel-bridge<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （ 在您的 <code>build.gradle</code> 文件中 ）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-camel-bridge:4.0.0'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_bridge_configuration\"><a class=\"anchor\" href=\"#_bridge_configuration\"></a>配置桥接</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在使用桥接之前，需要对其进行配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">CamelContext camel = <span class=\"hljs-keyword\">new</span> DefaultCamelContext();\nCamelBridge.create(vertx,\n    <span class=\"hljs-keyword\">new</span> CamelBridgeOptions(camel)\n        .addInboundMapping(InboundMapping.fromCamel(<span class=\"hljs-string\">\"direct:stuff\"</span>).toVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>))\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>).toCamel(<span class=\"hljs-string\">\"stream:out\"</span>))\n).start();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>此桥接需要一个 <code>CamelContext</code> 上下文，它将从上下文中找到端点。桥接在使用之前，要确保已经启动。 需要注意的是 <code>start</code> 方法是异步的，你可以使用\n<code><a href=\"../../apidocs/io/vertx/camel/CamelBridge.html#start-io.vertx.core.Handler-\">start</a></code>\n方法来注册桥接启动时的回调。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_inbound_mapping\"><a class=\"anchor\" href=\"#_inbound_mapping\"></a>入站映射</h3>\n<div class=\"paragraph\">\n<p>入站映射将 Camel 的端点关联到对应事件总线地址上。\n在此端点上接收到的消息将被转换成事件总线的消息。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Endpoint endpoint = camel.getEndpoint(<span class=\"hljs-string\">\"direct:foo\"</span>);\n\nCamelBridge.create(vertx,\n    <span class=\"hljs-keyword\">new</span> CamelBridgeOptions(camel)\n        .addInboundMapping(InboundMapping.fromCamel(<span class=\"hljs-string\">\"direct:stuff\"</span>).toVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>))\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>))\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>)\n            .withoutHeadersCopy())\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>)\n            .usePublish())\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>)\n            .withBodyType(String<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))\n)</span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上面的代码展示了配置入站映射的不同方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>您可以使用 <code>Endpoint</code> 对象或对应的 url 来配置 Camel 端点。</p>\n</li>\n<li>\n<p>您可以禁用 header 头的复制（ Camel 消息头将会被复制到事件总线的消息中）。</p>\n</li>\n<li>\n<p>您可以使用 <code>publish</code> 代替 <code>send</code> 来将消息广播给所有事件总线的消费者。</p>\n</li>\n<li>\n<p>您可以配置事件总线消息体的类型。如果您未配置，则默认使用 Camel消息负载。\n如果您配置了，它将在 Camel 上下文中查找 Camel 消息有效负载和所需要类型之间的转换器。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><em>注意</em>: <code>org.fusesource.hawtbuf.Buffer</code> 会自动转换成 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您调用了 <code>send</code> （而不是 <code>publish</code> ）方法，并且 Camel 交换 期望收到回复 （ <em>In Out</em> 交换），\n那么 Vert.x 代码应回复接受到的消息。回复的消息会被传播到 Camel 交换：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Endpoint endpoint = camel.getEndpoint(<span class=\"hljs-string\">\"direct:stuff\"</span>);\n\nCamelBridge bridge = CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> CamelBridgeOptions(camel)\n    .addInboundMapping(<span class=\"hljs-keyword\">new</span> InboundMapping().setAddress(<span class=\"hljs-string\">\"test-reply\"</span>).setEndpoint(endpoint)));\n\nvertx.eventBus().consumer(<span class=\"hljs-string\">\"with-reply\"</span>, message -&gt; {\n  message.reply(<span class=\"hljs-string\">\"How are you ?\"</span>);\n});\n\ncamel.start();\nbridge.start();\n\nProducerTemplate template = camel.createProducerTemplate();\nFuture&lt;Object&gt; future = template.asyncRequestBody(endpoint, <span class=\"hljs-string\">\"hello\"</span>);\nString response = template.extractFutureBody(future, String<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还可以通过 <code><a href=\"../../apidocs/io/vertx/camel/InboundMapping.html#setTimeout-int-\">setTimeout</a></code> 方法来配置回复的 <code>超时</code>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_outbound_mapping\"><a class=\"anchor\" href=\"#_outbound_mapping\"></a>出站映射</h3>\n<div class=\"paragraph\">\n<p>出站映射将事件总线地址关联到 Camel 的端点上。\n在此地址上接收到的消息将被转换成发送到 Camel 对应端点的消息</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Endpoint endpoint = camel.getEndpoint(<span class=\"hljs-string\">\"stream:out\"</span>);\n\nCamelBridge.create(vertx,\n    <span class=\"hljs-keyword\">new</span> CamelBridgeOptions(camel)\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>).toCamel(<span class=\"hljs-string\">\"stream:out\"</span>))\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>).toCamel(endpoint))\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>).toCamel(endpoint)\n            .withoutHeadersCopy())\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"eventbus-address\"</span>).toCamel(endpoint))\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上面的示例展示了配置出站映射的不同方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以将出站映射链接到 Camel 路由上：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">camel.addRoutes(<span class=\"hljs-keyword\">new</span> RouteBuilder() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    from(<span class=\"hljs-string\">\"direct:start\"</span>)\n        .transform(constant(<span class=\"hljs-string\">\"OK\"</span>));\n  }\n});\n\nCamelBridge bridge = CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> CamelBridgeOptions(camel)\n    .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"test\"</span>).toCamel(<span class=\"hljs-string\">\"direct:start\"</span>)));\n\ncamel.start();\nbridge.start();\n\n\nvertx.eventBus().request(<span class=\"hljs-string\">\"test\"</span>, <span class=\"hljs-string\">\"hello\"</span>, reply -&gt; {\n  <span class=\"hljs-comment\">// 来自路由的回复（这里是“OK”）</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您在事件总线上发送消息时注册了回复的处理器，则它将 Camel 交换 配置为期望收到响应\n（它使用EIP的请求-响应模式），响应在回复的消息体中。\n如果路由失败，您将收到一个失败的回复（收件人失败），并伴随以下消息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">camel.addRoutes(<span class=\"hljs-keyword\">new</span> RouteBuilder() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    from(<span class=\"hljs-string\">\"direct:my-route\"</span>)\n        .to(<span class=\"hljs-string\">\"http://localhost:8080\"</span>);\n  }\n});\n\nCamelBridge bridge = CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> CamelBridgeOptions(camel)\n    .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"camel-route\"</span>).toCamel(<span class=\"hljs-string\">\"direct:my-route\"</span>)));\n\ncamel.start();\nbridge.start();\n\nvertx.eventBus().request(<span class=\"hljs-string\">\"camel-route\"</span>, <span class=\"hljs-string\">\"hello\"</span>, reply -&gt; {\n  <span class=\"hljs-keyword\">if</span> (reply.succeeded()) {\n    Object theResponse = reply.result().body();\n  } <span class=\"hljs-keyword\">else</span> {\n    Throwable theCause = reply.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您正在执行阻塞的逻辑，您<strong>必须</strong>将 <em>blocking</em> 设置为 <code>true</code> 。这样可以避免在\nevent loop 线程执行相应逻辑。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">camel.addRoutes(<span class=\"hljs-keyword\">new</span> RouteBuilder() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    from(<span class=\"hljs-string\">\"direct:my-route\"</span>)\n      .process(<span class=\"hljs-keyword\">new</span> Processor() {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(Exchange exchange)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n          <span class=\"hljs-comment\">// 执行阻塞逻辑……</span>\n        }\n      })\n      .to(<span class=\"hljs-string\">\"http://localhost:8080\"</span>);\n  }\n});\n\nCamelBridge bridge = CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> CamelBridgeOptions(camel)\n  .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">\"camel-route\"</span>).toCamel(<span class=\"hljs-string\">\"direct:my-route\"</span>).setBlocking(<span class=\"hljs-keyword\">true</span>)));\n\ncamel.start();\nbridge.start();\n\nvertx.eventBus().request(<span class=\"hljs-string\">\"camel-route\"</span>, <span class=\"hljs-string\">\"hello\"</span>, reply -&gt; {\n  <span class=\"hljs-keyword\">if</span> (reply.succeeded()) {\n    Object theResponse = reply.result().body();\n  } <span class=\"hljs-keyword\">else</span> {\n    Throwable theCause = reply.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，它使用默认的工作线程池，您也可以通过\n<code><a href=\"../../apidocs/io/vertx/camel/OutboundMapping.html#setWorkerExecutor-io.vertx.core.WorkerExecutor-\">setWorkerExecutor</a></code> 方法来自定义。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_stopping_the_bridge\"><a class=\"anchor\" href=\"#_stopping_the_bridge\"></a>停止桥接</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>别忘记使用 <code>stop</code> 方法来停止桥接。 <code>stop</code> 方法是异步的，你可以使用\n<code><a href=\"../../apidocs/io/vertx/camel/CamelBridge.html#stop-io.vertx.core.Handler-\">stop</a></code> 方法注册桥接结束时的回调。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_exchanging_custom_object\"><a class=\"anchor\" href=\"#_exchanging_custom_object\"></a>交换自定义对象</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果您需要发送或者接收自定义的对象，您需要在事件总线上注册编码/解码器。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.eventBus().registerDefaultCodec(Person<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">codec</span>)</span>;</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}