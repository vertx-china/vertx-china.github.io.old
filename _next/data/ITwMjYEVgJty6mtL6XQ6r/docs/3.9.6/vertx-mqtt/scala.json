{"pageProps":{"slug":"3.9.6/vertx-mqtt/scala","title":"Vert.x MQTT","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_mqtt\">Using Vert.x MQTT</a></li>\n<li><a href=\"#_vert_x_mqtt_server\">Vert.x MQTT server</a>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">Getting Started</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_handling_client_connectiondisconnection\">Handling client connection/disconnection</a></li>\n<li><a href=\"#_handling_client_connectiondisconnection_with_ssltls_support\">Handling client connection/disconnection with SSL/TLS support</a></li>\n<li><a href=\"#_handling_client_subscriptionunsubscription_request\">Handling client subscription/unsubscription request</a></li>\n<li><a href=\"#_handling_client_published_message\">Handling client published message</a></li>\n<li><a href=\"#_publish_message_to_the_client\">Publish message to the client</a></li>\n<li><a href=\"#_be_notified_by_client_keep_alive\">Be notified by client keep alive</a></li>\n<li><a href=\"#_closing_the_server\">Closing the server</a></li>\n<li><a href=\"#_automatic_clean_up_in_verticles\">Automatic clean-up in verticles</a></li>\n<li><a href=\"#_scaling_sharing_mqtt_servers\">Scaling : sharing MQTT servers</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#_vert_x_mqtt_client\">Vert.x MQTT client</a>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started_2\">Getting started</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_connectdisconnect\">Connect/Disconnect</a></li>\n<li><a href=\"#_subscribe_to_a_topic\">Subscribe to a topic</a></li>\n<li><a href=\"#_publishing_message_to_a_topic\">Publishing message to a topic</a></li>\n<li><a href=\"#_keep_connection_with_server_alive\">Keep connection with server alive</a></li>\n<li><a href=\"#_be_notified_when\">Be notified when</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x MQTT</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_mqtt\"><a class=\"anchor\" href=\"#_using_vert_x_mqtt\"></a>Using Vert.x MQTT</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This component had officially released in the Vert.x stack, just following dependency to the <em>dependencies</em> section\nof your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mqtt<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${maven.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile io.<span class=\"hljs-string\">vertx:</span>vertx-<span class=\"hljs-string\">mqtt:</span>${maven.version}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<h1 id=\"_vert_x_mqtt_server\" class=\"sect0\"><a class=\"anchor\" href=\"#_vert_x_mqtt_server\"></a>Vert.x MQTT server</h1>\n<div class=\"paragraph\">\n<p>This component provides a server which is able to handle connections, communication and messages exchange with remote\n<a href=\"http://mqtt.org/\">MQTT</a> clients. Its API provides a bunch of events related to raw protocol messages received by\nclients and exposes some features in order to send messages to them.</p>\n</div>\n<div class=\"paragraph\">\n<p>It&#8217;s not a fully featured MQTT broker but can be used for building something like that or for protocol translation.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nthis module has the tech preview status, this means the API can change between versions.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting Started</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_handling_client_connectiondisconnection\"><a class=\"anchor\" href=\"#_handling_client_connectiondisconnection\"></a>Handling client connection/disconnection</h3>\n<div class=\"paragraph\">\n<p>This example shows how it&#8217;s possible to handle the connection request from a remote MQTT client. First, an\n<code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttServer.html\">MqttServer</a></code> instance is created and the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttServer.html#endpointHandler()\">endpointHandler</a></code> method is used to specify the handler called\nwhen a remote client sends a CONNECT message for connecting to the server itself. The <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code>\ninstance, provided as parameter to the handler, brings all main information related to the CONNECT message like client identifier,\nusername/password, \"will\" information, clean session flag, protocol version and the \"keep alive\" timeout.\nInside that handler, the <em>endpoint</em> instance provides the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#accept()\">accept</a></code> method\nfor replying to the remote client with the corresponding CONNACK message : in this way, the connection is established.\nFinally, the server is started using the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttServer.html#listen()\">listen</a></code> method with\nthe default behavior (on localhost and default MQTT port 1883). The same method allows to specify an handler in order\nto check if the server is started properly or not.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> mqttServer = <span class=\"hljs-type\">MqttServer</span>.create(vertx)\nmqttServer.endpointHandler((endpoint: io.vertx.scala.mqtt.<span class=\"hljs-type\">MqttEndpoint</span>) =&gt; {\n\n  <span class=\"hljs-comment\">// shows main connect info</span>\n  println(<span class=\"hljs-string\">s\"MQTT client [<span class=\"hljs-subst\">${endpoint.clientIdentifier()}</span>] request to connect, clean session = <span class=\"hljs-subst\">${endpoint.isCleanSession()}</span>\"</span>)\n\n  <span class=\"hljs-keyword\">if</span> (endpoint.auth() != <span class=\"hljs-literal\">null</span>) {\n    println(<span class=\"hljs-string\">s\"[username = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span>, password = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span>]\"</span>)\n  }\n  <span class=\"hljs-keyword\">if</span> (endpoint.will() != <span class=\"hljs-literal\">null</span>) {\n    println(<span class=\"hljs-string\">s\"[will topic = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span> msg = <span class=\"hljs-subst\">${new java.lang.String(todo-renderDataObjectMemberSelect)}</span> QoS = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span> isRetain = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span>]\"</span>)\n  }\n\n  println(<span class=\"hljs-string\">s\"[keep alive timeout = <span class=\"hljs-subst\">${endpoint.keepAliveTimeSeconds()}</span>]\"</span>)\n\n  <span class=\"hljs-comment\">// accept connection from the remote client</span>\n  endpoint.accept(<span class=\"hljs-literal\">false</span>)\n\n}).listenFuture().onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n\n    println(<span class=\"hljs-string\">s\"MQTT server is listening on port <span class=\"hljs-subst\">${result.actualPort()}</span>\"</span>)\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s\"<span class=\"hljs-subst\">$cause</span>\"</span>)\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same <em>endpoint</em> instance provides the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#disconnectHandler()\">disconnectHandler</a></code>\nfor specifying the handler called when the remote client sends a DISCONNECT message in order to disconnect from the server;\nthis handler takes no parameters.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// handling disconnect message</span>\nendpoint.disconnectHandler((v: java.lang.<span class=\"hljs-type\">Void</span>) =&gt; {\n\n  println(<span class=\"hljs-string\">\"Received disconnect from client\"</span>)\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_client_connectiondisconnection_with_ssltls_support\"><a class=\"anchor\" href=\"#_handling_client_connectiondisconnection_with_ssltls_support\"></a>Handling client connection/disconnection with SSL/TLS support</h3>\n<div class=\"paragraph\">\n<p>The server has the support for accepting connection requests through the SSL/TLS protocol for authentication and encryption.\nIn order to do that, the <code><a href=\"../dataobjects.html#MqttServerOptions\">MqttServerOptions</a></code> class provides the <code><a href=\"../dataobjects.html#MqttServerOptions#setSsl()\">ssl</a></code> method\nfor setting the usage of SSL/TLS (passing 'true' as value) and some other useful methods for providing server certificate and\nrelated private key (as Java key store reference, PEM or PFX format). In the following example, the\n<code><a href=\"../dataobjects.html#MqttServerOptions#setKeyCertOptions()\">keyCertOptions</a></code> method is used in order to\npass the certificates in PEM format. This method requires an instance of the possible implementations of the\n<code>KeyCertOptions</code> interface and in this case the <code><a href=\"../../vertx-core/dataobjects.html#PemKeyCertOptions\">PemKeyCertOptions</a></code> class\nis used in order to provide the path for the server certificate and the private key with the correspondent\n<code><a href=\"../../vertx-core/dataobjects.html#PemKeyCertOptions#setCertPath()\">certPath</a></code> and\n<code><a href=\"../../vertx-core/dataobjects.html#PemKeyCertOptions#setKeyPath()\">keyPath</a></code> methods.\nThe MQTT server is started passing the Vert.x instance as usual and the above MQTT options instance to the creation method.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> options = <span class=\"hljs-type\">MqttServerOptions</span>()\n  .setPort(<span class=\"hljs-number\">8883</span>)\n  .setKeyCertOptions(<span class=\"hljs-type\">PemKeyCertOptions</span>()\n    .setKeyPath(<span class=\"hljs-string\">\"./src/test/resources/tls/server-key.pem\"</span>)\n    .setCertPath(<span class=\"hljs-string\">\"./src/test/resources/tls/server-cert.pem\"</span>)\n  )\n  .setSsl(<span class=\"hljs-literal\">true</span>)\n\n\n<span class=\"hljs-keyword\">var</span> mqttServer = <span class=\"hljs-type\">MqttServer</span>.create(vertx, options)\nmqttServer.endpointHandler((endpoint: io.vertx.scala.mqtt.<span class=\"hljs-type\">MqttEndpoint</span>) =&gt; {\n\n  <span class=\"hljs-comment\">// shows main connect info</span>\n  println(<span class=\"hljs-string\">s\"MQTT client [<span class=\"hljs-subst\">${endpoint.clientIdentifier()}</span>] request to connect, clean session = <span class=\"hljs-subst\">${endpoint.isCleanSession()}</span>\"</span>)\n\n  <span class=\"hljs-keyword\">if</span> (endpoint.auth() != <span class=\"hljs-literal\">null</span>) {\n    println(<span class=\"hljs-string\">s\"[username = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span>, password = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span>]\"</span>)\n  }\n  <span class=\"hljs-keyword\">if</span> (endpoint.will() != <span class=\"hljs-literal\">null</span>) {\n    println(<span class=\"hljs-string\">s\"[will topic = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span> msg = <span class=\"hljs-subst\">${new java.lang.String(todo-renderDataObjectMemberSelect)}</span> QoS = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span> isRetain = <span class=\"hljs-subst\">${todo-renderDataObjectMemberSelect}</span>]\"</span>)\n  }\n\n  println(<span class=\"hljs-string\">s\"[keep alive timeout = <span class=\"hljs-subst\">${endpoint.keepAliveTimeSeconds()}</span>]\"</span>)\n\n  <span class=\"hljs-comment\">// accept connection from the remote client</span>\n  endpoint.accept(<span class=\"hljs-literal\">false</span>)\n\n}).listenFuture().onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n\n    println(<span class=\"hljs-string\">s\"MQTT server is listening on port <span class=\"hljs-subst\">${result.actualPort()}</span>\"</span>)\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s\"<span class=\"hljs-subst\">$cause</span>\"</span>)\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>All the other stuff related to handle endpoint connection and related disconnection is managed in the same way without SSL/TLS support.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_client_subscriptionunsubscription_request\"><a class=\"anchor\" href=\"#_handling_client_subscriptionunsubscription_request\"></a>Handling client subscription/unsubscription request</h3>\n<div class=\"paragraph\">\n<p>After a connection is established between client and server, the client can send a subscription request for a topic\nusing the SUBSCRIBE message. The <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code> interface allows to specify an handler for the\nincoming subscription request using the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#subscribeHandler()\">subscribeHandler</a></code> method.\nSuch handler receives an instance of the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/messages/MqttSubscribeMessage.html\">MqttSubscribeMessage</a></code> interface which brings\nthe list of topics with related QoS levels as desired by the client.\nFinally, the endpoint instance provides the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#subscribeAcknowledge(int)\">subscribeAcknowledge</a></code> method\nfor replying to the client with the related SUBACK message containing the granted QoS levels.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// handling requests for subscriptions</span>\nendpoint.subscribeHandler((subscribe: io.vertx.scala.mqtt.messages.<span class=\"hljs-type\">MqttSubscribeMessage</span>) =&gt; {\n\n  <span class=\"hljs-keyword\">var</span> grantedQosLevels = <span class=\"hljs-type\">List</span>()\n  subscribe.topicSubscriptions().foreach(s =&gt; {\n    println(<span class=\"hljs-string\">s\"Subscription for <span class=\"hljs-subst\">${s.topicName()}</span> with QoS <span class=\"hljs-subst\">${s.qualityOfService()}</span>\"</span>)\n    grantedQosLevels :::= <span class=\"hljs-type\">List</span>(s.qualityOfService())\n  })\n\n  <span class=\"hljs-comment\">// ack the subscriptions request</span>\n  endpoint.subscribeAcknowledge(subscribe.messageId(), grantedQosLevels)\n\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the same way, it&#8217;s possible to use the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#unsubscribeHandler()\">unsubscribeHandler</a></code> method\non the endpoint in order to specify the handler called when the client sends an UNSUBSCRIBE message. This handler receives\nan instance of the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/messages/MqttUnsubscribeMessage.html\">MqttUnsubscribeMessage</a></code> interface as parameter with the list of topics to unsubscribe.\nFinally, the endpoint instance provides the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#unsubscribeAcknowledge()\">unsubscribeAcknowledge</a></code> method\nfor replying to the client with the related UNSUBACK message.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// handling requests for unsubscriptions</span>\nendpoint.unsubscribeHandler((unsubscribe: io.vertx.scala.mqtt.messages.<span class=\"hljs-type\">MqttUnsubscribeMessage</span>) =&gt; {\n\n  unsubscribe.topics().foreach(t =&gt; {\n    println(<span class=\"hljs-string\">s\"Unsubscription for <span class=\"hljs-subst\">${t}</span>\"</span>)\n  })\n\n  <span class=\"hljs-comment\">// ack the subscriptions request</span>\n  endpoint.unsubscribeAcknowledge(unsubscribe.messageId())\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_client_published_message\"><a class=\"anchor\" href=\"#_handling_client_published_message\"></a>Handling client published message</h3>\n<div class=\"paragraph\">\n<p>In order to handle incoming messages published by the remote client, the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code> interface provides\nthe <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishHandler()\">publishHandler</a></code> method for specifying the handler called\nwhen the client sends a PUBLISH message. This handler receives an instance of the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/messages/MqttPublishMessage.html\">MqttPublishMessage</a></code>\ninterface as parameter with the payload, the QoS level, the duplicate and retain flags.</p>\n</div>\n<div class=\"paragraph\">\n<p>If the QoS level is 0 (AT_MOST_ONCE), there is no need from the endpoint to reply the client.</p>\n</div>\n<div class=\"paragraph\">\n<p>If the QoS level is 1 (AT_LEAST_ONCE), the endpoind needs to reply with a PUBACK message using the\navailable <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishAcknowledge()\">publishAcknowledge</a></code> method.</p>\n</div>\n<div class=\"paragraph\">\n<p>If the QoS level is 2 (EXACTLY_ONCE), the endpoint needs to reply with a PUBREC message using the\navailable <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishReceived()\">publishReceived</a></code> method; in this case the same endpoint should handle\nthe PUBREL message received from the client as well (the remote client sends it after receiving the PUBREC from the endpoint)\nand it can do that specifying the handler through the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishReleaseHandler()\">publishReleaseHandler</a></code> method.\nIn order to close the QoS level 2 delivery, the endpoint can use the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishComplete()\">publishComplete</a></code> method\nfor sending the PUBCOMP message to the client.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// handling incoming published messages</span>\nendpoint.publishHandler((message: io.vertx.scala.mqtt.messages.<span class=\"hljs-type\">MqttPublishMessage</span>) =&gt; {\n\n  println(<span class=\"hljs-string\">s\"Just received message [<span class=\"hljs-subst\">${message.payload().toString(java.nio.charset.Charset.defaultCharset())}</span>] with QoS [<span class=\"hljs-subst\">${message.qosLevel()}</span>]\"</span>)\n\n  <span class=\"hljs-keyword\">if</span> (message.qosLevel() == <span class=\"hljs-type\">MqttQoS</span>.<span class=\"hljs-type\">AT_LEAST_ONCE</span>) {\n    endpoint.publishAcknowledge(message.messageId())\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message.qosLevel() == <span class=\"hljs-type\">MqttQoS</span>.<span class=\"hljs-type\">EXACTLY_ONCE</span>) {\n    endpoint.publishReceived(message.messageId())\n  }\n\n}).publishReleaseHandler((messageId: java.lang.<span class=\"hljs-type\">Integer</span>) =&gt; {\n\n  endpoint.publishComplete(messageId)\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_publish_message_to_the_client\"><a class=\"anchor\" href=\"#_publish_message_to_the_client\"></a>Publish message to the client</h3>\n<div class=\"paragraph\">\n<p>The endpoint can publish a message to the remote client (sending a PUBLISH message) using the\n<code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publish(java.lang.String,%20io.vertx.core.buffer.Buffer,%20io.netty.handler.codec.mqtt.MqttQoS,%20boolean)\">publish</a></code> method\nwhich takes the following input parameters : the topic to publish, the payload, the QoS level, the duplicate and retain flags.</p>\n</div>\n<div class=\"paragraph\">\n<p>If the QoS level is 0 (AT_MOST_ONCE), the endpoint won&#8217;t receiving any feedback from the client.</p>\n</div>\n<div class=\"paragraph\">\n<p>If the QoS level is 1 (AT_LEAST_ONCE), the endpoint needs to handle the PUBACK message received from the client\nin order to receive final acknowledge of delivery. It&#8217;s possible using the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishAcknowledgeHandler()\">publishAcknowledgeHandler</a></code> method\nspecifying such an handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>If the QoS level is 2 (EXACTLY_ONCE), the endpoint needs to handle the PUBREC message received from the client.\nThe <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishReceivedHandler()\">publishReceivedHandler</a></code> method allows to specify\nthe handler for that. Inside that handler, the endpoint can use the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishRelease()\">publishRelease</a></code> method\nfor replying to the client with the PUBREL message. The last step is to handle the PUBCOMP message received from the client\nas final acknowledge for the published message; it&#8217;s possible using the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#publishCompletionHandler()\">publishCompletionHandler</a></code>\nfor specifying the handler called when the final PUBCOMP message is received.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// just as example, publish a message with QoS level 2</span>\nendpoint.publish(<span class=\"hljs-string\">\"my_topic\"</span>, <span class=\"hljs-type\">Buffer</span>.buffer(<span class=\"hljs-string\">\"Hello from the Vert.x MQTT server\"</span>), <span class=\"hljs-type\">MqttQoS</span>.<span class=\"hljs-type\">EXACTLY_ONCE</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>)\n\n<span class=\"hljs-comment\">// specifing handlers for handling QoS 1 and 2</span>\nendpoint.publishAcknowledgeHandler((messageId: java.lang.<span class=\"hljs-type\">Integer</span>) =&gt; {\n\n  println(<span class=\"hljs-string\">s\"Received ack for message = <span class=\"hljs-subst\">${messageId}</span>\"</span>)\n\n}).publishReceivedHandler((messageId: java.lang.<span class=\"hljs-type\">Integer</span>) =&gt; {\n\n  endpoint.publishRelease(messageId)\n\n}).publishCompletionHandler((messageId: java.lang.<span class=\"hljs-type\">Integer</span>) =&gt; {\n\n  println(<span class=\"hljs-string\">s\"Received ack for message = <span class=\"hljs-subst\">${messageId}</span>\"</span>)\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_be_notified_by_client_keep_alive\"><a class=\"anchor\" href=\"#_be_notified_by_client_keep_alive\"></a>Be notified by client keep alive</h3>\n<div class=\"paragraph\">\n<p>The underlying MQTT keep alive mechanism is handled by the server internally. When the CONNECT message is received,\nthe server takes care of the keep alive timeout specified inside that message in order to check if the client doesn&#8217;t\nsend messages in such timeout. At same time, for every PINGREQ received, the server replies with the related PINGRESP.</p>\n</div>\n<div class=\"paragraph\">\n<p>Even if there is no need for the high level application to handle that, the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html\">MqttEndpoint</a></code> interface\nprovides the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttEndpoint.html#pingHandler()\">pingHandler</a></code> method for specifying an handler\ncalled when a PINGREQ message is received from the client. It&#8217;s just a notification to the application that the client\nisn&#8217;t sending meaningful messages but only pings for keeping alive; in any case the PINGRESP is automatically sent\nby the server internally as described above.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// handling ping from client</span>\nendpoint.pingHandler((v: java.lang.<span class=\"hljs-type\">Void</span>) =&gt; {\n\n  println(<span class=\"hljs-string\">\"Ping received from client\"</span>)\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_closing_the_server\"><a class=\"anchor\" href=\"#_closing_the_server\"></a>Closing the server</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttServer.html\">MqttServer</a></code> interface provides the <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttServer.html#close()\">close</a></code> method\nthat can be used for closing the server; it stops to listen for incoming connections and closes all the active connections\nwith remote clients. This method is asynchronous and one overload provides the possibility to specify a complention handler\nthat will be called when the server is really closed.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">mqttServer.closeFuture().onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">\"Success\"</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">\"Failure\"</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_clean_up_in_verticles\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles\"></a>Automatic clean-up in verticles</h3>\n<div class=\"paragraph\">\n<p>If you’re creating MQTT servers from inside verticles, those servers will be automatically closed when the verticle is undeployed.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scaling_sharing_mqtt_servers\"><a class=\"anchor\" href=\"#_scaling_sharing_mqtt_servers\"></a>Scaling : sharing MQTT servers</h3>\n<div class=\"paragraph\">\n<p>The handlers related to the MQTT server are always executed in the same event loop thread. It means that on a system with\nmore cores, only one instance is deployed so only one core is used. In order to use more cores, it&#8217;s possible to deploy\nmore instances of the MQTT server.</p>\n</div>\n<div class=\"paragraph\">\n<p>It&#8217;s possible to do that programmatically:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">for</span> ( i &lt;- <span class=\"hljs-number\">0</span> until <span class=\"hljs-number\">10</span>) {\n\n  <span class=\"hljs-keyword\">var</span> mqttServer = <span class=\"hljs-type\">MqttServer</span>.create(vertx)\n  mqttServer.endpointHandler((endpoint: io.vertx.scala.mqtt.<span class=\"hljs-type\">MqttEndpoint</span>) =&gt; {\n    <span class=\"hljs-comment\">// handling endpoint</span>\n  }).listenFuture().onComplete{\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">\"Success\"</span>)\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">\"Failure\"</span>)\n  }\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>or using a verticle specifying the number of instances:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> options = <span class=\"hljs-type\">DeploymentOptions</span>()\n  .setInstances(<span class=\"hljs-number\">10</span>)\n\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyVerticle\"</span>, options)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>What&#8217;s really happen is that even only MQTT server is deployed but as incoming connections arrive, Vert.x distributes\nthem in a round-robin fashion to any of the connect handlers executed on different cores.</p>\n</div>\n</div>\n</div>\n</div>\n<h1 id=\"_vert_x_mqtt_client\" class=\"sect0\"><a class=\"anchor\" href=\"#_vert_x_mqtt_client\"></a>Vert.x MQTT client</h1>\n<div class=\"paragraph\">\n<p>This component provides an <a href=\"http://mqtt.org/\">MQTT</a> client which is compliant with the 3.1.1 spec. Its API provides a bunch of methods\nfor connecting/disconnecting to a broker, publishing messages (with all three different levels of QoS) and subscribing to topics.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nthis module has the tech preview status, this means the API can change between versions.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started_2\"><a class=\"anchor\" href=\"#_getting_started_2\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_connectdisconnect\"><a class=\"anchor\" href=\"#_connectdisconnect\"></a>Connect/Disconnect</h3>\n<div class=\"paragraph\">\n<p>The client gives you opportunity to connect to a server and disconnect from it.\nAlso, you could specify things like the host and port of a server you would like\nto connect to passing instance of <code><a href=\"../dataobjects.html#MqttClientOptions\">MqttClientOptions</a></code> as a param through constructor.</p>\n</div>\n<div class=\"paragraph\">\n<p>This example shows how you could connect to a server and disconnect from it using Vert.x MQTT client\nand calling <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#connect(int,%20java.lang.String)\">connect</a></code> and <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#disconnect()\">disconnect</a></code> methods.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> client = <span class=\"hljs-type\">MqttClient</span>.create(vertx)\n\nclient.connectFuture(<span class=\"hljs-number\">1883</span>, <span class=\"hljs-string\">\"mqtt.eclipse.org\"</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">\"Success\"</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">\"Failure\"</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\ndefault address of server provided by <code><a href=\"../dataobjects.html#MqttClientOptions\">MqttClientOptions</a></code> is localhost:1883 and localhost:8883 if you are using SSL/TSL.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_subscribe_to_a_topic\"><a class=\"anchor\" href=\"#_subscribe_to_a_topic\"></a>Subscribe to a topic</h3>\n<div class=\"paragraph\">\n<p>Now, lest go deeper and take look at this example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">client.publishHandler((s: io.vertx.scala.mqtt.messages.<span class=\"hljs-type\">MqttPublishMessage</span>) =&gt; {\n  println(<span class=\"hljs-string\">s\"There are new message in topic: <span class=\"hljs-subst\">${s.topicName()}</span>\"</span>)\n  println(<span class=\"hljs-string\">s\"Content(as string) of the message: <span class=\"hljs-subst\">${s.payload().toString()}</span>\"</span>)\n  println(<span class=\"hljs-string\">s\"QoS: <span class=\"hljs-subst\">${s.qosLevel()}</span>\"</span>)\n}).subscribe(<span class=\"hljs-string\">\"rpi2/temp\"</span>, <span class=\"hljs-number\">2</span>)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Here we have the example of usage of <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#subscribe(java.lang.String)\">subscribe</a></code> method. In order to receive messages from rpi2/temp topic we call <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#subscribe(java.lang.String)\">subscribe</a></code> method.\nAlthough, to handle received messages from server you need to provide a handler, which will be called each time you have a new messages in the topics you subscribe on.\nAs this example shows, handler could be provided via <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#publishHandler()\">publishHandler</a></code> method.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_publishing_message_to_a_topic\"><a class=\"anchor\" href=\"#_publishing_message_to_a_topic\"></a>Publishing message to a topic</h3>\n<div class=\"paragraph\">\n<p>If you would like to publish some message into topic then <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#publish(java.lang.String,%20io.vertx.core.buffer.Buffer,%20io.netty.handler.codec.mqtt.MqttQoS,%20boolean)\">publish</a></code> should be called.\nLet&#8217;s take a look at the example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">client.publish(<span class=\"hljs-string\">\"temperature\"</span>, <span class=\"hljs-type\">Buffer</span>.buffer(<span class=\"hljs-string\">\"hello\"</span>), <span class=\"hljs-type\">MqttQoS</span>.<span class=\"hljs-type\">AT_LEAST_ONCE</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the example we send message to topic with name \"temperature\".</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_keep_connection_with_server_alive\"><a class=\"anchor\" href=\"#_keep_connection_with_server_alive\"></a>Keep connection with server alive</h3>\n<div class=\"paragraph\">\n<p>In order to keep connection with server you should time to time send something to server otherwise server will close the connection.\nThe right way to keep connection alive is a <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#ping()\">ping</a></code> method.</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\nby default you client keep connections with server automatically. That means that you don&#8217;t need to call <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#ping()\">ping</a></code> in order to keep connections with server.\nThe <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html\">MqttClient</a></code> will do it for you.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If you want to disable this feature then you should call <code><a href=\"../dataobjects.html#MqttClientOptions#setAutoKeepAlive()\">autoKeepAlive</a></code> with <code>false</code> as argument:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">options.setAutoKeepAlive(<span class=\"hljs-literal\">false</span>)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_be_notified_when\"><a class=\"anchor\" href=\"#_be_notified_when\"></a>Be notified when</h3>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>publish is completed</p>\n<div class=\"paragraph\">\n<p>You could provide handler by calling <code><a href=\"../../scaladocs/io/vertx/scala/mqtt/MqttClient.html#publishCompletionHandler()\">publishCompletionHandler</a></code>. The handler will be called each time publish is completed.\nThis one is pretty useful because you could see the packetId of just received PUBACK or PUBCOMP packet.</p>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>client.publishCompletionHandler((id: java.lang.Integer) =&gt; {\n  println(s\"Id of just received PUBACK or PUBCOMP packet is ${id}\")\n}).publish(\"hello\", Buffer.buffer(\"hello\"), MqttQoS.EXACTLY_ONCE, false, false).publish(\"hello\", Buffer.buffer(\"hello\"), MqttQoS.AT_LEAST_ONCE, false, false).publish(\"hello\", Buffer.buffer(\"hello\"), MqttQoS.AT_LEAST_ONCE, false, false)</pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nThe handler WILL NOT BE CALLED if sent publish packet with QoS=0.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>subscribe completed</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">client.subscribeCompletionHandler((mqttSubAckMessage: io.vertx.scala.mqtt.messages.<span class=\"hljs-type\">MqttSubAckMessage</span>) =&gt; {\n  println(<span class=\"hljs-string\">s\"Id of just received SUBACK packet is <span class=\"hljs-subst\">${mqttSubAckMessage.messageId()}</span>\"</span>)\n  mqttSubAckMessage.grantedQoSLevels().foreach(s =&gt; {\n    <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-number\">128</span>) {\n      println(<span class=\"hljs-string\">\"Failure\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n      println(<span class=\"hljs-string\">s\"Success. Maximum QoS is <span class=\"hljs-subst\">${s}</span>\"</span>)\n    }\n  })\n\n}).subscribe(<span class=\"hljs-string\">\"temp\"</span>, <span class=\"hljs-number\">1</span>).subscribe(<span class=\"hljs-string\">\"temp2\"</span>, <span class=\"hljs-number\">2</span>)</code></pre>\n</div>\n</div>\n</li>\n<li>\n<p>unsubscribe completed</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">client.unsubscribeCompletionHandler((id: java.lang.<span class=\"hljs-type\">Integer</span>) =&gt; {\n  println(<span class=\"hljs-string\">s\"Id of just received UNSUBACK packet is <span class=\"hljs-subst\">${id}</span>\"</span>)\n}).subscribe(<span class=\"hljs-string\">\"temp\"</span>, <span class=\"hljs-number\">1</span>).unsubscribe(<span class=\"hljs-string\">\"temp\"</span>)</code></pre>\n</div>\n</div>\n</li>\n<li>\n<p>unsubscribe sent</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">client.subscribe(<span class=\"hljs-string\">\"temp\"</span>, <span class=\"hljs-number\">1</span>).unsubscribeFuture(<span class=\"hljs-string\">\"temp\"</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">\"Success\"</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">\"Failure\"</span>)\n}</code></pre>\n</div>\n</div>\n</li>\n<li>\n<p>PINGRESP received</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">client.pingResponseHandler((s: java.lang.<span class=\"hljs-type\">Void</span>) =&gt; {\n  <span class=\"hljs-comment\">//The handler will be called time to time by default</span>\n  println(<span class=\"hljs-string\">\"We have just received PINGRESP packet\"</span>)\n})</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>","version":"3.9.6"},"__N_SSG":true}