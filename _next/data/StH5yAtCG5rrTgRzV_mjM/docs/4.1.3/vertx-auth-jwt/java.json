{"pageProps":{"slug":"4.1.3/vertx-auth-jwt/java","title":"JWT 认证","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_loading_keys\">加载秘钥</a></li>\n<li><a href=\"#_read_only_tokens\">读取令牌</a></li>\n<li><a href=\"#_authnauthz_with_jwt\">AuthN/AuthZ 和 JWT</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_authenticating_authn\">鉴权/身份验证 (AuthN)</a></li>\n<li><a href=\"#_authorizing_authz\">授权 (AuthZ)</a></li>\n<li><a href=\"#_validating_tokens\">校验令牌</a></li>\n<li><a href=\"#_customizing_token_generation\">自定义 Token 生成</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>JWT 认证</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>该组件包含了一个现成的 JWT 实现，要使用这个项目，\n将下面的依赖添加到构建描述符里的 <em>dependencies</em> 部分</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code>）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-auth-jwt<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-auth-jwt:4.1.3&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>JSON Web 令牌是一种简单的以明文（通常是URL）发送信息的方法，\n其内容可被验证为是可信的。\n像下面的这些场景 JWT 是非常适用的：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>在单点登录方案中，需要一个单独的身份验证服务器，\n然后该服务器可以以被信任的方式发送用户信息。</p>\n</li>\n<li>\n<p>无状态的API 服务，非常适合单页应用。</p>\n</li>\n<li>\n<p>等等&#8230;&#8203;</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在决定使用 JWT 之前, 需要重点注意的是 JWT 并不加密 payload, 而是对它签名。\n您不应该使用 JWT 发送任何机密信息，相反应该发送的是非私密的，但需要被验证的信息。\n举个例子，使用 JWT 发送一个签名过的用户 id 来表明这个用户已经登录了的做法非常棒！\n相反发送一个用户的密码的做法则是非常非常错误的。</p>\n</div>\n<div class=\"paragraph\">\n<p>JWT 主要的优点有：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>它允许您验证令牌的真实性。</p>\n</li>\n<li>\n<p>它有一个 JSON 结构，可以包含任何您所需的任意数量的数据。</p>\n</li>\n<li>\n<p>它是无状态的。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您可使用 <code><a href=\"../../apidocs/io/vertx/ext/auth/jwt/JWTAuth.html\">JWTAuth</a></code> 创建一个验证器的实例。\n并指定一个格式为 JSON 的配置文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是创建一个 JWT 身份验证器的示例代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuthOptions config = <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> KeyStoreOptions()\n    .setPath(<span class=\"hljs-string\">&quot;keystore.jceks&quot;</span>)\n    .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>));\n\nAuthenticationProvider provider = JWTAuth.create(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>JWT 用法的典型流程是，您的应用程序中有一个接口负责颁发令牌，这个接口应在 SSL 模式下运行，\n接口在通过用户名和密码验证完请求用户之后，\n您应当这样做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuthOptions config = <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> KeyStoreOptions()\n    .setPath(<span class=\"hljs-string\">&quot;keystore.jceks&quot;</span>)\n    .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>));\n\nJWTAuth provider = JWTAuth.create(vertx, config);\n\n<span class=\"hljs-comment\">// 验证用户的用户名和密码之后</span>\n<span class=\"hljs-comment\">// 通过端点生成签名令牌</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;paulo&quot;</span>.equals(username) &amp;&amp; <span class=\"hljs-string\">&quot;super_secret&quot;</span>.equals(password)) {\n  String token = provider.generateToken(\n    <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;sub&quot;</span>, <span class=\"hljs-string\">&quot;paulo&quot;</span>), <span class=\"hljs-keyword\">new</span> JWTOptions());\n\n  <span class=\"hljs-comment\">// 现在，对于任何对受保护资源的请求，您应该</span>\n  <span class=\"hljs-comment\">// 检查他们的HTTP头中Authorization字符串：</span>\n  <span class=\"hljs-comment\">// Authorization: Bearer &lt;token&gt;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_loading_keys\"><a class=\"anchor\" href=\"#_loading_keys\"></a>加载秘钥</h3>\n<div class=\"paragraph\">\n<p>秘钥可以通过三种不同的方式载入:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>使用 secrets（对称秘钥）</p>\n</li>\n<li>\n<p>使用 OpenSSL 生成的 <code>pem</code> 格式文件（公钥）</p>\n</li>\n<li>\n<p>使用 Java Keystore 文件（对称加密公钥）</p>\n</li>\n</ul>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_symmetric_keys\"><a class=\"anchor\" href=\"#_using_symmetric_keys\"></a>使用对称秘钥</h4>\n<div class=\"paragraph\">\n<p>JWT的默认签名方法称为 <code>HS256</code>。 <code>HS</code> 默认表示为 <code>HMAC 加密 使用 SHA256</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>这便是最简单的加载秘钥方式。您只需要将 secret 与第三方共享，举个例子\n假设 secret 是：<code>keyboard cat</code> 那么您可将 Auth 配置为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuth provider = JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .addPubSecKey(<span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n    .setAlgorithm(<span class=\"hljs-string\">&quot;HS256&quot;</span>)\n    .setBuffer(<span class=\"hljs-string\">&quot;keyboard cat&quot;</span>)));\n\nString token = provider.generateToken(<span class=\"hljs-keyword\">new</span> JsonObject());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下 secret 将被设置为公钥，因为这是双方都知道的令牌，\n您可配置 PubSec 密钥为对称的。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_rsa_keys\"><a class=\"anchor\" href=\"#_using_rsa_keys\"></a>使用 RSA 秘钥</h4>\n<div class=\"paragraph\">\n<p>这部分不是 OpenSSL 文档，建议阅读 OpenSSL 文档了解命令的使用。\n我们将介绍如何生成最通用的密钥以及如何与 JWT auth 一起使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>想象一下，您想使用非常常见的 <code>RS256</code> 加密算法来保护您的资源。 与您想象的相反，\n256 不是秘钥长度而是哈希算法的签名长度。 任何 RSA 秘钥都可以和 JWT 加密算法一期使用。\n这是信息表：</p>\n</div>\n<table class=\"tableblock frame-all grid-all\" style=\"width: 80%;\">\n<colgroup>\n<col style=\"width: 50%;\">\n<col style=\"width: 50%;\">\n</colgroup>\n<thead>\n<tr>\n<th class=\"tableblock halign-left valign-top\">\"alg\" 参数值</th>\n<th class=\"tableblock halign-right valign-top\">数字签名算法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><em>RS256</em></p></td>\n<td class=\"tableblock halign-right valign-top\"><p class=\"tableblock\"><strong>RSASSA-PKCS1-v1_5 using SHA-256</strong></p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><em>RS384</em></p></td>\n<td class=\"tableblock halign-right valign-top\"><p class=\"tableblock\"><strong>RSASSA-PKCS1-v1_5 using SHA-384</strong></p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><em>RS512</em></p></td>\n<td class=\"tableblock halign-right valign-top\"><p class=\"tableblock\"><strong>RSASSA-PKCS1-v1_5 using SHA-512</strong></p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"paragraph\">\n<p>如果您想生成一个2048位的 RSA 密钥对，那么您应该 （请记住 <strong>不要</strong> 添加密码，\n否则 JWT auth 将无法载入秘钥文件）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl genrsa -out private.pem 2048</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如您看到类似的文件内容，那么恭喜您，秘钥文件正确的生成了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAxPSbCQY5mBKFDIn1kggvWb4ChjrctqD4nFnJOJk4mpuZ/u3h\n...\ne4k0yN3F1J1DVlqYWJxaIMzxavQsi9Hz4p2JgyaZMDGB6kGixkMo\n-----END RSA PRIVATE KEY-----</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>标准的 JDK 是无法读取该文件的，所以我们 <strong>必须</strong> 将其转换成 PKCS8 标准格式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl pkcs8 -topk8 -inform PEM -in private.pem -out private_key.pem -nocrypt</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在类似原始文件的新文件 <code>private_key.pem</code> 里包含了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDE9JsJBjmYEoUM\n...\n0fPinYmDJpkwMYHqQaLGQyg=\n-----END PRIVATE KEY-----</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如您只验证令牌（只需要 private_key.pem 文件）那么您需要签发令牌，\n故而您需要一个公钥。在这种情况下您需要从私钥文件中提取公钥文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl rsa -in private.pem -outform PEM -pubout -out public.pem</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您会见到类似以下内容的文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxPSbCQY5mBKFDIn1kggv\n...\nqwIDAQAB\n-----END PUBLIC KEY-----</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在可以校验令牌有效性了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuth provider = JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .addPubSecKey(<span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n    .setAlgorithm(<span class=\"hljs-string\">&quot;RS256&quot;</span>)\n    .setBuffer(\n      <span class=\"hljs-string\">&quot;-----BEGIN PUBLIC KEY-----\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxPSbCQY5mBKFDIn1kggv\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;Wb4ChjrctqD4nFnJOJk4mpuZ/u3h2ZgeKJJkJv8+5oFO6vsEwF7/TqKXp0XDp6IH\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;byaOSWdkl535rCYR5AxDSjwnuSXsSp54pvB+fEEFDPFF81GHixepIbqXCB+BnCTg\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;N65BqwNn/1Vgqv6+H3nweNlbTv8e/scEgbg6ZYcsnBBB9kYLp69FSwNWpvPmd60e\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;3DWyIo3WCUmKlQgjHL4PHLKYwwKgOHG/aNl4hN4/wqTixCAHe6KdLnehLn71x+Z0\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;SyXbWooftefpJP1wMbwlCpH3ikBzVIfHKLWT9QIOVoRgchPU3WAsZv/ePgl5i8Co\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;qwIDAQAB\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;-----END PUBLIC KEY-----&quot;</span>))\n  .addPubSecKey(<span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n    .setAlgorithm(<span class=\"hljs-string\">&quot;RS256&quot;</span>)\n    .setBuffer(\n      <span class=\"hljs-string\">&quot;-----BEGIN PRIVATE KEY-----\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDE9JsJBjmYEoUM\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;ifWSCC9ZvgKGOty2oPicWck4mTiam5n+7eHZmB4okmQm/z7mgU7q+wTAXv9Oopen\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;RcOnogdvJo5JZ2SXnfmsJhHkDENKPCe5JexKnnim8H58QQUM8UXzUYeLF6khupcI\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;H4GcJOA3rkGrA2f/VWCq/r4fefB42VtO/x7+xwSBuDplhyycEEH2Rgunr0VLA1am\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;8+Z3rR7cNbIijdYJSYqVCCMcvg8cspjDAqA4cb9o2XiE3j/CpOLEIAd7op0ud6Eu\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;fvXH5nRLJdtaih+15+kk/XAxvCUKkfeKQHNUh8cotZP1Ag5WhGByE9TdYCxm/94+\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;CXmLwKirAgMBAAECggEAeQ+M+BgOcK35gAKQoklLqZLEhHNL1SnOhnQd3h84DrhU\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;CMF5UEFTUEbjLqE3rYGP25mdiw0ZSuFf7B5SrAhJH4YIcZAO4a7ll23zE0SCW+/r\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;zr9DpX4Q1TP/2yowC4uGHpBfixxpBmVljkWnai20cCU5Ef/O/cAh4hkhDcHrEKwb\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;m9nymKQt06YnvpCMKoHDdqzfB3eByoAKuGxo/sbi5LDpWalCabcg7w+WKIEU1PHb\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;Qi+RiDf3TzbQ6TYhAEH2rKM9JHbp02TO/r3QOoqHMITW6FKYvfiVFN+voS5zzAO3\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;c5X4I+ICNzm+mnt8wElV1B6nO2hFg2PE9uVnlgB2GQKBgQD8xkjNhERaT7f78gBl\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;ch15DRDH0m1rz84PKRznoPrSEY/HlWddlGkn0sTnbVYKXVTvNytKSmznRZ7fSTJB\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;2IhQV7+I0jeb7pyLllF5PdSQqKTk6oCeL8h8eDPN7awZ731zff1AGgJ3DJXlRTh/\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;O6zj9nI8llvGzP30274I2/+cdwKBgQDHd/twbiHZZTDexYewP0ufQDtZP1Nk54fj\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;EpkEuoTdEPymRoq7xo+Lqj5ewhAtVKQuz6aH4BeEtSCHhxy8OFLDBdoGCEd/WBpD\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;f+82sfmGk+FxLyYkLxHCxsZdOb93zkUXPCoCrvNRaUFO1qq5Dk8eftGCdC3iETHE\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;6h5avxHGbQKBgQCLHQVMNhL4MQ9slU8qhZc627n0fxbBUuhw54uE3s+rdQbQLKVq\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;lxcYV6MOStojciIgVRh6FmPBFEvPTxVdr7G1pdU/k5IPO07kc6H7O9AUnPvDEFwg\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;suN/vRelqbwhufAs85XBBY99vWtxdpsVSt5nx2YvegCgdIj/jUAU2B7hGQKBgEgV\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;sCRdaJYr35FiSTsEZMvUZp5GKFka4xzIp8vxq/pIHUXp0FEz3MRYbdnIwBfhssPH\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;/yKzdUxcOLlBtry+jgo0nyn26/+1Uyh5n3VgtBBSePJyW5JQAFcnhqBCMlOVk5pl\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;/7igiQYux486PNBLv4QByK0gV0SPejDzeqzIyB+xAoGAe5if7DAAKhH0r2M8vTkm\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;JvbCFjwuvhjuI+A8AuS8zw634BHne2a1Fkvc8c3d9VDbqsHCtv2tVkxkKXPjVvtB\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;DtzuwUbp6ebF+jOfPK0LDuJoTdTdiNjIcXJ7iTTI3cXUnUNWWphYnFogzPFq9CyL\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;0fPinYmDJpkwMYHqQaLGQyg=\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;-----END PRIVATE KEY-----&quot;</span>)\n  ));\n\nString token = provider.generateToken(\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;some&quot;</span>, <span class=\"hljs-string\">&quot;token-data&quot;</span>),\n  <span class=\"hljs-keyword\">new</span> JWTOptions().setAlgorithm(<span class=\"hljs-string\">&quot;RS256&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_ec_keys\"><a class=\"anchor\" href=\"#_using_ec_keys\"></a>使用 EC 秘钥</h4>\n<div class=\"paragraph\">\n<p>我们还支持椭圆曲线加密算法，但是在默认 JDK 上使用有一定限制</p>\n</div>\n<div class=\"paragraph\">\n<p>用法和 RSA 加密算法极其相似，首先您需要创建一个公钥：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl ecparam -name secp256r1 -genkey -out private.pem</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后您会看到类似以下内容的文件了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-----BEGIN EC PARAMETERS-----\nBggqhkjOPQMBBw==\n-----END EC PARAMETERS-----\n-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIMZGaqZDTHL+IzFYEWLIYITXpGzOJuiQxR2VNGheq7ShoAoGCCqGSM49\nAwEHoUQDQgAEG1O9LCrP6hg3Y9q68+LF0q48UcOkwVKE1ax0b56wjVusf3qnuFO2\n/+XHKKhtzEavvFMeXRQ+ZVEqM0yGNb04qw==\n-----END EC PRIVATE KEY-----</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>但是 JDK 更倾向于使用PKCS8格式，我们必须将其转换：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl pkcs8 -topk8 -nocrypt -in private.pem -out private_key.pem</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后会看到类似内容的文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-----BEGIN PRIVATE KEY-----\nMIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgxkZqpkNMcv4jMVgR\nYshghNekbM4m6JDFHZU0aF6rtKGhRANCAAQbU70sKs/qGDdj2rrz4sXSrjxRw6TB\nUoTVrHRvnrCNW6x/eqe4U7b/5ccoqG3MRq+8Ux5dFD5lUSozTIY1vTir\n-----END PRIVATE KEY-----</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>使用私钥您可生成令牌：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuth provider = JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .addPubSecKey(<span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n    .setAlgorithm(<span class=\"hljs-string\">&quot;ES256&quot;</span>)\n    .setBuffer(\n      <span class=\"hljs-string\">&quot;-----BEGIN PRIVATE KEY-----\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgeRyEfU1NSHPTCuC9\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;rwLZMukaWCH2Fk6q5w+XBYrKtLihRANCAAStpUnwKmSvBM9EI+W5QN3ALpvz6bh0\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;SPCXyz5KfQZQuSj4f3l+xNERDUDaygIUdLjBXf/bc15ur2iZjcq4r0Mr\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;-----END PRIVATE KEY-----\\n&quot;</span>)\n  ));\n\nString token = provider.generateToken(\n  <span class=\"hljs-keyword\">new</span> JsonObject(),\n  <span class=\"hljs-keyword\">new</span> JWTOptions().setAlgorithm(<span class=\"hljs-string\">&quot;ES256&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了验证令牌您还需要一个公钥：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>openssl ec -in private.pem -pubout -out public.pem</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在您可用它进行全部操作了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuth provider = JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .addPubSecKey(<span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n    .setAlgorithm(<span class=\"hljs-string\">&quot;ES256&quot;</span>)\n    .setBuffer(\n      <span class=\"hljs-string\">&quot;-----BEGIN PUBLIC KEY-----\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEraVJ8CpkrwTPRCPluUDdwC6b8+m4\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;dEjwl8s+Sn0GULko+H95fsTREQ1A2soCFHS4wV3/23Nebq9omY3KuK9DKw==\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;-----END PUBLIC KEY-----&quot;</span>))\n  .addPubSecKey(<span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n    .setAlgorithm(<span class=\"hljs-string\">&quot;RS256&quot;</span>)\n    .setBuffer(\n      <span class=\"hljs-string\">&quot;-----BEGIN PRIVATE KEY-----\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgeRyEfU1NSHPTCuC9\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;rwLZMukaWCH2Fk6q5w+XBYrKtLihRANCAAStpUnwKmSvBM9EI+W5QN3ALpvz6bh0\\n&quot;</span> +\n        <span class=\"hljs-string\">&quot;SPCXyz5KfQZQuSj4f3l+xNERDUDaygIUdLjBXf/bc15ur2iZjcq4r0Mr&quot;</span>)\n  ));\n\nString token = provider.generateToken(\n  <span class=\"hljs-keyword\">new</span> JsonObject(),\n  <span class=\"hljs-keyword\">new</span> JWTOptions().setAlgorithm(<span class=\"hljs-string\">&quot;ES256&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_the_jwt_keystore_file\"><a class=\"anchor\" href=\"#_the_jwt_keystore_file\"></a>JWT keystore 文件</h4>\n<div class=\"paragraph\">\n<p>如果您更倾向于使用 Java Keystores 格式的秘钥文件，那么您也可如此做。</p>\n</div>\n<div class=\"paragraph\">\n<p>身份认证器需要在 classpath 或文件路径上加载一个秘钥库，以供\n<code><a href=\"https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html\">javax.crypto.Mac</a></code>\n或 <code><a href=\"https://docs.oracle.com/javase/8/docs/api/java/security/Signature.html\">java.security.Signature</a></code>\n生成或认证令牌。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，该实现将查找以下别名，并不是所有加密算法都有别名。\n就比如 <code>HS256</code> 是存在的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>`HS256`:: HMAC 使用SHA-256哈希算法\n`HS384`:: HMAC 使用SHA-384哈希算法\n`HS512`:: HMAC 使用SHA-512哈希算法\n`RS256`:: RSASSA 使用SHA-256哈希算法\n`RS384`:: RSASSA 使用SHA-384哈希算法\n`RS512`:: RSASSA 使用SHA-512哈希算法\n`ES256`:: ECDSA 使用P-256曲线和SHA-256哈希算法\n`ES384`:: ECDSA 使用P-384曲线和SHA-384哈希算法\n`ES512`:: ECDSA 使用P-521曲线和SHA-512哈希算法</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果未提供密钥库，则实现将回退到不安全模式，并且不会验证签名，\n这对于通过外部手段对 payload 签名会很有用。</p>\n</div>\n<div class=\"paragraph\">\n<p>存储于 keystore 里的密钥对始终包含证书。 证书的有效性在加载时就进行了测试，\n如果证书已过期或无效， 则不会加载证书。</p>\n</div>\n<div class=\"paragraph\">\n<p>给定别名将在所有的密钥算法中匹配最合适的。 例如 <code>RS256</code> 算法是不允许的，<code>EC</code> 算法或 <code>RSA</code> 算法是允许的，\n注意 <code>RSA</code> 具体为 <code>SHA1WithRSA</code> 而不是 <code>SHA256WithRSA</code>。</p>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_generate_a_new_keystore_file\"><a class=\"anchor\" href=\"#_generate_a_new_keystore_file\"></a>生成新的Keystore格式秘钥</h5>\n<div class=\"paragraph\">\n<p>生成秘钥文件需要唯一的工具是 <code>keytool</code>，\n您通过以下方式指定算法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA256 -keysize 2048 -alias HS256 -keypass secret\nkeytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA384 -keysize 2048 -alias HS384 -keypass secret\nkeytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA512 -keysize 2048 -alias HS512 -keypass secret\nkeytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS256 -keypass secret -sigalg SHA256withRSA -dname \"CN=,OU=,O=,L=,ST=,C=\" -validity 360\nkeytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS384 -keypass secret -sigalg SHA384withRSA -dname \"CN=,OU=,O=,L=,ST=,C=\" -validity 360\nkeytool -genkey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg RSA -keysize 2048 -alias RS512 -keypass secret -sigalg SHA512withRSA -dname \"CN=,OU=,O=,L=,ST=,C=\" -validity 360\nkeytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 256 -alias ES256 -keypass secret -sigalg SHA256withECDSA -dname \"CN=,OU=,O=,L=,ST=,C=\" -validity 360\nkeytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 384 -alias ES384 -keypass secret -sigalg SHA384withECDSA -dname \"CN=,OU=,O=,L=,ST=,C=\" -validity 360\nkeytool -genkeypair -keystore keystore.jceks -storetype jceks -storepass secret -keyalg EC -keysize 521 -alias ES512 -keypass secret -sigalg SHA512withECDSA -dname \"CN=,OU=,O=,L=,ST=,C=\" -validity 360</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多有关 keystores 的信息以及如何使用 <code>PKCS12</code> 格式秘钥 (默认：Java版本 &gt;=9)\n请参阅通用模块的文档。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_read_only_tokens\"><a class=\"anchor\" href=\"#_read_only_tokens\"></a>读取令牌</h3>\n<div class=\"paragraph\">\n<p>如果由第三方发布 JWT 令牌，而您没有私钥，\n在这种情况下您的公钥必须是 PEM 格式的。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JWTAuthOptions config = <span class=\"hljs-keyword\">new</span> JWTAuthOptions()\n  .addPubSecKey(<span class=\"hljs-keyword\">new</span> PubSecKeyOptions()\n    .setAlgorithm(<span class=\"hljs-string\">&quot;RS256&quot;</span>)\n    .setBuffer(<span class=\"hljs-string\">&quot;BASE64-ENCODED-PUBLIC_KEY&quot;</span>));\n\nAuthenticationProvider provider = JWTAuth.create(vertx, config);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authnauthz_with_jwt\"><a class=\"anchor\" href=\"#_authnauthz_with_jwt\"></a>AuthN/AuthZ 和 JWT</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>通常在开发微服务时，您希望应用程序能够调用一些 API ​​。\n而这些 API 并不打算暴露给一般用户，\n因而我们应该在架构中移除所有对 API 调用方进行身份验证的交互部分的内容。</p>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，可以使用 HTTP 作为调用 API 的协议，\n并且 HTTP 协议已经定义了应该用于传递授权信息的标头 <code>Authorization</code> 。在大多数情况下令牌将以承载令牌（bearer tokens）的形式发送，\n例如：<code>Authorization: Bearer some+base64+string</code>。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_authenticating_authn\"><a class=\"anchor\" href=\"#_authenticating_authn\"></a>鉴权/身份验证 (AuthN)</h3>\n<div class=\"paragraph\">\n<p>对于此验证器，如果令牌通过签名检查并且令牌未过期，\n则对用户进行身份验证。因此，必须保证私钥安全不被泄露，并且不要在项目中复制粘贴，\n因为这将是一个安全漏洞。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">jwtAuth.authenticate(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;token&quot;</span>, <span class=\"hljs-string\">&quot;BASE64-ENCODED-STRING&quot;</span>))\n  .onSuccess(user -&gt; System.out.println(<span class=\"hljs-string\">&quot;User: &quot;</span> + user.principal()))\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// 失败!</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>简而言之，验证服务正在检查以下几件事：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>令牌签名是否有效</p>\n</li>\n<li>\n<p><code>exp</code>, <code>iat</code>, <code>nbf</code>, <code>audience</code>, <code>issuer</code> 等字段是否满足配置要求</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>如果所有这些都有效，则令牌被认为是正确的，并返回一个用户对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>尽管字段 <code>exp</code>，<code>iat</code>、<code>nbf</code> 是简单的时间戳校验，但只有 <code>exp</code> 可以被配置成忽略：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">jwtAuth.authenticate(\n  <span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">&quot;token&quot;</span>, <span class=\"hljs-string\">&quot;BASE64-ENCODED-STRING&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;options&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n      .put(<span class=\"hljs-string\">&quot;ignoreExpiration&quot;</span>, <span class=\"hljs-keyword\">true</span>)))\n  .onSuccess(user -&gt; System.out.println(<span class=\"hljs-string\">&quot;User: &quot;</span> + user.principal()))\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// 失败!</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了验证 <code>aud</code> 字段需要像以上用例一样传递选项：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">jwtAuth.authenticate(\n  <span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">&quot;token&quot;</span>, <span class=\"hljs-string\">&quot;BASE64-ENCODED-STRING&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;options&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n      .put(<span class=\"hljs-string\">&quot;audience&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonArray().add(<span class=\"hljs-string\">&quot;paulo@server.com&quot;</span>))))\n  .onSuccess(user -&gt; System.out.println(<span class=\"hljs-string\">&quot;User: &quot;</span> + user.principal()))\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// 失败!</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>验证 issuer 字段：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">jwtAuth.authenticate(\n  <span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">&quot;token&quot;</span>, <span class=\"hljs-string\">&quot;BASE64-ENCODED-STRING&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;options&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n      .put(<span class=\"hljs-string\">&quot;issuer&quot;</span>, <span class=\"hljs-string\">&quot;mycorp.com&quot;</span>)))\n  .onSuccess(user -&gt; System.out.println(<span class=\"hljs-string\">&quot;User: &quot;</span> + user.principal()))\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// Failed!</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_authorizing_authz\"><a class=\"anchor\" href=\"#_authorizing_authz\"></a>授权 (AuthZ)</h3>\n<div class=\"paragraph\">\n<p>一旦令牌被解析并且有效，我们就可以使用它来执行授权任务。最简单的方法是验证用户是否具有特定权限。\n授权将遵循通用的 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code> API。\n选择相应的验证服务 API 来产生、验证令牌。</p>\n</div>\n<div class=\"paragraph\">\n<p>目前有两个工厂类：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/jwt/authorization/JWTAuthorization.html\">JWTAuthorization</a></code> 根据权限声明确定权限。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/auth/jwt/authorization/MicroProfileAuthorization.html\">MicroProfileAuthorization</a></code> 令牌根据 &lt;a href=\"https://www.eclipse.org/community/eclipse_newsletter/2017/september/article2.php\"&gt;MP JWT spec&lt;/a&gt;.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>典型的用法是使用验证器从用户对象中提取权限并执行证明：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">AuthorizationProvider authz = MicroProfileAuthorization.create();\n\nauthz.getAuthorizations(user)\n  .onSuccess(v -&gt; {\n    <span class=\"hljs-comment\">// 现在我们可以根据需要执行检查</span>\n    <span class=\"hljs-keyword\">if</span> (PermissionBasedAuthorization.create(<span class=\"hljs-string\">&quot;create-report&quot;</span>).match(user)) {\n      <span class=\"hljs-comment\">// 是的，用户可以创建报告</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下验证器会检查 <code>permissions</code> 键，但是和其他验证器一样,\n可以通过使用 <code>:</code> 分隔符将概念拓展到角色，因此可以用 <code>role:authority</code> 查找令牌。</p>\n</div>\n<div class=\"paragraph\">\n<p>JWT 是个相当自由的格式，并没有强制规定，所以可以将 <code>permissions</code> 配置成其他内容，\n例如，甚至可以在这样的路径下查找：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject config = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;public-key&quot;</span>, <span class=\"hljs-string\">&quot;BASE64-ENCODED-PUBLIC_KEY&quot;</span>)\n  <span class=\"hljs-comment\">// 因为我们正在使用 keycloak JWT 因此我们需要</span>\n  <span class=\"hljs-comment\">// 在令牌中设置许可声明</span>\n  .put(<span class=\"hljs-string\">&quot;permissionsClaimKey&quot;</span>, <span class=\"hljs-string\">&quot;realm_access/roles&quot;</span>);\n\nAuthenticationProvider provider =\n  JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> JWTAuthOptions(config));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>所以在此示例中，我们将 JWT 配置为使用 Keycloak 令牌格式。在这种情况下 <code>realm_access/roles</code> 路径下的 claims 会被检查\n而不是 <code>permissions</code>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_validating_tokens\"><a class=\"anchor\" href=\"#_validating_tokens\"></a>校验令牌</h3>\n<div class=\"paragraph\">\n<p>方法 <code>authenticate</code> 被调用时，令牌将根据初始化期间提供的 <code>JWTOptions</code> 进行\n验证。验证步骤如下:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><code>ignoreExpiration</code> (默认关闭) 是关闭的的情况下, 校验令牌的有效期,\n将检查字段: <code>exp</code>, <code>iat</code> 和 <code>nbf</code>。 由于各端时间存在一定偏差, 可以配置 `leeway`宽限日期，\n应对时间超出而失效的情况。</p>\n</li>\n<li>\n<p>如果配置了 <code>audience</code>, 那么根据配置检查令牌中的 <code>aud</code> 属性，\n所以令牌中必须有属性。</p>\n</li>\n<li>\n<p>如果配置了 <code>issuer</code> ，那么令牌的 <code>iss</code> 属性会被检查。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>这些验证完成后，将返回 JWTUser 对象，该对象包含了配置中对权限声明密文的引用，\n这个值在后面验证时会用到。\n该值对应于权限检查会用的 json 路径。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_customizing_token_generation\"><a class=\"anchor\" href=\"#_customizing_token_generation\"></a>自定义 Token 生成</h3>\n<div class=\"paragraph\">\n<p>以相同的方式验证令牌，生成是在初始化期间进行初始配置的。</p>\n</div>\n<div class=\"paragraph\">\n<p>生成令牌时，可以提供一个可选的额外参数来控制令牌的生成，\n这是一个 <code>JWTOptions</code> 对象。\n可以使用 <code>algorithm</code> 属性来配置令牌签名算法（默认为：HS256）。 在这种情况下，将执行与该算法相对应的密钥的查找并将其用于签名。</p>\n</div>\n<div class=\"paragraph\">\n<p>令牌的 <code>headers</code>\n属性可以添加额外的信息或者与默认选项合并。</p>\n</div>\n<div class=\"paragraph\">\n<p>有时我们发行的令牌会没有时间戳（例如：在测试、开发过程中），在这种情况下 <code>noTimestamp</code> 属性应该被设置成 ture (默认为 false)。\n这将表示着令牌中没有 <code>iat</code> 字段。</p>\n</div>\n<div class=\"paragraph\">\n<p>令牌的过期时间由 <code>expiresInSeconds</code> 属性控制，默认情况下不会过期。\n然后可以配置其他控制字段 <code>audience</code>，<code>issuer</code> 以及 <code>subject</code> 并将其加入到令牌元数据中。</p>\n</div>\n<div class=\"paragraph\">\n<p>最后对令牌以正确的格式进行编码并签名。</p>\n</div>\n</div>\n</div>\n</div>","version":"4.1.3"},"__N_SSG":true}