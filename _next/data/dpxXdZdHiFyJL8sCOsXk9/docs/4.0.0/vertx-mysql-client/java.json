{"pageProps":{"slug":"4.0.0/vertx-mysql-client/java","title":"响应式 MySQL 客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_usage\">使用方法</a></li>\n<li><a href=\"#_getting_started\">开始</a></li>\n<li><a href=\"#_connecting_to_mysql\">连接到 MySQL</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_unix_domain_socket\">Unix 域套接字</a></li>\n</ul>\n</li>\n<li><a href=\"#_configuration\">配置</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_object\">数据对象</a></li>\n<li><a href=\"#_connection_uri\">连接 URI</a></li>\n</ul>\n</li>\n<li><a href=\"#_connect_retries\">连接重试</a></li>\n<li><a href=\"#_running_queries\">运行查询</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_queries\">预处理查询</a></li>\n<li><a href=\"#_batches\">批处理</a></li>\n</ul>\n</li>\n<li><a href=\"#_mysql_last_insert_id\">MySQL LAST_INSERT_ID</a></li>\n<li><a href=\"#_using_connections\">使用连接</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_a_connection\">获取连接</a></li>\n<li><a href=\"#_simplified_transaction_api\">简单事务 API</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_transactions\">使用事务</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_transactions_with_connections\">带事务的连接</a></li>\n<li><a href=\"#_simplified_transaction_api_2\">简单事务 API</a></li>\n</ul>\n</li>\n<li><a href=\"#_cursors_and_streaming\">游标和流</a></li>\n<li><a href=\"#_tracing_queries\">追踪查询</a></li>\n<li><a href=\"#_mysql_type_mapping\">MySQL 类型映射</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_implicit_type_conversion\">隐式类型转换</a></li>\n<li><a href=\"#_handling_boolean\">处理布尔值</a></li>\n<li><a href=\"#_handling_json\">处理 JSON</a></li>\n<li><a href=\"#_handling_bit\">处理 BIT</a></li>\n<li><a href=\"#_handling_time\">处理 TIME</a></li>\n<li><a href=\"#_handling_numeric\">处理 NUMERIC</a></li>\n<li><a href=\"#_handling_enum\">处理 ENUM</a></li>\n<li><a href=\"#_handling_geometry\">处理 GEOMETRY</a></li>\n</ul>\n</li>\n<li><a href=\"#_collector_queries\">集合类查询</a></li>\n<li><a href=\"#_mysql_stored_procedure\">MySQL 存储过程</a></li>\n<li><a href=\"#_mysql_local_infile\">MySQL 导入本地文件</a></li>\n<li><a href=\"#_authentication\">认证</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_default_authentication_plugin\">默认身份验证插件</a></li>\n<li><a href=\"#_new_authentication_method_introduced_in_mysql_8\">MySQL 8 中引入的新身份验证方法</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_ssltls\">使用 SSL/TLS</a></li>\n<li><a href=\"#_mysql_utility_command\">MySQL 实用程序命令</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_com_ping\">COM_PING</a></li>\n<li><a href=\"#_com_reset_connection\">COM_RESET_CONNECTION</a></li>\n<li><a href=\"#_com_change_user\">COM_CHANGE_USER</a></li>\n<li><a href=\"#_com_init_db\">COM_INIT_DB</a></li>\n<li><a href=\"#_com_statistics\">COM_STATISTICS</a></li>\n<li><a href=\"#_com_debug\">COM_DEBUG</a></li>\n<li><a href=\"#_com_set_option\">COM_SET_OPTION</a></li>\n</ul>\n</li>\n<li><a href=\"#_mysql_and_mariadb_version_support_matrix\">MySQL 和 MariaDB 版本支持情况</a></li>\n<li><a href=\"#_pitfalls_good_practices\">陷阱和最佳实践</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_statement_count_limit\">预处理语句的计数限制</a></li>\n<li><a href=\"#_demystifying_prepared_batch\">揭开批量预处理神秘面纱</a></li>\n<li><a href=\"#_tricky_date_time_data_types\">棘手的日期和时间数据类型</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>响应式 MySQL 客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>响应式 MySQL 客户端具有简单易懂的 API，专注于可扩展性和低开销。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>特性</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>事件驱动</p>\n</li>\n<li>\n<p>轻量级</p>\n</li>\n<li>\n<p>内置连接池</p>\n</li>\n<li>\n<p>预处理查询缓存</p>\n</li>\n<li>\n<p>支持游标</p>\n</li>\n<li>\n<p>流式行处理</p>\n</li>\n<li>\n<p>RxJava 1 和 RxJava 2</p>\n</li>\n<li>\n<p>支持对象存储在直接内存，避免不必要的拷贝</p>\n</li>\n<li>\n<p>完整的数据类型支持</p>\n</li>\n<li>\n<p>支持存储过程</p>\n</li>\n<li>\n<p>支持 TLS/SSL</p>\n</li>\n<li>\n<p>MySQL 实用程序命令支持</p>\n</li>\n<li>\n<p>支持 MySQL 和 MariaDB</p>\n</li>\n<li>\n<p>丰富的字符排序（collation）和字符集支持</p>\n</li>\n<li>\n<p>Unix 域套接字</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_usage\"><a class=\"anchor\" href=\"#_usage\"></a>使用方法</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用响应式 MySQL 客户端，需要将以下依赖项添加到项目构建工具的 <em>依赖</em> 配置中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mysql-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-mysql-client:4.0.0'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>开始</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>以下是最简单的连接，查询和断开连接方法</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// 连接池选项</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 创建客户端池</span>\nMySQLPool client = MySQLPool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// 一个简单的查询</span>\nclient\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n\n  <span class=\"hljs-comment\">// 现在关闭客户端池</span>\n  client.close();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_mysql\"><a class=\"anchor\" href=\"#_connecting_to_mysql\"></a>连接到 MySQL</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>大多数时间，您将使用连接池连接到 MySQL：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// 连接池选项</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 创建带连接池的客户端</span>\nMySQLPool client = MySQLPool.pool(connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>带连接池的客户端使用连接池，任何操作都将借用连接池中的连接来执行该操作，\n并将连接释放回连接池中。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 Vert.x 运行，您可以将 Vertx 实例传递给它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// 连接池选项</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-comment\">// 创建带连接池的客户端</span>\nMySQLPool client = MySQLPool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您不再需要连接池时，您需要释放它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您需要在同一连接上执行多个操作时，您需要使用\n<code><a href=\"../../apidocs/io/vertx/mysqlclient/MySQLConnection.html\">connection</a></code> 客户端 。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以轻松地从连接池中获取一个：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// 连接池选项</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 创建带连接池的客户端</span>\nMySQLPool client = MySQLPool.pool(vertx, connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// 从连接池获得连接</span>\nclient.getConnection().compose(conn -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Got a connection from the pool\"</span>);\n\n  <span class=\"hljs-comment\">// 所有操作都在同一连接上执行</span>\n  <span class=\"hljs-keyword\">return</span> conn\n    .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n    .execute()\n    .compose(res -&gt; conn\n      .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='emad'\"</span>)\n      .execute())\n    .onComplete(ar -&gt; {\n      <span class=\"hljs-comment\">// 释放连接池的连接</span>\n      conn.close();\n    });\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    System.out.println(<span class=\"hljs-string\">\"Done\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>连接完成后，您必须关闭它以释放到连接池中，以便可以重复使用。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_unix_domain_socket\"><a class=\"anchor\" href=\"#_unix_domain_socket\"></a>Unix 域套接字</h3>\n<div class=\"paragraph\">\n<p>有时为了简单，安全或性能原因，需要通过 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_socket\">Unix 域套接字</a> 进行连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于 JVM 不支持域套接字，因此首先必须向项目添加本地传输（native transport）扩展。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.netty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>netty-transport-native-epoll<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${netty.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>linux-x86_64<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.netty:netty-transport-native-epoll:${netty.version}:linux-x86_64'</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nARM64 的原生 <code>epoll</code> 支持也可以与分类器（classifier） <code>linux-aarch64</code> 一起添加。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果您的团队中有 Mac 用户，在 <code>osx-x86_64</code> 上添加 <code>netty-transport-native-kqueue</code> 分类器（classifier）。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>然后通过 <code><a href=\"../../apidocs/io/vertx/mysqlclient/MySQLConnectOptions.html#setHost-java.lang.String-\">MySQLConnectOptions#setHost</a></code> 设置域套接字的路径：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setHost(<span class=\"hljs-string\">\"/var/run/mysqld/mysqld.sock\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>);\n\n<span class=\"hljs-comment\">// 连接池选项</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 创建带连接池的客户端</span>\nMySQLPool client = MySQLPool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// 使用vertx实例创建带连接池的客户端</span>\n<span class=\"hljs-comment\">// 确保vertx实例已启用native transports</span>\n<span class=\"hljs-comment\">// vertxOptions.setPreferNativeTransport(true);</span>\nMySQLPool client2 = MySQLPool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有关 native transport 的详细信息，请参阅 <a href=\"https://vertx.io/docs/vertx-core/java/#_native_transports\">Vert.x 文档</a> 。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>有几个选项供您配置客户端。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_data_object\"><a class=\"anchor\" href=\"#_data_object\"></a>数据对象</h3>\n<div class=\"paragraph\">\n<p>配置客户端的简单方法就是指定 <code>MySQLConnectOptions</code> 数据对象。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// 连接池选项</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 从数据对象创建连接池</span>\nMySQLPool pool = MySQLPool.pool(vertx, connectOptions, poolOptions);\n\npool.getConnection(ar -&gt; {\n  <span class=\"hljs-comment\">// 处理您的连接</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_collations_and_character_sets\"><a class=\"anchor\" href=\"#_collations_and_character_sets\"></a>字符序（collations）和字符集（character sets）</h4>\n<div class=\"paragraph\">\n<p>响应式 MySQL 客户端支持配置字符序或字符集，并将它们映射到一个相关的 <code>java.nio.charset.Charset</code> 。\n您可以为数据库连接指定字符集，例如</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions();\n\n<span class=\"hljs-comment\">// 将连接的字符集设置为utf8而不是默认的字符集utf8mb4</span>\nconnectOptions.setCharset(<span class=\"hljs-string\">\"utf8\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>响应式 MySQL 客户端的默认字符集是 <code>utf8mb4</code> 。字符串值，如密码和错误消息等，总是使用 <code>UTF-8</code> 字符集解码。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>characterEncoding</code> 选项用于设置字符串（例如查询字符串和参数值）使用的 Java 字符集，默认使用 <code>UTF-8</code> 字符集；如果设置为 <code>null</code> ，则客户端将使用 Java 的默认字符集。</p>\n</div>\n<div class=\"paragraph\">\n<p>您还可以为连接指定字符序，例如</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions();\n\n<span class=\"hljs-comment\">// 将连接的字符序设置为 utf8_general_ci 来代替默认字符序 utf8mb4_general_ci</span>\n<span class=\"hljs-comment\">// 设置字符序将覆盖charset选项</span>\nconnectOptions.setCharset(<span class=\"hljs-string\">\"gbk\"</span>);\nconnectOptions.setCollation(<span class=\"hljs-string\">\"utf8_general_ci\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意，在数据对象上设置字符序将覆盖 <strong>charset</strong> 和 <strong>characterEncoding</strong> 选项。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以执行 SQL <code>SHOW COLLATION;</code> 或 <code>SHOW CHARACTER SET;</code> 获取服务器支持的字符序和字符集。</p>\n</div>\n<div class=\"paragraph\">\n<p>有关 MySQL 字符集和字符序的更多信息，请参阅 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/charset.html\">MySQL 参考手册</a>。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_connection_attributes\"><a class=\"anchor\" href=\"#_connection_attributes\"></a>连接属性</h4>\n<div class=\"paragraph\">\n<p>还可以使用 <code>setProperties</code> 或 <code>addProperty</code> 方法配置连接属性。注意 <code>setProperties</code> 将覆盖客户端的默认属性。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions();\n\n<span class=\"hljs-comment\">// 添加连接属性</span>\nconnectOptions.addProperty(<span class=\"hljs-string\">\"_java_version\"</span>, <span class=\"hljs-string\">\"1.8.0_212\"</span>);\n\n<span class=\"hljs-comment\">// 覆盖属性</span>\nMap&lt;String, String&gt; attributes = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\nattributes.put(<span class=\"hljs-string\">\"_client_name\"</span>, <span class=\"hljs-string\">\"myapp\"</span>);\nattributes.put(<span class=\"hljs-string\">\"_client_version\"</span>, <span class=\"hljs-string\">\"1.0.0\"</span>);\nconnectOptions.setProperties(attributes);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有关连接属性的更多信息，请参阅 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/performance-schema-connection-attribute-tables.html\">MySQL 参考手册</a>。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_useaffectedrows\"><a class=\"anchor\" href=\"#_useaffectedrows\"></a>配置 <code>useAffectedRows</code></h4>\n<div class=\"paragraph\">\n<p>您可以 <code>useAffectedRows</code> 选项以决定是否在连接到服务器时设置标志 <code>CLIENT_FOUND_ROWS</code>。如果指定了 <code>CLIENT_FOUND_ROWS</code> 标志，则受影响的行计数（返回的）是查找到的行数，而不是受影响的行数。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多有关信息，请参阅 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/mysql-affected-rows.html\">MySQL 参考手册</a></p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection_uri\"><a class=\"anchor\" href=\"#_connection_uri\"></a>连接 URI</h3>\n<div class=\"paragraph\">\n<p>除了使用 <code>MySQLConnectOptions</code> 数据对象进行配置外，我们还为您提供了另外一种使用连接URI进行配置的方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String connectionUri = <span class=\"hljs-string\">\"mysql://dbuser:secretpassword@database.server.com:3211/mydb\"</span>;\n\n<span class=\"hljs-comment\">// 从连接URI创建连接池</span>\nMySQLPool pool = MySQLPool.pool(connectionUri);\n\n<span class=\"hljs-comment\">// 从连接URI创建连接</span>\nMySQLConnection.connect(vertx, connectionUri, res -&gt; {\n  <span class=\"hljs-comment\">// 处理您的连接</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有关连接字符串格式的有关更多信息，请参阅 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/connecting-using-uri-or-key-value-pairs.html#connecting-using-uri\">MySQL 参考手册</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>目前，客户端支持以下的连接 uri 参数关键字（不区分大小写）：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>host</p>\n</li>\n<li>\n<p>port</p>\n</li>\n<li>\n<p>user</p>\n</li>\n<li>\n<p>password</p>\n</li>\n<li>\n<p>schema</p>\n</li>\n<li>\n<p>socket</p>\n</li>\n<li>\n<p>useAffectedRows</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connect_retries\"><a class=\"anchor\" href=\"#_connect_retries\"></a>连接重试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以将客户端配置为在连接无法建立时重试。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options\n  .setReconnectAttempts(<span class=\"hljs-number\">2</span>)\n  .setReconnectInterval(<span class=\"hljs-number\">1000</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_queries\"><a class=\"anchor\" href=\"#_running_queries\"></a>运行查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您不需要事务或运行单个查询时，您可以直接在连接池上运行查询。连接池将使用其中一个连接来运行查询并将结果返回给您。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是运行简单查询的方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>预处理查询</h3>\n<div class=\"paragraph\">\n<p>您可以对预处理查询执行相同的操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>SQL字符串可以使用数据库语法 `?` 按位置引用参数</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id=?\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>查询方法提供异步 <code><a href=\"../../apidocs/io/vertx/sqlclient/RowSet.html\">RowSet</a></code> 实例，它适用于 <em>SELECT</em> 查询。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT first_name, last_name FROM users\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或 <em>UPDATE</em>/<em>INSERT</em> 查询:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO users (first_name, last_name) VALUES (?, ?)\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> 使您可以按索引访问数据</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或按名字</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-string\">\"first_name\"</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端在这里不会使用任何魔术，并且无论您的SQL文本如何，列名都将用表中的名称标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以访问多样的类型</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String firstName = row.getString(<span class=\"hljs-string\">\"first_name\"</span>);\nBoolean male = row.getBoolean(<span class=\"hljs-string\">\"male\"</span>);\nInteger age = row.getInteger(<span class=\"hljs-string\">\"age\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用缓存的预处理语句执行一次性的预处理查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connectOptions.setCachePreparedStatements(<span class=\"hljs-keyword\">true</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = ?\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以创建一个 <code>PreparedStatement</code> 并自己管理生命周期。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sqlConnection\n  .prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = ?\"</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      PreparedStatement preparedStatement = ar.result();\n      preparedStatement.query()\n        .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n            System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n            preparedStatement.close();\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar2.cause().getMessage());\n          }\n        });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batches\"><a class=\"anchor\" href=\"#_batches\"></a>批处理</h3>\n<div class=\"paragraph\">\n<p>您可以执行预处理的批处理</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;Tuple&gt; batch = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>, <span class=\"hljs-string\">\"Julien Viet\"</span>));\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"emad\"</span>, <span class=\"hljs-string\">\"Emad Alblueshi\"</span>));\n\n<span class=\"hljs-comment\">// 执行预处理的批处理</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO USERS (id, name) VALUES (?, ?)\"</span>)\n  .executeBatch(batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// 处理行</span>\n    RowSet&lt;Row&gt; rows = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Batch failed \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_mysql_last_insert_id\"><a class=\"anchor\" href=\"#_mysql_last_insert_id\"></a>MySQL LAST_INSERT_ID</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>往表中插入一条记录后，可以获得自增值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"INSERT INTO test(val) VALUES ('v1')\"</span>)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      <span class=\"hljs-keyword\">long</span> lastInsertId = rows.property(MySQLClient.LAST_INSERTED_ID);\n      System.out.println(<span class=\"hljs-string\">\"Last inserted id is: \"</span> + lastInsertId);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多有关信息，请参阅 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/getting-unique-id.html\">如何获取最近一条插入记录的唯一ID</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_connections\"><a class=\"anchor\" href=\"#_using_connections\"></a>使用连接</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>获取连接</h3>\n<div class=\"paragraph\">\n<p>当需要执行顺序查询（无事务）时，可以创建一个新连接或从连接池中借用一个：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection(ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    SqlConnection connection = ar1.result();\n\n    connection\n      .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n      .execute(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n        connection\n          .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='paulo'\"</span>)\n          .execute(ar3 -&gt; {\n          <span class=\"hljs-comment\">// 对行执行一些操作，然后将连接返回到连接池中</span>\n          connection.close();\n        });\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 将连接返回到连接池中</span>\n        connection.close();\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以创建预处理查询语句：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE ?\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    PreparedStatement prepared = ar1.result();\n    prepared.query().execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        <span class=\"hljs-comment\">// 所有的行</span>\n        RowSet&lt;Row&gt; rows = ar2.result();\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_transaction_api\"><a class=\"anchor\" href=\"#_simplified_transaction_api\"></a>简单事务 API</h3>\n<div class=\"paragraph\">\n<p>当您创建了一个连接池, 您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withConnection-java.util.function.Function-io.vertx.core.Handler-\">withConnection</a></code> 并传入一个使用连接进行处理的函数。</p>\n</div>\n<div class=\"paragraph\">\n<p>它从连接池中借用一个连接，并使用该连接调用函数。</p>\n</div>\n<div class=\"paragraph\">\n<p>该函数必须返回一个任意结果的 Future。</p>\n</div>\n<div class=\"paragraph\">\n<p>Future 完成后, 连接将归还至连接池，并提供全部的结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;Integer&gt; future = pool.withConnection(conn -&gt; conn\n  .query(<span class=\"hljs-string\">\"SELECT id FROM USERS WHERE name = 'Julien'\"</span>)\n  .execute()\n  .flatMap(rowSet -&gt; {\n    Iterator&lt;Row&gt; rows = rowSet.iterator();\n    <span class=\"hljs-keyword\">if</span> (rows.hasNext()) {\n      Row row = rows.next();\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture(row.getInteger(<span class=\"hljs-string\">\"id\"</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"No results\"</span>);\n    }\n  }));\nfuture.onSuccess(id -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"User id: \"</span> + id);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_transactions\"><a class=\"anchor\" href=\"#_using_transactions\"></a>使用事务</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_transactions_with_connections\"><a class=\"anchor\" href=\"#_transactions_with_connections\"></a>带事务的连接</h3>\n<div class=\"paragraph\">\n<p>您可以使用SQL <code>BEGIN</code>/<code>COMMIT</code>/<code>ROLLBACK</code> 执行事务，如果您必须这么做，就必须使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 自己管理事务。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者您使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 的事务API：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// 事务必须使用一个连接</span>\n    SqlConnection conn = res.result();\n\n    <span class=\"hljs-comment\">// 开始事务</span>\n    conn.begin(ar0 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar0.succeeded()) {\n        Transaction tx = ar0.result();\n        <span class=\"hljs-comment\">// 各种语句</span>\n        conn\n          .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n          .execute(ar1 -&gt; {\n            <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n              conn\n                .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\"</span>)\n                .execute(ar2 -&gt; {\n                  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n                    <span class=\"hljs-comment\">// 提交事务</span>\n                    tx.commit(ar3 -&gt; {\n                      <span class=\"hljs-keyword\">if</span> (ar3.succeeded()) {\n                        System.out.println(<span class=\"hljs-string\">\"Transaction succeeded\"</span>);\n                      } <span class=\"hljs-keyword\">else</span> {\n                        System.out.println(<span class=\"hljs-string\">\"Transaction failed \"</span> + ar3.cause().getMessage());\n                      }\n                      <span class=\"hljs-comment\">// 将连接返回到连接池</span>\n                      conn.close();\n                    });\n                  } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">// 将连接返回到连接池</span>\n                    conn.close();\n                  }\n                });\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">// 将连接返回到连接池</span>\n              conn.close();\n            }\n          });\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 将连接返回到连接池</span>\n        conn.close();\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当数据库服务器报告当前事务失败时（例如，臭名昭著的 <em>current transaction is aborted, commands ignored until end of transaction block</em>），\n事务被回滚，此时 <code><a href=\"../../apidocs/io/vertx/sqlclient/Transaction.html#completion--\">completion</a></code> Future 会失败，\n并返回 <code><a href=\"../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html\">TransactionRollbackException</a></code> 异常：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">tx.completion().onFailure(err -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Transaction failed =&gt; rollbacked\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_transaction_api_2\"><a class=\"anchor\" href=\"#_simplified_transaction_api_2\"></a>简单事务 API</h3>\n<div class=\"paragraph\">\n<p>当您创建了一个连接池, 您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withConnection-java.util.function.Function-io.vertx.core.Handler-\">withConnection</a></code> 并传入一个使用连接进行处理的函数。</p>\n</div>\n<div class=\"paragraph\">\n<p>它从连接池中借用一个连接，开始事务，并且，在此事务范围内所有执行操作的客户端调用该函数。</p>\n</div>\n<div class=\"paragraph\">\n<p>该函数必须返回一个任意结果的Future。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当Future成功，客户端提交这个事务</p>\n</li>\n<li>\n<p>当Future失败，客户端回滚这个事务</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>事务完成后, 连接将返回到连接池中，并提供全部的结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withTransaction(client -&gt; client\n  .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n  .execute()\n  .flatMap(res -&gt; client\n    .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n    .execute()\n    <span class=\"hljs-comment\">// 映射一个消息结果</span>\n    .map(<span class=\"hljs-string\">\"Users inserted\"</span>))\n).onComplete(ar -&gt; {\n  <span class=\"hljs-comment\">// 连接已自动返回到连接池中</span>\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 事务被提交</span>\n    String message = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Transaction succeeded: \"</span> + message);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 事务被回滚</span>\n    System.out.println(<span class=\"hljs-string\">\"Transaction failed \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cursors_and_streaming\"><a class=\"anchor\" href=\"#_cursors_and_streaming\"></a>游标和流</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下，执行预处理查询将获取所有行，您可以使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Cursor.html\">Cursor</a></code> 控制想读取的行数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE age &gt; ?\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    PreparedStatement pq = ar1.result();\n\n    <span class=\"hljs-comment\">// 创建游标</span>\n    Cursor cursor = pq.cursor(Tuple.of(<span class=\"hljs-number\">18</span>));\n\n    <span class=\"hljs-comment\">// 读取50行</span>\n    cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        RowSet&lt;Row&gt; rows = ar2.result();\n\n        <span class=\"hljs-comment\">// 检查更多 ?</span>\n        <span class=\"hljs-keyword\">if</span> (cursor.hasMore()) {\n          <span class=\"hljs-comment\">// 重复这个过程...</span>\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// 没有更多行-关闭游标</span>\n          cursor.close();\n        }\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>游标提前释放时应将其关闭：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n    <span class=\"hljs-comment\">// 关闭游标</span>\n    cursor.close();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>游标还可以使用流式API，这可以更加方便，尤其是在Rx化的版本中。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE age &gt; ?\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    PreparedStatement pq = ar1.result();\n\n    <span class=\"hljs-comment\">// 一次获取50行</span>\n    RowStream&lt;Row&gt; stream = pq.createStream(<span class=\"hljs-number\">50</span>, Tuple.of(<span class=\"hljs-number\">18</span>));\n\n    <span class=\"hljs-comment\">// 使用流</span>\n    stream.exceptionHandler(err -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"Error: \"</span> + err.getMessage());\n    });\n    stream.endHandler(v -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"End of stream\"</span>);\n    });\n    stream.handler(row -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"User: \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当这些行已传递给处理程序时，该流将批量读取 <code>50</code> 行并将其流化。\n然后读取新一批的 <code>50</code> 行数据，依此类推。</p>\n</div>\n<div class=\"paragraph\">\n<p>流可以恢复或暂停，已加载的行将保留在内存中，直到被送达，游标将停止迭代。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>追踪查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当Vert.x启用了跟踪时，SQL客户端可以跟踪查询执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端报告以下 <em>client</em> 跨度（spans）：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> operation name</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>db.user</code>: the database username</p>\n</li>\n<li>\n<p><code>db.instance</code>: the database instance</p>\n</li>\n<li>\n<p><code>db.statement</code>: the SQL query</p>\n</li>\n<li>\n<p><code>db.type</code>: <em>sql</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认的跟踪策略是 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code> ，客户端仅当涉及活动跟踪时才创建跨度（span）。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnectOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 更改客户策略，例如 您可以设置  <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code> 总是报告跨度（span）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_mysql_type_mapping\"><a class=\"anchor\" href=\"#_mysql_type_mapping\"></a>MySQL 类型映射</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当前客户端支持以下 MySQL 类型</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>BOOL,BOOLEAN (<code>java.lang.Byte</code>)</p>\n</li>\n<li>\n<p>TINYINT (<code>java.lang.Byte</code>)</p>\n</li>\n<li>\n<p>TINYINT UNSIGNED(<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>SMALLINT (<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>SMALLINT UNSIGNED(<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>MEDIUMINT (<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>MEDIUMINT UNSIGNED(<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>INT,INTEGER (<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>INTEGER UNSIGNED(<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>BIGINT (<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>BIGINT UNSIGNED(<code>io.vertx.sqlclient.data.Numeric</code>)</p>\n</li>\n<li>\n<p>FLOAT (<code>java.lang.Float</code>)</p>\n</li>\n<li>\n<p>FLOAT UNSIGNED(<code>java.lang.Float</code>)</p>\n</li>\n<li>\n<p>DOUBLE (<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>DOUBLE UNSIGNED(<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>BIT (<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>NUMERIC (<code>io.vertx.sqlclient.data.Numeric</code>)</p>\n</li>\n<li>\n<p>NUMERIC UNSIGNED(<code>io.vertx.sqlclient.data.Numeric</code>)</p>\n</li>\n<li>\n<p>DATE (<code>java.time.LocalDate</code>)</p>\n</li>\n<li>\n<p>DATETIME (<code>java.time.LocalDateTime</code>)</p>\n</li>\n<li>\n<p>TIME (<code>java.time.Duration</code>)</p>\n</li>\n<li>\n<p>TIMESTAMP (<code>java.time.LocalDateTime</code>)</p>\n</li>\n<li>\n<p>YEAR (<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>CHAR (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>VARCHAR (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>BINARY (<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n<li>\n<p>VARBINARY (<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n<li>\n<p>TINYBLOB (<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n<li>\n<p>TINYTEXT (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>BLOB (<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n<li>\n<p>TEXT (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>MEDIUMBLOB (<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n<li>\n<p>MEDIUMTEXT (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>LONGBLOB (<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n<li>\n<p>LONGTEXT (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>ENUM (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>SET (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>JSON (<code>io.vertx.core.json.JsonObject</code>, <code>io.vertx.core.json.JsonArray</code>, <code>Number</code>, <code>Boolean</code>, <code>String</code>, <code>io.vertx.sqlclient.Tuple#JSON_NULL</code>)</p>\n</li>\n<li>\n<p>GEOMETRY(<code>io.vertx.mysqlclient.data.spatial.*</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>元组解码在存储值时使用上述类型</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意：在Java中，没有无符号数字值的具体表示形式，因此客户端会将无符号值转换为相关的Java类型。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_implicit_type_conversion\"><a class=\"anchor\" href=\"#_implicit_type_conversion\"></a>隐式类型转换</h3>\n<div class=\"paragraph\">\n<p>当执行预处理语句时，响应式 MySQL 客户端支持隐式类型转换。\n假设您的表中有一个 <code>TIME</code> 列，下面的两个示例都是有效的。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM students WHERE updated_time = ?\"</span>)\n  .execute(Tuple.of(LocalTime.of(<span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">25</span>)), ar -&gt; {\n  <span class=\"hljs-comment\">// 处理结果</span>\n});\n<span class=\"hljs-comment\">// 这个也适用于隐式类型转换</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM students WHERE updated_time = ?\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"19:10:25\"</span>), ar -&gt; {\n  <span class=\"hljs-comment\">// 处理结果</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>MySQL 数据类型编码是根据参数值推断的。下面是具体的类型映射：</p>\n</div>\n<table class=\"tableblock frame-all grid-all stretch\">\n<colgroup>\n<col style=\"width: 50%;\">\n<col style=\"width: 50%;\">\n</colgroup>\n<thead>\n<tr>\n<th class=\"tableblock halign-left valign-top\">参数值</th>\n<th class=\"tableblock halign-left valign-top\">MySQL 类型编码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">null</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_NULL</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.lang.Byte</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_TINY</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.lang.Boolean</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_TINY</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.lang.Short</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_SHORT</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.lang.Integer</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_LONG</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.lang.Long</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_LONGLONG</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.lang.Double</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_DOUBLE</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.lang.Float</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_FLOAT</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.time.LocalDate</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_DATE</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.time.Duration</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_TIME</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.time.LocalTime</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_TIME</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">io.vertx.core.buffer.Buffer</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_BLOB</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">java.time.LocalDateTime</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_DATETIME</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">io.vertx.mysqlclient.data.spatial.*</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_BLOB</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">default</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">MYSQL_TYPE_STRING</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_boolean\"><a class=\"anchor\" href=\"#_handling_boolean\"></a>处理布尔值</h3>\n<div class=\"paragraph\">\n<p>在 MySQL 中 <code>BOOLEAN</code> 和 <code>BOOL</code> 数据类型是 <code>TINYINT(1)</code> 的同义词。零值视为 false，非零值视为 true。\n<code>BOOLEAN</code> 数据类型值以 <code>java.lang.Byte</code> 类型存储在 <code>Row</code> 或 <code>Tuple</code> 中，调用 <code>Row#getValue</code> 可以获取到 <code>java.lang.Byte</code> 类型的值，\n也可以调用 <code>Row#getBoolean</code> 获取 <code>java.lang.Boolean</code> 类型的值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT graduated FROM students WHERE id = 0\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rowSet = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rowSet) {\n      <span class=\"hljs-keyword\">int</span> pos = row.getColumnIndex(<span class=\"hljs-string\">\"graduated\"</span>);\n      Byte value = row.get(Byte<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">pos</span>)</span>;\n      Boolean graduated = row.getBoolean(<span class=\"hljs-string\">\"graduated\"</span>);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您想要使用一个 <code>BOOLEAN</code> 参数值执行预处理语句时，只要简单地在参数列表中添加  <code>java.lang.Boolean</code> 值即可。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"UPDATE students SET graduated = ? WHERE id = 0\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-keyword\">true</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Updated with the boolean value\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_json\"><a class=\"anchor\" href=\"#_handling_json\"></a>处理 JSON</h3>\n<div class=\"paragraph\">\n<p>MySQL <code>JSON</code> 数据类型由以下Java类型表示：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>String</code></p>\n</li>\n<li>\n<p><code>Number</code></p>\n</li>\n<li>\n<p><code>Boolean</code></p>\n</li>\n<li>\n<p><code>io.vertx.core.json.JsonObject</code></p>\n</li>\n<li>\n<p><code>io.vertx.core.json.JsonArray</code></p>\n</li>\n<li>\n<p><code>io.vertx.sqlclient.Tuple#JSON_NULL</code> 表示 JSON null 字面量</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Tuple tuple = Tuple.of(\n  Tuple.JSON_NULL,\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>),\n  <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-comment\">// 获取 json</span>\nObject value = tuple.getValue(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 期望得到 JSON_NULL</span>\n\n<span class=\"hljs-comment\">//</span>\nvalue = tuple.get(JsonObject<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 1)</span>; <span class=\"hljs-comment\">// 期望得到 JSON object</span>\n\n<span class=\"hljs-comment\">//</span>\nvalue = tuple.get(Integer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 2)</span>; <span class=\"hljs-comment\">// 期望得到 3</span>\nvalue = tuple.getInteger(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 期望得到 3</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_bit\"><a class=\"anchor\" href=\"#_handling_bit\"></a>处理 BIT</h3>\n<div class=\"paragraph\">\n<p><code>BIT</code> 是 <code>java.lang.Long</code> 类型的映射, 但是Java没有无符号数值的概念, 因此，如果您要插入或更新一条记录为 <code>BIT(64)</code> 的最大值 , 可以将参数设置为 <code>-1L</code> 。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_time\"><a class=\"anchor\" href=\"#_handling_time\"></a>处理 TIME</h3>\n<div class=\"paragraph\">\n<p>MySQL <code>TIME</code> 数据类型可用于表示一天中的时间或范围为 <code>-838:59:59</code> 到 <code>838:59:59</code> 的时间间隔。在响应式MySQL客户端， <code>TIME</code> 数据类型自然的被映射为 <code>java.time.Duration</code>，您也可以调用 <code>Row#getLocalTime</code> 获取到 <code>java.time.LocalTime</code> 类型的值。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_numeric\"><a class=\"anchor\" href=\"#_handling_numeric\"></a>处理 NUMERIC</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/sqlclient/data/Numeric.html\">Numeric</a></code> Java类型用于表示MySQL的 <code>NUMERIC</code> 类型。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Numeric numeric = row.get(Numeric<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 0)</span>;\n<span class=\"hljs-keyword\">if</span> (numeric.isNaN()) {\n  <span class=\"hljs-comment\">// 处理 NaN</span>\n} <span class=\"hljs-keyword\">else</span> {\n  BigDecimal value = numeric.bigDecimalValue();\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_enum\"><a class=\"anchor\" href=\"#_handling_enum\"></a>处理 ENUM</h3>\n<div class=\"paragraph\">\n<p>MySQL支持ENUM数据类型，客户端将这些类型检索为String数据类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以像这样将Java枚举编码为String：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO colors VALUES (?)\"</span>)\n  .execute(Tuple.of(Color.red),  res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以将 ENUM 类型的列读取为 Java 的枚举，如以下代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT color FROM colors\"</span>)\n  .execute()\n  .onComplete(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    RowSet&lt;Row&gt; rows = res.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(row.get(Color<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, \"<span class=\"hljs-title\">color</span>\"))</span>;\n    }\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_geometry\"><a class=\"anchor\" href=\"#_handling_geometry\"></a>处理 GEOMETRY</h3>\n<div class=\"paragraph\">\n<p>MYSQL 还支持 <code>GEOMETRY</code>  数据类型，下面是一些示例展示您可以使用 Well-Known Text（WKT）格式或 Well-Known Binary（WKB）格式处理几何数据，数据被解码为MySQL TEXT 或 BLOB 数据类型。有很多很棒的第三方库可以处理这种格式的数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以以 WKT 格式获取空间数据：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT ST_AsText(g) FROM geom;\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 以WKT格式获取空间数据</span>\n    RowSet&lt;Row&gt; result = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : result) {\n      String wktString = row.getString(<span class=\"hljs-number\">0</span>);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者，您可以以WKB格式获取空间数据：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT ST_AsBinary(g) FROM geom;\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 以WKB格式获取空间数据</span>\n    RowSet&lt;Row&gt; result = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : result) {\n      Buffer wkbValue = row.getBuffer(<span class=\"hljs-number\">0</span>);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在响应式 MySQL 客户端中，我们还提供了一种处理几何数据类型的简单方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以将几何数据作为Vert.x数据对象检索：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT g FROM geom;\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 以Vert.x数据对象获取空间数据</span>\n    RowSet&lt;Row&gt; result = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : result) {\n      Point point = row.get(Point<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 0)</span>;\n      System.out.println(<span class=\"hljs-string\">\"Point x: \"</span> + point.getX());\n      System.out.println(<span class=\"hljs-string\">\"Point y: \"</span> + point.getY());\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以将WKB描述用作预处理语句参数。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Point point = <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1.5</span>, <span class=\"hljs-number\">1.5</span>);\n<span class=\"hljs-comment\">// 以 WKB 描述发送</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO geom VALUES (ST_GeomFromWKB(?))\"</span>)\n  .execute(Tuple.of(point), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Success\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>集合类查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以将查询API与Java集合类结合使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, Map&lt;Long, String&gt;&gt; collector = Collectors.toMap(\n  row -&gt; row.getLong(<span class=\"hljs-string\">\"id\"</span>),\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n\n<span class=\"hljs-comment\">// 运行查询使用集合类</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>).collecting(collector).execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;Map&lt;Long, String&gt;&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// 获取用集合类创建的map</span>\n      Map&lt;Long, String&gt; map = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + map);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>集合类处理不能保留 <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code>\n的引用，因为只有一个 Row 对象用于处理整个集合。</p>\n</div>\n<div class=\"paragraph\">\n<p>Java <code>Collectors</code> 提供了许多有趣的预定义集合类，例如，\n您可以直接用 Row 中的集合轻松拼接成一个字符串：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, String&gt; collector = Collectors.mapping(\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>),\n  Collectors.joining(<span class=\"hljs-string\">\",\"</span>, <span class=\"hljs-string\">\"(\"</span>, <span class=\"hljs-string\">\")\"</span>)\n);\n\n<span class=\"hljs-comment\">// 运行查询使用集合类</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>).collecting(collector).execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;String&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// 获取用集合类创建的String</span>\n      String list = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + list);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_mysql_stored_procedure\"><a class=\"anchor\" href=\"#_mysql_stored_procedure\"></a>MySQL 存储过程</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以在查询中运行存储过程。结果将按照 <a href=\"https://dev.mysql.com/doc/dev/mysql-server/8.0.12/page_protocol_command_phase_sp.html\">MySQL 协议</a> 从服务器获取，无需任何魔法。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.query(<span class=\"hljs-string\">\"CREATE PROCEDURE multi() BEGIN\\n\"</span> +\n  <span class=\"hljs-string\">\"  SELECT 1;\\n\"</span> +\n  <span class=\"hljs-string\">\"  SELECT 1;\\n\"</span> +\n  <span class=\"hljs-string\">\"  INSERT INTO ins VALUES (1);\\n\"</span> +\n  <span class=\"hljs-string\">\"  INSERT INTO ins VALUES (2);\\n\"</span> +\n  <span class=\"hljs-string\">\"END;\"</span>).execute(ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    <span class=\"hljs-comment\">// 创建存储过程成功</span>\n    client\n      .query(<span class=\"hljs-string\">\"CALL multi();\"</span>)\n      .execute(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        <span class=\"hljs-comment\">// 处理结果</span>\n        RowSet&lt;Row&gt; result1 = ar2.result();\n        Row row1 = result1.iterator().next();\n        System.out.println(<span class=\"hljs-string\">\"First result: \"</span> + row1.getInteger(<span class=\"hljs-number\">0</span>));\n\n        RowSet&lt;Row&gt; result2 = result1.next();\n        Row row2 = result2.iterator().next();\n        System.out.println(<span class=\"hljs-string\">\"Second result: \"</span> + row2.getInteger(<span class=\"hljs-number\">0</span>));\n\n        RowSet&lt;Row&gt; result3 = result2.next();\n        System.out.println(<span class=\"hljs-string\">\"Affected rows: \"</span> + result3.rowCount());\n      } <span class=\"hljs-keyword\">else</span> {\n        System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar2.cause().getMessage());\n      }\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar1.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Note: 目前尚不支持绑定OUT参数的预处理语句。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_mysql_local_infile\"><a class=\"anchor\" href=\"#_mysql_local_infile\"></a>MySQL 导入本地文件</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>该客户端支持处理 LOCAL INFILE 请求, 如果要将数据从本地文件加载到服务器，则可以使用语句\n<code>LOAD DATA LOCAL INFILE '&lt;filename&gt;' INTO TABLE &lt;table&gt;;</code>。 更多有关信息，请参阅 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/load-data.html\">MySQL 参考手册</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authentication\"><a class=\"anchor\" href=\"#_authentication\"></a>认证</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_default_authentication_plugin\"><a class=\"anchor\" href=\"#_default_authentication_plugin\"></a>默认身份验证插件</h3>\n<div class=\"paragraph\">\n<p>该客户端支持指定在连接开始时使用缺省的身份验证插件。\n当前支持以下插件：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>mysql_native_password</p>\n</li>\n<li>\n<p>caching_sha2_password</p>\n</li>\n<li>\n<p>mysql_clear_password</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions options = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n  .setAuthenticationPlugin(MySQLAuthenticationPlugin.MYSQL_NATIVE_PASSWORD); <span class=\"hljs-comment\">// 设定默认身份验证插件</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_new_authentication_method_introduced_in_mysql_8\"><a class=\"anchor\" href=\"#_new_authentication_method_introduced_in_mysql_8\"></a>MySQL 8 中引入的新身份验证方法</h3>\n<div class=\"paragraph\">\n<p>MySQL 8.0 引入了一种名为 <code>caching_sha2_password</code> 的身份验证方法，它是默认的身份验证方法。\n为了使用此新的身份验证方法连接到服务器，您需要使用安全连接（例如 启用 TLS/SSL）或使用 RSA 密钥对交换加密密码，以避免密码泄漏。RSA 密钥对在通信过程中会自动交换，但服务器 RSA 公钥可能会在这个过程中被黑客攻击，因为它通过不安全的连接传输。\n因此，如果您使用不安全的连接，并且希望避免暴露服务器 RSA 公钥的风险，可以这样设置服务器 RSA 公钥：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions options1 = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n  .setServerRsaPublicKeyPath(<span class=\"hljs-string\">\"tls/files/public_key.pem\"</span>); <span class=\"hljs-comment\">// 配置公钥路径</span>\n\nMySQLConnectOptions options2 = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n  .setServerRsaPublicKeyValue(Buffer.buffer(<span class=\"hljs-string\">\"-----BEGIN PUBLIC KEY-----\\n\"</span> +\n    <span class=\"hljs-string\">\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3yvG5s0qrV7jxVlp0sMj\\n\"</span> +\n    <span class=\"hljs-string\">\"xP0a6BuLKCMjb0o88hDsJ3xz7PpHNKazuEAfPxiRFVAV3edqfSiXoQw+lJf4haEG\\n\"</span> +\n    <span class=\"hljs-string\">\"HQe12Nfhs+UhcAeTKXRlZP/JNmI+BGoBduQ1rCId9bKYbXn4pvyS/a1ft7SwFkhx\\n\"</span> +\n    <span class=\"hljs-string\">\"aogCur7iIB0WUWvwkQ0fEj/Mlhw93lLVyx7hcGFq4FOAKFYr3A0xrHP1IdgnD8QZ\\n\"</span> +\n    <span class=\"hljs-string\">\"0fUbgGLWWLOossKrbUP5HWko1ghLPIbfmU6o890oj1ZWQewj1Rs9Er92/UDj/JXx\\n\"</span> +\n    <span class=\"hljs-string\">\"7ha1P+ZOgPBlV037KDQMS6cUh9vTablEHsMLhDZanymXzzjBkL+wH/b9cdL16LkQ\\n\"</span> +\n    <span class=\"hljs-string\">\"5QIDAQAB\\n\"</span> +\n    <span class=\"hljs-string\">\"-----END PUBLIC KEY-----\\n\"</span>)); <span class=\"hljs-comment\">// 配置公钥缓冲</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有关 <code>caching_sha2_password</code> 身份验证方法的更多信息，请参见 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html\">MySQL 参考手册</a>.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_ssltls\"><a class=\"anchor\" href=\"#_using_ssltls\"></a>使用 SSL/TLS</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>配置客户端使用SSL连接, 您可以像 Vert.x <code>NetClient</code> 一样配置\n<code><a href=\"../../apidocs/io/vertx/mysqlclient/MySQLConnectOptions.html\">MySQLConnectOptions</a></code> 。\n响应式 MySQL 客户端 支持所有 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/connection-options.html#option_general_ssl-mode\">SSL 模式</a> ，而且您能够配置 <code>sslmode</code>. 客户端默认设置为 <code>DISABLED</code> SSL 模式。\n <code>ssl</code> 参数仅作为设置 <code>sslmode</code> 的快捷方式存在。<code>setSsl(true)</code> 等价于 <code>setSslMode(VERIFY_CA)</code> ， <code>setSsl(false)</code> 等价于 <code>setSslMode(DISABLED)</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLConnectOptions options = <span class=\"hljs-keyword\">new</span> MySQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">3306</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n  .setSslMode(SslMode.VERIFY_CA)\n  .setPemTrustOptions(<span class=\"hljs-keyword\">new</span> PemTrustOptions().addCertPath(<span class=\"hljs-string\">\"/path/to/cert.pem\"</span>));\n\nMySQLConnection.connect(vertx, options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// 用SSL连接</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Could not connect \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多详细信息，请参阅 <a href=\"http://vertx.io/docs/vertx-core/java/#ssl\">Vert.x 文档</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_mysql_utility_command\"><a class=\"anchor\" href=\"#_mysql_utility_command\"></a>MySQL 实用程序命令</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>有时您希望使用 MySQL 实用程序命令，我们为此提供支持。有关更多信息，请参阅 <a href=\"https://dev.mysql.com/doc/dev/mysql-server/8.0.12/page_protocol_command_phase_utility.html\">MySQL 实用程序命令</a>.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_com_ping\"><a class=\"anchor\" href=\"#_com_ping\"></a>COM_PING</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code>COM_PING</code> 命令检查服务器是否处于活动状态。如果服务器响应 PING，将通知处理程序，否则将永远不会调用处理程序。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.ping(ar -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"The server has responded to the PING\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_com_reset_connection\"><a class=\"anchor\" href=\"#_com_reset_connection\"></a>COM_RESET_CONNECTION</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code>COM_RESET_CONNECTION</code> 命令重置会话状态，这将重置连接状态，如：\n- user variables\n- temporary tables\n- prepared statements</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.resetConnection(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Connection has been reset now\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_com_change_user\"><a class=\"anchor\" href=\"#_com_change_user\"></a>COM_CHANGE_USER</h3>\n<div class=\"paragraph\">\n<p>您可以更改当前连接的用户，这将执行re-authentication并重置连接状态，如 <code>COM_RESET_CONNECTION</code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MySQLAuthOptions authenticationOptions = <span class=\"hljs-keyword\">new</span> MySQLAuthOptions()\n  .setUser(<span class=\"hljs-string\">\"newuser\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"newpassword\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"newdatabase\"</span>);\nconnection.changeUser(authenticationOptions, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"User of current connection has been changed.\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_com_init_db\"><a class=\"anchor\" href=\"#_com_init_db\"></a>COM_INIT_DB</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code>COM_INIT_DB</code> 命令更改连接的默认schema。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.specifySchema(<span class=\"hljs-string\">\"newschema\"</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Default schema changed to newschema\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_com_statistics\"><a class=\"anchor\" href=\"#_com_statistics\"></a>COM_STATISTICS</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code>COM_STATISTICS</code> 命令获取某些内部状态变量的可读字符串。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.getInternalStatistics(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Statistics: \"</span> + ar.result());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_com_debug\"><a class=\"anchor\" href=\"#_com_debug\"></a>COM_DEBUG</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code>COM_DEBUG</code> 命令将调试信息转储到MySQL服务器的STDOUT。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.debug(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"Debug info dumped to server's STDOUT\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_com_set_option\"><a class=\"anchor\" href=\"#_com_set_option\"></a>COM_SET_OPTION</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code>COM_SET_OPTION</code> 命令设置当前连接的选项。目前只能设置 <code>CLIENT_MULTI_STATEMENTS</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您可以使用此命令禁用 <code>CLIENT_MULTI_STATEMENTS</code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.setOption(MySQLSetOption.MYSQL_OPTION_MULTI_STATEMENTS_OFF, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">\"CLIENT_MULTI_STATEMENTS is off now\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_mysql_and_mariadb_version_support_matrix\"><a class=\"anchor\" href=\"#_mysql_and_mariadb_version_support_matrix\"></a>MySQL 和 MariaDB 版本支持情况</h2>\n<div class=\"sectionbody\">\n<table class=\"tableblock frame-all grid-all stretch\">\n<colgroup>\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n</colgroup>\n<thead>\n<tr>\n<th class=\"tableblock halign-center valign-top\" colspan=\"2\">MySQL</th>\n<th class=\"tableblock halign-center valign-top\" colspan=\"2\">MariaDB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">版本</p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">是否支持</p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">版本</p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">是否支持</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>5.5</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>10.1</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>5.6</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>10.2</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>5.7</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>10.3</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>8.0</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\"><code>10.4</code></p></td>\n<td class=\"tableblock halign-center valign-top\"><p class=\"tableblock\">&#10004;</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"paragraph\">\n<p>已知问题：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>重置连接实用程序命令在 MySQL 5.5、5.6 和 MariaDB 10.1 中不可用</p>\n</li>\n<li>\n<p>MariaDB 10.2 和 10.3 不支持更改用户实用程序命令</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pitfalls_good_practices\"><a class=\"anchor\" href=\"#_pitfalls_good_practices\"></a>陷阱和最佳实践</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>以下是使用响应式 MySQL 客户端时避免常见陷阱的一些最佳实践。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_statement_count_limit\"><a class=\"anchor\" href=\"#_prepared_statement_count_limit\"></a>预处理语句的计数限制</h3>\n<div class=\"paragraph\">\n<p>有时您可能会遇到臭名昭著的错误 <code>Can&#8217;t create more than max_prepared_stmt_count statements (current value: 16382)</code> ，这是因为服务器已达到预处理语句的总数限制。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以调整服务器系统变量  <code>max_prepared_stmt_count</code> ，但它具有上限值，因此您无法以这种方式摆脱错误。</p>\n</div>\n<div class=\"paragraph\">\n<p>缓解这种情况的最佳方法是启用预处理语句缓存，因此可以重用具有相同 SQL 字符串的预处理语句，并且客户端不必为每个请求创建全新的预处理语句。\n执行语句后，预处理语句将自动关闭。\n这样，虽然无法完全消除错误，但达到极限的机会可以大大减少。</p>\n</div>\n<div class=\"paragraph\">\n<p>还可以通过接口 <code>SqlConnection#prepare</code> 创建 <code>PreparedStatement</code> 对象来手动管理预处理语句的生命周期，以便可以选择何时释放语句句柄，甚至使用 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html\">SQL syntax prepared statement</a>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_demystifying_prepared_batch\"><a class=\"anchor\" href=\"#_demystifying_prepared_batch\"></a>揭开批量预处理神秘面纱</h3>\n<div class=\"paragraph\">\n<p>当您要将数据批量插入到数据库中时，您可以使用 <code>PreparedQuery#executeBatch</code> ，它提供了一个简单的 API 来处理此问题。\n请记住，MySQL 原生不支持批处理协议，因此 API 只是语法糖，一个接一个执行预处理语句，这意味着比执行一个预处理语句插入多条带有值列表的记录，需要更多的网络往返耗时。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_tricky_date_time_data_types\"><a class=\"anchor\" href=\"#_tricky_date_time_data_types\"></a>棘手的日期和时间数据类型</h3>\n<div class=\"paragraph\">\n<p>处理 MYSQL 日期和时间数据类型（尤其是时区）是棘手的，因此响应式 MySQL 客户端不会为这些值进行魔法转换。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>MySQL DATETIME 数据类型不包含时区信息，因此无论当前会话中的时区是什么，您获取的内容都与您设置的内容相同</p>\n</li>\n<li>\n<p>MySQL TIMESTAMP 数据类型包含时区信息，因此当您设置或获取值时，服务器总是通过当前会话中设置的时区来转换该值。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}