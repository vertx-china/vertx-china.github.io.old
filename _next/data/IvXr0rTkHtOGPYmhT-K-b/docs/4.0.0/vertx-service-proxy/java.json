{"pageProps":{"slug":"4.0.0/vertx-service-proxy/java","title":"Vert.x Service Proxy","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_service_proxies\">使用Vert.x服务代理</a></li>\n<li><a href=\"#_introduction_to_service_proxies\">服务代理简介</a></li>\n<li><a href=\"#_async_interface\">异步接口</a></li>\n<li><a href=\"#_security\">安全</a></li>\n<li><a href=\"#_code_generation\">代码生成</a></li>\n<li><a href=\"#_exposing_your_service\">公开服务</a></li>\n<li><a href=\"#_proxy_creation\">代理创建</a></li>\n<li><a href=\"#_error_handling\">错误处理</a></li>\n<li><a href=\"#_restrictions_for_service_interface\">接口类型限制</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_返回类型\">返回类型</a></li>\n<li><a href=\"#_参数类型\">参数类型</a></li>\n<li><a href=\"#_重载方法\">重载方法</a></li>\n</ul>\n</li>\n<li><a href=\"#_通过事件总线调用服务的规则_不使用服务代理\">通过事件总线调用服务的规则 (不使用服务代理)</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Service Proxy</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您编写Vert.x程序的时候，您也许想将某处独立服务功能提供给其他程序使用。这时候可以使用服务代理了。 它可以让您在事件总线上公开您的 <em>服务</em> , 因此，任何Vert.x程序只要知道其推送的 <em>地址</em> 就可以消费使用它。</p>\n</div>\n<div class=\"paragraph\">\n<p><em>服务</em> 它是遵循Java接口定义，方法定义必须遵循 <em>异步规范</em>。更深层次下,\n在事件总线上发送请求消息并调用服务响应请求。 但是为了更简单使用,\n他会成为一个 <em>代理</em> 可以直接调用 (使用服务接口的API)。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_service_proxies\"><a class=\"anchor\" href=\"#_using_vert_x_service_proxies\"></a>使用Vert.x服务代理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用Vert.x Service Proxy之前，您必须在您得项目当中添加 <em>依赖</em> :</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在 <code>pom.xml</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在 <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-service-proxy:4.0.0'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了 <strong>实现</strong> 服务代理, 您还需要添加:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-codegen<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>provided<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle版本小于 5 的情况(在 <code>build.gradle</code> 文件中)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compileOnly <span class=\"hljs-string\">'io.vertx:vertx-codegen:4.0.0'</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle版本大于等于 5 (在 <code>build.gradle</code> 文件中)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">annotationProcessor <span class=\"hljs-string\">'io.vertx:vertx-codegen:4.0.0:processor'</span>\nannotationProcessor <span class=\"hljs-string\">'io.vertx:vertx-service-proxy:4.0.0'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意：因为服务代理类是通过代码生成的缘故，每当您修改了 <em>服务接口</em> 您必须重新编译编码，以重新 生成代理类。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您要生成不同语言的代理类，您需要添加相应的依赖。例如，生成Groovy需要添加 <code>vertx-lang-groovy</code> 依赖</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_introduction_to_service_proxies\"><a class=\"anchor\" href=\"#_introduction_to_service_proxies\"></a>服务代理简介</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>让我看看服务代理它怎么用。 如果您在事件总线上公开 <em>数据库服务</em> 您可以执行下面的操作</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject message = <span class=\"hljs-keyword\">new</span> JsonObject();\n\nmessage\n  .put(<span class=\"hljs-string\">\"collection\"</span>, <span class=\"hljs-string\">\"mycollection\"</span>)\n  .put(<span class=\"hljs-string\">\"document\"</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"tim\"</span>));\n\nDeliveryOptions options = <span class=\"hljs-keyword\">new</span> DeliveryOptions().addHeader(<span class=\"hljs-string\">\"action\"</span>, <span class=\"hljs-string\">\"save\"</span>);\n\nvertx.eventBus()\n  .request(<span class=\"hljs-string\">\"database-service-address\"</span>, message, options)\n  .onSuccess(msg -&gt; {\n    <span class=\"hljs-comment\">// 完成</span>\n  }).onFailure(err -&gt; {\n  <span class=\"hljs-comment\">// 失败</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当创建服务的时候足够的样本代码在事件总线接收信息，路由会找到合适的方法并在总线上返回</p>\n</div>\n<div class=\"paragraph\">\n<p>使用Vert.x服务代理时,您可以使用代码生成避免编写重复的代码，从而集中精力编写服务</p>\n</div>\n<div class=\"paragraph\">\n<p>在您编写的Java接口上面打上 <code>@ProxyGen</code> 注解, 例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n <span class=\"hljs-comment\">// 几个工厂方法用于创建实例</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl(vertx);\n }\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx,\n   String address)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n }\n\n<span class=\"hljs-comment\">// 服务实际的接口订单</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String collection, JsonObject document,\n  Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler)</span></span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还需要编写 <code>package-info.java</code> 文件，位置处于接口定义包中。\n这个包还需要 <code>@ModuleGen</code> 注解，以方便Vert.x代码生成器生成事件总线代理代码。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">package-info.java</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@io</span>.vertx.codegen.annotations.ModuleGen(groupPackage = <span class=\"hljs-string\">\"io.vertx.example\"</span>, name = <span class=\"hljs-string\">\"services\"</span>)\n<span class=\"hljs-keyword\">package</span> io.vertx.example;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有了这个接口，Vert.x会生成所有需要的用于在Event Bus上访问您的服务的模板代码，同时也会生成对应的 调用端代理类（client side proxy），\n这样您的服务调用端就可以使用一个相当符合习惯的API（译者注：即相同的服务接口）进行服务调用，而不是去手动地向Event Bus发送消息。\n不管您的服务实际在哪个Event Bus上（可能是在不同的机器上），调用端代理类都能正常工作。</p>\n</div>\n<div class=\"paragraph\">\n<p>也就是说，您可以通过以下方式进行服务调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = SomeDatabaseService\n  .createProxy(vertx, <span class=\"hljs-string\">\"database-service-address\"</span>);\n\n<span class=\"hljs-comment\">// 保存数据到数据库，这里使用了代理</span>\nservice.save(\n  <span class=\"hljs-string\">\"mycollection\"</span>,\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"tim\"</span>),\n  res2 -&gt; {\n    <span class=\"hljs-keyword\">if</span> (res2.succeeded()) {\n      <span class=\"hljs-comment\">// 调用完毕</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以将多语言API生成功能（@VertxGen注解）与 @ProxyGen 注解相结合，用于生成其它Vert.x支持的JVM语言对应的服务代理 —— 这意味着您可以只用Java编写您的服务一次，就可以在其他语言中以一种习惯的API风格进行服务调用，而不必管服务是在本地还是在Event Bus的某处。\n想要利用多语言代码生成功能，不要忘记添加对应支持语言的依赖。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span> <span class=\"hljs-comment\">// 生成服务代理</span>\n<span class=\"hljs-meta\">@VertxGen</span> <span class=\"hljs-comment\">// 生成客户端</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_async_interface\"><a class=\"anchor\" href=\"#_async_interface\"></a>异步接口</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>想要正确地生成服务代理类，<em>服务接口</em> 的设计必须遵循一些规则。\n首先是需要遵循异步模式。\n如果需要返回结果，对应的方法需要包含一个 Handler&lt;AsyncResult&lt;ResultType&gt;&gt; 类型的参数\n其中 <code>ResultType</code> 可以是另一种代理类型（所以一个代理类可以作为另一个代理类的工厂）。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n<span class=\"hljs-comment\">// 一些用于创建服务实例和服务代理实例的工厂方法</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl(vertx);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx, String address)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n}\n\n<span class=\"hljs-comment\">// 异步方法，仅通知调用是否完成，不返回结果</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String collection, JsonObject document,\n  Handler&lt;AsyncResult&lt;Void&gt;&gt; result)</span></span>;\n\n<span class=\"hljs-comment\">// 异步方法，包含JsonObject类型的返回结果</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findOne</span><span class=\"hljs-params\">(String collection, JsonObject query,\n  Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; result)</span></span>;\n\n<span class=\"hljs-comment\">// 创建连接</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize,\n  Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler)</span></span>;\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以及：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-meta\">@VertxGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">MyDatabaseConnection</span> </span>{\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(JsonObject someData)</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler)</span></span>;\n\n<span class=\"hljs-meta\">@ProxyClose</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">close</span><span class=\"hljs-params\">()</span></span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过声明一个特殊方法，并给其加上 <code>@ProxyClose</code> 注解来注销代理。\n当此方法被调用时，代理实例被清除。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多 <code>服务接口</code> 的限制会在下面详解。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_security\"><a class=\"anchor\" href=\"#_security\"></a>安全</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>服务代理可以使用简单的拦截器保障基本安全。\n提供一个身份验证器，可以选择添加 <code>Authorization</code> 在这种情况下，<code>AuthorizationProvider</code> 是必须提提供的。\n注意，身份认证的令牌从 <code>auth-token</code> 信息头获取。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// 注册处理器</span>\n<span class=\"hljs-keyword\">new</span> ServiceBinder(vertx)\n  .setAddress(<span class=\"hljs-string\">\"database-service-address\"</span>)\n  <span class=\"hljs-comment\">// 保护传输中的信息</span>\n  .addInterceptor(\n    <span class=\"hljs-keyword\">new</span> ServiceAuthInterceptor()\n      <span class=\"hljs-comment\">// 使用JWT认证进行校验令牌</span>\n      .setAuthenticationProvider(JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> JWTAuthOptions()))\n      <span class=\"hljs-comment\">// 我们可以选择部分权限进行保护</span>\n\n      <span class=\"hljs-comment\">// 比如admin组</span>\n      .addAuthorization(RoleBasedAuthorization.create(<span class=\"hljs-string\">\"admin\"</span>))\n      <span class=\"hljs-comment\">// 比如打印权限</span>\n      .addAuthorization(PermissionBasedAuthorization.create(<span class=\"hljs-string\">\"print\"</span>))\n\n      <span class=\"hljs-comment\">// 或者从令牌种加载权限</span>\n      <span class=\"hljs-comment\">// 如果有需要您也可以从数据库或文件加载中权限</span>\n      .setAuthorizationProvider(\n        JWTAuthorization.create(<span class=\"hljs-string\">\"permissions\"</span>)))\n\n  .register(SomeDatabaseService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">service</span>)</span>;</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_code_generation\"><a class=\"anchor\" href=\"#_code_generation\"></a>代码生成</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>被 @ProxyGen 注解的服务接口会触发生成对应的服务辅助类：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>服务代理类（service proxy）：一个编译时产生的代理类，用 <code>EventBus</code> 通过消息与服务交互。</p>\n</li>\n<li>\n<p>服务处理器类（service handler）： 一个编译时产生的 <code>EventBus</code> 处理器类，用于响应由服务代理发送的事件。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>产生的服务代理和处理器的命名是在类名的后面加相关的字段，例如，如果一个服务接口名为 <code>MyService</code>，\n则对应的处理器类命名为 <code>MyServiceProxyHandler</code>,对应的服务代理类命名为 MyServiceVertxEBProxy。</p>\n</div>\n<div class=\"paragraph\">\n<p>此外Vert.x Core提供了一个生成器用于数据转化器，以简化服务代理中数据对象的使用。\n数据转化器要求数据对象提供一个以 <code>JsonObject</code> 为基础的构造器和`toJson()` 方法</p>\n</div>\n<div class=\"paragraph\">\n<p><em>codegen</em> 注释处理器在编译时生成这些类\n它是Java编译器的功能 所以无需 <em>额外步骤</em>, 只需正确配置您的构建参数即可：</p>\n</div>\n<div class=\"paragraph\">\n<p>只需要在构建配置中加上 <code>io.vertx:vertx-service-proxy:processor</code> 依赖。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个针对Maven的配置示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-codegen<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>processor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>此功能也可以在Gradle中使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>compile \"io.vertx:vertx-codegen:4.0.0:processor\"\ncompile \"io.vertx:vertx-service-proxy:4.0.0\"</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>IDE通常为注释处理器提供支持。\n代码生成 <code>处理器</code> 分类器会把服务代理注释处理器的配置自动添加到jar中 <code>META-INF/services</code> 当中\n如果您想和其与常规jar一起使用，但是需要显式声明注释处理器 , 例如在Maven中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">annotationProcessors</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">annotationProcessor</span>&gt;</span>io.vertx.codegen.CodeGenProcessor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">annotationProcessor</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">annotationProcessors</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_exposing_your_service\"><a class=\"anchor\" href=\"#_exposing_your_service\"></a>公开服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您写好服务接口以后，执行构建操作以生成代码。\n然后您需要将您的服务 <code>注册</code> 到Event Bus上：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// Register the handler</span>\n<span class=\"hljs-keyword\">new</span> ServiceBinder(vertx)\n  .setAddress(<span class=\"hljs-string\">\"database-service-address\"</span>)\n  .register(SomeDatabaseService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">service</span>)</span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个过程既可以在 Verticle 中完成，也可以在您的代码的任何其它位置完成。</p>\n</div>\n<div class=\"paragraph\">\n<p>一旦注册了，这个服务就可用了。如果您的应用运行在集群上，则集群中节点都可访问。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果想注销这个服务, 使用 <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceBinder.html#unregister-io.vertx.core.eventbus.MessageConsumer-\">unregister</a></code>\n方法注销：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceBinder binder = <span class=\"hljs-keyword\">new</span> ServiceBinder(vertx);\n\n<span class=\"hljs-comment\">// 创建服务实现实例</span>\nSomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// 注册处理器</span>\nMessageConsumer&lt;JsonObject&gt; consumer = binder\n  .setAddress(<span class=\"hljs-string\">\"database-service-address\"</span>)\n  .register(SomeDatabaseService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">service</span>)</span>;\n\n<span class=\"hljs-comment\">// ....</span>\n\n<span class=\"hljs-comment\">// 销毁服务。</span>\nbinder.unregister(consumer);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_proxy_creation\"><a class=\"anchor\" href=\"#_proxy_creation\"></a>代理创建</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>现在服务已经公开, 现在可以消费使用它。\n为此，您必须创建一个代理。\n创建代理使用 <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceProxyBuilder.html\">ServiceProxyBuilder</a></code> 类：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceProxyBuilder builder = <span class=\"hljs-keyword\">new</span> ServiceProxyBuilder(vertx)\n  .setAddress(<span class=\"hljs-string\">\"database-service-address\"</span>);\n\nSomeDatabaseService service = builder.build(SomeDatabaseService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n<span class=\"hljs-comment\">// 设置其他属性：</span>\nSomeDatabaseService service2 = builder.setOptions(options)\n  .build(SomeDatabaseService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>第二种构造通过 <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html\">DeliveryOptions</a></code> 构造实例，您可以在其中配置属性（例如：超时）</p>\n</div>\n<div class=\"paragraph\">\n<p>或者,您也可以使用代理类。\n这个代理名称为 <em>服务接口</em> 类目后追加 <code>VertxEBProxy</code>。\n例如, 如果您的 <em>服务接口</em> 名为 <code>SomeDatabaseService</code>，那么代理类名为 <code>SomeDatabaseServiceVertxEBProxy</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>一般来说, <em>服务接口</em> 包含 <code>createProxy</code> 静态方法用于创建代理。\n但这不是必须的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n<span class=\"hljs-comment\">// 静态方法创建代理。</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx, String address)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n}\n\n<span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_error_handling\"><a class=\"anchor\" href=\"#_error_handling\"></a>错误处理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>服务方法可能会通过向方法的处理器（Handler）传递一个失败状态的 Future （包含一个 <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceException.html\">ServiceException</a></code>\n实例。\n一个 <code>ServiceException</code> 包含 <code>int</code> 类型的错误码、消息,以及一个可选的\n<code>JsonObject</code> 对象用于传递额外信息。\n为了方便，\n<code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceException.html#fail-int-java.lang.String-\">ServiceException.fail</a></code> 工厂方法来创建一个已经是失败状态并且包装着\n<code>ServiceException</code> 实例的失败 <code>Future</code> 。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeDatabaseServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> BAD_SHOE_SIZE = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> CONNECTION_FAILED = <span class=\"hljs-number\">43</span>;\n\n <span class=\"hljs-comment\">// 创建连接</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler)</span> </span>{\n   <span class=\"hljs-keyword\">if</span> (!shoeSize.equals(<span class=\"hljs-string\">\"9\"</span>)) {\n     resultHandler.handle(ServiceException.fail(BAD_SHOE_SIZE, <span class=\"hljs-string\">\"The shoe size must be 9!\"</span>,\n       <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"shoeSize\"</span>, shoeSize));\n    } <span class=\"hljs-keyword\">else</span> {\n       doDbConnection(result -&gt; {\n         <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n           resultHandler.handle(Future.succeededFuture(result.result()));\n         } <span class=\"hljs-keyword\">else</span> {\n           resultHandler.handle(ServiceException.fail(CONNECTION_FAILED, result.cause().getMessage()));\n         }\n       });\n    }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>服务调用端（客户端）可以检查它接收到的失败状态的AsyncResult包含的Throwable对象是否为ServiceException实例。如果是的话，继续检查内部的特定的错误状态码。\n调用端可以通过这些信息来将业务逻辑错误与系统错误（如服务没有被注册到Event Bus上）区分开，以便确定到底发生了哪一种业务逻辑错误。下面是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; handler)</span> </span>{\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n service.createConnection(<span class=\"hljs-string\">\"8\"</span>, result -&gt; {\n   <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n     <span class=\"hljs-comment\">// 正常调用。</span>\n   } <span class=\"hljs-keyword\">else</span> {\n     <span class=\"hljs-keyword\">if</span> (result.cause() <span class=\"hljs-keyword\">instanceof</span> ServiceException) {\n       ServiceException exc = (ServiceException) result.cause();\n       <span class=\"hljs-keyword\">if</span> (exc.failureCode() == SomeDatabaseServiceImpl.BAD_SHOE_SIZE) {\n         handler.handle(Future.failedFuture(\n           <span class=\"hljs-keyword\">new</span> InvalidInputError(<span class=\"hljs-string\">\"You provided a bad shoe size: \"</span> +\n             exc.getDebugInfo().getString(<span class=\"hljs-string\">\"shoeSize\"</span>))\n         ));\n       } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (exc.failureCode() == SomeDatabaseServiceImpl.CONNECTION) {\n         handler.handle(Future.failedFuture(\n           <span class=\"hljs-keyword\">new</span> ConnectionError(<span class=\"hljs-string\">\"Failed to connect to the DB\"</span>)));\n       }\n     } <span class=\"hljs-keyword\">else</span> {\n       <span class=\"hljs-comment\">//必须是一个系统错误，如：服务代理没有对应的已注册的服务</span>\n       handler.handle(Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> SystemError(<span class=\"hljs-string\">\"An unexpected error occurred: + \"</span> result.cause().getMessage())\n       ));\n     }\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果需要的话, 服务实现的时候也可以返回 <code>ServiceException</code> 子类, 只要向Event Bus注册了对应的默认 <code>MessageCodec</code> 就可以了。例如, 比如给定下面的 <code>ServiceException</code> 子类：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShoeSizeException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ServiceException</span> </span>{\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> BAD_SHOE_SIZE_ERROR = <span class=\"hljs-number\">42</span>;\n\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String shoeSize;\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ShoeSizeException</span><span class=\"hljs-params\">(String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">super</span>(BAD_SHOE_SIZE_ERROR, <span class=\"hljs-string\">\"In invalid shoe size was received: \"</span> + shoeSize);\n   <span class=\"hljs-keyword\">this</span>.shoeSize = shoeSize;\n }\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getShoeSize</span><span class=\"hljs-params\">()</span> </span>{\n   <span class=\"hljs-keyword\">return</span> extra;\n }\n\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">AsyncResult&lt;T&gt; <span class=\"hljs-title\">fail</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> failureCode, String message, String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-keyword\">new</span> MyServiceException(failureCode, message, shoeSize));\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>只要向Event Bus注册了对应的 <code>MessageCodec</code> , 服务就可以直接向调用者返回自定义的异常类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeDatabaseServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SomeDataBaseServiceImpl</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n   <span class=\"hljs-comment\">// 注册服务，如果你是用event bus使用本地模式，这就是全部</span>\n   <span class=\"hljs-comment\">// 因为代理端和服务端共享一个vert.x实例</span>\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n   vertx.eventBus().registerDefaultCodec(ShoeSizeException<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>,\n     <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">ShoeSizeExceptionMessageCodec</span>())</span>;\n }\n\n <span class=\"hljs-comment\">// 创建连接</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler)</span> </span>{\n   <span class=\"hljs-keyword\">if</span> (!shoeSize.equals(<span class=\"hljs-string\">\"9\"</span>)) {\n     resultHandler.handle(ShoeSizeException.fail(shoeSize));\n   } <span class=\"hljs-keyword\">else</span> {\n     <span class=\"hljs-comment\">// 此处创建连接</span>\n     resultHandler.Handle(Future.succeededFuture(myDbConnection));\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>最后调用端可以检查自定义的异常类型了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; handler)</span> </span>{\n <span class=\"hljs-comment\">// 如果运行在集群模式当中，代码在不同的节点运行,</span>\n <span class=\"hljs-comment\">// ShoeSizeExceptionMessageCodec 必须注册到</span>\n <span class=\"hljs-comment\">// 该节点的Vertx当中</span>\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n service.createConnection(<span class=\"hljs-string\">\"8\"</span>, result -&gt; {\n   <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n     <span class=\"hljs-comment\">// 成功调用。</span>\n   } <span class=\"hljs-keyword\">else</span> {\n     <span class=\"hljs-keyword\">if</span> (result.cause() <span class=\"hljs-keyword\">instanceof</span> ShoeSizeException) {\n       ShoeSizeException exc = (ShoeSizeException) result.cause();\n       handler.handle(Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> InvalidInputError(<span class=\"hljs-string\">\"You provided a bad shoe size: \"</span> + exc.getShoeSize())));\n     } <span class=\"hljs-keyword\">else</span> {\n       <span class=\"hljs-comment\">// 必须是个系统错误 (例如：没有为服务代理进行注册)</span>\n       handler.handle(Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> SystemError(<span class=\"hljs-string\">\"An unexpected error occurred: + \"</span> result.cause().getMessage())\n       ));\n     }\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意在`Vertx` 集群模式下，您需要向集群中每个节点的Event Bus注册对应的自定义异常类型\n的 <code>MessageCodec</code> 实例</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_restrictions_for_service_interface\"><a class=\"anchor\" href=\"#_restrictions_for_service_interface\"></a>接口类型限制</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在服务中参数和返回值在类型上有一定的限制,因此可以方便在Event Bus中进行转化。\n他们是：</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_返回类型\"><a class=\"anchor\" href=\"#_返回类型\"></a>返回类型</h3>\n<div class=\"paragraph\">\n<p>必须是以下两种：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>void</code></p>\n</li>\n<li>\n<p><code>@Fluent</code> 返回服务实例本身(即： <code>this</code> )：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Fluent</span>\n<span class=\"hljs-function\">SomeDatabaseService <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">()</span></span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这是因为方法不能被阻塞，远程服务是不可能不堵塞立即返回结果</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_参数类型\"><a class=\"anchor\" href=\"#_参数类型\"></a>参数类型</h3>\n<div class=\"paragraph\">\n<p>类型简写说明：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>JSON</code> = <code>JsonObject 或 JsonArray</code></p>\n</li>\n<li>\n<p><code>PRIMITIVE</code> = 任何原始类型或被自动拆装箱的原始类型</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>参数可以是以下任意一种：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>JSON</code></p>\n</li>\n<li>\n<p><code>PRIMITIVE</code></p>\n</li>\n<li>\n<p><code>List&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>List&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Map&lt;String, JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Map&lt;String, PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p>任何 <em>枚举</em> 类型</p>\n</li>\n<li>\n<p>任何被打上 <code>@DataObject</code> 注解的实体类</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>如果需要返回异步结果，可以提供一个 <code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>R</code> 的类型可以是：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>JSON</code></p>\n</li>\n<li>\n<p><code>PRIMITIVE</code></p>\n</li>\n<li>\n<p><code>List&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>List&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p>任何 <em>枚举</em> 类型</p>\n</li>\n<li>\n<p>任何打上 <code>@DataObject</code> 注解的类（需符合上文的代码篇章要求）</p>\n</li>\n<li>\n<p>另一个代理类</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_重载方法\"><a class=\"anchor\" href=\"#_重载方法\"></a>重载方法</h3>\n<div class=\"paragraph\">\n<p>服务接口不支持任何的重载服务方法。(方法名相同，参数列表不同)。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_通过事件总线调用服务的规则_不使用服务代理\"><a class=\"anchor\" href=\"#_通过事件总线调用服务的规则_不使用服务代理\"></a>通过事件总线调用服务的规则 (不使用服务代理)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>服务代理假定Event Bus中的消息遵循一定的格式，因此能被用于服务的调用</p>\n</div>\n<div class=\"paragraph\">\n<p>当然，如果不愿意的话，您也可以 <strong>不用</strong> 服务代理类来访问远程服务。\n被广泛接受的与服务交互的方式就是直接在Event Bus发送消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了使服务访问的方式一致，所有的服务都必须遵循以下的消息格式。</p>\n</div>\n<div class=\"paragraph\">\n<p>格式非常简单：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>需要有一个名为 <code>action</code> 的 消息头(header)，作为要执行操作的名称。</p>\n</li>\n<li>\n<p>消息体（message body）应该是一个 <code>JsonObject</code> 对象，里面需要包含操作需要的所有参数。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>举个例子，假如我们要去执行一个名为 <code>save</code> 的操作，此操作接受一个字符串类型的 collection 和 JsonObject 类型 document：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>Headers:\n   \"action\": \"save\"\nBody:\n   {\n       \"collection\", \"mycollection\",\n       \"document\", {\n           \"name\": \"tim\"\n       }\n   }</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>无论有没有用到服务代理来创建服务，都应该用上面这种方式编写服务，因为这样允许服务交互时保持一致性。</p>\n</div>\n<div class=\"paragraph\">\n<p>在上面的例子中，\"action\"对应的值应该与服务接口的某个方法名称相对应，而消息体中每个 <code>[key, value]</code> 都要与服务方法中的某个 <code>[arg_name, arg_value]</code> 相对应</p>\n</div>\n<div class=\"paragraph\">\n<p>对于返回值，服务需使用 <code>message.reply(&#8230;&#8203;)</code> 方法去向调用端发送回一个返回值 -  这个值可以是Event Bus支持的任何类型。\n如果需要表示调用失败，可以调用 <code>message.fail(&#8230;&#8203;)</code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用Vert.x 服务代理组件的话，生成的代码会自动帮您处理这些问题。</p>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}