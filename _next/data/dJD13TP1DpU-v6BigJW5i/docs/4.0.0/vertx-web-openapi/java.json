{"pageProps":{"slug":"4.0.0/vertx-web-openapi/java","title":"Vert.x OpenAPI","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_openapi\">使用 Vert.x OpenAPI</a></li>\n<li><a href=\"#_routerbuilder\"><code>RouterBuilder</code></a></li>\n<li><a href=\"#_access_to_operations\">获取operation</a></li>\n<li><a href=\"#_map_authenticationhandler_to_openapi_security_schemes\">将 <code>AuthenticationHandler</code> 映射到 OpenAPI 安全约束</a></li>\n<li><a href=\"#_not_implemented_error\">未实现的错误</a></li>\n<li><a href=\"#_response_content_type_handler\">响应内容类型处理器</a></li>\n<li><a href=\"#_operation_model\">operation 模型</a></li>\n<li><a href=\"#_body_handler\">请求体处理器</a></li>\n<li><a href=\"#_multipart_form_data_validation\"><code>multipart/form-data</code> 校验</a></li>\n<li><a href=\"#_custom_global_handlers\">自定义全局处理器</a></li>\n<li><a href=\"#_router_builder_handlers_mount_order\">Router builder 处理器的挂载顺序</a></li>\n<li><a href=\"#_generate_the_router\">生成路由器</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x OpenAPI</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x OpenAPI 继承了 Vert.x Web 用以支持 <a href=\"https://www.openapis.org/\">OpenAPI 3</a> ，同时为您提供了简便的接口来构建一个符合您接口协议的Vert.x Web 路由器。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x OpenAPI 可以做到如下事情：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>解析并校验您的 OpenAPI 3 协议</p>\n</li>\n<li>\n<p>根据您的约束来生成路由器（带有正确的路径以及方法）</p>\n</li>\n<li>\n<p>提供基于您接口协议的请求解析和校验的功能，该功能用 <a href=\"https://vertx.io/docs/vertx-web-validation/java/\">Vert.x Web Validation</a> 实现。</p>\n</li>\n<li>\n<p>挂载必要的安全处理器</p>\n</li>\n<li>\n<p>在 OpenAPI 风格和 Vert.x 风格之间转换路径</p>\n</li>\n<li>\n<p>用 <a href=\"https://vertx.io/docs/vertx-web-api-service/java/\">Vert.x Web API Service</a> 来将请求路由到事件总线</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_openapi\"><a class=\"anchor\" href=\"#_using_vert_x_openapi\"></a>使用 Vert.x OpenAPI</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用Vert.x OpenAPI，您需要添加如下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-openapi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-openapi:4.0.0'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routerbuilder\"><a class=\"anchor\" href=\"#_routerbuilder\"></a><code>RouterBuilder</code></h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html\">RouterBuilder</a></code> 是这个模块的主要元素，它提供了用来挂载请求处理器的接口，并且生成最终的 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>要使用 Vert.x Web OpenAPI ，您必须用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#create-io.vertx.core.Vertx-java.lang.String-io.vertx.core.Handler-\">RouterBuilder.create</a></code> 方法并传入您的接口协议来实例化 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html\">RouterBuilder</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>例如从本地文件系统来加载一个约束：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RouterBuilder.create(vertx, <span class=\"hljs-string\">\"src/main/resources/petstore.yaml\"</span>).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 约束加载成功</span>\n    RouterBuilder routerBuilder = ar.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// router builder 初始化失败</span>\n    Throwable exception = ar.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以从一个远程约束构建一个 router builder ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RouterBuilder.create(\n  vertx,\n  <span class=\"hljs-string\">\"https://raw.githubusercontent\"</span> +\n    <span class=\"hljs-string\">\".com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml\"</span>\n).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 约束加载成功</span>\n    RouterBuilder routerBuilder = ar.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// router builder 初始化失败</span>\n    Throwable exception = ar.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过配置 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/OpenAPILoaderOptions.html\">OpenAPILoaderOptions</a></code> 以获取私有的远程约束：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">OpenAPILoaderOptions loaderOptions = <span class=\"hljs-keyword\">new</span> OpenAPILoaderOptions()\n  .putAuthHeader(<span class=\"hljs-string\">\"Authorization\"</span>, <span class=\"hljs-string\">\"Bearer xx.yy.zz\"</span>);\nRouterBuilder.create(\n  vertx,\n  <span class=\"hljs-string\">\"https://raw.githubusercontent\"</span> +\n    <span class=\"hljs-string\">\".com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml\"</span>,\n  loaderOptions\n).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 约束加载成功</span>\n    RouterBuilder routerBuilder = ar.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// router builder 初始化失败</span>\n    Throwable exception = ar.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html\">RouterBuilderOptions</a></code> 来修改 router builder 的各种行为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder.setOptions(<span class=\"hljs-keyword\">new</span> RouterBuilderOptions());</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_access_to_operations\"><a class=\"anchor\" href=\"#_access_to_operations\"></a>获取operation</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了获取协议中定义的 <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#operationObject\">Operation</a> ，您需要用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#operation-java.lang.String-\">operation</a></code> 方法。\n这个方法返回了一个 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/Operation.html\">Operation</a></code> 对象，您可以既可以用它来获取模型，又可以用来注册处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/Operation.html#handler-io.vertx.core.Handler-\">handler</a></code> 为一个operation来挂载处理器，\n使用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/Operation.html#failureHandler-io.vertx.core.Handler-\">failureHandler</a></code> 来挂载失败处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以 <strong>在一个 operation 当中添加多个处理器</strong> ，而不覆盖已经存在的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder\n  .operation(<span class=\"hljs-string\">\"awesomeOperation\"</span>)\n  .handler(routingContext -&gt; {\n    RequestParameters params =\n      routingContext.get(ValidationHandler.REQUEST_CONTEXT_KEY);\n    RequestParameter body = params.body();\n    JsonObject jsonBody = body.getJsonObject();\n    <span class=\"hljs-comment\">// 处理请求体</span>\n  }).failureHandler(routingContext -&gt; {\n  <span class=\"hljs-comment\">// 处理失败</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>没有 <code>operationId</code> 的话，那么您不能获取到这个operation。 没有 <code>operationId</code> 的operation，会被 <code>RouterBuilder</code> 忽略。</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x OpenAPI 为您挂载了正确的 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/ValidationHandler.html\">ValidationHandler</a></code> ，所以您才可以获取到请求参数和请求体。\n请参考 <a href=\"https://vertx.io/docs/vertx-web-validation/java/\">Vert.x Web 校验文档</a> 来学习如何获取请求参数以及请求体，并学习如何管理校验失败的处理方式。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_map_authenticationhandler_to_openapi_security_schemes\"><a class=\"anchor\" href=\"#_map_authenticationhandler_to_openapi_security_schemes\"></a>将 <code>AuthenticationHandler</code> 映射到 OpenAPI 安全约束</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以将一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthenticationHandler.html\">AuthenticationHandler</a></code> 映射到一个接口协议当中定义的安全约束。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，给出一个名为 <code>security_scheme_name</code> 接口约束：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder.securityHandler(<span class=\"hljs-string\">\"security_scheme_name\"</span>, authenticationHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以挂载包含在Vert.x Web中模块中的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthenticationHandler.html\">AuthenticationHandler</a></code> ，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">routerBuilder.securityHandler(<span class=\"hljs-string\">\"jwt_auth\"</span>,\n  JWTAuthHandler.create(jwtAuthProvider));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您生成 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code> 之后，router builder会解析operation所必须的安全约束。\n如果一个operation所必须的 <code>AuthenticationHandler</code> 缺失，则这个过程会失败。</p>\n</div>\n<div class=\"paragraph\">\n<p>调试/测试时，您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setRequireSecurityHandlers-boolean-\">setRequireSecurityHandlers</a></code> 来禁用这个检验。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_not_implemented_error\"><a class=\"anchor\" href=\"#_not_implemented_error\"></a>未实现的错误</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果未指定处理器，那么Router builder会为一个operation自动挂载一个默认的处理器。\n这个默认的处理器会让 routing context 处于  405 <code>Method Not Allowed</code> 或者 501 <code>Not Implemented</code> 错误状态。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setMountNotImplementedHandler-boolean-\">setMountNotImplementedHandler</a></code> 启用/禁用它，并且您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code> 自定义这个错误的处理方式。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_response_content_type_handler\"><a class=\"anchor\" href=\"#_response_content_type_handler\"></a>响应内容类型处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当接口协议需要的时候，Router builder 自动挂载一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ResponseContentTypeHandler.html\">ResponseContentTypeHandler</a></code> 处理器。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setMountResponseContentTypeHandler-boolean-\">setMountResponseContentTypeHandler</a></code> 禁用这个特性。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_operation_model\"><a class=\"anchor\" href=\"#_operation_model\"></a>operation 模型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果您在处理请求的时候需要获取到operation模型，那么您可以配置router builder，从而用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderOptions.html#setOperationModelKey-java.lang.String-\">setOperationModelKey</a></code> 将其放入 <code>RoutingContext</code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setOperationModelKey(<span class=\"hljs-string\">\"operationModel\"</span>);\nrouterBuilder.setOptions(options);\n\n<span class=\"hljs-comment\">// 添加一个用这个operation模型的处理器</span>\nrouterBuilder\n  .operation(<span class=\"hljs-string\">\"listPets\"</span>)\n  .handler(\n    routingContext -&gt; {\n      JsonObject operation = routingContext.get(<span class=\"hljs-string\">\"operationModel\"</span>);\n\n      routingContext\n        .response()\n        .setStatusCode(<span class=\"hljs-number\">200</span>)\n        .setStatusMessage(<span class=\"hljs-string\">\"OK\"</span>)\n        <span class=\"hljs-comment\">// 以\"listPets\"为 operation id 回写响应</span>\n        .end(operation.getString(<span class=\"hljs-string\">\"operationId\"</span>));\n    });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_body_handler\"><a class=\"anchor\" href=\"#_body_handler\"></a>请求体处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Router builder自动挂载一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 用以管理请求体。\n您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#bodyHandler-io.vertx.ext.web.handler.BodyHandler-\">bodyHandler</a></code> 来配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 对象（例如，更换上传目录）</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_multipart_form_data_validation\"><a class=\"anchor\" href=\"#_multipart_form_data_validation\"></a><code>multipart/form-data</code> 校验</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>校验处理器像如下描述来区分文件上传和表单属性：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果参数中没有编码相关的字段：</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果参数存在 <code>type: string</code> 和 <code>format: base64</code> ，或者存在 <code>format: binary</code> ，那么它就是 content-type请求头为 <code>application/octet-stream</code> 的一个请求。</p>\n</li>\n<li>\n<p>否则是一个表单请求</p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>如果参数存在编码相关字段，则是一个文件上传的请求。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>对于表单属性，他们被解析、转换为Json、然后校验，\n然而对于文件上传请求，校验处理器仅仅检查存在性和Content-Type。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_custom_global_handlers\"><a class=\"anchor\" href=\"#_custom_global_handlers\"></a>自定义全局处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果您需要挂载一个处理器，而这个处理器在您路由器中每个operation执行之前都需要执行特定操作，那么您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilder.html#rootHandler-io.vertx.core.Handler-\">rootHandler</a></code></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_router_builder_handlers_mount_order\"><a class=\"anchor\" href=\"#_router_builder_handlers_mount_order\"></a>Router builder 处理器的挂载顺序</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>router builder以如下顺序加载处理器：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>请求体处理器</p>\n</li>\n<li>\n<p>自定义全局处理器</p>\n</li>\n<li>\n<p>已配置的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthenticationHandler.html\">AuthenticationHandler</a></code></p>\n</li>\n<li>\n<p>生成的 <code><a href=\"../../apidocs/io/vertx/ext/web/validation/ValidationHandler.html\">ValidationHandler</a></code></p>\n</li>\n<li>\n<p>用户处理器 或者 \"未实现的\"处理器（如果启用）</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_generate_the_router\"><a class=\"anchor\" href=\"#_generate_the_router\"></a>生成路由器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>万事俱备，生成路由器并使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = routerBuilder.createRouter();\n\nHttpServer server =\n  vertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions().setPort(<span class=\"hljs-number\">8080</span>).setHost(\n    <span class=\"hljs-string\">\"localhost\"</span>));\nserver.requestHandler(router).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个方法可能会失败并抛出 <code><a href=\"../../apidocs/io/vertx/ext/web/openapi/RouterBuilderException.html\">RouterBuilderException</a></code> 。</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>如果您需要挂载所有router builder生成的具有相同父级路径的路由器，您可以用 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#mountSubRouter-java.lang.String-io.vertx.ext.web.Router-\">mountSubRouter</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router global = Router.router(vertx);\n\nRouter generated = routerBuilder.createRouter();\nglobal.mountSubRouter(<span class=\"hljs-string\">\"/v1\"</span>, generated);</code></pre>\n</div>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}