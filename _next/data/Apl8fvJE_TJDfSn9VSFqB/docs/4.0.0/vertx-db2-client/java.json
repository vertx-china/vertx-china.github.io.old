{"pageProps":{"slug":"4.0.0/vertx-db2-client/java","title":"Reactive DB2 客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_usage\">Usage</a></li>\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_connecting_to_db2\">Connecting to DB2</a></li>\n<li><a href=\"#_configuration\">Configuration</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_object\">data object</a></li>\n<li><a href=\"#_connection_uri\">connection uri</a></li>\n</ul>\n</li>\n<li><a href=\"#_connect_retries\">Connect retries</a></li>\n<li><a href=\"#_running_queries\">执行查询</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_queries\">预查询</a></li>\n<li><a href=\"#_batches\">批处理</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_connections\">使用连接</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_a_connection\">获取一条连接</a></li>\n<li><a href=\"#_simplified_connection_api\">简化的连接API</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_transactions\">使用事务</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_transactions_with_connections\">连接中使用事务操作</a></li>\n<li><a href=\"#_simplified_transaction_api\">简化版事务API</a></li>\n</ul>\n</li>\n<li><a href=\"#_cursors_and_streaming\">游标和流式操作</a></li>\n<li><a href=\"#_tracing_queries\">Tracing queries</a></li>\n<li><a href=\"#_db2_type_mapping\">DB2 type mapping</a></li>\n<li><a href=\"#_using_java_enum_types\">Using Java enum types</a></li>\n<li><a href=\"#_collector_queries\">Collector queries</a></li>\n<li><a href=\"#_using_ssltls\">Using SSL/TLS</a></li>\n<li><a href=\"#_using_a_proxy\">Using a proxy</a></li>\n</ul>\n</div>","contents":"<h1>Reactive DB2 客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Reactive DB2 Client is a client for DB2 with a straightforward API focusing on\nscalability and low overhead.</p>\n</div>\n<div class=\"paragraph\">\n<p>The client is reactive and non blocking, allowing to handle many database connections with a single thread.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Features</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Support for DB2 on Linux, Unix, and Windows</p>\n</li>\n<li>\n<p>Limited support for DB2 on z/OS</p>\n</li>\n<li>\n<p>Event driven</p>\n</li>\n<li>\n<p>Lightweight</p>\n</li>\n<li>\n<p>Built-in connection pooling</p>\n</li>\n<li>\n<p>Prepared queries caching</p>\n</li>\n<li>\n<p>Batch and cursor</p>\n</li>\n<li>\n<p>Row streaming</p>\n</li>\n<li>\n<p>RxJava 1 and RxJava 2</p>\n</li>\n<li>\n<p>Direct memory to object without unnecessary copies</p>\n</li>\n<li>\n<p>Java 8 Date and Time</p>\n</li>\n<li>\n<p>SSL/TLS</p>\n</li>\n<li>\n<p>HTTP/1.x CONNECT, SOCKS4a or SOCKS5 proxy support</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><strong>Current limitations</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>No stored procedures support</p>\n</li>\n<li>\n<p>Some column types (e.g. BLOB and CLOB) are not supported</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_usage\"><a class=\"anchor\" href=\"#_usage\"></a>Usage</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use the Reactive DB2 Client add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-db2-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-db2-client:4.0.0'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Here is the simplest way to connect, query and disconnect</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DB2ConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> DB2ConnectOptions()\n  .setPort(<span class=\"hljs-number\">50000</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the client pool</span>\nDB2Pool client = DB2Pool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// A simple query</span>\nclient\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n\n  <span class=\"hljs-comment\">// Now close the pool</span>\n  client.close();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_db2\"><a class=\"anchor\" href=\"#_connecting_to_db2\"></a>Connecting to DB2</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Most of the time you will use a pool to connect to DB2:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DB2ConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> DB2ConnectOptions()\n  .setPort(<span class=\"hljs-number\">50000</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nDB2Pool client = DB2Pool.pool(connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The pooled client uses a connection pool and any operation will borrow a connection from the pool\nto execute the operation and release it to the pool.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are running with Vert.x you can pass it your Vertx instance:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DB2ConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> DB2ConnectOptions()\n  .setPort(<span class=\"hljs-number\">50000</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-comment\">// Create the pooled client</span>\nDB2Pool client = DB2Pool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You need to release the pool when you don&#8217;t need it anymore:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you need to execute several operations on the same connection, you need to use a client\n<code><a href=\"../../apidocs/io/vertx/db2client/DB2Connection.html\">connection</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can easily get one from the pool:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DB2ConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> DB2ConnectOptions()\n  .setPort(<span class=\"hljs-number\">50000</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nDB2Pool client = DB2Pool.pool(vertx, connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// Get a connection from the pool</span>\nclient.getConnection().compose(conn -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Got a connection from the pool\"</span>);\n\n  <span class=\"hljs-comment\">// All operations execute on the same connection</span>\n  <span class=\"hljs-keyword\">return</span> conn\n    .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n    .execute()\n    .compose(res -&gt; conn\n      .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='emad'\"</span>)\n      .execute())\n    .onComplete(ar -&gt; {\n      <span class=\"hljs-comment\">// Release the connection to the pool</span>\n      conn.close();\n    });\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    System.out.println(<span class=\"hljs-string\">\"Done\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Once you are done with the connection you must close it to release it to the pool, so it can be reused.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>Configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>There are several alternatives for you to configure the client.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_data_object\"><a class=\"anchor\" href=\"#_data_object\"></a>data object</h3>\n<div class=\"paragraph\">\n<p>A simple way to configure the client is to specify a <code>DB2ConnectOptions</code> data object.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DB2ConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> DB2ConnectOptions()\n  .setPort(<span class=\"hljs-number\">50000</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool Options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pool from the data object</span>\nDB2Pool pool = DB2Pool.pool(vertx, connectOptions, poolOptions);\n\npool.getConnection(ar -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also configure the generic properties with the <code>setProperties</code> or <code>addProperty</code> methods. Note <code>setProperties</code> will override the default client properties.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection_uri\"><a class=\"anchor\" href=\"#_connection_uri\"></a>connection uri</h3>\n<div class=\"paragraph\">\n<p>Apart from configuring with a <code>DB2ConnectOptions</code> data object, We also provide you an alternative way to connect when you want to configure with a connection URI:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String connectionUri = <span class=\"hljs-string\">\"db2://dbuser:secretpassword@database.server.com:50000/mydb\"</span>;\n\n<span class=\"hljs-comment\">// Create the pool from the connection URI</span>\nDB2Pool pool = DB2Pool.pool(connectionUri);\n\n<span class=\"hljs-comment\">// Create the connection from the connection URI</span>\nDB2Connection.connect(vertx, connectionUri, res -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The URI format for a connection string is:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>db2://&lt;USERNAME&gt;:&lt;PASSWORD&gt;@&lt;HOSTNAME&gt;:&lt;PORT&gt;/&lt;DBNAME&gt;</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Currently the client supports the following parameter key words in connection uri</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>host</p>\n</li>\n<li>\n<p>port</p>\n</li>\n<li>\n<p>user</p>\n</li>\n<li>\n<p>password</p>\n</li>\n<li>\n<p>dbname</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Note: configuring properties in connection URI will override the default properties.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connect_retries\"><a class=\"anchor\" href=\"#_connect_retries\"></a>Connect retries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can configure the client to retry when a connection fails to be established.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options\n  .setReconnectAttempts(<span class=\"hljs-number\">2</span>)\n  .setReconnectInterval(<span class=\"hljs-number\">1000</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_queries\"><a class=\"anchor\" href=\"#_running_queries\"></a>执行查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您不需要事务或者只是执行一个单次查询操作，您可以直接在连接池里执行查询；\n连接池会使用某一条连接执行并给您返回结果。\n下边是如何执行一个简单的查询的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='andy'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>预查询</h3>\n<div class=\"paragraph\">\n<p>执行预查询也是一样的操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>SQL字符通过位置引用实际的参数，并使用数据库的语法 `?`​</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id=$1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"andy\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>查询相关的方法为 <em>SELECT</em> 类型的操作提供了异步的 <code><a href=\"../../apidocs/io/vertx/sqlclient/RowSet.html\">RowSet</a></code> 实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT first_name, last_name FROM users\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者 <em>UPDATE</em>/<em>INSERT</em> 类型的查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO users (first_name, last_name) VALUES ($1, $2)\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"Andy\"</span>, <span class=\"hljs-string\">\"Guibert\"</span>),  ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Row对象（<code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code>）可以让您通过索引位置获取相应的数据</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者通过名称</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-string\">\"first_name\"</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端在此处没有做特殊处理，无论您的SQL文本时什么，列名都将使用数据库表中的名称标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以直接访问得到多种类型</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String firstName = row.getString(<span class=\"hljs-string\">\"first_name\"</span>);\nBoolean male = row.getBoolean(<span class=\"hljs-string\">\"male\"</span>);\nInteger age = row.getInteger(<span class=\"hljs-string\">\"age\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用缓存过的预处理语句去执行一次性的预查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connectOptions.setCachePreparedStatements(<span class=\"hljs-keyword\">true</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = ?\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以创建 <code>PreparedStatement</code> 并自主地管理它的生命周期。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sqlConnection\n  .prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id= ?\"</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      PreparedStatement preparedStatement = ar.result();\n      preparedStatement.query()\n        .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n            System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n            preparedStatement.close();\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar2.cause().getMessage());\n          }\n        });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batches\"><a class=\"anchor\" href=\"#_batches\"></a>批处理</h3>\n<div class=\"paragraph\">\n<p>您可以在预查询中执行批处理操作</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;Tuple&gt; batch = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>, <span class=\"hljs-string\">\"Julient Viet\"</span>));\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"emad\"</span>, <span class=\"hljs-string\">\"Emad Alblueshi\"</span>));\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"andy\"</span>, <span class=\"hljs-string\">\"Andy Guibert\"</span>));\n\n<span class=\"hljs-comment\">// Execute the prepared batch</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO USERS (id, name) VALUES ($1, $2)\"</span>)\n  .executeBatch(batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// Process rows</span>\n    RowSet&lt;Row&gt; rows = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Batch failed \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can fetch generated keys by wrapping your query in <code>SELECT &lt;COLUMNS&gt; FROM FINAL TABLE ( &lt;SQL&gt; )</code>, for example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT color_id FROM FINAL TABLE ( INSERT INTO color (color_name) VALUES (?), (?), (?) )\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"white\"</span>, <span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Inserted \"</span> + rows.rowCount() + <span class=\"hljs-string\">\" new rows.\"</span>);\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"generated key: \"</span> + row.getInteger(<span class=\"hljs-string\">\"color_id\"</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_connections\"><a class=\"anchor\" href=\"#_using_connections\"></a>使用连接</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>获取一条连接</h3>\n<div class=\"paragraph\">\n<p>当您要执行查询（无事务）操作时，您可以创建一条或者从连接池里拿到一条连接。\n请注意在从拿到连接到将连接释放回连接池这之间的连接状态，服务端可能由于某些原因比如空闲时间超时，而关闭这条连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection(ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    SqlConnection connection = ar1.result();\n\n    connection\n      .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='andy'\"</span>)\n      .execute(ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n        connection\n          .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n          .execute(ar3 -&gt; {\n          <span class=\"hljs-comment\">// Do something with rows and return the connection to the pool</span>\n          connection.close();\n        });\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// Return the connection to the pool</span>\n        connection.close();\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以通过连接对象创建预查询:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    PreparedStatement pq = ar1.result();\n    pq.query().execute(Tuple.of(<span class=\"hljs-string\">\"andy\"</span>), ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        <span class=\"hljs-comment\">// All rows</span>\n        RowSet&lt;Row&gt; rows = ar2.result();\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_connection_api\"><a class=\"anchor\" href=\"#_simplified_connection_api\"></a>简化的连接API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withConnection-java.util.function.Function-io.vertx.core.Handler-\">withConnection</a></code>\n并以当前连接要执行的操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这样会从连接池里拿到一条连接，并使用当前连接执行目标操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种方式需要返回一个future对象来表示操作结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>当这个future操作完成后，当前连接会被释放会连接池同时您也可能拿到最终的执行结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;Integer&gt; future = pool.withConnection(conn -&gt; conn\n  .query(<span class=\"hljs-string\">\"SELECT id FROM USERS WHERE name = 'Julien'\"</span>)\n  .execute()\n  .flatMap(rowSet -&gt; {\n    Iterator&lt;Row&gt; rows = rowSet.iterator();\n    <span class=\"hljs-keyword\">if</span> (rows.hasNext()) {\n      Row row = rows.next();\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture(row.getInteger(<span class=\"hljs-string\">\"id\"</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-string\">\"No results\"</span>);\n    }\n  }));\nfuture.onSuccess(id -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"User id: \"</span> + id);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_transactions\"><a class=\"anchor\" href=\"#_using_transactions\"></a>使用事务</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_transactions_with_connections\"><a class=\"anchor\" href=\"#_transactions_with_connections\"></a>连接中使用事务操作</h3>\n<div class=\"paragraph\">\n<p>您可以使用SQL语法 <code>BEGIN</code>/<code>COMMIT</code>/<code>ROLLBACK</code> 来执行事务操作，同时您必须使用\n<code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 并自己管理当前连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者您也可以使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 的事务API：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// Transaction must use a connection</span>\n    SqlConnection conn = res.result();\n\n    <span class=\"hljs-comment\">// Begin the transaction</span>\n    conn.begin(ar0 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar0.succeeded()) {\n        Transaction tx = ar0.result();\n        <span class=\"hljs-comment\">// Various statements</span>\n        conn\n          .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n          .execute(ar1 -&gt; {\n            <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n              conn\n                .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\"</span>)\n                .execute(ar2 -&gt; {\n                  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n                    <span class=\"hljs-comment\">// Commit the transaction</span>\n                    tx.commit(ar3 -&gt; {\n                      <span class=\"hljs-keyword\">if</span> (ar3.succeeded()) {\n                        System.out.println(<span class=\"hljs-string\">\"Transaction succeeded\"</span>);\n                      } <span class=\"hljs-keyword\">else</span> {\n                        System.out.println(<span class=\"hljs-string\">\"Transaction failed \"</span> + ar3.cause().getMessage());\n                      }\n                      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n                      conn.close();\n                    });\n                  } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">// Return the connection to the pool</span>\n                    conn.close();\n                  }\n                });\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">// Return the connection to the pool</span>\n              conn.close();\n            }\n          });\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// Return the connection to the pool</span>\n        conn.close();\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当数据库服务端返回当前事务已失败（比如常见的 <em>current transaction is aborted, commands ignored until end of transaction block</em>）\n，事务已回滚和 <code><a href=\"../../apidocs/io/vertx/sqlclient/Transaction.html#completion--\">completion</a></code> 方法的返回值future返回了\n<code><a href=\"../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html\">TransactionRollbackException</a></code> 异常时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">tx.completion().onFailure(err -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Transaction failed =&gt; rollbacked\"</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_transaction_api\"><a class=\"anchor\" href=\"#_simplified_transaction_api\"></a>简化版事务API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withTransaction-java.util.function.Function-io.vertx.core.Handler-\">withTransaction</a></code> 方法\n并传递待执行的事务操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将会从连接池里拿到一条连接，开启事务并调用待执行操作，配合客户端一起执行该事务范围内\n的所有操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>待执行操作需要返回一个future来表示可能产生的结果：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当future成功时，客户端提交该事务</p>\n</li>\n<li>\n<p>当future失败时，客户端回滚该事务</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>事务操作完成后，连接会被释放回连接池，并且可以获取到最终的操作结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withTransaction(client -&gt; client\n  .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n  .execute()\n  .flatMap(res -&gt; client\n    .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n    .execute()\n    <span class=\"hljs-comment\">// Map to a message result</span>\n    .map(<span class=\"hljs-string\">\"Users inserted\"</span>))\n).onComplete(ar -&gt; {\n  <span class=\"hljs-comment\">// The connection was automatically return to the pool</span>\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Transaction was committed</span>\n    String message = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Transaction succeeded: \"</span> + message);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Transaction was rolled back</span>\n    System.out.println(<span class=\"hljs-string\">\"Transaction failed \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cursors_and_streaming\"><a class=\"anchor\" href=\"#_cursors_and_streaming\"></a>游标和流式操作</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下预查询操作会拉去所有的行记录，您可以使用\n<code><a href=\"../../apidocs/io/vertx/sqlclient/Cursor.html\">游标</a></code> 来控制您想要读取的行数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>, ar0 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar0.succeeded()) {\n    PreparedStatement pq = ar0.result();\n\n    <span class=\"hljs-comment\">// Cursors require to run within a transaction</span>\n    connection.begin(ar1 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n        Transaction tx = ar1.result();\n\n        <span class=\"hljs-comment\">// Create a cursor</span>\n        Cursor cursor = pq.cursor(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>));\n\n        <span class=\"hljs-comment\">// Read 50 rows</span>\n        cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n\n            <span class=\"hljs-comment\">// Check for more ?</span>\n            <span class=\"hljs-keyword\">if</span> (cursor.hasMore()) {\n              <span class=\"hljs-comment\">// Repeat the process...</span>\n            } <span class=\"hljs-keyword\">else</span> {\n              <span class=\"hljs-comment\">// No more rows - commit the transaction</span>\n              tx.commit();\n            }\n          }\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>游标释放时需要同时执行关闭操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n    <span class=\"hljs-comment\">// Close the cursor</span>\n    cursor.close();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>stream API也可以用于游标，尤其是在Rx版的客户端，可能更为方便。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE $1\"</span>, ar0 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar0.succeeded()) {\n    PreparedStatement pq = ar0.result();\n\n    <span class=\"hljs-comment\">// Streams require to run within a transaction</span>\n    connection.begin(ar1 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n        Transaction tx = ar1.result();\n\n        <span class=\"hljs-comment\">// Fetch 50 rows at a time</span>\n        RowStream&lt;Row&gt; stream = pq.createStream(<span class=\"hljs-number\">50</span>, Tuple.of(<span class=\"hljs-string\">\"julien\"</span>));\n\n        <span class=\"hljs-comment\">// Use the stream</span>\n        stream.exceptionHandler(err -&gt; {\n          System.out.println(<span class=\"hljs-string\">\"Error: \"</span> + err.getMessage());\n        });\n        stream.endHandler(v -&gt; {\n          tx.commit();\n          System.out.println(<span class=\"hljs-string\">\"End of stream\"</span>);\n        });\n        stream.handler(row -&gt; {\n          System.out.println(<span class=\"hljs-string\">\"User: \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上边的stream会批量读取 <code>50</code> 行并同时将其转换为流，当这些行记录被传递给处理器时，\n会以此类推地读取下一批的 <code>50</code> 行记录。</p>\n</div>\n<div class=\"paragraph\">\n<p>stream支持重启或暂停，已经加载到的行记录将会被保留在内存里直到被传递给处理器，此时\n游标也将终止遍历。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>Tracing queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当Vert.x启用tracing功能时，SQL客户端可以跟踪查询的执行情况。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端会上报下列这些 <em>client</em> spans：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> 操作名称</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>db.user</code> ：数据库用户名</p>\n</li>\n<li>\n<p><code>db.instance</code> ：数据库实例</p>\n</li>\n<li>\n<p><code>db.statement</code> ：SQL语句</p>\n</li>\n<li>\n<p><code>db.type</code> ：<em>sql</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认的 tracing 策略时 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>，客户端\n在一个活跃trace里只创建一个span。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnectOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 方法来调整tracing策略，\n例如您可以设置为 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code>，\n客户端将始终上报span：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_db2_type_mapping\"><a class=\"anchor\" href=\"#_db2_type_mapping\"></a>DB2 type mapping</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Currently the client supports the following DB2 types</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>BOOLEAN (<code>java.lang.Boolean</code>) (DB2 LUW only)</p>\n</li>\n<li>\n<p>SMALLINT (<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>INTEGER (<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>BIGINT (<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>REAL (<code>java.lang.Float</code>)</p>\n</li>\n<li>\n<p>DOUBLE (<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>DECIMAL (<code>io.vertx.sqlclient.data.Numeric</code>)</p>\n</li>\n<li>\n<p>CHAR (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>VARCHAR (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>ENUM (<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>DATE (<code>java.time.LocalDate</code>)</p>\n</li>\n<li>\n<p>TIME (<code>java.time.LocalTime</code>)</p>\n</li>\n<li>\n<p>TIMESTAMP (<code>java.time.LocalDateTime</code>)</p>\n</li>\n<li>\n<p>BINARY (<code>byte[]</code>)</p>\n</li>\n<li>\n<p>VARBINARY (<code>byte[]</code>)</p>\n</li>\n<li>\n<p>ROWID (<code>io.vertx.db2client.impl.drda.DB2RowId</code> or <code>java.sql.RowId</code>) (DB2 z/OS only)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Some types that are currently NOT supported are:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>XML</p>\n</li>\n<li>\n<p>BLOB</p>\n</li>\n<li>\n<p>CLOB</p>\n</li>\n<li>\n<p>DBCLOB</p>\n</li>\n<li>\n<p>GRAPHIC / VARGRAPHIC</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>For a further documentation on DB2 data types, see the following resources:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008483.html\">DB2 for LUW 11.5 data types</a></p>\n</li>\n<li>\n<p><a href=\"https://www.ibm.com/support/knowledgecenter/SSEPEK_12.0.0/sqlref/src/tpc/db2z_datatypesintro.html\">DB2 for z/OS 12.0 data types</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Tuple decoding uses the above types when storing values, it also performs on the fly conversion of the actual value when possible:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .query(<span class=\"hljs-string\">\"SELECT an_int_column FROM exampleTable\"</span>)\n  .execute(ar -&gt; {\n  RowSet&lt;Row&gt; rowSet = ar.result();\n  Row row = rowSet.iterator().next();\n\n  <span class=\"hljs-comment\">// Stored as INTEGER column type and represented as java.lang.Integer</span>\n  Object value = row.getValue(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-comment\">// Convert to java.lang.Long</span>\n  Long longValue = row.getLong(<span class=\"hljs-number\">0</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_java_enum_types\"><a class=\"anchor\" href=\"#_using_java_enum_types\"></a>Using Java enum types</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can map Java <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html\">enum types</a> to these column\ntypes:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Strings (VARCHAR, TEXT)</p>\n</li>\n<li>\n<p>Numbers (SMALLINT, INTEGER, BIGINT)</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.preparedQuery(<span class=\"hljs-string\">\"SELECT day_name FROM FINAL TABLE ( INSERT INTO days (day_name) VALUES (?), (?), (?) )\"</span>)\n.execute(Tuple.of(Days.FRIDAY, Days.SATURDAY, Days.SUNDAY), ar -&gt; {\n <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n  RowSet&lt;Row&gt; rows = ar.result();\n  System.out.println(<span class=\"hljs-string\">\"Inserted \"</span> + rows.rowCount() + <span class=\"hljs-string\">\" new rows\"</span>);\n  <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n\t  System.out.println(<span class=\"hljs-string\">\"Day: \"</span> + row.get(Days<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, \"<span class=\"hljs-title\">day_name</span>\"))</span>;\n  }\n } <span class=\"hljs-keyword\">else</span> {\n  System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n }\n});\nclient.preparedQuery(<span class=\"hljs-string\">\"SELECT day_num FROM FINAL TABLE ( INSERT INTO days (day_num) VALUES (?), (?), (?) )\"</span>)\n   .execute(Tuple.of(Days.FRIDAY.ordinal(), Days.SATURDAY.ordinal(), Days.SUNDAY.ordinal()), ar -&gt; {\n   \t<span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n   \t\tRowSet&lt;Row&gt; rows = ar.result();\n   \t\tSystem.out.println(<span class=\"hljs-string\">\"Inserted \"</span> + rows.rowCount() + <span class=\"hljs-string\">\" new rows\"</span>);\n   \t\t<span class=\"hljs-keyword\">for</span> (Row row : rows) {\n   \t\t\tSystem.out.println(<span class=\"hljs-string\">\"Day: \"</span> + row.get(Days<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, \"<span class=\"hljs-title\">day_num</span>\"))</span>;\n   \t\t}\n   \t} <span class=\"hljs-keyword\">else</span> {\n   \t\tSystem.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n   \t}\n   });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The String type is matched with the Java enum&#8217;s name returned by the <code>name()</code> method.</p>\n</div>\n<div class=\"paragraph\">\n<p>Number types are matched with the Java enum&#8217;s ordinal returned by the <code>ordinal()</code> method and the row.get() method returns the corresponding enum&#8217;s <code>name()</code> value at the ordinal position of the integer value retrieved.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can use Java collectors with the query API:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, Map&lt;Long, String&gt;&gt; collector = Collectors.toMap(\n  row -&gt; row.getLong(<span class=\"hljs-string\">\"id\"</span>),\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    SqlResult&lt;Map&lt;Long, String&gt;&gt; result = ar.result();\n\n    <span class=\"hljs-comment\">// Get the map created by the collector</span>\n    Map&lt;Long, String&gt; map = result.value();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + map);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The collector processing must not keep a reference on the <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> as\nthere is a single row used for processing the entire set.</p>\n</div>\n<div class=\"paragraph\">\n<p>The Java <code>Collectors</code> provides many interesting predefined collectors, for example you can\ncreate easily create a string directly from the row set:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, String&gt; collector = Collectors.mapping(\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>),\n  Collectors.joining(<span class=\"hljs-string\">\",\"</span>, <span class=\"hljs-string\">\"(\"</span>, <span class=\"hljs-string\">\")\"</span>)\n);\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>).collecting(collector).execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;String&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the string created by the collector</span>\n      String list = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + list);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_ssltls\"><a class=\"anchor\" href=\"#_using_ssltls\"></a>Using SSL/TLS</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To configure the client to use SSL connection, you can configure the <code><a href=\"../../apidocs/io/vertx/db2client/DB2ConnectOptions.html\">DB2ConnectOptions</a></code>\nlike a Vert.x <code>NetClient</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DB2ConnectOptions options = <span class=\"hljs-keyword\">new</span> DB2ConnectOptions()\n  .setPort(<span class=\"hljs-number\">50001</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>)\n  .setSsl(<span class=\"hljs-keyword\">true</span>)\n  .setTrustStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions()\n      .setPath(<span class=\"hljs-string\">\"/path/to/keystore.p12\"</span>)\n      .setPassword(<span class=\"hljs-string\">\"keystoreSecret\"</span>));\n\nDB2Connection.connect(vertx, options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Connected with SSL</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Could not connect \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>More information can be found in the <a href=\"http://vertx.io/docs/vertx-core/java/#ssl\">Vert.x documentation</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_a_proxy\"><a class=\"anchor\" href=\"#_using_a_proxy\"></a>Using a proxy</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can also configure the client to use an HTTP/1.x CONNECT, SOCKS4a or SOCKS5 proxy.</p>\n</div>\n<div class=\"paragraph\">\n<p>More information can be found in the <a href=\"http://vertx.io/docs/vertx-core/java/#_using_a_proxy_for_client_connections\">Vert.x documentation</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in index.adoc - include::override/rxjava2.adoc[]</p>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}