{"pageProps":{"slug":"4.1.4/vertx-rx/java3","title":"Vert.x RxJava","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_vert_x_api_for_rxjava3\">用于RxJava3的Vert.x API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_api_for_rxjava3\">在 RxJava3 中使用 Vert.x API</a></li>\n<li><a href=\"#_read_stream_support\">可读流支持</a></li>\n<li><a href=\"#_write_stream_support\">可写流支持</a></li>\n<li><a href=\"#_async_result_support\">异步结果支持</a></li>\n<li><a href=\"#_scheduler_support\">调度器支持</a></li>\n<li><a href=\"#_json_unmarshalling\">JSON解码</a></li>\n<li><a href=\"#_deploying_a_verticle\">部署Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxified_api\">Rx化的 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_embedding_rxfified_vert.x\">嵌入Rx化的 Vert.x</a></li>\n<li><a href=\"#_as_a_verticle\">作为 Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_api_examples\">API 例子</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_eventBus_message_stream\">EventBus 消息流</a></li>\n<li><a href=\"#_timers\">定时器</a></li>\n<li><a href=\"#_http_client_requests\">HTTP客户端请求</a></li>\n<li><a href=\"#_http_server_requests\">HTTP服务端请求</a></li>\n<li><a href=\"#_websocket_client\">WebSocket客户端</a></li>\n<li><a href=\"#_websocket_server\">WebSocket服务端</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x RxJava</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_vert_x_api_for_rxjava3\"><a class=\"anchor\" href=\"#_vert_x_api_for_rxjava3\"></a>用于RxJava3的Vert.x API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> 是一个流行的库，\n旨在使用 Java VM 的可观察序列来编写异步和基于事件的程序。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 与 RxJava 集成起来很自然：它使得无论什么时候，只要我们能使用流和异步结果，就能使用 RxJava。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_api_for_rxjava3\"><a class=\"anchor\" href=\"#_using_vert_x_api_for_rxjava3\"></a>在 RxJava3 中使用 Vert.x API</h3>\n<div class=\"paragraph\">\n<p>要在 RxJava3 中使用 Vert.x API，请将以下依赖项添加到构建描述符的 <em>dependencies</em> 部分中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-rx-java3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-rx-java3:4.1.4&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有两种方式在 Vert.x 使用RxJava 3 的 API：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>通过原始的 Vert.x API 辅以辅助类， 这些辅助类提供了提供了用于 Vert.x Core API 和\nRxJava2 API 之间互相转化的静态方法。</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/RxHelper.html\">RxHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/ObservableHelper.html\">ObservableHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html\">FlowableHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/SingleHelper.html\">SingleHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/MaybeHelper.html\">MaybeHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/CompletableHelper.html\">CompletableHelper</a></code></p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>通过基于 Vert.x Core API 增强的 <em>Rx化的</em> Vert.x API。</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_read_stream_support\"><a class=\"anchor\" href=\"#_read_stream_support\"></a>可读流支持</h3>\n<div class=\"paragraph\">\n<p>RxJava 中 <code>Flowable</code> 的概念和 Vert.x 中 <code>ReadStream</code> 类是一对完美的匹配：都提供了一个对象流。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html#toFlowable-io.vertx.core.streams.ReadStream-\">FlowableHelper.toFlowable</a></code> 这个静态方法可以把 Vert.x 可读流转换为  <code>Flowable</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">FileSystem</span> <span class=\"hljs-variable\">fileSystem</span> <span class=\"hljs-operator\">=</span> vertx.fileSystem();\nfileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenOptions</span>(), result -&gt; {\n  <span class=\"hljs-type\">AsyncFile</span> <span class=\"hljs-variable\">file</span> <span class=\"hljs-operator\">=</span> result.result();\n  Flowable&lt;Buffer&gt; observable = FlowableHelper.toFlowable(file);\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>而 <em>Rx化的</em> Vert.x API 在 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/ReadStream.html\">ReadStream</a></code> 类上提供了\n<code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/ReadStream.html#toFlowable--\">toFlowable</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">FileSystem</span> <span class=\"hljs-variable\">fs</span> <span class=\"hljs-operator\">=</span> vertx.fileSystem();\nfs.rxOpen(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenOptions</span>())\n  .flatMapPublisher(file -&gt; file.toFlowable())\n  .subscribe(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这样的 Flowable 是所谓 <strong>hot</strong> Flowable，即不管是否有订阅，它们都会产生通知。\n<code>ReadStream</code> 是否能自发地发射数据，这取决于它的具体实现：</p>\n</div>\n<div class=\"paragraph\">\n<p>当订阅动作发生时，适配器会调用`<a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-\">handler</a>`\n来设置它的处理器（handler）。</p>\n</div>\n<div class=\"paragraph\">\n<p>某些 <code>ReadStream</code> 实现会在这个调用之后开始发射事件，而其他的则与\n是否设置了处理器无关：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>AsyncFile</code> 在处理器设置后开始产生 buffer 事件</p>\n</li>\n<li>\n<p><code>HttpServerRequest</code> 则不依赖于此（即 如果处理器未设置，buffer 可能会丢失）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在上述两种情形中，订阅 <code>Flowable</code> 都是安全的。原因在于不管 event loop 还是 worker\nverticle 都不会被并发执行，\n所以订阅一定是在处理器开始发射数据之前产生。</p>\n</div>\n<div class=\"paragraph\">\n<p>当您想延迟订阅时，需要先 <code>暂停（pause）</code> <code>ReadStream</code> ，并在之后 <code>恢复（resume）</code> 它，\n这与使用 <code>ReadStream</code> 一样。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.POST) {\n\n    <span class=\"hljs-comment\">// 暂停接收 buffer</span>\n    request.pause();\n\n    checkAuth(res -&gt; {\n\n      <span class=\"hljs-comment\">// 现在可以重新接收 buffer</span>\n      request.resume();\n\n      <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n        Flowable&lt;Buffer&gt; flowable = request.toFlowable();\n        flowable.subscribe(buff -&gt; {\n          <span class=\"hljs-comment\">// Get buffers</span>\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同样的，将一个 <code>Flowable</code> 转变为 Vert.x <code>ReadStream</code> 也是可以的。</p>\n</div>\n<div class=\"paragraph\">\n<p>静态方法 <code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html#toReadStream-io.reactivex.rxjava3.core.Flowable-\">FlowableHelper.toReadStream</a></code>  用于将\n<code>Flowable</code> 转换为 Vert.x 可读流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Buffer&gt; observable = getFlowable();\nReadStream&lt;Buffer&gt; readStream = FlowableHelper.toReadStream(observable);\n<span class=\"hljs-type\">Pump</span> <span class=\"hljs-variable\">pump</span> <span class=\"hljs-operator\">=</span> Pump.pump(readStream, response);\npump.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_write_stream_support\"><a class=\"anchor\" href=\"#_write_stream_support\"></a>可写流支持</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 类似于 <code>org.reactivestreams.Subscriber</code> ，它会消费数据，并且在消费速度无法跟上生产速度时与生产者协作，以避免积压的情况不断增加。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 提供了 <code><a href=\"../../apidocs/io/vertx/rxjava3/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> 适配器，它可以发送 <code>Flowable</code> 对象到任意 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">将 buffer 发送到 HTTP 服务响应</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-literal\">true</span>);\nWriteStreamSubscriber&lt;io.vertx.core.buffer.Buffer&gt; subscriber = io.vertx.rxjava3.RxHelper.toSubscriber(response);\nflowable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n另外也存在用于非背压的 <code>io.reactivex.Observable</code> 使用的 <code>io.vertx.rxjava3.WriteStreamObserver</code> 适配器。\n不同之处在于，这个适配器将向 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 发送对象，即使它不能跟上生产者速率\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果您正在使用 <em>RX化的</em> Vert.x API进行编程， <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> 的实现提供了一个 <code>toSubscriber</code> 方法。\n这样一来，上面的例子可以变得更直接明了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-literal\">true</span>);\nflowable.subscribe(response.toSubscriber());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n当 <code>Flowable</code> 成功结束时，该适配器会调用 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html#end--\">end</a></code> 方法。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n该适配器会设置 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> 的 <code>drain</code> 和 <code>exception</code> handler，所以订阅后请不要使用它们。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> 适配器在下述情况下会调用回调方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Flowable</code> 错误地结束，或</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> 失败（如 HTTP 连接被关闭，或文件系统已满），或</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> 结束（即，所有写入已完成，且文件已关闭），或</p>\n</li>\n<li>\n<p>the `<a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a>`错误地结束（即，所有写入已结束，当关闭文件时发生了错误）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这样不但可以设计更健壮的程序，而且可以在处理完流之后安排其他任务：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-literal\">true</span>);\n\nWriteStreamSubscriber&lt;Buffer&gt; subscriber = response.toSubscriber();\n\nsubscriber.onError(throwable -&gt; {\n  <span class=\"hljs-keyword\">if</span> (!response.headWritten() &amp;&amp; response.closed()) {\n    response.setStatusCode(<span class=\"hljs-number\">500</span>).end(<span class=\"hljs-string\">&quot;oops&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 错误日志</span>\n  }\n});\n\nsubscriber.onWriteStreamError(throwable -&gt; {\n  <span class=\"hljs-comment\">// 错误日志</span>\n});\n\nsubscriber.onWriteStreamEnd(() -&gt; {\n  <span class=\"hljs-comment\">// 将事务结束记录到审计系统...</span>\n});\n\nflowable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> 失败, 适配器会取消订阅 <code>org.reactivestreams.Subscription</code>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_async_result_support\"><a class=\"anchor\" href=\"#_async_result_support\"></a>异步结果支持</h3>\n<div class=\"paragraph\">\n<p>以一个现有的 Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 对象为基础，您可以创建一个 RxJava <code>Observer</code>，\n并订阅它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;String&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// 订阅 Single</span>\nSingle.just(<span class=\"hljs-string\">&quot;hello&quot;</span>).subscribe(SingleHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;String&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// 订阅 Single</span>\nMaybe.just(<span class=\"hljs-string\">&quot;hello&quot;</span>).subscribe(MaybeHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// 订阅 Single</span>\nCompletable.complete().subscribe(CompletableHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化的</em> Vert.x API 复制了类似的每一个方法，并冠以 <code>rx</code> 的前缀，它们都返回 RxJava 的 <code>Single</code> 、\n<code>Maybe</code> 或 <code>Completable</code> 对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpServer&gt; single = vertx\n  .createHttpServer()\n  .rxListen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>);\n\n<span class=\"hljs-comment\">// 订阅绑定端口的事件</span>\nsingle.\n    subscribe(\n        server -&gt; {\n          <span class=\"hljs-comment\">// 服务器在监听</span>\n        },\n        failure -&gt; {\n          <span class=\"hljs-comment\">// 服务器无法启动</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这样的 Single 是 <strong>“冷的”(cold)</strong> ，对应的 API 方法将在注册时被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>Maybe</code> 对象可能有结果、也可能没有结果：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">DnsClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createDnsClient(dnsPort, dnsHost);\n\n<span class=\"hljs-comment\">// 此处会返回一个 Maybe 对象，用于订阅实际执行反向DNS查询的结果</span>\nMaybe&lt;String&gt; maybe = client.rxReverseLookup(ipAddress);\n\n<span class=\"hljs-comment\">// Subscribe to perform the lookup</span>\nmaybe.\n  subscribe(\n    name -&gt; {\n      <span class=\"hljs-comment\">// DNS反向查询返回结果</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// Lookup failed</span>\n    },\n    () -&gt; {\n      <span class=\"hljs-comment\">// DNS反向查询没返回结果</span>\n    }\n  );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>Completable</code> 一般对应 <code>Handler&lt;AsyncResult&lt;Void&gt;&gt;</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Completable</span> <span class=\"hljs-variable\">single</span> <span class=\"hljs-operator\">=</span> server.rxClose();\n\n<span class=\"hljs-comment\">// 订阅服务器关闭事件</span>\nsingle.\n  subscribe(\n    () -&gt; {\n      <span class=\"hljs-comment\">// 服务器关闭</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// 服务器关闭，但是遇到问题</span>\n    }\n  );</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>如果您不能使用 <em>Rx化的</em> Vert.x API，或您有自己的基于回调的异步方法，Vert.x 提供了下述的适配器：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/SingleHelper.html#toSingle-java.util.function.Consumer-\">SingleHelper.toSingle</a></code>,</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/MaybeHelper.html#toMaybe-java.util.function.Consumer-\">MaybeHelper.toMaybe</a></code> 和</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/CompletableHelper.html#toCompletable-java.util.function.Consumer-\">CompletableHelper.toCompletable</a></code>.</p>\n</li>\n</ul>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">适配 Vert.x core 的 <em>executeBlocking</em> 方法</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Maybe&lt;String&gt; maybe = MaybeHelper.toMaybe(handler -&gt; {\n  vertx.executeBlocking(fut -&gt; fut.complete(invokeBlocking()), handler);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scheduler_support\"><a class=\"anchor\" href=\"#_scheduler_support\"></a>调度器支持</h3>\n<div class=\"paragraph\">\n<p>有时候 Reactive 扩展库需要执行一些可调度的操作，例如 <code>Flowable#timer</code>\n方法将创建一个能周期性发射事件的定时器并返回之。默认情况下，这些可调度的操作由 RxJava 管理，\n这意味着定时器线程并非 Vert.x 线程，因此（这些操作）并不在 Vert.x Event Loop 线程上执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>当 Rxjava方法处理一个调度器的时候，它接受一个额外 <code>io.reactivex.Scheduler</code> 参数的重载方法，\n<code><a href=\"../../apidocs/io/vertx/rxjava3/RxHelper.html#scheduler-io.vertx.core.Vertx-\">RxHelper.scheduler</a></code> 方法返回的调度器可以供RxJava的\n这些方法使用</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Scheduler</span> <span class=\"hljs-variable\">scheduler</span> <span class=\"hljs-operator\">=</span> RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于阻塞型的可调度操作，我们可以通过 <code><a href=\"../../apidocs/io/vertx/rxjava3/RxHelper.html#blockingScheduler-io.vertx.core.Vertx-\">RxHelper.blockingScheduler</a></code>\n方法获得适用的调度器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Scheduler</span> <span class=\"hljs-variable\">scheduler</span> <span class=\"hljs-operator\">=</span> RxHelper.blockingScheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava 也能被配置成使用 Vert.x 的调度器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaPlugins.setComputationSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));\nRxJavaPlugins.setIoSchedulerHandler(s -&gt; RxHelper.blockingScheduler(vertx));\nRxJavaPlugins.setNewThreadSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\nRxJava使用 <em>computation</em> 表示非阻塞任务，使用 <em>io</em> 表示阻塞任务，\n这与 Vert.x 术语相反\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化的</em> Vert.x API 在 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/RxHelper.html\">RxHelper</a></code> 类中也提供了相似的方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Scheduler</span> <span class=\"hljs-variable\">scheduler</span> <span class=\"hljs-operator\">=</span> RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaPlugins.setComputationSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));\nRxJavaPlugins.setIoSchedulerHandler(s -&gt; RxHelper.blockingScheduler(vertx));\nRxJavaPlugins.setNewThreadSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以基于一个命名的工作线程池（named worker pool）创建调度器，\n如果您想为了调度阻塞操作复用特定的线程池，这将会很有帮助：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Scheduler</span> <span class=\"hljs-variable\">scheduler</span> <span class=\"hljs-operator\">=</span> RxHelper.blockingScheduler(workerExecutor);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_unmarshalling\"><a class=\"anchor\" href=\"#_json_unmarshalling\"></a>JSON解码</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html#unmarshaller-java.lang.Class-\">FlowableHelper.unmarshaller</a></code> 方法创建了一个 <code>io.reactivex.rxjava3.FlowableOperator</code> 对象，\n它可以将json格式的 <code>Flowable&lt;Buffer&gt;</code> 转换为对象的 flowable</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenOptions</span>(), result -&gt; {\n  <span class=\"hljs-type\">AsyncFile</span> <span class=\"hljs-variable\">file</span> <span class=\"hljs-operator\">=</span> result.result();\n  Flowable&lt;Buffer&gt; observable = FlowableHelper.toFlowable(file);\n  observable.compose(FlowableHelper.unmarshaller(MyPojo.class)).subscribe(\n      mypojo -&gt; {\n        <span class=\"hljs-comment\">// 处理对象</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化</em> 的辅助类也能做同样的事情：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem\n  .rxOpen(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenOptions</span>())\n  .flatMapObservable(file -&gt; file.toObservable())\n  .compose(ObservableHelper.unmarshaller((MyPojo.class)))\n  .subscribe(mypojo -&gt; {\n    <span class=\"hljs-comment\">// 处理对象</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_a_verticle\"><a class=\"anchor\" href=\"#_deploying_a_verticle\"></a>部署Verticle</h3>\n<div class=\"paragraph\">\n<p>部署一个已经存在的 Verticle 实例可以使用 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/RxHelper.html#deployVerticle-io.vertx.rxjava3.core.Vertx-io.vertx.core.Verticle-\">RxHelper.deployVerticle</a></code> 方法，\n它会部署一个 <code>Verticle</code> 并返回包含部署ID 的 <code>Single&lt;String&gt;</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; deployment = RxHelper.deployVerticle(vertx, verticle);\n\ndeployment.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// 部署</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// 部署失败</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxified_api\"><a class=\"anchor\" href=\"#_rxified_api\"></a>Rx化的 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><em>Rx化的</em> API 是 Vert.x API 的一个代码自动生成版本，就像 Vert.x 的 <em>JavaScript</em> 或 <em>Groovy</em> 版本一样。\n这些 API 以 <code>io.vertx.rxjava</code> 为包名前缀，例如 <code>io.vertx.core.Vertx</code> 类对应为 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html\">Vertx</a></code> 类。</p>\n</div>\n<div class=\"paragraph\">\n<p>Rx化的API以两种方式提供Vert.x的异步方法</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>把原始的方法转化为一个等效的RxJava风格的方法，其会返回一个带有缓存的立即订阅源（eager and cached subscription）</p>\n</li>\n<li>\n<p>一个 <em>rx</em> 前缀的派生方法，它在订阅的时候会调用原始的方法</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// 直接写入</span>\n<span class=\"hljs-comment\">// 无需订阅</span>\n<span class=\"hljs-comment\">// 完成后提供异步结果</span>\nresponse.write(buffer);\n\n<span class=\"hljs-comment\">// 写操作并没有发生</span>\ncompletion = response.rxWrite(buffer);\n\n<span class=\"hljs-comment\">// 执行实际写操作</span>\ncompletion.subscribe(() -&gt; ..., err -&gt; ...);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以根据您的需要使用原始的方法或Rx化方法，\n例如当您不想订阅或不关心结果，可以调用原始方法。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_embedding_rxfified_vert.x\"><a class=\"anchor\" href=\"#_embedding_rxfified_vert.x\"></a>嵌入Rx化的 Vert.x</h3>\n<div class=\"paragraph\">\n<p>只需使用 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html#vertx--\">Vertx.vertx</a></code> 方法:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> io.vertx.rxjava3.core.Vertx.vertx();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_as_a_verticle\"><a class=\"anchor\" href=\"#_as_a_verticle\"></a>作为 Verticle</h3>\n<div class=\"paragraph\">\n<p>继承 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/AbstractVerticle.html\">AbstractVerticle</a></code> 类, 它会做一些包装（您将获得一个 RxJava Verticle）:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractVerticle</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-comment\">// 在此可使用Rx化的Vert.x了</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>部署一个 RxJava Verticle 不需要特别的部署器，使用 Java\n部署器即可。</p>\n</div>\n<div class=\"paragraph\">\n<p>支持异步启动的 Verticle 可以重写 <code>rxStart</code> 方法并返回一个 <code>Completable</code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractVerticle</span> {\n  <span class=\"hljs-keyword\">public</span> Completable <span class=\"hljs-title function_\">rxStart</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Hello World&quot;</span>))\n      .rxListen()\n      .ignoreElement();\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_api_examples\"><a class=\"anchor\" href=\"#_api_examples\"></a>API 例子</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>让我们通过研究一些例子来了解相关 API 吧。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_eventBus_message_stream\"><a class=\"anchor\" href=\"#_eventBus_message_stream\"></a>EventBus 消息流</h3>\n<div class=\"paragraph\">\n<p>EventBus的 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 很自然地提供了 <code>Observable&lt;Message&lt;T&gt;&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">EventBus</span> <span class=\"hljs-variable\">eb</span> <span class=\"hljs-operator\">=</span> vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nFlowable&lt;Message&lt;String&gt;&gt; flowable = consumer.toFlowable();\n<span class=\"hljs-type\">Disposable</span> <span class=\"hljs-variable\">sub</span> <span class=\"hljs-operator\">=</span> flowable.subscribe(msg -&gt; {\n  <span class=\"hljs-comment\">// 获得消息</span>\n});\n\n<span class=\"hljs-comment\">// 10秒后注销</span>\nvertx.setTimer(<span class=\"hljs-number\">10000</span>, id -&gt; {\n  sub.dispose();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 提供了一个 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/Message.html\">Message</a></code> 的流.\n如果有需要，可以通过 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/Message.html#body--\">body</a></code> 方法获取信息体组成的流</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">EventBus</span> <span class=\"hljs-variable\">eb</span> <span class=\"hljs-operator\">=</span> vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nFlowable&lt;String&gt; flowable = consumer.bodyStream().toFlowable();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava 的 map/reduce 组合风格在这里是相当有用的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Double&gt; flowable = vertx.eventBus().\n    &lt;Double&gt;consumer(<span class=\"hljs-string\">&quot;heat-sensor&quot;</span>).\n    bodyStream().\n    toFlowable();\n\nflowable.\n    buffer(<span class=\"hljs-number\">1</span>, TimeUnit.SECONDS).\n    map(samples -&gt; samples.\n        stream().\n        collect(Collectors.averagingDouble(d -&gt; d))).\n    subscribe(heat -&gt; {\n      vertx.eventBus().send(<span class=\"hljs-string\">&quot;news-feed&quot;</span>, <span class=\"hljs-string\">&quot;Current heat is &quot;</span> + heat);\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timers\"><a class=\"anchor\" href=\"#_timers\"></a>定时器</h3>\n<div class=\"paragraph\">\n<p>可以通过 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html#timerStream-long-\">timerStream</a></code> 创建定时器任务</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.timerStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback after 1 second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以通过 <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html#periodicStream-long-\">periodicStream</a></code> 创建周期性任务</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback every second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过注销操作可以取消对 Observable 的订阅：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>&lt;Long&gt;() {\n      <span class=\"hljs-keyword\">private</span> Disposable sub;\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onSubscribe</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Disposable d)</span> {\n        sub = d;\n      }\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onNext</span><span class=\"hljs-params\">(Long aLong)</span> {\n        <span class=\"hljs-comment\">// Callback</span>\n        sub.dispose();\n      }\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onError</span><span class=\"hljs-params\">(Throwable e)</span> {}\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onComplete</span><span class=\"hljs-params\">()</span> {}\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_client_requests\"><a class=\"anchor\" href=\"#_http_client_requests\"></a>HTTP客户端请求</h3>\n<div class=\"paragraph\">\n<p>您可以很轻松地使用http client发送请求和处理响应</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\nclient.rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n  .flatMap(request -&gt; request\n    .rxSend()\n    .flatMap(response -&gt; {\n      <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">200</span>) {\n        <span class=\"hljs-keyword\">return</span> response.body();\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> Single.error(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoStackTraceThrowable</span>(<span class=\"hljs-string\">&quot;Invalid response&quot;</span>));\n      }\n    }))\n  .subscribe(body -&gt; {\n    <span class=\"hljs-comment\">// 处理响应体</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您需要处理大规模的响应流时，您可以通过http response获取 <code>Flowable&lt;Buffer&gt;</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\nclient.rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n  .flatMapPublisher(request -&gt; request\n    .rxSend()\n    .flatMapPublisher(response -&gt; {\n      <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">200</span>) {\n        <span class=\"hljs-keyword\">return</span> response.toFlowable();\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> Flowable.error(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoStackTraceThrowable</span>(<span class=\"hljs-string\">&quot;Invalid response&quot;</span>));\n      }\n    }))\n  .subscribe(chunk -&gt; {\n    <span class=\"hljs-comment\">// Process the response chunks</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <a href=\"http://vertx.io/docs/vertx-web-client/java/#_rxjava_api\">Vert.x Web Client</a></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_server_requests\"><a class=\"anchor\" href=\"#_http_server_requests\"></a>HTTP服务端请求</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/HttpServer.html#requestStream--\">requestStream</a></code>\n方法对到达的每个请求都提供了回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;HttpServerRequest&gt; requestFlowable = server.requestStream().toFlowable();\nrequestFlowable.subscribe(request -&gt; {\n  <span class=\"hljs-comment\">// 处理请求</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> 可以适配为 <code>Observable&lt;Buffer&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;HttpServerRequest&gt; requestFlowable = server.requestStream().toFlowable();\nrequestFlowable.subscribe(request -&gt; {\n  Observable&lt;Buffer&gt; observable = request.toObservable();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/ObservableHelper.html#unmarshaller-java.lang.Class-\">ObservableHelper.unmarshaller</a></code> 方法可以用来解析 JSON 格式的请求，\n并将其映射为对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;HttpServerRequest&gt; requestFlowable = server.requestStream().toFlowable();\nrequestFlowable.subscribe(request -&gt; {\n  Flowable&lt;MyPojo&gt; flowable = request.\n    toFlowable().\n    compose(FlowableHelper.unmarshaller(MyPojo.class));\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_client\"><a class=\"anchor\" href=\"#_websocket_client\"></a>WebSocket客户端</h3>\n<div class=\"paragraph\">\n<p>当 WebSocket 连接成功或失败时，<code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/HttpClient.html#webSocket-int-java.lang.String-java.lang.String-\">webSocket</a></code>\n方法对此提供了一次性的回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpClientOptions</span>());\nclient.rxWebSocket(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>).subscribe(\n    ws -&gt; {\n      <span class=\"hljs-comment\">// 使用websocket</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// 连接失败</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/WebSocket.html\">WebSocket</a></code>  对象可以轻松地转换为 <code>Observable&lt;Buffer&gt;</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Flowable&lt;Buffer&gt; dataObs = socket.toFlowable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_server\"><a class=\"anchor\" href=\"#_websocket_server\"></a>WebSocket服务端</h3>\n<div class=\"paragraph\">\n<p>当有连接接入时， <code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/HttpServer.html#webSocketStream--\">webSocketStream</a></code>\n为每个接入的连接提供了回调</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;ServerWebSocket&gt; socketFlowable = server.webSocketStream().toFlowable();\nsocketFlowable.subscribe(\n    socket -&gt; System.out.println(<span class=\"hljs-string\">&quot;Web socket connect&quot;</span>),\n    failure -&gt; System.out.println(<span class=\"hljs-string\">&quot;Should never be called&quot;</span>),\n    () -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Subscription ended or server closed&quot;</span>);\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> 对象可以轻松地转换为 <code>Observable&lt;Buffer&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Flowable&lt;Buffer&gt; dataObs = socket.toFlowable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.1.4"},"__N_SSG":true}