{"pageProps":{"slug":"4.1.4/vertx-auth-webauthn/java","title":"WebAuthn 权限管理器","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_webauthn_api\">WebAuthn API</a></li>\n<li><a href=\"#_registration\">注册</a></li>\n<li><a href=\"#_login\">登陆</a></li>\n<li><a href=\"#_device_attestation\">设备证明</a></li>\n<li><a href=\"#_a_simple_example\">一个简单的示例</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_create_a_registration_request\">创建一个注册请求</a></li>\n<li><a href=\"#_verify_the_registration_request\">校验注册请求</a></li>\n<li><a href=\"#_create_a_Login_request\">创建登陆请求</a></li>\n<li><a href=\"#_verify_the_login_request\">校验登陆请求</a></li>\n</ul>\n</li>\n<li><a href=\"#_metadata_service\">元数据服务</a></li>\n<li><a href=\"#_updating_certificates\">更新证书</a></li>\n</ul>\n</div>","contents":"<h1>WebAuthn 权限管理器</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>本组件包含一个开箱即用的\n<a href=\"https://github.com/herrjemand/awesome-webauthn#server-libs\">符合FIDO标准</a> 的 WebAuthn 实现。要使用该组件，\n您需要在编译脚本中添加如下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在您的 <code>pom.xml</code> ）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-auth-webauthn<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> ）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-auth-webauthn:4.1.4&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API\">WebAuthn (Web Authentication)</a> 是一个web标准，\n该标准使用了公钥和私钥来给web应用的用户授权。\n严格来讲，WebAuthn仅仅是浏览器API的名称， 而且它还是 <a href=\"https://fidoalliance.org/fido2/\">FIDO2</a> 的一部分。\nFIDO2 是一系列标准的宏观总体，它包含了 WebAuthn 和 CTAP。\nFIDO2 是历史遗留协议 FIDO Universal 2nd Factor（U2F）的替代者。</p>\n</div>\n<div class=\"paragraph\">\n<p>作为应用开发者，我们不处理 CTAP（Client-to-Authenticator Protocol），\nCTAP是一个协议，类似FIDO安全口令一样，浏览器用它来与认证器交互。</p>\n</div>\n<div class=\"paragraph\">\n<p>FIDO2使用公钥/私钥。用户有一个认证器，该认证器创建公钥/私钥的密钥对。\n这些密钥对在每个网站都不一样。公钥被传送到服务器端并被存储到用户账号名下。\n私钥存储在验证器方从不暴露。如果要登陆，服务器首先创建一个随机码（一个随机的二进制序列），\n然后将它发送到验证器。验证器将随机码加入签名后用私钥加密，\n然后将签名加密后的数据发送回服务器。\n服务器用存储的公钥校验签名，如果签名合法，则进行授权。</p>\n</div>\n<div class=\"paragraph\">\n<p>按传统，该技术需要一个硬件安全口令，类似 <a href=\"https://www.yubico.com/products/\">Yubico key</a> 或者 <a href=\"https://www.ftsafe.com/Products/FIDO\">Feitian</a> 生成的口令，\n从而命名客户端和服务端两方。</p>\n</div>\n<div class=\"paragraph\">\n<p>FIDO2 依旧支持这些硬件口令，但是这个技术也支持其他的。如果您有一个安卓7以上版本的手机，\n或者Windows10系统，那么您用WebAuthn时，便不再需要购买FIDO2安全口令。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 <a href=\"https://fidoalliance.org/news-your-google-android-7-phone-is-now-a-fido2-security-key/\">2019年4月, 谷歌声明</a> 所有安卓7版本以上的手机都可以充当一个FIDO2安全密钥。\n在 <a href=\"https://www.microsoft.com/en-us/microsoft-365/blog/2018/11/20/sign-in-to-your-microsoft-account-without-a-password-using-windows-hello-or-a-security-key/\">2018年11月, 微软声明</a> 您可以用 Windows Hello 作为一个FIDO2的安全密钥。\n在 <a href=\"https://developer.apple.com/videos/play/wwdc2020/10670/\">2020年6月 苹果声明</a> ，\n您可以通过兼容WebAuthn标准的方式，\n将IOS系统的 FaceID 和 TouchID 用于web应用。</p>\n</div>\n<div class=\"paragraph\">\n<p>WebAuthn协议已经在 Edge、Firefox、Chrome、和 Safari 浏览器当中实现。\n访问 <a href=\"https://caniuse.com\" class=\"bare\">https://caniuse.com</a> 来查看当前已实现该标准的浏览器： <a href=\"https://caniuse.com/#search=webauthn\" class=\"bare\">https://caniuse.com/#search=webauthn</a></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_webauthn_api\"><a class=\"anchor\" href=\"#_webauthn_api\"></a>WebAuthn API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API\">Web Authentication API</a> 是\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Credential_Management_API\">Credential Management API</a> 的扩展。</p>\n</div>\n<div class=\"paragraph\">\n<p>WebAuthn 从 Credential Management API 中继承了两个功能，\n他们分别是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create\">navigator.credentials.create()</a> 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get\">navigator.credentials.get()</a> ，\n所以他们会就收一个 publickKey 参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了简化该API的用法，我们提供了一个JavaScript客户端应用：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在您的 <code>pom.xml</code> 文件）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-auth-webauthn<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>js<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在您的 <code>build.gradle</code> 文件）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-auth-webauthn:4.1.4:client@js&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该库应该和vertx-web配合使用，\n因为它处理了web层和鉴权码之间的API交互问题。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_registration\"><a class=\"anchor\" href=\"#_registration\"></a>注册</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>注册是将一个新的鉴权器存入数据库并与用户生成关系的过程。</p>\n</div>\n<div class=\"paragraph\">\n<p>该过程总共有两个步骤：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>调用 <code><a href=\"../../apidocs/io/vertx/ext/auth/webauthn/WebAuthn.html#createCredentialsOptions-io.vertx.core.json.JsonObject-\">createCredentialsOptions</a></code> 生成一个JsonObject</p>\n</li>\n<li>\n<p>调用常规的 <code>authenticate</code> API来解密。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>如果解密正确，则新的鉴权器应该添加到数据库中并在登陆中可用。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_login\"><a class=\"anchor\" href=\"#_login\"></a>登陆</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>类似注册，登陆也有两个步骤：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>调用 <code><a href=\"../../apidocs/io/vertx/ext/auth/webauthn/WebAuthn.html#getCredentialsOptions-java.lang.String-\">getCredentialsOptions</a></code> 并生成字符串。</p>\n</li>\n<li>\n<p>调用常规的 <code>authenticate</code> API来解密。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>解密成功，则用户被视为已登陆。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_device_attestation\"><a class=\"anchor\" href=\"#_device_attestation\"></a>设备证明</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当一个鉴权器将一个新的密钥对注册于一个服务，则该鉴权器会用证书在公钥上签名。\n这个证书在设备制造的时候就已经被内置于鉴权器当中并指定一个设备模型。\n也就是说，\n所有的 \"Samsung Galaxy S8\" 手机在出厂时间或特定运行时间拥有同样的证书。</p>\n</div>\n<div class=\"paragraph\">\n<p>不同设备的证书格式不同。WebAuthn预定义的证书格式如下：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Packed</code> - 广泛用于核心功能为WebAuthn鉴权器的通用证书格式，例如安全口令。</p>\n</li>\n<li>\n<p><code>TPM</code> - 可信平台模块（TPM）是可信平台组（TPG）中的一系列标准。这个证书格式在台式电脑中广泛应用，并且在Window Hello中作为首选证书格式。</p>\n</li>\n<li>\n<p><code>Android Key Attestation</code> - 安卓密钥证书是在安卓0版本中的一个特性，它允许安卓系统校验口令。</p>\n</li>\n<li>\n<p><code>Android SafetyNet</code> - 主要用于Android Key Attestation，创建 Android SafetyNet 证书对于安卓是唯一的可选项。</p>\n</li>\n<li>\n<p><code>FIDO U2F</code> - 实现了 FIDO U2F 的安全密钥使用这个格式。</p>\n</li>\n<li>\n<p><code>Apple</code> - 校验匿名苹果设备证书</p>\n</li>\n<li>\n<p><code>none</code> - 浏览器可能会提示用户选择是否允许网站查看证书数据或者在 <code>navigator.credentials.create()</code> 的 <code>attestation</code> 参数被设置为 <code>none</code> 时是否允许从鉴权器响应中移除证书信息。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这个证书的目的在于，从密码学角度证明，一个新生成的密钥对是来自于一个指定的设备。\n这提供了一个受信的基础，并且能够识别正在使用的设备的属性\n（私钥如何被保护；是否使用了生物识别或使用哪一种生物识别；\n设备是否已认证；等等）。</p>\n</div>\n<div class=\"paragraph\">\n<p>要注意的是，尽管证书提供了信任的基础，但是校验这个受信的基础是非常不必要的。\n当为一个新的用户注册鉴权器时，通常会使用首次使用信任模型（TOFU）；\n当对一个已存在的用户添加鉴权器时，\n则用户此时已经被授权并已经处于一个安全的会话当中。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_a_simple_example\"><a class=\"anchor\" href=\"#_a_simple_example\"></a>一个简单的示例</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_create_a_registration_request\"><a class=\"anchor\" href=\"#_create_a_registration_request\"></a>创建一个注册请求</h3>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebAuthn webAuthN = WebAuthn.create(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> WebAuthnOptions()\n    .setRelyingParty(<span class=\"hljs-keyword\">new</span> RelyingParty().setName(<span class=\"hljs-string\">&quot;ACME Corporation&quot;</span>)))\n  .authenticatorFetcher(query -&gt; {\n    <span class=\"hljs-comment\">// 从持久层</span>\n    <span class=\"hljs-comment\">// 获取鉴权器的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(authenticators);\n  })\n  .authenticatorUpdater(authenticator -&gt; {\n    <span class=\"hljs-comment\">// 更新一个鉴权器并持久化</span>\n    <span class=\"hljs-comment\">// 的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture();\n  });\n\n<span class=\"hljs-comment\">// 某用户</span>\nJsonObject user = <span class=\"hljs-keyword\">new</span> JsonObject()\n  <span class=\"hljs-comment\">// id最好是base64url字符串</span>\n  .put(<span class=\"hljs-string\">&quot;id&quot;</span>, <span class=\"hljs-string\">&quot;000000000000000000000000&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;rawId&quot;</span>, <span class=\"hljs-string\">&quot;000000000000000000000000&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;john.doe@email.com&quot;</span>)\n  <span class=\"hljs-comment\">// 可选项</span>\n  .put(<span class=\"hljs-string\">&quot;displayName&quot;</span>, <span class=\"hljs-string\">&quot;John Doe&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;icon&quot;</span>, <span class=\"hljs-string\">&quot;https://pics.example.com/00/p/aBjjjpqPb.png&quot;</span>);\n\nwebAuthN\n  .createCredentialsOptions(user)\n  .onSuccess(challengeResponse -&gt; {\n    <span class=\"hljs-comment\">// 将密钥返回到浏览器</span>\n    <span class=\"hljs-comment\">// 以供后续使用</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verify_the_registration_request\"><a class=\"anchor\" href=\"#_verify_the_registration_request\"></a>校验注册请求</h3>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebAuthn webAuthN = WebAuthn.create(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> WebAuthnOptions()\n    .setRelyingParty(<span class=\"hljs-keyword\">new</span> RelyingParty().setName(<span class=\"hljs-string\">&quot;ACME Corporation&quot;</span>)))\n  .authenticatorFetcher(query -&gt; {\n    <span class=\"hljs-comment\">// 从持久层</span>\n    <span class=\"hljs-comment\">// 获取鉴权器的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(authenticators);\n  })\n  .authenticatorUpdater(authenticator -&gt; {\n    <span class=\"hljs-comment\">// 更新一个鉴权器并持久化</span>\n    <span class=\"hljs-comment\">// 的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture();\n  });\n\n<span class=\"hljs-comment\">// the response received from the browser</span>\nJsonObject request = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;id&quot;</span>, <span class=\"hljs-string\">&quot;Q-MHP0Xq20CKM5LW3qBt9gu5vdOYLNZc3jCcgyyL...&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;rawId&quot;</span>, <span class=\"hljs-string\">&quot;Q-MHP0Xq20CKM5LW3qBt9gu5vdOYLNZc3jCcgyyL...&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;type&quot;</span>, <span class=\"hljs-string\">&quot;public-key&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;response&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">&quot;attestationObject&quot;</span>, <span class=\"hljs-string\">&quot;o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVj...&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;clientDataJSON&quot;</span>, <span class=\"hljs-string\">&quot;eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlb...&quot;</span>));\n\nwebAuthN\n  .authenticate(\n    <span class=\"hljs-keyword\">new</span> JsonObject()\n      <span class=\"hljs-comment\">// 您想要关联到用户名</span>\n      .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;paulo&quot;</span>)\n      <span class=\"hljs-comment\">// 服务器源地址</span>\n      .put(<span class=\"hljs-string\">&quot;origin&quot;</span>, <span class=\"hljs-string\">&quot;https://192.168.178.206.xip.io:8443&quot;</span>)\n      <span class=\"hljs-comment\">// 域名</span>\n      .put(<span class=\"hljs-string\">&quot;domain&quot;</span>, <span class=\"hljs-string\">&quot;192.168.178.206.xip.io&quot;</span>)\n      <span class=\"hljs-comment\">// 上一步获取到到密钥</span>\n      .put(<span class=\"hljs-string\">&quot;challenge&quot;</span>, <span class=\"hljs-string\">&quot;BH7EKIDXU6Ct_96xTzG0l62qMhW_Ef_K4MQdDLoVNc1UX...&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;webauthn&quot;</span>, request))\n  .onSuccess(user -&gt; {\n    <span class=\"hljs-comment\">// success!</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_create_a_Login_request\"><a class=\"anchor\" href=\"#_create_a_Login_request\"></a>创建登陆请求</h3>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebAuthn webAuthN = WebAuthn.create(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> WebAuthnOptions()\n    .setRelyingParty(<span class=\"hljs-keyword\">new</span> RelyingParty().setName(<span class=\"hljs-string\">&quot;ACME Corporation&quot;</span>)))\n  .authenticatorFetcher(query -&gt; {\n    <span class=\"hljs-comment\">// 从持久层</span>\n    <span class=\"hljs-comment\">// 获取鉴权器的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(authenticators);\n  })\n  .authenticatorUpdater(authenticator -&gt; {\n    <span class=\"hljs-comment\">// 更新一个鉴权器并持久化</span>\n    <span class=\"hljs-comment\">// 的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture();\n  });\n\n<span class=\"hljs-comment\">// 登陆仅仅需要username，</span>\n<span class=\"hljs-comment\">// 而且在支持常驻密钥时甚至可以设置为null</span>\n<span class=\"hljs-comment\">// 这个场景下，鉴权器存储用户方使用的公钥</span>\nwebAuthN.getCredentialsOptions(<span class=\"hljs-string\">&quot;paulo&quot;</span>)\n  .onSuccess(challengeResponse -&gt; {\n    <span class=\"hljs-comment\">// 将密钥返回到浏览器</span>\n    <span class=\"hljs-comment\">// 以供后续使用</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verify_the_login_request\"><a class=\"anchor\" href=\"#_verify_the_login_request\"></a>校验登陆请求</h3>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebAuthn webAuthN = WebAuthn.create(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> WebAuthnOptions()\n    .setRelyingParty(<span class=\"hljs-keyword\">new</span> RelyingParty().setName(<span class=\"hljs-string\">&quot;ACME Corporation&quot;</span>)))\n  .authenticatorFetcher(query -&gt; {\n    <span class=\"hljs-comment\">// 从持久层</span>\n    <span class=\"hljs-comment\">// 获取鉴权器的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(authenticators);\n  })\n  .authenticatorUpdater(authenticator -&gt; {\n    <span class=\"hljs-comment\">// 更新一个鉴权器并持久化</span>\n    <span class=\"hljs-comment\">// 的函数</span>\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture();\n  });\n\n<span class=\"hljs-comment\">// The response from the login challenge request</span>\nJsonObject body = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;id&quot;</span>, <span class=\"hljs-string\">&quot;rYLaf9xagyA2YnO-W3CZDW8udSg8VeMMm25nenU7nCSxUqy1pEzOdb9o...&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;rawId&quot;</span>, <span class=\"hljs-string\">&quot;rYLaf9xagyA2YnO-W3CZDW8udSg8VeMMm25nenU7nCSxUqy1pEzOdb9o...&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;type&quot;</span>, <span class=\"hljs-string\">&quot;public-key&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;response&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">&quot;authenticatorData&quot;</span>, <span class=\"hljs-string\">&quot;fxV8VVBPmz66RLzscHpg5yjRhO...&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;clientDataJSON&quot;</span>, <span class=\"hljs-string\">&quot;eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlb...&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;signature&quot;</span>, <span class=\"hljs-string\">&quot;MEUCIFXjL0ONRuLP1hkdlRJ8d0ofuRAS12c6w8WgByr-0yQZA...&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;userHandle&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>));\n\nwebAuthN.authenticate(<span class=\"hljs-keyword\">new</span> JsonObject()\n  <span class=\"hljs-comment\">// 您想要关联到用户名</span>\n  .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;paulo&quot;</span>)\n  <span class=\"hljs-comment\">// 服务器源地址</span>\n  .put(<span class=\"hljs-string\">&quot;origin&quot;</span>, <span class=\"hljs-string\">&quot;https://192.168.178.206.xip.io:8443&quot;</span>)\n  <span class=\"hljs-comment\">// 服务器域名</span>\n  .put(<span class=\"hljs-string\">&quot;domain&quot;</span>, <span class=\"hljs-string\">&quot;192.168.178.206.xip.io&quot;</span>)\n  <span class=\"hljs-comment\">// 之前得到的密钥</span>\n  .put(<span class=\"hljs-string\">&quot;challenge&quot;</span>, <span class=\"hljs-string\">&quot;BH7EKIDXU6Ct_96xTzG0l62qMhW_Ef_K4MQdDLoVNc1UX...&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;webauthn&quot;</span>, body))\n  .onSuccess(user -&gt; {\n    <span class=\"hljs-comment\">// success!</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_metadata_service\"><a class=\"anchor\" href=\"#_metadata_service\"></a>元数据服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当前模块通过了所有FIDO2一致性测试，<strong>包括</strong>尚未确定的FIDO2元数据服务API。\n这意味着我们遵循这个协议，并且此处理器<strong>可以</strong>检测被令牌供应商标记为不可信任的令牌。\n例如，一个安全漏洞允许从令牌中提取私钥。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了支持元数据服务API，作为用户，\n您需要注册自己或者在 <a href=\"https://fidoalliance.org/metadata/\">https://fidoalliance.org/metadata</a> 注册您的应用</p>\n</div>\n<div class=\"paragraph\">\n<p>在注册之后，您可以获取到 <code>APIKey</code> ，并将您到应用配置为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">final</span> WebAuthnOptions webAuthnOptions = <span class=\"hljs-keyword\">new</span> WebAuthnOptions()\n  <span class=\"hljs-comment\">// 为了完全信任MDS口令，</span>\n  <span class=\"hljs-comment\">// 我们需要按照 https://fidoalliance.org/metadata/ 来加载CRLs</span>\n\n  <span class=\"hljs-comment\">// here the content of: http://mds.fidoalliance.org/Root.crl</span>\n  .addRootCrl(\n    <span class=\"hljs-string\">&quot;MIIB1jCCAV0CAQEwCg...&quot;</span>)\n  <span class=\"hljs-comment\">// 内容: http://mds.fidoalliance.org/CA-1.crl</span>\n  .addRootCrl(\n    <span class=\"hljs-string\">&quot;MIIB5DCCAYoCAQEwCg...&quot;</span>);\n\n<span class=\"hljs-comment\">// 类似前述，创建webauthn安全对象</span>\n<span class=\"hljs-keyword\">final</span> WebAuthn webAuthN = WebAuthn.create(vertx, webAuthnOptions);\n\nwebAuthN.metaDataService()\n  .fetchTOC(<span class=\"hljs-string\">&quot;https://mds2.fidoalliance.org/?token=your-access-token-string&quot;</span>)\n  .onSuccess(allOk -&gt; {\n    <span class=\"hljs-comment\">// 如果所有的元数据下载完毕，并且解析正确，allOk为true</span>\n    <span class=\"hljs-comment\">// 如果这个对象已经过时，那么这个过程不会停止</span>\n    <span class=\"hljs-comment\">// 这个场景下，会跳过指定对象且标识位为false。这也意味着</span>\n    <span class=\"hljs-comment\">// 这个对象会被标记为 &quot;不受信任&quot;，</span>\n    <span class=\"hljs-comment\">// 因为我们无法做出任何校验判断</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_updating_certificates\"><a class=\"anchor\" href=\"#_updating_certificates\"></a>更新证书</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>几乎所有设备的证书都基于 <code>X509</code> 证书校验。这意味着，证书在某个时间点会过期。\n默认情况下，当前 \"激活的\" 证书是在 <code>WebAuthnOptions</code> 中硬编码的。</p>\n</div>\n<div class=\"paragraph\">\n<p>然而，如果您的应用需要在自身更新一个证书，例如，用一个时效更近的证书，\n或者用另一个不同的密钥，此时，\n您可以调用 <code>WebAuthnOptions.putRootCertificate(String, String)</code> 替换默认的 <code>根证书</code> ，\n第一个参数是证书名称或者 FIDO元数据服务的\"mds\"：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>none</p>\n</li>\n<li>\n<p>u2f</p>\n</li>\n<li>\n<p>packed</p>\n</li>\n<li>\n<p>android-key</p>\n</li>\n<li>\n<p>android-safetynet</p>\n</li>\n<li>\n<p>tpm</p>\n</li>\n<li>\n<p>apple</p>\n</li>\n<li>\n<p>mds</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>其次，PEM格式的X509证书（大小不做要求）。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">final</span> WebAuthnOptions webAuthnOptions = <span class=\"hljs-keyword\">new</span> WebAuthnOptions()\n  <span class=\"hljs-comment\">// fido2 MDS 自定义根证书</span>\n  .putRootCertificate(<span class=\"hljs-string\">&quot;mds&quot;</span>, <span class=\"hljs-string\">&quot;MIIB1jCCAV0CAQEwCg...&quot;</span>)\n  <span class=\"hljs-comment\">// 从 https://pki.goog/repository/ 更新谷歌根证书</span>\n  .putRootCertificate(<span class=\"hljs-string\">&quot;android-safetynet&quot;</span>, <span class=\"hljs-string\">&quot;MIIDvDCCAqSgAwIBAgINAgPk9GHs...&quot;</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.1.4"},"__N_SSG":true}