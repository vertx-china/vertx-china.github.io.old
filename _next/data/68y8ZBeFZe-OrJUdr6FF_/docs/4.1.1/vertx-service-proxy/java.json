{"pageProps":{"slug":"4.1.1/vertx-service-proxy/java","title":"Vert.x 服务代理","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_service_proxies\">使用Vert.x服务代理</a></li>\n<li><a href=\"#_introduction_to_service_proxies\">服务代理简介</a></li>\n<li><a href=\"#_async_interface\">异步接口</a></li>\n<li><a href=\"#_async_interface_with_callbacks\">带回调的异步接口</a></li>\n<li><a href=\"#_security\">安全</a></li>\n<li><a href=\"#_code_generation\">代码生成</a></li>\n<li><a href=\"#_exposing_your_service\">公开服务</a></li>\n<li><a href=\"#_proxy_creation\">代理创建</a></li>\n<li><a href=\"#_error_handling\">错误处理</a></li>\n<li><a href=\"#_restrictions_for_service_interface\">接口类型限制</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_types\">数据类型</a></li>\n<li><a href=\"#_overloaded_methods\">重载方法</a></li>\n</ul>\n</li>\n<li><a href=\"#_convention_for_invoking_services_over_the_event_bus_without_proxies\">通过事件总线调用服务的规则 (不使用服务代理)</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x 服务代理</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您编写 Vert.x 程序的时候，您也许想将某处独立服务功能提供给其他程序使用。\n此时便使用服务代理。它可以让您在事件总线上发布您的 <em>服务</em> ，\n任何 Vert.x 程序只要知道其 <em>地址</em>\n即可使用该服务。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个 <em>服务</em> 通过 Java 接口描述并遵循 <em>异步</em> 模式。\n从本质上说，消息通过事件总线发送调用服务并获取响应。\n但为了方便使用，它会生成一个 <em>代理</em> ，您可直接使用该代理（用代理提供的服务接口 API）。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_service_proxies\"><a class=\"anchor\" href=\"#_using_vert_x_service_proxies\"></a>使用Vert.x服务代理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><strong>使用</strong> Vert.x Service Proxies 之前，\n您必须在您得项目当中添加 <em>依赖</em> ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-service-proxy:4.1.1&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了 <strong>实现</strong> 服务代理, 您还需要添加：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-codegen<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>provided<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle &lt; 5 （在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compileOnly <span class=\"hljs-string\">&#x27;io.vertx:vertx-codegen:4.1.1&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle &gt;= 5（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">annotationProcessor <span class=\"hljs-string\">&#x27;io.vertx:vertx-codegen:4.1.1:processor&#x27;</span>\nannotationProcessor <span class=\"hljs-string\">&#x27;io.vertx:vertx-service-proxy:4.1.1&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意：因为服务代理类是由代码自动生成的，因此每当您修改了 <em>服务接口</em> 您必须重新编译源码，\n以重新生成代理类。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您要生成不同语言的代理类，您需要添加相应的依赖。例如，\n生成 Groovy 语言的代理接口需要添加 <code>vertx-lang-groovy</code> 依赖</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_introduction_to_service_proxies\"><a class=\"anchor\" href=\"#_introduction_to_service_proxies\"></a>服务代理简介</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>让我看看服务代理它怎么用。\n如果您在事件总线上公开 <em>数据库服务</em> 您可以执行下面的操作</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject message = <span class=\"hljs-keyword\">new</span> JsonObject();\n\nmessage\n  .put(<span class=\"hljs-string\">&quot;collection&quot;</span>, <span class=\"hljs-string\">&quot;mycollection&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;document&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;tim&quot;</span>));\n\nDeliveryOptions options = <span class=\"hljs-keyword\">new</span> DeliveryOptions().addHeader(<span class=\"hljs-string\">&quot;action&quot;</span>, <span class=\"hljs-string\">&quot;save&quot;</span>);\n\nvertx.eventBus()\n  .request(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>, message, options)\n  .onSuccess(msg -&gt; {\n    <span class=\"hljs-comment\">// 完成</span>\n  }).onFailure(err -&gt; {\n  <span class=\"hljs-comment\">// 失败</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当创建服务的时候，会有一定数量的样本代码在事件总线接收信息，\n路由会找到合适的方法并在总线上返回结果</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 Vert.x 服务代理时, 您可以使用代码生成避免编写重复的代码，从而集中精力编写服务</p>\n</div>\n<div class=\"paragraph\">\n<p>在您编写的Java接口上面打上 <code>@ProxyGen</code> 注解, 例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n <span class=\"hljs-comment\">// 几个工厂方法用于创建实例和代理</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl(vertx);\n }\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx,\n   String address)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n }\n\n<span class=\"hljs-comment\">// 此处是实际的服务操作……</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String collection, JsonObject document,\n  Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler)</span></span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还需要编写 <code>package-info.java</code> 文件，位置处于接口定义包中。\n这个包还需要 <code>@ModuleGen</code> 注解，\n以便 Vert.x 代码生成器生成事件总线代理代码。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">package-info.java</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@io</span>.vertx.codegen.annotations.ModuleGen(groupPackage = <span class=\"hljs-string\">&quot;io.vertx.example&quot;</span>, name = <span class=\"hljs-string\">&quot;services&quot;</span>, useFutures = <span class=\"hljs-keyword\">true</span>)\n<span class=\"hljs-keyword\">package</span> io.vertx.example;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有了这个接口，Vert.x 会生成所有需要的用于在事件总线上访问您服务的模板代码，\n同时也会生成对应的 <strong>调用端代理类（client side proxy）</strong> ，\n这样您的服务调用端就可以使用一个相当符合习惯的 API（译者注：即相同的服务接口）进行服务调用，而不是去手动地向事件总线发送消息。\n不管您的服务实际依赖于哪个事件总线上（可能是在不同的机器上），调用端代理类都能正常工作。</p>\n</div>\n<div class=\"paragraph\">\n<p>也就是说，您可以通过以下方式进行服务调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = SomeDatabaseService\n  .createProxy(vertx, <span class=\"hljs-string\">&quot;database-service-address&quot;</span>);\n\n<span class=\"hljs-comment\">// 保存数据到数据库，这里使用了代理</span>\nservice.save(\n  <span class=\"hljs-string\">&quot;mycollection&quot;</span>,\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;tim&quot;</span>),\n  res2 -&gt; {\n    <span class=\"hljs-keyword\">if</span> (res2.succeeded()) {\n      <span class=\"hljs-comment\">// 调用完毕</span>\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以将多语言 API 生成功能（@VertxGen 注解）与 @ProxyGen 注解相结合，\n用于生成其它 Vert.x 支持的 JVM 语言对应的服务代理 —— 这意味着您可以只用 Java 编写您的服务一次，\n就可以在其他语言中以一种习惯的 API 风格进行服务调用，而完全不必管服务是在本地还是在哪个事件总线上。\n想要利用多语言代码生成功能，不要忘记添加对应支持语言的依赖。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span> <span class=\"hljs-comment\">// 生成服务代理</span>\n<span class=\"hljs-meta\">@VertxGen</span> <span class=\"hljs-comment\">// 生成客户端</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_async_interface\"><a class=\"anchor\" href=\"#_async_interface\"></a>异步接口</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>想要正确地生成服务代理类，<em>服务接口</em> 的设计必须遵循一些规则。 首先是需要遵循异步模式。\n如果需要返回结果，对应的方法需要包含一个 <code>Future&lt;ResultType&gt;</code> 类型的返回值。\n其中 <code>ResultType</code> 可以是另一种代理类型（所以一个代理类可以作为另一个代理类的工厂）。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n<span class=\"hljs-comment\">// 一些用于创建服务实例和服务代理实例的工厂方法</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl(vertx);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx, String address)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n}\n\n<span class=\"hljs-comment\">// 异步方法，仅通知调用是否完成，不返回结果</span>\n<span class=\"hljs-function\">Future&lt;Void&gt; <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String collection, JsonObject document)</span></span>;\n\n<span class=\"hljs-comment\">// 异步方法，包含JsonObject类型的返回结果</span>\n<span class=\"hljs-function\">Future&lt;JsonObject&gt; <span class=\"hljs-title\">findOne</span><span class=\"hljs-params\">(String collection, JsonObject query)</span></span>;\n\n<span class=\"hljs-comment\">// 创建连接</span>\n<span class=\"hljs-function\">Future&lt;MyDatabaseConnection&gt; <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize)</span></span>;\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以及：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-meta\">@VertxGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">MyDatabaseConnection</span> </span>{\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(JsonObject someData)</span></span>;\n\n<span class=\"hljs-function\">Future&lt;Void&gt; <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">()</span></span>;\n\n<span class=\"hljs-meta\">@ProxyClose</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">close</span><span class=\"hljs-params\">()</span></span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过声明一个特殊方法，并给其加上 <code>@ProxyClose</code> 注解来注销代理。\n当此方法被调用时，代理实例被清除。</p>\n</div>\n<div class=\"paragraph\">\n<p>更多 <code>服务接口</code> 的限制会在下面详解。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_async_interface_with_callbacks\"><a class=\"anchor\" href=\"#_async_interface_with_callbacks\"></a>带回调的异步接口</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在 Vert.x 4.1 之前，服务异步接口由回调定义。</p>\n</div>\n<div class=\"paragraph\">\n<p>您仍然可以使用回调创建服务异步接口，使用以下模块声明：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">package-info.java</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@io</span>.vertx.codegen.annotations.ModuleGen(groupPackage = <span class=\"hljs-string\">&quot;io.vertx.example&quot;</span>, name = <span class=\"hljs-string\">&quot;services&quot;</span>, useFutures = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-keyword\">package</span> io.vertx.example;</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n为向后兼容，<code>useFutures</code> 的默认值为 <code>false</code>，因此您也可以省略该声明\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>带有回调的服务异步接口如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n <span class=\"hljs-comment\">// 一个通知完成而没有结果的方法（void）</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String collection, JsonObject document,\n  Handler&lt;AsyncResult&lt;Void&gt;&gt; result)</span></span>;\n\n <span class=\"hljs-comment\">// 一个提供了结果的方法（一个 json 对象）</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findOne</span><span class=\"hljs-params\">(String collection, JsonObject query,\n  Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; result)</span></span>;\n\n <span class=\"hljs-comment\">// 创建连接</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize,\n  Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler)</span></span>;\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>返回类型必须是以下之一：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>void</code></p>\n</li>\n<li>\n<p><code>@Fluent</code> 并返回对该服务的引用（<code>this</code>）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Fluent</span>\n<span class=\"hljs-function\">SomeDatabaseService <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">()</span></span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这是因为方法不允许阻塞，如果该服务是远程调用（remote）（译者注：远程意思是服务代理通过事件总线调用其他verticle中的服务），\n那么无法在不阻塞的前提下立即返回结果。（译者注：因为远程调用需要消耗一定时间）</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_security\"><a class=\"anchor\" href=\"#_security\"></a>安全</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>服务代理可以使用简单的拦截器保障基本安全。\n提供一个身份验证器，可以选择添加 <code>Authorization</code> 在这种情况下，<code>AuthorizationProvider</code> 是必须提提供的。\n注意，身份认证的令牌从 <code>auth-token</code> 信息头获取。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// 注册处理器</span>\n<span class=\"hljs-keyword\">new</span> ServiceBinder(vertx)\n  .setAddress(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>)\n  <span class=\"hljs-comment\">// 保护传输中的信息</span>\n  .addInterceptor(\n    <span class=\"hljs-keyword\">new</span> ServiceAuthInterceptor()\n      <span class=\"hljs-comment\">// 使用JWT认证进行校验令牌</span>\n      .setAuthenticationProvider(JWTAuth.create(vertx, <span class=\"hljs-keyword\">new</span> JWTAuthOptions()))\n      <span class=\"hljs-comment\">// 我们可以选择部分权限进行保护：</span>\n\n      <span class=\"hljs-comment\">// 比如admin组</span>\n      .addAuthorization(RoleBasedAuthorization.create(<span class=\"hljs-string\">&quot;admin&quot;</span>))\n      <span class=\"hljs-comment\">// 比如打印权限</span>\n      .addAuthorization(PermissionBasedAuthorization.create(<span class=\"hljs-string\">&quot;print&quot;</span>))\n\n      <span class=\"hljs-comment\">// 或者从令牌种加载权限</span>\n      <span class=\"hljs-comment\">// 如果有需要您也可以从数据库或文件加载中权限</span>\n      .setAuthorizationProvider(\n        JWTAuthorization.create(<span class=\"hljs-string\">&quot;permissions&quot;</span>)))\n\n  .register(SomeDatabaseService.class, service);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_code_generation\"><a class=\"anchor\" href=\"#_code_generation\"></a>代码生成</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>被 @ProxyGen 注解的服务接口会触发生成对应的服务辅助类：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>服务代理类（service proxy）：一个编译时产生的代理类，用 <code>EventBus</code> 通过消息与服务交互。</p>\n</li>\n<li>\n<p>服务处理器类（service handler）： 一个编译时产生的 <code>EventBus</code> 处理器类，用于响应由服务代理发送的事件。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>产生的服务代理和处理器的命名是在类名的后面加相关的字段，例如，如果一个服务接口名为 <code>MyService</code>，\n则对应的处理器类命名为 <code>MyServiceProxyHandler</code>，对应的服务代理类命名为 MyServiceVertxEBProxy。</p>\n</div>\n<div class=\"paragraph\">\n<p>此外 Vert.x Core 提供了一个生成器用于数据转化器，以简化服务代理中数据对象的使用。\n数据转化器要求数据对象提供一个以 <code>JsonObject</code>\n为基础的构造器和 <code>toJson()</code> 方法</p>\n</div>\n<div class=\"paragraph\">\n<p><em>codegen</em> 注释处理器在编译时生成这些类\n它是Java编译器的功能 所以无需 <em>额外步骤</em>, 只需正确配置您的构建参数即可：</p>\n</div>\n<div class=\"paragraph\">\n<p>只需要在构建配置中加上 <code>io.vertx:vertx-codegen:processor</code> 和 <code>io.vertx:vertx-service-proxy</code>\n依赖。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个针对 Maven 的配置示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-codegen<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>processor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>此功能也可以在 Gradle 中使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>compile \"io.vertx:vertx-codegen:4.1.1:processor\"\ncompile \"io.vertx:vertx-service-proxy:4.1.1\"</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>IDE 通常为注释处理器提供支持。</p>\n</div>\n<div class=\"paragraph\">\n<p>代码生成 <code>处理器</code> 分类器会把服务代理注释处理器的配置自动添加到 jar 包目录下的\n<code>META-INF/services</code> 当中。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您想和其与常规 jar一起使用，但是需要显式声明注释处理器,\n例如在 Maven 中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">annotationProcessors</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">annotationProcessor</span>&gt;</span>io.vertx.codegen.CodeGenProcessor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">annotationProcessor</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">annotationProcessors</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_exposing_your_service\"><a class=\"anchor\" href=\"#_exposing_your_service\"></a>公开服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您写好服务接口以后，执行构建操作以生成代码。\n然后您需要将您的服务 <code>注册</code> 到事件总线上：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// 注册处理器</span>\n<span class=\"hljs-keyword\">new</span> ServiceBinder(vertx)\n  .setAddress(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>)\n  .register(SomeDatabaseService.class, service);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个过程既可以在 Verticle 中完成，也可以在您的代码的任何其它位置完成。</p>\n</div>\n<div class=\"paragraph\">\n<p>一旦注册了，这个服务就可用了。如果您的应用运行在集群上，\n则集群中节点都可访问。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果想注销这个服务, 使用 <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceBinder.html#unregister-io.vertx.core.eventbus.MessageConsumer-\">unregister</a></code>\n方法注销：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceBinder binder = <span class=\"hljs-keyword\">new</span> ServiceBinder(vertx);\n\n<span class=\"hljs-comment\">// 创建服务实现实例</span>\nSomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// 注册处理器</span>\nMessageConsumer&lt;JsonObject&gt; consumer = binder\n  .setAddress(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>)\n  .register(SomeDatabaseService.class, service);\n\n<span class=\"hljs-comment\">// ....</span>\n\n<span class=\"hljs-comment\">// 销毁服务。</span>\nbinder.unregister(consumer);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_proxy_creation\"><a class=\"anchor\" href=\"#_proxy_creation\"></a>代理创建</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>现在服务已经公开, 现在可以消费使用它。 为此，您必须创建一个代理。\n创建代理使用 <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceProxyBuilder.html\">ServiceProxyBuilder</a></code> 类：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceProxyBuilder builder = <span class=\"hljs-keyword\">new</span> ServiceProxyBuilder(vertx)\n  .setAddress(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>);\n\nSomeDatabaseService service = builder.build(SomeDatabaseService.class);\n<span class=\"hljs-comment\">// 设置其他属性：</span>\nSomeDatabaseService service2 = builder.setOptions(options)\n  .build(SomeDatabaseService.class);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>第二种构造通过 <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html\">DeliveryOptions</a></code> 构造实例，\n您可以在其中配置属性（例如：超时）</p>\n</div>\n<div class=\"paragraph\">\n<p>或者,您也可以使用代理类。\n这个代理名称为 <em>服务接口</em> 类目后追加 <code>VertxEBProxy</code>。\n例如, 如果您的 <em>服务接口</em> 名为 <code>SomeDatabaseService</code>，那么代理类名为 <code>SomeDatabaseServiceVertxEBProxy</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>一般来说, <em>服务接口</em> 包含 <code>createProxy</code> 静态方法用于创建代理。 但这不是必须的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n<span class=\"hljs-comment\">// 静态方法创建代理。</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx, String address)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n}\n\n<span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_error_handling\"><a class=\"anchor\" href=\"#_error_handling\"></a>错误处理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>服务方法可能会通过向方法的处理器（Handler）传递一个失败状态的 Future （包含一个 <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceException.html\">ServiceException</a></code> 实例。\n一个 <code>ServiceException</code> 包含 <code>int</code> 类型的错误码、消息,以及一个可选的\n <code>JsonObject</code> 对象用于传递额外信息。为了方便，\n<code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceException.html#fail-int-java.lang.String-\">ServiceException.fail</a></code> 工厂方法来创建一个已经是失败状态并且包装着\n<code>ServiceException</code> 实例的失败 <code>Future</code> 。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeDatabaseServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> BAD_SHOE_SIZE = <span class=\"hljs-number\">42</span>;\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> CONNECTION_FAILED = <span class=\"hljs-number\">43</span>;\n\n <span class=\"hljs-comment\">// 创建连接</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;MyDatabaseConnection&gt; <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">if</span> (!shoeSize.equals(<span class=\"hljs-string\">&quot;9&quot;</span>)) {\n     <span class=\"hljs-keyword\">return</span> Future.failedFuture(ServiceException.fail(BAD_SHOE_SIZE, <span class=\"hljs-string\">&quot;The shoe size must be 9!&quot;</span>,\n       <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;shoeSize&quot;</span>, shoeSize)));\n    } <span class=\"hljs-keyword\">else</span> {\n       <span class=\"hljs-keyword\">return</span> doDbConnection().recover(err -&gt; Future.failedFuture(ServiceException.fail(CONNECTION_FAILED, result.cause().getMessage())));\n    }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>服务调用端（客户端）可以检查它接收到的失败状态的 <code>Future</code> 包含的 <code>Throwable</code> 对象是否为 <code>ServiceException</code> 实例。\n如果是的话，继续检查内部的特定的错误状态码。\n调用端可以通过这些信息来将业务逻辑错误与系统错误（如服务没有被注册到事件总线上）区分开，\n以便确定到底发生了哪一种业务逻辑错误。下面是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;JsonObject&gt; <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(String shoeSize)</span> </span>{\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n server.createConnection(<span class=\"hljs-string\">&quot;8&quot;</span>)\n   .compose(connection -&gt; {\n     <span class=\"hljs-comment\">// 正常调用。</span>\n     <span class=\"hljs-keyword\">return</span> doSuccessStuff(connection);\n   })\n   .recover(err -&gt; {\n     <span class=\"hljs-keyword\">if</span> (err <span class=\"hljs-keyword\">instanceof</span> ServiceException) {\n       ServiceException exc = (ServiceException) err;\n       <span class=\"hljs-keyword\">if</span> (exc.failureCode() == SomeDatabaseServiceImpl.BAD_SHOE_SIZE) {\n         <span class=\"hljs-keyword\">return</span> Future.failedFuture(\n           <span class=\"hljs-keyword\">new</span> InvalidInputError(<span class=\"hljs-string\">&quot;You provided a bad shoe size: &quot;</span> +\n             exc.getDebugInfo().getString(<span class=\"hljs-string\">&quot;shoeSize&quot;</span>)));\n       } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (exc.failureCode() == SomeDatabaseServiceImpl.CONNECTION) {\n         <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-keyword\">new</span> ConnectionError(<span class=\"hljs-string\">&quot;Failed to connect to the DB&quot;</span>));\n       }\n     } <span class=\"hljs-keyword\">else</span> {\n       <span class=\"hljs-comment\">// 必须是一个系统错误，如：服务代理没有对应的已注册的服务</span>\n       <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-keyword\">new</span> SystemError(<span class=\"hljs-string\">&quot;An unexpected error occurred: + &quot;</span> result.cause().getMessage()));\n     }\n   });\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果需要的话, 服务实现的时候也可以返回 <code>ServiceException</code> 子类,\n只要向事件总线注册了对应的默认 <code>MessageCodec</code> 就可以了。 例如, 比如给定下面的 <code>ServiceException</code> 子类：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShoeSizeException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ServiceException</span> </span>{\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> BAD_SHOE_SIZE_ERROR = <span class=\"hljs-number\">42</span>;\n\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String shoeSize;\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ShoeSizeException</span><span class=\"hljs-params\">(String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">super</span>(BAD_SHOE_SIZE_ERROR, <span class=\"hljs-string\">&quot;In invalid shoe size was received: &quot;</span> + shoeSize);\n   <span class=\"hljs-keyword\">this</span>.shoeSize = shoeSize;\n }\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getShoeSize</span><span class=\"hljs-params\">()</span> </span>{\n   <span class=\"hljs-keyword\">return</span> extra;\n }\n\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">Future&lt;T&gt; <span class=\"hljs-title\">fail</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> failureCode, String message, String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-keyword\">new</span> MyServiceException(failureCode, message, shoeSize));\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>只要向事件总线注册了对应的 <code>MessageCodec</code> ，\n服务就可以直接向调用者返回自定义的异常类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeDatabaseServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SomeDataBaseServiceImpl</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n   <span class=\"hljs-comment\">// 注册服务，如果你是用事件总线使用本地模式，这就是全部</span>\n   <span class=\"hljs-comment\">// 因为代理端和服务端共享一个vert.x实例</span>\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n   vertx.eventBus().registerDefaultCodec(ShoeSizeException.class,\n     <span class=\"hljs-keyword\">new</span> ShoeSizeExceptionMessageCodec());\n }\n\n <span class=\"hljs-comment\">// 创建连接</span>\n <span class=\"hljs-function\">Future&lt;MyDatabaseConnection&gt; <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">if</span> (!shoeSize.equals(<span class=\"hljs-string\">&quot;9&quot;</span>)) {\n     <span class=\"hljs-keyword\">return</span> ShoeSizeException.fail(shoeSize);\n   } <span class=\"hljs-keyword\">else</span> {\n     <span class=\"hljs-comment\">// 此处创建连接</span>\n     <span class=\"hljs-keyword\">return</span> Future.succeededFuture(myDbConnection);\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>最后调用端可以检查自定义的异常类型了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;JsonObject&gt; <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(String shoeSize)</span> </span>{\n <span class=\"hljs-comment\">// 如果运行在集群模式当中，代码在不同的节点运行，</span>\n <span class=\"hljs-comment\">// ShoeSizeExceptionMessageCodec 必须注册到</span>\n <span class=\"hljs-comment\">// 该节点的Vertx当中</span>\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n service.createConnection(<span class=\"hljs-string\">&quot;8&quot;</span>)\n   .compose(connection -&gt; {\n     <span class=\"hljs-comment\">// 成功调用。</span>\n     <span class=\"hljs-keyword\">return</span> doSuccessStuff(connection);\n   })\n   .recover(err -&gt; {\n     <span class=\"hljs-keyword\">if</span> (result.cause() <span class=\"hljs-keyword\">instanceof</span> ShoeSizeException) {\n       ShoeSizeException exc = (ShoeSizeException) result.cause();\n       <span class=\"hljs-keyword\">return</span> Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> InvalidInputError(<span class=\"hljs-string\">&quot;You provided a bad shoe size: &quot;</span> + exc.getShoeSize()));\n     } <span class=\"hljs-keyword\">else</span> {\n       <span class=\"hljs-comment\">// 必须是个系统错误 (例如：没有为服务代理进行注册)</span>\n       <span class=\"hljs-keyword\">return</span> Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> SystemError(<span class=\"hljs-string\">&quot;An unexpected error occurred: + &quot;</span> result.cause().getMessage())\n       );\n     }\n   });\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意在 <code>Vertx</code> 集群模式下，您需要向集群中每个节点的事件总线注册对应的自定义异常类型\n的 <code>MessageCodec</code> 实例</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_restrictions_for_service_interface\"><a class=\"anchor\" href=\"#_restrictions_for_service_interface\"></a>接口类型限制</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在服务中参数和返回值在类型上有一定的限制,因此可以方便在事件总线中进行转化。\n他们是：</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_data_types\"><a class=\"anchor\" href=\"#_data_types\"></a>数据类型</h3>\n<div class=\"paragraph\">\n<p><code>JSON</code> 表示 <code>JsonObject 或 JsonArray</code>\n<code>PRIMITIVE</code> 表示任何原始类型或被自动拆装箱的原始类型</p>\n</div>\n<div class=\"paragraph\">\n<p>参数可以是以下任意一种：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>JSON</code></p>\n</li>\n<li>\n<p><code>PRIMITIVE</code></p>\n</li>\n<li>\n<p><code>List&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>List&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Map&lt;String, JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Map&lt;String, PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p>任何 <em>枚举</em> 类型</p>\n</li>\n<li>\n<p>任何被打上 <code>@DataObject</code> 注解的实体类</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>异步结果可建模为</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Future&lt;R&gt;</code></p>\n</li>\n<li>\n<p>用于回调样式的 <code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><code>R</code> 的类型可以是：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>JSON</code></p>\n</li>\n<li>\n<p><code>PRIMITIVE</code></p>\n</li>\n<li>\n<p><code>List&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>List&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p>任何 <em>枚举</em> 类型</p>\n</li>\n<li>\n<p>任何打上 <code>@DataObject</code> 注解的类（需符合上文的代码篇章要求）</p>\n</li>\n<li>\n<p>另一个代理类</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_overloaded_methods\"><a class=\"anchor\" href=\"#_overloaded_methods\"></a>重载方法</h3>\n<div class=\"paragraph\">\n<p>服务接口不支持任何的重载(即方法名称相同，但参数列表不同)服务方法。。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_convention_for_invoking_services_over_the_event_bus_without_proxies\"><a class=\"anchor\" href=\"#_convention_for_invoking_services_over_the_event_bus_without_proxies\"></a>通过事件总线调用服务的规则 (不使用服务代理)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>服务代理假定事件总线中的消息遵循一定的格式，因此能被用于服务的调用</p>\n</div>\n<div class=\"paragraph\">\n<p>当然，如果不愿意的话，您也可以 <strong>不用</strong> 服务代理类来访问远程服务。\n被广泛接受的与服务交互的方式就是直接在事件总线发送消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了使服务访问的方式一致，\n所有的服务都必须遵循以下的消息格式。</p>\n</div>\n<div class=\"paragraph\">\n<p>格式非常简单：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>需要有一个名为 <code>action</code> 的 消息头(header)，作为要执行操作的名称。</p>\n</li>\n<li>\n<p>消息体（message body）应该是一个 <code>JsonObject</code> 对象，里面需要包含操作需要的所有参数。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>举个例子，假如我们要去执行一个名为 <code>save</code> 的操作，此操作接受一个字符串类型的 collection 和 JsonObject 类型 document：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>Headers:\n   \"action\": \"save\"\nBody:\n   {\n       \"collection\", \"mycollection\",\n       \"document\", {\n           \"name\": \"tim\"\n       }\n   }</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>无论有没有用到服务代理来创建服务，都应该用上面这种方式编写服务，\n因为这样允许服务交互时保持一致性。</p>\n</div>\n<div class=\"paragraph\">\n<p>在上面的例子中，\"action\" 对应的值应该与服务接口的某个方法名称相对应，\n而消息体中每个 <code>[key, value]</code> 都要与服务方法中的某个 <code>[arg_name, arg_value]</code> 相对应</p>\n</div>\n<div class=\"paragraph\">\n<p>对于返回值，服务需使用 <code>message.reply(&#8230;&#8203;)</code> 方法去向调用端发送回一个返回值 - 这个值可以是事件总线支持的任何类型。\n如果需要表示调用失败，可以调用 <code>message.fail(&#8230;&#8203;)</code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 Vert.x 服务代理组件的话，生成的代码会自动帮您处理这些问题。</p>\n</div>\n</div>\n</div>","version":"4.1.1"},"__N_SSG":true}