{"pageProps":{"categories":["releases","guides","news"],"post":{"meta":{"title":"Eclipse Vert.x RabbitMQ client gets a new consumer API!","category":"guides","authors":[{"name":"Pavel Drankov","github_id":"Sammers21"}],"summary":"In this blog post, we present the new consumer API of the RabbitMQ client that will be released with Eclipse Vert.x 3.6.0."},"date":"2018-04-23","slug":"eclipse-vert-x-rabbitmq-client-gets-a-new-consumer-api","readingTime":{"text":"3 min read","minutes":2.245,"time":134700.00000000003,"words":449},"content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Eclipse Vert.x 3.6.0, the Rab\\xADbitMQ client will get a new con\\xADsumer API. In this post we are going to show\\nthe im\\xADprove\\xADments since the pre\\xADvi\\xADous API and how easy it is to use now.\"), mdx(\"p\", null, \"Be\\xADfore dig\\xADging into the new API let\\u2019s find out what were the lim\\xADi\\xADta\\xADtions of the ac\\xADtual one:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The API uses the event bus in such lim\\xADit\\xADing the con\\xADtrol of the con\\xADsumer over the Rab\\xADbitMQ queue.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The mes\\xADsage API is based on \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"JsonObject\"), \" which does not pro\\xADvide a typed API\")), mdx(\"h2\", {\n    \"id\": \"the-new-api-at-a-glance\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#the-new-api-at-a-glance\"\n  })), \"The new API at a glance\"), mdx(\"p\", null, \"Here is how sim\\xADple queue con\\xADsump\\xADtion looks like with the new API:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), \"RabbitMQClient client = RabbitMQClient.create(vertx, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" RabbitMQOptions());\\n\\nclient.basicConsumer(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"my.queue\\\"\"), \", res -> {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (res.succeeded()) {\\n    System.out.println(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"RabbitMQ consumer created !\\\"\"), \");\\n    RabbitMQConsumer mqConsumer = res.result();\\n    mqConsumer.handler((RabbitMQMessage message) -> {\\n        System.out.println(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"Got message: \\\"\"), \" + message.body().toString());\\n    });\\n  } \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"else\"), \" {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// Oups something went wrong\"), \"\\n    res.cause().printStackTrace();\\n  }\\n});\\n\")), mdx(\"p\", null, \"Now to cre\\xADate a queue you sim\\xADply call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"basicConsumer\"), \" method and you ob\\xADtain asyn\\xADchro\\xADnously\\na \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RabbitMQConsumer\"), \".\"), mdx(\"p\", null, \"Then you need to pro\\xADvide a han\\xADdler called for each mes\\xADsage con\\xADsumed via \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Rab\\xADbit\\xADMQ\\xADCon\\xADsumer#han\\xADdler\"), \" which\\nis the id\\xADiomatic way to con\\xADsumer stream in Vert.x\"), mdx(\"p\", null, \"You may also note that when we a mes\\xADsage ar\\xADrives, it has the type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RabbitMQMessage\"), \", this is a typed\\nmes\\xADsage rep\\xADre\\xADsen\\xADta\\xADtion.\"), mdx(\"p\", null, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RabbitMQConsumer\"), \" is a stream, you also al\\xADlowed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pause\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resume\"), \" the stream, sub\\xADscribe to the\\nend event, get no\\xADti\\xADfied when an ex\\xADcep\\xADtion oc\\xADcurs.\"), mdx(\"p\", null, \"In ad\\xADdi\\xADtion, you can can\\xADcel the sub\\xADscrip\\xADtion by call\\xADing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RabbitMQConsumer#cancel\"), \" method.\"), mdx(\"h2\", {\n    \"id\": \"backpressure\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#backpressure\"\n  })), \"Backpressure\"), mdx(\"p\", null, \"Some\\xADtimes you can have more in\\xADcom\\xADing mes\\xADsages than you can han\\xADdle.\"), mdx(\"p\", null, \"The new con\\xADsumer API al\\xADlows you to con\\xADtrol this and lets you store ar\\xADrived mes\\xADsages in the in\\xADter\\xADnal queue\\nbe\\xADfore they are de\\xADliv\\xADered to the ap\\xADpli\\xADca\\xADtion. In\\xADdeed, you can con\\xADfig\\xADure the queue size.\"), mdx(\"p\", null, \"Here is how you can limit the in\\xADter\\xADnal queue size:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// Limit to max 300 messages\"), \"\\nQueueOptions options = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" QueueOptions()\\n  .setMaxInternalQueueSize(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"300\"), \");\\n\\nRabbitMQClient client = RabbitMQClient.create(vertx, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" RabbitMQOptions());\\n\\nclient.basicConsumer(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"my.queue\\\"\"), \", options, res -> {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (res.succeeded()) {\\n    System.out.println(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"RabbitMQ consumer created !\\\"\"), \");\\n    RabbitMQConsumer mqConsumer = res.result();\\n    mqConsumer.handler((RabbitMQMessage message) -> {\\n      System.out.println(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"Got message: \\\"\"), \" + message.body().toString());\\n    });\\n  } \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"else\"), \" {\\n    res.cause().printStackTrace();\\n  }\\n});\\n\")), mdx(\"p\", null, \"When the in\\xADten\\xADral queue queue ca\\xADpac\\xADity is ex\\xADceeded, the new mes\\xADsage will be sim\\xADply dropped.\"), mdx(\"p\", null, \"An al\\xADter\\xADna\\xADtive op\\xADtion is to drop the old\\xADest mes\\xADsage in the queue.\"), mdx(\"p\", null, \"In order to achieve this, you should spec\\xADify the be\\xADhav\\xADior by call\\xADing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueueOptions#setKeepMostRecent\"), \" method.\"), mdx(\"h2\", {\n    \"id\": \"finally\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#finally\"\n  })), \"Finally\"), mdx(\"p\", null, \"The new Vert.x Rab\\xADbitMQ client con\\xADsumer API is way more id\\xADiomatic and mod\\xADern way to con\\xADsume mes\\xADsages from a queue.\"), mdx(\"p\", null, \"This API is going to pro\\xADvided in the 3.6.0 re\\xADlease, while the old will be dep\\xADre\\xADcated.\"), mdx(\"p\", null, \"I hope you en\\xADjoyed read\\xADing this ar\\xADti\\xADcle. See you soon on our \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://gitter.im/eclipse-vertx/vertx-users\"\n  }), \"Git\\xADter chan\\xADnel\"), \"!\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>In Eclipse Vert.x 3.6.0, the Rab­bitMQ client will get a new con­sumer API. In this post we are going to show\nthe im­prove­ments since the pre­vi­ous API and how easy it is to use now.</p><p>Be­fore dig­ging into the new API let’s find out what were the lim­i­ta­tions of the ac­tual one:</p><ol><li>The API uses the event bus in such lim­it­ing the con­trol of the con­sumer over the Rab­bitMQ queue.</li><li>The mes­sage API is based on <code>JsonObject</code> which does not pro­vide a typed API</li></ol><h2 id=\"the-new-api-at-a-glance\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#the-new-api-at-a-glance\"></a>The new API at a glance</h2><p>Here is how sim­ple queue con­sump­tion looks like with the new API:</p><pre><code class=\"hljs language-java\">RabbitMQClient client = RabbitMQClient.create(vertx, <span class=\"hljs-keyword\">new</span> RabbitMQOptions());\n\nclient.basicConsumer(<span class=\"hljs-string\">&quot;my.queue&quot;</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ consumer created !&quot;</span>);\n    RabbitMQConsumer mqConsumer = res.result();\n    mqConsumer.handler((RabbitMQMessage message) -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message: &quot;</span> + message.body().toString());\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Oups something went wrong</span>\n    res.cause().printStackTrace();\n  }\n});\n</code></pre><p>Now to cre­ate a queue you sim­ply call the <code>basicConsumer</code> method and you ob­tain asyn­chro­nously\na <code>RabbitMQConsumer</code>.</p><p>Then you need to pro­vide a han­dler called for each mes­sage con­sumed via <em>Rab­bit­MQ­Con­sumer#han­dler</em> which\nis the id­iomatic way to con­sumer stream in Vert.x</p><p>You may also note that when we a mes­sage ar­rives, it has the type of <code>RabbitMQMessage</code>, this is a typed\nmes­sage rep­re­sen­ta­tion.</p><p>Since <code>RabbitMQConsumer</code> is a stream, you also al­lowed to <code>pause</code> and <code>resume</code> the stream, sub­scribe to the\nend event, get no­ti­fied when an ex­cep­tion oc­curs.</p><p>In ad­di­tion, you can can­cel the sub­scrip­tion by call­ing <code>RabbitMQConsumer#cancel</code> method.</p><h2 id=\"backpressure\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#backpressure\"></a>Backpressure</h2><p>Some­times you can have more in­com­ing mes­sages than you can han­dle.</p><p>The new con­sumer API al­lows you to con­trol this and lets you store ar­rived mes­sages in the in­ter­nal queue\nbe­fore they are de­liv­ered to the ap­pli­ca­tion. In­deed, you can con­fig­ure the queue size.</p><p>Here is how you can limit the in­ter­nal queue size:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-comment\">// Limit to max 300 messages</span>\nQueueOptions options = <span class=\"hljs-keyword\">new</span> QueueOptions()\n  .setMaxInternalQueueSize(<span class=\"hljs-number\">300</span>);\n\nRabbitMQClient client = RabbitMQClient.create(vertx, <span class=\"hljs-keyword\">new</span> RabbitMQOptions());\n\nclient.basicConsumer(<span class=\"hljs-string\">&quot;my.queue&quot;</span>, options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;RabbitMQ consumer created !&quot;</span>);\n    RabbitMQConsumer mqConsumer = res.result();\n    mqConsumer.handler((RabbitMQMessage message) -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Got message: &quot;</span> + message.body().toString());\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});\n</code></pre><p>When the in­ten­ral queue queue ca­pac­ity is ex­ceeded, the new mes­sage will be sim­ply dropped.</p><p>An al­ter­na­tive op­tion is to drop the old­est mes­sage in the queue.</p><p>In order to achieve this, you should spec­ify the be­hav­ior by call­ing <code>QueueOptions#setKeepMostRecent</code> method.</p><h2 id=\"finally\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#finally\"></a>Finally</h2><p>The new Vert.x Rab­bitMQ client con­sumer API is way more id­iomatic and mod­ern way to con­sume mes­sages from a queue.</p><p>This API is going to pro­vided in the 3.6.0 re­lease, while the old will be dep­re­cated.</p><p>I hope you en­joyed read­ing this ar­ti­cle. See you soon on our <a href=\"https://gitter.im/eclipse-vertx/vertx-users\">Git­ter chan­nel</a>!</p>","scope":{}}},"prevPost":{"meta":{"title":"Eclipse Vert.x goes Native","category":"guides","authors":[{"name":"Johannes Schüth","github_id":"jotschi"}],"summary":"This blog post introduces native image generation of Vert.x applications with GraalVM. Generated executables can be run without a JVM."},"date":"2018-06-04","slug":"eclipse-vert-x-goes-native"},"nextPost":{"meta":{"title":"New community channels","category":"news","authors":[{"name":"Thomas Segismont","github_id":"tsegismont"}],"summary":"In order to better support the community, we (the core team and module maintainers) now also provide help on Stack Overflow and Gitter."},"date":"2018-04-13","slug":"new-community-channels"},"relatedPosts":[{"meta":{"title":"Some Rest with Vert.x","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"This post is part of the Introduction to Vert.x series. Let’s go a bit further this time and develop a CRUD-ish application"},"date":"2015-07-27","slug":"some-rest-with-vert-x"},{"meta":{"title":"Real-time bidding with Websockets and Vert.x","category":"guides","authors":[{"name":"Marcin Warczyglowa","github_id":"mwarc"}],"summary":"The expectations of users for interactivity with web applications have changed over the past few years.\n    Users during bidding in auction no longer want to press the refresh button."},"date":"2016-01-15","slug":"real-time-bidding-with-websockets-and-vert-x"},{"meta":{"title":"Eclipse Vert.x 3.7.0 released!","category":"releases","authors":[{"name":"Julien Viet","github_id":"vietj"}],"summary":"We are extremely pleased to announce that the Eclipse Vert.x version 3.7.0 has been released."},"date":"2019-04-02","slug":"eclipse-vert-x-3-7-0-released"}]},"__N_SSG":true}