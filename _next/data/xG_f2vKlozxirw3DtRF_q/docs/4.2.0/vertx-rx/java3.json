{"pageProps":{"slug":"4.2.0/vertx-rx/java3","title":"Vert.x RxJava","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_vert_x_api_for_rxjava3\">Vert.x API for RxJava3</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_api_for_rxjava3\">Using Vert.x API for RxJava3</a></li>\n<li><a href=\"#_read_stream_support\">Read stream support</a></li>\n<li><a href=\"#_write_stream_support\">Write stream support</a></li>\n<li><a href=\"#_async_result_support\">Async result support</a></li>\n<li><a href=\"#_scheduler_support\">Scheduler support</a></li>\n<li><a href=\"#_json_unmarshalling\">Json unmarshalling</a></li>\n<li><a href=\"#_deploying_a_verticle\">Deploying a Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxified_api\">Rxified API</a></li>\n<li><a href=\"#_embedding_rxfified_vert_x\">Embedding Rxfified Vert.x</a></li>\n<li><a href=\"#_as_a_verticle\">As a Verticle</a></li>\n<li><a href=\"#_api_examples\">Api examples</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_eventbus_message_stream\">EventBus message stream</a></li>\n<li><a href=\"#_timers\">Timers</a></li>\n<li><a href=\"#_http_client_requests\">Http client requests</a></li>\n<li><a href=\"#_http_server_requests\">Http server requests</a></li>\n<li><a href=\"#_websocket_client\">WebSocket client</a></li>\n<li><a href=\"#_websocket_server\">WebSocket server</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x RxJava</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_vert_x_api_for_rxjava3\"><a class=\"anchor\" href=\"#_vert_x_api_for_rxjava3\"></a>Vert.x API for RxJava3</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> is a popular library for composing asynchronous and event based programs using\nobservable sequences for the Java VM.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x integrates naturally with RxJava, allowing using RxJava wherever you can use streams or asynchronous results.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_api_for_rxjava3\"><a class=\"anchor\" href=\"#_using_vert_x_api_for_rxjava3\"></a>Using Vert.x API for RxJava3</h3>\n<div class=\"paragraph\">\n<p>To use Vert.x API for RxJava3, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-rx-java3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.0.Beta1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-rx-java3:4.2.0.Beta1&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>There are two ways for using the RxJava 3 API with Vert.x:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>via the original Vert.x API with helpers class that provides static methods for converting objects between Vert.x core\nAPI and RxJava 3 API</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/RxHelper.html\">RxHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/ObservableHelper.html\">ObservableHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html\">FlowableHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/SingleHelper.html\">SingleHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/MaybeHelper.html\">MaybeHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/CompletableHelper.html\">CompletableHelper</a></code></p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>via the <em>Rxified</em> Vert.x API enhancing the core Vert.x API.</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_read_stream_support\"><a class=\"anchor\" href=\"#_read_stream_support\"></a>Read stream support</h3>\n<div class=\"paragraph\">\n<p>RxJava <code>Flowable</code> is a perfect match for Vert.x <code>ReadStream</code> class : both provide a flow of items.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html#toFlowable-io.vertx.core.streams.ReadStream-\">FlowableHelper.toFlowable</a></code> static methods convert\na Vert.x read stream to a <code>Flowable</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fileSystem = vertx.fileSystem();\nfileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Flowable&lt;Buffer&gt; observable = FlowableHelper.toFlowable(file);\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API provides a <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/ReadStream.html#toFlowable--\">toFlowable</a></code>  method on\n<code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/ReadStream.html\">ReadStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\nfs.rxOpen(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions())\n  .flatMapPublisher(file -&gt; file.toFlowable())\n  .subscribe(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Such flowables are <strong>hot</strong> flowables, i.e. they will produce notifications regardless of subscriptions because\na <code>ReadStream</code> can potentially emit items spontaneously or not, depending on the implementation:</p>\n</div>\n<div class=\"paragraph\">\n<p>At subscription time, the adapter calls <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-\">handler</a></code>\nto set its own handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Some <code>ReadStream</code> implementations can start to emit events after this call, others will emit events wether an\nhandler is set:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>AsyncFile</code> produces buffer events after the handler is set</p>\n</li>\n<li>\n<p><code>HttpServerRequest</code> produces events independantly of the handler (i.e buffer may be lost if no handler is set)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>In both cases, subscribing to the <code>Flowable</code> in the same call is safe because the event loop or the worker\nverticles cannot be called concurrently, so the subscription will always happens before the handler starts emitting\ndata.</p>\n</div>\n<div class=\"paragraph\">\n<p>When you need to delay the subscription, you need to <code>pause</code> the <code>ReadStream</code> and then <code>resume</code> it, which is what\nyou would do with a <code>ReadStream</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.POST) {\n\n    <span class=\"hljs-comment\">// Stop receiving buffers</span>\n    request.pause();\n\n    checkAuth(res -&gt; {\n\n      <span class=\"hljs-comment\">// Now we can receive buffers again</span>\n      request.resume();\n\n      <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n        Flowable&lt;Buffer&gt; flowable = request.toFlowable();\n        flowable.subscribe(buff -&gt; {\n          <span class=\"hljs-comment\">// Get buffers</span>\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Likewise it is possible to turn an existing <code>Flowable</code> into a Vert.x <code>ReadStream</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html#toReadStream-io.reactivex.rxjava3.core.Flowable-\">FlowableHelper.toReadStream</a></code>  static methods convert\na <code>Flowable</code> to a Vert.x read stream:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Buffer&gt; observable = getFlowable();\nReadStream&lt;Buffer&gt; readStream = FlowableHelper.toReadStream(observable);\nPump pump = Pump.pump(readStream, response);\npump.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_write_stream_support\"><a class=\"anchor\" href=\"#_write_stream_support\"></a>Write stream support</h3>\n<div class=\"paragraph\">\n<p>A <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>, like a <code>org.reactivestreams.Subscriber</code>, consumes items, and, when it can&#8217;t keep-up, collaborates with the producer to avoid an ever-growing backlog.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x provides the <code><a href=\"../../apidocs/io/vertx/rxjava3/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> adapter that you can use to send <code>Flowable</code> items to any <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Sending buffers to an HTTP server response</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nWriteStreamSubscriber&lt;io.vertx.core.buffer.Buffer&gt; subscriber = io.vertx.rxjava3.RxHelper.toSubscriber(response);\nflowable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\nThere is also a <code>io.vertx.rxjava3.WriteStreamObserver</code> adapter for the non-backpressured <code>io.reactivex.Observable</code>.\nThe difference is that this adapter will send items to the <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> even when it can&#8217;t keep-up with the producer rate.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If you are progamming with the <em>Rxified</em> Vert.x API, the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> implementations provide a <code>toSubscriber</code> method.\nThe previous example then becomes even more straightforward:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nflowable.subscribe(response.toSubscriber());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nWhen the <code>Flowable</code> terminates successfully, the adapter invokes the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html#end--\">end</a></code> method.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\nThe adapter sets the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> <code>drain</code> and <code>exception</code> handlers, so don&#8217;t use them after subscribing.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> adapter is able to invoke callbacks when:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>the <code>Flowable</code> terminates with an error, or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> fails (e.g. HTTP connection is closed or filesystem is full), or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> ends (i.e. all writes done and file is closed), or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> ends with an error (i.e. all writes done and an error occured when closing the file)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This allows for a more robust program design, as well as scheduling other tasks after the stream has been handled:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\nWriteStreamSubscriber&lt;Buffer&gt; subscriber = response.toSubscriber();\n\nsubscriber.onError(throwable -&gt; {\n  <span class=\"hljs-keyword\">if</span> (!response.headWritten() &amp;&amp; response.closed()) {\n    response.setStatusCode(<span class=\"hljs-number\">500</span>).end(<span class=\"hljs-string\">&quot;oops&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// log error</span>\n  }\n});\n\nsubscriber.onWriteStreamError(throwable -&gt; {\n  <span class=\"hljs-comment\">// log error</span>\n});\n\nsubscriber.onWriteStreamEnd(() -&gt; {\n  <span class=\"hljs-comment\">// log end of transaction to audit system...</span>\n});\n\nflowable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nIf the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/WriteStream.html\">WriteStream</a></code> fails, the adapter cancels the <code>org.reactivestreams.Subscription</code>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_async_result_support\"><a class=\"anchor\" href=\"#_async_result_support\"></a>Async result support</h3>\n<div class=\"paragraph\">\n<p>You can create an RxJava <code>Observer</code> from an existing Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> and subscribe\nit:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;String&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// Subscribe to a Single</span>\nSingle.just(<span class=\"hljs-string\">&quot;hello&quot;</span>).subscribe(SingleHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;String&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// Subscribe to a Single</span>\nMaybe.just(<span class=\"hljs-string\">&quot;hello&quot;</span>).subscribe(MaybeHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// Subscribe to a Single</span>\nCompletable.complete().subscribe(CompletableHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API duplicates each such method with the <code>rx</code> prefix that returns an RxJava <code>Single</code>,\n<code>Maybe</code> or <code>Completable</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpServer&gt; single = vertx\n  .createHttpServer()\n  .rxListen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>);\n\n<span class=\"hljs-comment\">// Subscribe to bind the server</span>\nsingle.\n    subscribe(\n        server -&gt; {\n          <span class=\"hljs-comment\">// Server is listening</span>\n        },\n        failure -&gt; {\n          <span class=\"hljs-comment\">// Server could not start</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Such single are <strong>cold</strong> singles, and the corresponding API method is called on subscribe.</p>\n</div>\n<div class=\"paragraph\">\n<p><code>Maybe</code> can produce a result or no result:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(dnsPort, dnsHost);\n\n<span class=\"hljs-comment\">// Obtain a maybe that performs the actual reverse lookup on subscribe</span>\nMaybe&lt;String&gt; maybe = client.rxReverseLookup(ipAddress);\n\n<span class=\"hljs-comment\">// Subscribe to perform the lookup</span>\nmaybe.\n  subscribe(\n    name -&gt; {\n      <span class=\"hljs-comment\">// Lookup produced a result</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// Lookup failed</span>\n    },\n    () -&gt; {\n      <span class=\"hljs-comment\">// Lookup produced no result</span>\n    }\n  );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>Completable</code> is usually mapped to <code>Handler&lt;AsyncResult&lt;Void&gt;&gt;</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Completable single = server.rxClose();\n\n<span class=\"hljs-comment\">// Subscribe to close the server</span>\nsingle.\n  subscribe(\n    () -&gt; {\n      <span class=\"hljs-comment\">// Server is closed</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// Server closed but encountered issue</span>\n    }\n  );</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>If you cannot use the Vert.x <em>Rxified</em> API or, if you have your own, callback-based, asynchronous methods, Vert.x provides adapters:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/SingleHelper.html#toSingle-java.util.function.Consumer-\">SingleHelper.toSingle</a></code>,</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/MaybeHelper.html#toMaybe-java.util.function.Consumer-\">MaybeHelper.toMaybe</a></code> and</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/CompletableHelper.html#toCompletable-java.util.function.Consumer-\">CompletableHelper.toCompletable</a></code>.</p>\n</li>\n</ul>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Adapting Vert.x core <em>executeBlocking</em> method</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Maybe&lt;String&gt; maybe = MaybeHelper.toMaybe(handler -&gt; {\n  vertx.executeBlocking(fut -&gt; fut.complete(invokeBlocking()), handler);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scheduler_support\"><a class=\"anchor\" href=\"#_scheduler_support\"></a>Scheduler support</h3>\n<div class=\"paragraph\">\n<p>The reactive extension sometimes needs to schedule actions, for instance <code>Flowable#timer</code> creates and returns\na timer that emit periodic events. By default, scheduled actions are managed by RxJava, it means that the\ntimer threads are not Vert.x threads and therefore not executing in a Vert.x event loop nor on a Vert.x worker thread.</p>\n</div>\n<div class=\"paragraph\">\n<p>When an RxJava method deals with a scheduler, it accepts an overloaded method accepting an extra <code>io.reactivex.Scheduler</code>,\nthe <code><a href=\"../../apidocs/io/vertx/rxjava3/RxHelper.html#scheduler-io.vertx.core.Vertx-\">RxHelper.scheduler</a></code>  method will return a scheduler that can be used\nin such places.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For blocking scheduled actions, a scheduler can be created with the <code><a href=\"../../apidocs/io/vertx/rxjava3/RxHelper.html#blockingScheduler-io.vertx.core.Vertx-\">RxHelper.blockingScheduler</a></code>\nmethod:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.blockingScheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava can also be reconfigured to use the Vert.x scheduler:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaPlugins.setComputationSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));\nRxJavaPlugins.setIoSchedulerHandler(s -&gt; RxHelper.blockingScheduler(vertx));\nRxJavaPlugins.setNewThreadSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\nRxJava uses the words <em>computation</em> for non-blocking tasks and <em>io</em> for blocking tasks\nwhich is the opposite of the Vert.x terminology\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API provides also similar method on the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/RxHelper.html\">RxHelper</a></code> class:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaPlugins.setComputationSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));\nRxJavaPlugins.setIoSchedulerHandler(s -&gt; RxHelper.blockingScheduler(vertx));\nRxJavaPlugins.setNewThreadSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is also possible to create a scheduler backed by a named worker pool. This can be useful if you want to re-use\nthe specific thread pool for scheduling blocking actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.blockingScheduler(workerExecutor);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_unmarshalling\"><a class=\"anchor\" href=\"#_json_unmarshalling\"></a>Json unmarshalling</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/FlowableHelper.html#unmarshaller-java.lang.Class-\">FlowableHelper.unmarshaller</a></code> creates an <code>io.reactivex.rxjava3.FlowableOperator</code> that\ntransforms an <code>Flowable&lt;Buffer&gt;</code> in json format into an object flowable:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Flowable&lt;Buffer&gt; observable = FlowableHelper.toFlowable(file);\n  observable.compose(FlowableHelper.unmarshaller(MyPojo.class)).subscribe(\n      mypojo -&gt; {\n        <span class=\"hljs-comment\">// Process the object</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same can be done with the <em>Rxified</em> helper:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem\n  .rxOpen(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions())\n  .flatMapObservable(file -&gt; file.toObservable())\n  .compose(ObservableHelper.unmarshaller((MyPojo.class)))\n  .subscribe(mypojo -&gt; {\n    <span class=\"hljs-comment\">// Process the object</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_a_verticle\"><a class=\"anchor\" href=\"#_deploying_a_verticle\"></a>Deploying a Verticle</h3>\n<div class=\"paragraph\">\n<p>To deploy existing Verticle instances, you can use <code><a href=\"../../apidocs/io/vertx/rxjava3/core/RxHelper.html#deployVerticle-io.vertx.rxjava3.core.Vertx-io.vertx.core.Verticle-\">RxHelper.deployVerticle</a></code>\n, it deploys a <code>Verticle</code> and returns an <code>Single&lt;String&gt;</code> of the deployment ID.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; deployment = RxHelper.deployVerticle(vertx, verticle);\n\ndeployment.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// Deployed</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// Could not deploy</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxified_api\"><a class=\"anchor\" href=\"#_rxified_api\"></a>Rxified API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <em>rxified</em> API is a code generated version of the Vert.x API. The API uses the <code>io.vertx.rxjava3</code> prefix, for instance\nthe <code>io.vertx.core.Vertx</code> class is translated to the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html\">Vertx</a></code> class.</p>\n</div>\n<div class=\"paragraph\">\n<p>Rxified API expose Vert.x asynchronous methods in two fashion</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>the original method translated to a RxJava equivalent returning an eager and cached subscription</p>\n</li>\n<li>\n<p>a <em>rx</em> prefixed derived method that invokes the original method at subscription time</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// Immediate write</span>\n<span class=\"hljs-comment\">// no need to subscribe</span>\n<span class=\"hljs-comment\">// completion provides the asynchronous result</span>\nresponse.write(buffer);\n\n<span class=\"hljs-comment\">// No write happened</span>\ncompletion = response.rxWrite(buffer);\n\n<span class=\"hljs-comment\">// Perform an actual write</span>\ncompletion.subscribe(() -&gt; ..., err -&gt; ...);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can use the original method or the rxified method depending on your needs, e.g when you\ndon&#8217;t want to subscribe or you don&#8217;t care of the result you can call the original method.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_embedding_rxfified_vert_x\"><a class=\"anchor\" href=\"#_embedding_rxfified_vert_x\"></a>Embedding Rxfified Vert.x</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Just use the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html#vertx--\">Vertx.vertx</a></code> methods:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = io.vertx.rxjava3.core.Vertx.vertx();</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_as_a_verticle\"><a class=\"anchor\" href=\"#_as_a_verticle\"></a>As a Verticle</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Extend the <code><a href=\"../../apidocs/io/vertx/rxjava3/core/AbstractVerticle.html\">AbstractVerticle</a></code> class, it will wrap it for you:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Use Rxified Vertx here</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Deploying an RxJava verticle is still performed by the Java deployer and does not need a specified\ndeployer.</p>\n</div>\n<div class=\"paragraph\">\n<p>Verticles having an asynchronous start can override instead the <code>rxStart</code> method and return a <code>Completable</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Completable <span class=\"hljs-title\">rxStart</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Hello World&quot;</span>))\n      .rxListen()\n      .ignoreElement();\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_api_examples\"><a class=\"anchor\" href=\"#_api_examples\"></a>Api examples</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Let&#8217;s study now a few examples of using Vert.x with RxJava.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_eventbus_message_stream\"><a class=\"anchor\" href=\"#_eventbus_message_stream\"></a>EventBus message stream</h3>\n<div class=\"paragraph\">\n<p>The event bus <code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> provides naturally an <code>Observable&lt;Message&lt;T&gt;&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nFlowable&lt;Message&lt;String&gt;&gt; flowable = consumer.toFlowable();\nDisposable sub = flowable.subscribe(msg -&gt; {\n  <span class=\"hljs-comment\">// Got message</span>\n});\n\n<span class=\"hljs-comment\">// Unregisters the stream after 10 seconds</span>\nvertx.setTimer(<span class=\"hljs-number\">10000</span>, id -&gt; {\n  sub.dispose();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> provides a stream of <code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/Message.html\">Message</a></code>.\nThe <code><a href=\"../../apidocs/io/vertx/rxjava3/core/eventbus/Message.html#body--\">body</a></code> gives access to a new stream of message bodies if needed:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nFlowable&lt;String&gt; flowable = consumer.bodyStream().toFlowable();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava map/reduce composition style can then be used:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Double&gt; flowable = vertx.eventBus().\n    &lt;Double&gt;consumer(<span class=\"hljs-string\">&quot;heat-sensor&quot;</span>).\n    bodyStream().\n    toFlowable();\n\nflowable.\n    buffer(<span class=\"hljs-number\">1</span>, TimeUnit.SECONDS).\n    map(samples -&gt; samples.\n        stream().\n        collect(Collectors.averagingDouble(d -&gt; d))).\n    subscribe(heat -&gt; {\n      vertx.eventBus().send(<span class=\"hljs-string\">&quot;news-feed&quot;</span>, <span class=\"hljs-string\">&quot;Current heat is &quot;</span> + heat);\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timers\"><a class=\"anchor\" href=\"#_timers\"></a>Timers</h3>\n<div class=\"paragraph\">\n<p>Timer task can be created with <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html#timerStream-long-\">timerStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.timerStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback after 1 second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Periodic task can be created with <code><a href=\"../../apidocs/io/vertx/rxjava3/core/Vertx.html#periodicStream-long-\">periodicStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback every second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The observable can be cancelled with an unsubscription:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(<span class=\"hljs-keyword\">new</span> Observer&lt;Long&gt;() {\n      <span class=\"hljs-keyword\">private</span> Disposable sub;\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onSubscribe</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Disposable d)</span> </span>{\n        sub = d;\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(Long aLong)</span> </span>{\n        <span class=\"hljs-comment\">// Callback</span>\n        sub.dispose();\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{}\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onComplete</span><span class=\"hljs-params\">()</span> </span>{}\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_client_requests\"><a class=\"anchor\" href=\"#_http_client_requests\"></a>Http client requests</h3>\n<div class=\"paragraph\">\n<p>You can easily use the http client to create a request and process the response:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient();\nclient.rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n  .flatMap(request -&gt; request\n    .rxSend()\n    .flatMap(response -&gt; {\n      <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">200</span>) {\n        <span class=\"hljs-keyword\">return</span> response.body();\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> Single.error(<span class=\"hljs-keyword\">new</span> NoStackTraceThrowable(<span class=\"hljs-string\">&quot;Invalid response&quot;</span>));\n      }\n    }))\n  .subscribe(body -&gt; {\n    <span class=\"hljs-comment\">// Process the body</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you need to process large streaming response, you can get a <code>Flowable&lt;Buffer&gt;</code> from the http response</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient();\nclient.rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n  .flatMapPublisher(request -&gt; request\n    .rxSend()\n    .flatMapPublisher(response -&gt; {\n      <span class=\"hljs-keyword\">if</span> (response.statusCode() == <span class=\"hljs-number\">200</span>) {\n        <span class=\"hljs-keyword\">return</span> response.toFlowable();\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> Flowable.error(<span class=\"hljs-keyword\">new</span> NoStackTraceThrowable(<span class=\"hljs-string\">&quot;Invalid response&quot;</span>));\n      }\n    }))\n  .subscribe(chunk -&gt; {\n    <span class=\"hljs-comment\">// Process the response chunks</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also use the <a href=\"http://vertx.io/docs/vertx-web-client/java/#_rxjava_api\">Vert.x Web Client</a>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_server_requests\"><a class=\"anchor\" href=\"#_http_server_requests\"></a>Http server requests</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/HttpServer.html#requestStream--\">requestStream</a></code> provides a callback for each incoming\nrequest:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;HttpServerRequest&gt; requestFlowable = server.requestStream().toFlowable();\nrequestFlowable.subscribe(request -&gt; {\n  <span class=\"hljs-comment\">// Process request</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> can then be adapted to an <code>Observable&lt;Buffer&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;HttpServerRequest&gt; requestFlowable = server.requestStream().toFlowable();\nrequestFlowable.subscribe(request -&gt; {\n  Observable&lt;Buffer&gt; observable = request.toObservable();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/ObservableHelper.html#unmarshaller-java.lang.Class-\">ObservableHelper.unmarshaller</a></code> can be used to parse and map\na json request to an object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;HttpServerRequest&gt; requestFlowable = server.requestStream().toFlowable();\nrequestFlowable.subscribe(request -&gt; {\n  Flowable&lt;MyPojo&gt; flowable = request.\n    toFlowable().\n    compose(FlowableHelper.unmarshaller(MyPojo.class));\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_client\"><a class=\"anchor\" href=\"#_websocket_client\"></a>WebSocket client</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/HttpClient.html#webSocket-int-java.lang.String-java.lang.String-\">webSocket</a></code> provides a single callback when the WebSocket\nconnects, otherwise a failure:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nclient.rxWebSocket(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>).subscribe(\n    ws -&gt; {\n      <span class=\"hljs-comment\">// Use the websocket</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// Could not connect</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/WebSocket.html\">WebSocket</a></code> can then be turned into an <code>Observable&lt;Buffer&gt;</code> easily:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Flowable&lt;Buffer&gt; dataObs = socket.toFlowable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_server\"><a class=\"anchor\" href=\"#_websocket_server\"></a>WebSocket server</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava3/core/http/HttpServer.html#webSocketStream--\">webSocketStream</a></code> provides a callback for each incoming\nconnection:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;ServerWebSocket&gt; socketFlowable = server.webSocketStream().toFlowable();\nsocketFlowable.subscribe(\n    socket -&gt; System.out.println(<span class=\"hljs-string\">&quot;Web socket connect&quot;</span>),\n    failure -&gt; System.out.println(<span class=\"hljs-string\">&quot;Should never be called&quot;</span>),\n    () -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Subscription ended or server closed&quot;</span>);\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> can be turned into an <code>Observable&lt;Buffer&gt;</code> easily:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Flowable&lt;Buffer&gt; dataObs = socket.toFlowable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.2.0"},"__N_SSG":true}