{"pageProps":{"slug":"3.9.0/vertx-web-graphql/groovy","title":"Vert.x Web GraphQL","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_handler_setup\">Handler setup</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_graphiql_client\">GraphiQL client</a></li>\n<li><a href=\"#_enable_query_batching\">Enable query batching</a></li>\n</ul>\n</li>\n<li><a href=\"#_building_a_graphql_server\">Building a GraphQL server</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_fetching_data_with_callback_based_apis\">Fetching data with callback-based APIs</a></li>\n<li><a href=\"#_providing_data_fetchers_with_some_context\">Providing data fetchers with some context</a></li>\n<li><a href=\"#_json_data_results\">JSON data results</a></li>\n<li><a href=\"#_using_dataloaders\">Using dataloaders</a></li>\n<li><a href=\"#_apollo_websocketlink\">Apollo WebSocketLink</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Web GraphQL</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL extends Vert.x Web with the <a href=\"https://www.graphql-java.com\">GraphQL-Java</a> library so that you can build a GraphQL server.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\nThis is the reference documentation for Vert.x Web GraphQL.\nIt is highly recommended to get familiar with the GraphQL-Java API first.\nYou may start by reading the <a href=\"https://www.graphql-java.com/documentation/v13/\">GraphQL-Java documentation</a>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nThis module has <em>Tech Preview</em> status, this means the API can change between versions.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use this module, add the following to the <em>dependencies</em> section of your Maven POM file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-graphql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or, if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-web-graphql:3.9.0'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handler_setup\"><a class=\"anchor\" href=\"#_handler_setup\"></a>Handler setup</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Create a Vert.x Web <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html\">Route</a></code> and a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> for it:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> graphQL = <span class=\"hljs-keyword\">this</span>.setupGraphQLJava()\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(GraphQLHandler.create(graphQL))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The handler serves both <code>GET</code> and <code>POST</code> requests.\nHowever you can restrict the service to one type of HTTP method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> graphQL = <span class=\"hljs-keyword\">this</span>.setupGraphQLJava()\n\nrouter.post(<span class=\"hljs-string\">\"/graphql\"</span>).handler(GraphQLHandler.create(graphQL))</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\nThe <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> does not require a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> to read <code>POST</code> requests content.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_graphiql_client\"><a class=\"anchor\" href=\"#_graphiql_client\"></a>GraphiQL client</h3>\n<div class=\"paragraph\">\n<p>As you are building your application, testing your GraphQL queries in <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> can be handy.</p>\n</div>\n<div class=\"paragraph\">\n<p>To do so, create a route for GraphiQL resources and a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> for them:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> options = [\n<span class=\"hljs-symbol\">  enabled:</span><span class=\"hljs-literal\">true</span>\n]\n\nrouter.route(<span class=\"hljs-string\">\"/graphiql/*\"</span>).handler(GraphiQLHandler.create(options))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then browse to <a href=\"http://localhost:8080/graphiql/\" class=\"bare\">http://localhost:8080/graphiql/</a>.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nThe GraphiQL user interface is disabled by default for security reasons.\nThis is why you must configure the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> to enable it.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\nGraphiQL is enabled automatically when Vert.x Web runs in development mode.\nTo switch the development mode on, use the <code>VERTXWEB_ENVIRONMENT</code> environment variable or <code>vertxweb.environment</code> system property and set it to <code>dev</code>.\nIn this case, create the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> without changing the <code>enabled</code> property.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If your application is protected by authentication, you can customize the headers sent by GraphiQL dynamically:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">graphiQLHandler.graphiQLRequestHeaders({ rc -&gt;\n  <span class=\"hljs-keyword\">def</span> token = rc.get(<span class=\"hljs-string\">\"token\"</span>)\n  <span class=\"hljs-keyword\">return</span> MultiMap.caseInsensitiveMultiMap().add(io.vertx.core.http.HttpHeaders.AUTHORIZATION, <span class=\"hljs-string\">\"Bearer ${token}\"</span>)\n})\n\nrouter.route(<span class=\"hljs-string\">\"/graphiql/*\"</span>).handler(graphiQLHandler)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Please refer to the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> documentation for further details.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_enable_query_batching\"><a class=\"anchor\" href=\"#_enable_query_batching\"></a>Enable query batching</h3>\n<div class=\"paragraph\">\n<p>Query batching consists in posting an array instead of a single object to the GraphQL endpoint.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL can handle such requests but by default the feature is disabled.\nTo enable it, create the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> with options:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> options = [\n<span class=\"hljs-symbol\">  requestBatchingEnabled:</span><span class=\"hljs-literal\">true</span>\n]\n\n<span class=\"hljs-keyword\">def</span> handler = GraphQLHandler.create(graphQL, options)</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_building_a_graphql_server\"><a class=\"anchor\" href=\"#_building_a_graphql_server\"></a>Building a GraphQL server</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The GraphQL-Java API is very well suited for the asynchronous world: the asynchronous execution strategy is the default for queries (serial asynchronous for mutations).</p>\n</div>\n<div class=\"paragraph\">\n<p>To <a href=\"https://vertx.io/docs/vertx-core/java/#golden_rule\">avoid blocking the event loop</a>, all you have to do is implement <a href=\"https://www.graphql-java.com/documentation/v13/data-fetching/\">data fetchers</a> that return a <code>CompletionStage</code> instead of the result directly.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> dataFetcher = { environment -&gt;\n\n  <span class=\"hljs-keyword\">def</span> completableFuture = <span class=\"hljs-keyword\">new</span> java.util.concurrent.CompletableFuture()\n\n  <span class=\"hljs-keyword\">this</span>.retrieveLinksFromBackend(environment, { ar -&gt;\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      completableFuture.complete(ar.result())\n    } <span class=\"hljs-keyword\">else</span> {\n      completableFuture.completeExceptionally(ar.cause())\n    }\n  })\n\n  <span class=\"hljs-keyword\">return</span> completableFuture\n}\n\n<span class=\"hljs-keyword\">def</span> runtimeWiring = graphql.schema.idl.RuntimeWiring.newRuntimeWiring().type(<span class=\"hljs-string\">\"Query\"</span>, { builder -&gt;\n  builder.dataFetcher(<span class=\"hljs-string\">\"allLinks\"</span>, dataFetcher)\n}).build()</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_fetching_data_with_callback_based_apis\"><a class=\"anchor\" href=\"#_fetching_data_with_callback_based_apis\"></a>Fetching data with callback-based APIs</h3>\n<div class=\"paragraph\">\n<p>Implementing a data fetcher that returns a <code>CompletionStage</code> is not a complex task.\nBut when you work with Vert.x callback-based APIs, it requires a bit of boilerplate.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is where the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/VertxDataFetcher.html\">VertxDataFetcher</a></code> can help:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> dataFetcher = <span class=\"hljs-keyword\">new</span> io.vertx.ext.web.handler.graphql.VertxDataFetcher({ environment, future -&gt;\n\n  <span class=\"hljs-keyword\">this</span>.retrieveLinksFromBackend(environment, future)\n\n})\n\n<span class=\"hljs-keyword\">def</span> runtimeWiring = graphql.schema.idl.RuntimeWiring.newRuntimeWiring().type(<span class=\"hljs-string\">\"Query\"</span>, { builder -&gt;\n  builder.dataFetcher(<span class=\"hljs-string\">\"allLinks\"</span>, dataFetcher)\n}).build()</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_providing_data_fetchers_with_some_context\"><a class=\"anchor\" href=\"#_providing_data_fetchers_with_some_context\"></a>Providing data fetchers with some context</h3>\n<div class=\"paragraph\">\n<p>Very often, the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> will be declared after other route handlers.\nFor example, you could protect your application with authentication.</p>\n</div>\n<div class=\"paragraph\">\n<p>In this case, it is likely that your data fetchers will need to know which user is logged-in to narrow down the results.\nLet&#8217;s say your authentication layer stores a <code>User</code> object in the <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You may retrieve this object by inspecting the <code>DataFetchingEnvironment</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> dataFetcher = <span class=\"hljs-keyword\">new</span> io.vertx.ext.web.handler.graphql.VertxDataFetcher({ environment, future -&gt;\n\n  <span class=\"hljs-keyword\">def</span> routingContext = environment.getContext()\n\n  <span class=\"hljs-keyword\">def</span> user = routingContext.get(<span class=\"hljs-string\">\"user\"</span>)\n\n  <span class=\"hljs-keyword\">this</span>.retrieveLinksPostedBy(user, future)\n\n})</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nThe routing context is available with any kind of data fetchers, not just <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/VertxDataFetcher.html\">VertxDataFetcher</a></code>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If you prefer not to expose the routing context to your data fetchers, configure the GraphQL handler to customize the context object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> dataFetcher = <span class=\"hljs-keyword\">new</span> io.vertx.ext.web.handler.graphql.VertxDataFetcher({ environment, future -&gt;\n\n  <span class=\"hljs-comment\">// User as custom context object</span>\n  <span class=\"hljs-keyword\">def</span> user = environment.getContext()\n\n  <span class=\"hljs-keyword\">this</span>.retrieveLinksPostedBy(user, future)\n\n})\n\n<span class=\"hljs-keyword\">def</span> graphQL = <span class=\"hljs-keyword\">this</span>.setupGraphQLJava(dataFetcher)\n\n<span class=\"hljs-comment\">// Customize the query context object when setting up the handler</span>\n<span class=\"hljs-keyword\">def</span> handler = GraphQLHandler.create(graphQL).queryContext({ routingContext -&gt;\n\n  <span class=\"hljs-keyword\">return</span> routingContext.get(<span class=\"hljs-string\">\"user\"</span>)\n\n})\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(handler)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_data_results\"><a class=\"anchor\" href=\"#_json_data_results\"></a>JSON data results</h3>\n<div class=\"paragraph\">\n<p>The default GraphQL data fetcher is <code>PropertyDataFetcher</code>.\nAs a consequence, it will be able to read the fields of your domain objects without further configuration.</p>\n</div>\n<div class=\"paragraph\">\n<p>Nevertheless, some Vert.x data clients return <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> and <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> results.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t need (or don&#8217;t wish to) use a domain object layer, you can configure GraphQL-Java to use <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> instead:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> builder = graphql.schema.idl.RuntimeWiring.newRuntimeWiring()\n\nbuilder.wiringFactory(<span class=\"hljs-keyword\">new</span> graphql.schema.idl.WiringFactory())</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> wraps a <code>PropertyDataFetcher</code> so you can still use it with domain objects.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_dataloaders\"><a class=\"anchor\" href=\"#_using_dataloaders\"></a>Using dataloaders</h3>\n<div class=\"paragraph\">\n<p>Dataloaders help you to load data efficiently by batching fetch requests and caching results.</p>\n</div>\n<div class=\"paragraph\">\n<p>First, create a batch loader:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> linksBatchLoader = { keys, environment -&gt;\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.retrieveLinksFromBackend(keys, environment)\n\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\nIf you work with Vert.x callback-based APIs, you may use a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/VertxBatchLoader.html\">VertxBatchLoader</a></code> or a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/VertxMappedBatchLoader.html\">VertxMappedBatchLoader</a></code> to simplify your code.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Then, configure the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> to create a <code>DataLoaderRegistry</code> for each request:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Code not translatable</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_apollo_websocketlink\"><a class=\"anchor\" href=\"#_apollo_websocketlink\"></a>Apollo WebSocketLink</h3>\n<div class=\"paragraph\">\n<p>You can use an <a href=\"https://www.apollographql.com/docs/link/links/ws/\">Apollo WebSocketLink</a> which connects over a websocket.\nThis is specially useful if you want to add subscriptions to your GraphQL schema, but you can also use the websocket for queries and mutations.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> graphQL = <span class=\"hljs-keyword\">this</span>.setupGraphQLJava()\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(ApolloWSHandler.create(graphQL))</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\nTo support the <code>graphql-ws</code> websocket subprotocol, it has to be added to the server configuration:\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> httpServerOptions = [\n<span class=\"hljs-symbol\">  webSocketSubProtocols:</span>[\n    <span class=\"hljs-string\">\"graphql-ws\"</span>\n  ]\n]\nvertx.createHttpServer(httpServerOptions).requestHandler(router).listen(<span class=\"hljs-number\">8080</span>)</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nIf you want to support a WebSocketLink and a HttpLink in the same path, you can add the ApolloWSHandler in first place and then the GraphQLHandler.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> graphQL = <span class=\"hljs-keyword\">this</span>.setupGraphQLJava()\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(ApolloWSHandler.create(graphQL))\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(GraphQLHandler.create(graphQL))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Here you can find how to configure the Apollo SubscriptionClient: <a href=\"https://github.com/apollographql/subscriptions-transport-ws\" class=\"bare\">https://github.com/apollographql/subscriptions-transport-ws</a></p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\nA subscription <code>DataFetcher</code> has to return a <code>org.reactivestreams.Publisher</code> instance.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>","version":"3.9.0"},"__N_SSG":true}