{"pageProps":{"slug":"vertx-web-graphql/java","title":"Vert.x Web GraphQL","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">由此开始</a></li>\n<li><a href=\"#_getting_started\">设置处理器</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_http\">HTTP</a></li>\n<li><a href=\"#_graphiql_ide\">GraphiQL IDE</a></li>\n<li><a href=\"#_apollo_websocketlink\">Apollo WebSocketLink</a></li>\n</ul>\n</li>\n<li><a href=\"#_fetching_data\">获取数据</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_working_with_callback_based_apis\">Working with callback-based APIs</a></li>\n<li><a href=\"#_working_with_vert_x_futures\">Working with Vert.x Futures</a></li>\n<li><a href=\"#_providing_data_fetchers_with_some_context\">Providing data fetchers with some context</a></li>\n<li><a href=\"#_json_data_results\">JSON data results</a></li>\n<li><a href=\"#_batch_loading\">Batch loading</a></li>\n<li><a href=\"#_file_uploads\">File uploads</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxjava_2_api\">RxJava 2 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_setting_up_with_an_rxified_router\">Setting up with an Rxified router</a></li>\n<li><a href=\"#_working_with_vert_x_rxified_apis\">Working with Vert.x Rxified APIs</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Web GraphQL</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL 用 <a href=\"https://www.graphql-java.com\">GraphQL-Java</a> 库扩展了 Vert.x Web 以便您创建一个 GraphQL 的服务器。</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n这是一个 Vert.x Web GraphQL 的参考文档。\n强烈建议您先熟悉一下 GraphQL-Java API。\n您可以从此处开始阅读 <a href=\"https://www.graphql-java.com/documentation/v16/\">GraphQL-Java documentation</a>。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>由此开始</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>若要使用该模块，请在您的 Maven POM 文件的 <em>dependencies</em> 部分中添加以下依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-graphql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或您使用的是Gradle：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-web-graphql:4.0.3'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>设置处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_http\"><a class=\"anchor\" href=\"#_http\"></a>HTTP</h3>\n<div class=\"paragraph\">\n<p>为此您需要创建 Vert.x Web <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html\">Route</a></code> 以及 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该处理器可处理 <code>GET</code> 以及 <code>POST</code> 请求。\n然而，您可限制处理器仅处理其中一种 HTTP 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.post(<span class=\"hljs-string\">\"/graphql\"</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> 需要 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 以读取 <code>POST</code> 请求内容。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_query_batching\"><a class=\"anchor\" href=\"#_query_batching\"></a>查询批处理</h4>\n<div class=\"paragraph\">\n<p>查询批处理将数组而非单个对象通过 post 方法发送到 GraphQL 端点（endpoint）。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL 可以处理此类请求但该特性默认是被禁用的。\n如要启用，需创建带参数的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQLHandlerOptions options = <span class=\"hljs-keyword\">new</span> GraphQLHandlerOptions()\n  .setRequestBatchingEnabled(<span class=\"hljs-keyword\">true</span>);\n\nGraphQLHandler handler = GraphQLHandler.create(graphQL, options);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_graphiql_ide\"><a class=\"anchor\" href=\"#_graphiql_ide\"></a>GraphiQL IDE</h3>\n<div class=\"paragraph\">\n<p>在构建应用程序时，可以在 <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> 中很方便地测试您的 GraphQL 查询。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，您需要为 GraphiQL 资源创建一个路由（route）及相应的处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphiQLHandlerOptions options = <span class=\"hljs-keyword\">new</span> GraphiQLHandlerOptions()\n  .setEnabled(<span class=\"hljs-keyword\">true</span>);\n\nrouter.route(<span class=\"hljs-string\">\"/graphiql/*\"</span>).handler(GraphiQLHandler.create(options));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>随后浏览以下地址 <a href=\"http://localhost:8080/graphiql/。\" class=\"bare\">http://localhost:8080/graphiql/。</a></p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n出于安全原因，默认情况下GraphiQL用户界面是禁用的。\n这就是为什么必需配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> 以启用它的原因。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n当Vert.x Web在开发模式下运行时，将自动启用GraphiQL。\n要打开开发模式，请使用 <code>VERTXWEB_ENVIRONMENT</code> 环境变量或 <code>vertxweb.environment</code> 系统属性并将其设置为 <code>dev</code> 。\n在这种情况下，创建 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> 时， <code>options</code> 无需设置为 <code>enabled</code> 属性。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果您的应用程序受身份验证保护，则可以动态自定义 GraphiQL 发送的标头（headers）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">graphiQLHandler.graphiQLRequestHeaders(rc -&gt; {\n  String token = rc.get(<span class=\"hljs-string\">\"token\"</span>);\n  <span class=\"hljs-keyword\">return</span> MultiMap.caseInsensitiveMultiMap().add(<span class=\"hljs-string\">\"Authorization\"</span>, <span class=\"hljs-string\">\"Bearer \"</span> + token);\n});\n\nrouter.route(<span class=\"hljs-string\">\"/graphiql/*\"</span>).handler(graphiQLHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请参考 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> 文档以获取更多详细信息。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_apollo_websocketlink\"><a class=\"anchor\" href=\"#_apollo_websocketlink\"></a>Apollo WebSocketLink</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <a href=\"https://www.apollographql.com/docs/link/links/ws/\">Apollo WebSocketLink</a> 连接 websocket。\n如果要订阅 GraphQL schema，这将特别有效，但您亦可以使用 websocket 查询和变异。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(ApolloWSHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n想要支持 <code>graphql-ws</code> websocket 子协议，必需在服务器配置中添加：\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerOptions httpServerOptions = <span class=\"hljs-keyword\">new</span> HttpServerOptions()\n  .addWebSocketSubProtocol(<span class=\"hljs-string\">\"graphql-ws\"</span>);\nvertx.createHttpServer(httpServerOptions)\n  .requestHandler(router)\n  .listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果要在同一路径中支持 WebSocketLink 和 HttpLink ，您可先添加 ApolloWSHandler ，然后再添加 GraphQLHandler 。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(ApolloWSHandler.create(graphQL));\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可在此处找到配置 Apollo 订阅客户端（SubscriptionClient）的方法：https://github.com/apollographql/subscriptions-transport-ws</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n一个 <code>DataFetcher</code> 订阅必需返回一个 <code>org.reactivestreams.Publisher</code> 实例。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_fetching_data\"><a class=\"anchor\" href=\"#_fetching_data\"></a>获取数据</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The GraphQL-Java API is very well suited for the asynchronous world: the asynchronous execution strategy is the default for queries (serial asynchronous for mutations).</p>\n</div>\n<div class=\"paragraph\">\n<p>To <a href=\"https://vertx.io/docs/vertx-core/java/#golden_rule\">avoid blocking the event loop</a>, all you have to do is implement <a href=\"https://www.graphql-java.com/documentation/v16/data-fetching/\">data fetchers</a> that return a <code>CompletionStage</code> instead of the result directly.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DataFetcher&lt;CompletionStage&lt;List&lt;Link&gt;&gt;&gt; dataFetcher = environment -&gt; {\n\n  CompletableFuture&lt;List&lt;Link&gt;&gt; completableFuture = <span class=\"hljs-keyword\">new</span> CompletableFuture&lt;&gt;();\n\n  retrieveLinksFromBackend(environment, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      completableFuture.complete(ar.result());\n    } <span class=\"hljs-keyword\">else</span> {\n      completableFuture.completeExceptionally(ar.cause());\n    }\n  });\n\n  <span class=\"hljs-keyword\">return</span> completableFuture;\n};\n\nRuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">\"Query\"</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">\"allLinks\"</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_callback_based_apis\"><a class=\"anchor\" href=\"#_working_with_callback_based_apis\"></a>Working with callback-based APIs</h3>\n<div class=\"paragraph\">\n<p>Implementing a data fetcher that returns a <code>CompletionStage</code> is not a complex task.\nBut when you work with Vert.x callback-based APIs, it requires a bit of boilerplate.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is where the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code> can help:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((env, promise) -&gt; {\n  retrieveLinksFromBackend(env, promise);\n});\n\nRuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">\"Query\"</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">\"allLinks\"</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_vert_x_futures\"><a class=\"anchor\" href=\"#_working_with_vert_x_futures\"></a>Working with Vert.x Futures</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code> can also help with futurized APIs:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create(environment -&gt; {\n  Future&lt;List&lt;Link&gt;&gt; future = retrieveLinksFromBackend(environment);\n  <span class=\"hljs-keyword\">return</span> future;\n});\n\nRuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">\"Query\"</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">\"allLinks\"</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_providing_data_fetchers_with_some_context\"><a class=\"anchor\" href=\"#_providing_data_fetchers_with_some_context\"></a>Providing data fetchers with some context</h3>\n<div class=\"paragraph\">\n<p>Very often, the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> will be declared after other route handlers.\nFor example, you could protect your application with authentication.</p>\n</div>\n<div class=\"paragraph\">\n<p>In this case, it is likely that your data fetchers will need to know which user is logged-in to narrow down the results.\nLet&#8217;s say your authentication layer stores a <code>User</code> object in the <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You may retrieve this object by inspecting the <code>DataFetchingEnvironment</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((environment, promise) -&gt; {\n\n  RoutingContext routingContext = environment.getContext();\n\n  User user = routingContext.get(<span class=\"hljs-string\">\"user\"</span>);\n\n  retrieveLinksPostedBy(user, promise);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nThe routing context is available with any kind of data fetchers, not just <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If you prefer not to expose the routing context to your data fetchers, configure the GraphQL handler to customize the context object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((environment, promise) -&gt; {\n\n  <span class=\"hljs-comment\">// User as custom context object</span>\n  User user = environment.getContext();\n\n  retrieveLinksPostedBy(user, promise);\n\n});\n\nGraphQL graphQL = setupGraphQLJava(dataFetcher);\n\n<span class=\"hljs-comment\">// Customize the query context object when setting up the handler</span>\nGraphQLHandler handler = GraphQLHandler.create(graphQL).queryContext(routingContext -&gt; {\n\n  <span class=\"hljs-keyword\">return</span> routingContext.get(<span class=\"hljs-string\">\"user\"</span>);\n\n});\n\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(handler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_data_results\"><a class=\"anchor\" href=\"#_json_data_results\"></a>JSON data results</h3>\n<div class=\"paragraph\">\n<p>The default GraphQL data fetcher is <code>PropertyDataFetcher</code>.\nAs a consequence, it will be able to read the fields of your domain objects without further configuration.</p>\n</div>\n<div class=\"paragraph\">\n<p>Nevertheless, some Vert.x data clients return <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> and <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> results.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t need (or don&#8217;t wish to) use a domain object layer, you can configure GraphQL-Java to use <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> instead:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RuntimeWiring.Builder builder = RuntimeWiring.newRuntimeWiring();\n\nbuilder.wiringFactory(<span class=\"hljs-keyword\">new</span> WiringFactory() {\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataFetcher&lt;Object&gt; <span class=\"hljs-title\">getDefaultDataFetcher</span><span class=\"hljs-params\">(FieldWiringEnvironment environment)</span> </span>{\n\n    <span class=\"hljs-keyword\">return</span> VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName());\n\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> wraps a <code>PropertyDataFetcher</code> so you can still use it with domain objects.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batch_loading\"><a class=\"anchor\" href=\"#_batch_loading\"></a>Batch loading</h3>\n<div class=\"paragraph\">\n<p>Dataloaders help you to load data efficiently by batching fetch requests and caching results.</p>\n</div>\n<div class=\"paragraph\">\n<p>First, create a batch loader:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">BatchLoaderWithContext&lt;String, Link&gt; linksBatchLoader = <span class=\"hljs-keyword\">this</span>::retrieveLinksFromBackend;</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\nIf you work with Vert.x callback-based APIs, you may use a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/dataloader/VertxBatchLoader.html\">VertxBatchLoader</a></code>\nor a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/dataloader/VertxMappedBatchLoader.html\">VertxMappedBatchLoader</a></code> to simplify your code.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Then, configure the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> to create a <code>DataLoaderRegistry</code> for each request:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQLHandler handler = GraphQLHandler.create(graphQL).dataLoaderRegistry(rc -&gt; {\n\n  DataLoader&lt;String, Link&gt; linkDataLoader = DataLoader.newDataLoader(linksBatchLoader);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> DataLoaderRegistry().register(<span class=\"hljs-string\">\"link\"</span>, linkDataLoader);\n\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_file_uploads\"><a class=\"anchor\" href=\"#_file_uploads\"></a>File uploads</h3>\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/jaydenseric/graphql-multipart-request-spec\">GraphQL multipart request</a> is an interoperable multipart form field structure for <code>GraphQL</code> requests.\nBy enabling this functionality, GraphQL clients will be able to upload files using a single mutation call.\nAll the server-side file handling will be abstracted by the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To enable it, create a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> with the requestMultipartEnabled configuration set to true and add the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> to the router.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQLHandler graphQLHandler = GraphQLHandler.create(\n  setupGraphQLJava(),\n  <span class=\"hljs-keyword\">new</span> GraphQLHandlerOptions().setRequestMultipartEnabled(<span class=\"hljs-keyword\">true</span>)\n);\n\nRouter router = Router.router(vertx);\n\nrouter.route().handler(BodyHandler.create());\nrouter.route(<span class=\"hljs-string\">\"/graphql\"</span>).handler(graphQLHandler);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\nIf the router does not have a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code>, the multipart request parser will not be able to handle the GraphQL mutation call.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Finally, create the <code>Upload</code> scalar and set it to the <code>RuntimeWiring</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring().scalar(UploadScalar.build()).build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>FileUpload</code> instance can be accessed using the <code>DataFetchingEnvironment::getArgument</code> method.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileUpload file = environment.getArgument(<span class=\"hljs-string\">\"myFile\"</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_2_api\"><a class=\"anchor\" href=\"#_rxjava_2_api\"></a>RxJava 2 API</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_setting_up_with_an_rxified_router\"><a class=\"anchor\" href=\"#_setting_up_with_an_rxified_router\"></a>Setting up with an Rxified router</h3>\n<div class=\"paragraph\">\n<p>To handle GraphQL requests on a Rxified <code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/Route.html\">Route</a></code>, make sure to import the <code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> class.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_vert_x_rxified_apis\"><a class=\"anchor\" href=\"#_working_with_vert_x_rxified_apis\"></a>Working with Vert.x Rxified APIs</h3>\n<div class=\"paragraph\">\n<p>GraphQL-Java expects <code>CompletionStage</code> for asynchronous results in data fetchers and batch loaders.</p>\n</div>\n<div class=\"paragraph\">\n<p>Therefore, if you work with the Vert.x Rxified APIs (e.g. the <a href=\"https://vertx.io/docs/vertx-web-client/java/#_rxjava_2_api\">Web Client</a> or the <a href=\"https://vertx.io/docs/vertx-cassandra-client/java/#_rxjava_2_api\">Cassandra Client</a>), you will have to adapt the <code>Single</code> and <code>Maybe</code> objects.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code>RxJava2Jdk8Interop</code> library provides the tooling to do just that.\nAdd the following to the <em>dependencies</em> section of your Maven build file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.github.akarnokd<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>rxjava2-jdk8-interop<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.3.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'com.github.akarnokd:rxjava2-jdk8-interop:0.3.5'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then you can create a data fetcher from a <code>Single</code> result:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; data = loadDataFromBackend();\nDataFetcher&lt;CompletionStage&lt;String&gt;&gt; fetcher = environment -&gt; {\n <span class=\"hljs-keyword\">return</span> data.to(SingleInterop.get());\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For <code>Maybe</code> results, use <code>MaybeInterop</code>.</p>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}