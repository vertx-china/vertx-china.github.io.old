{"pageProps":{"slug":"4.2.2/vertx-opentracing/java","title":"Vertx OpenTracing","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_tracing_policy\">追踪策略</a></li>\n<li><a href=\"#_http_tracing\">HTTP tracing</a></li>\n<li><a href=\"#_eventbus_tracing\">事件总线追踪</a></li>\n<li><a href=\"#_obtain_current_span\">获取当前的 Span</a></li>\n<li><a href=\"#_coroutines_support\">协程支持</a></li>\n</ul>\n</div>","contents":"<h1>Vertx OpenTracing</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 借助 Jaeger 的支持集成了 OpenTracing 。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 Jaeger 客户端的下列配置项来配置 Vert.x\n<a href=\"https://github.com/jaegertracing/jaeger-client-java/blob/master/jaeger-core/README.md#configuration-via-environment\">环境</a>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> Vertx.vertx(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VertxOptions</span>()\n  .setTracingOptions(\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenTracingOptions</span>()\n  )\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以传递一个自定义的 <code>Tracer</code> 来更好地调控\n配置项</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> Vertx.vertx(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VertxOptions</span>()\n  .setTracingOptions(\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenTracingOptions</span>(tracer)\n  )\n);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_policy\"><a class=\"anchor\" href=\"#_tracing_policy\"></a>追踪策略</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当追踪功能启用时, 一个组件的行为由追踪策略来定义：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>: 该组件上报活跃trace中的span</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code>: 该组件上报活跃trace中的span或者创建一个新的活跃trace</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#IGNORE\">IGNORE</a></code>: 该组件不会参与任何的trace</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>tracing 策略通常可在组件选项里配置</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_http_tracing\"><a class=\"anchor\" href=\"#_http_tracing\"></a>HTTP tracing</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x HTTP 服务端和客户端根据 HTTP 请求上报跨度（span）：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>operationName</code>: 当前HTTP方法</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>http.method</code>: HTTP 请求方法</p>\n</li>\n<li>\n<p><code>http.url</code>: 请求 URL</p>\n</li>\n<li>\n<p><code>http.status_code</code>: HTTP 状态码</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>HTTP服务端默认的追踪策略是 <code>ALWAYS</code>,\n您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 来调配该策略。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerOptions</span>()\n  .setTracingPolicy(TracingPolicy.IGNORE)\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>HTTP 客户端默认的追踪策略是 <code>PROPAGATE</code> ,\n您可以使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClientOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 来调配该策略。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpClientOptions</span>()\n  .setTracingPolicy(TracingPolicy.IGNORE)\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>要启动客户端调用的追踪，\n您需要先创建它并使得 Vert.x 通过使用 OpenTracingUtil.setSpan 留意到这一点：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Span</span> <span class=\"hljs-variable\">span</span> <span class=\"hljs-operator\">=</span> tracer.buildSpan(<span class=\"hljs-string\">&quot;my-operation&quot;</span>)\n  .withTag(<span class=\"hljs-string\">&quot;some-key&quot;</span>, <span class=\"hljs-string\">&quot;some-value&quot;</span>)\n  .start();\nOpenTracingUtil.setSpan(span);\n<span class=\"hljs-comment\">// 做一些事，例如客户端发送请求</span>\nspan.finish();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在包含有两个 Vert.x 服务的 HTTP 场景中，将会在客户端创建一个跨度，\n而后追踪上下文将在服务器端传播，另一个跨度将添加到追踪中。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_eventbus_tracing\"><a class=\"anchor\" href=\"#_eventbus_tracing\"></a>事件总线追踪</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 事件总线围绕消息交换报告跨度。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认的追踪策略是 <code>PROPAGATE</code> ,\n您可以使用 <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 来调配该策略.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">DeliveryOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeliveryOptions</span>().setTracingPolicy(TracingPolicy.ALWAYS);\nvertx.eventBus().send(<span class=\"hljs-string\">&quot;the-address&quot;</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>, options);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_obtain_current_span\"><a class=\"anchor\" href=\"#_obtain_current_span\"></a>获取当前的 Span</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 使用本地上下文来保存当前的 <code>Span</code> 对象。\n为了获取当前的 <code>Span</code> 实例，请使用 <code>OpenTracingUtil.getSpan()</code> 方法</p>\n</div>\n<div class=\"paragraph\">\n<p>这个方法只能在 Vert.x 的线程上使用 (线程必须是 <code>VertxThread</code> 的实例)。\n在一个不是 Vert.x 的线程上调用该方法是不符合设计预期的，因此该方法会返回 null。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_coroutines_support\"><a class=\"anchor\" href=\"#_coroutines_support\"></a>协程支持</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>现在并没有提供对协程的直接支持，但是通过极小的改动就可以做到。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了支持协程，您需要做以下几步。</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>使用 <code>CoroutineVerticle</code>。</p>\n</li>\n<li>\n<p>将您的 <strong>每个路由处理器</strong> 转换为协程。</p>\n</li>\n<li>\n<p>使用 CoroutineContext 来保存 <code>Tracer</code> 和当前的 <code>Span</code> 对象</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>示例代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TracedVerticle</span></span>(<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> tracer: Tracer): CoroutineVerticle() {\n   <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span></span> {\n       <span class=\"hljs-keyword\">val</span> router = Router.router(vertx)\n\n       router.route(<span class=\"hljs-string\">&quot;/hello1&quot;</span>)\n           .method(HttpMethod.GET)\n           .coroutineHandler { ctx -&gt;                          <span class=\"hljs-comment\">// (1)</span>\n               launch { println(<span class=\"hljs-string\">&quot;Hello to Console&quot;</span>) }\n               ctx.end(<span class=\"hljs-string\">&quot;Hello from coroutine handler&quot;</span>)\n           }\n\n       router.route(<span class=\"hljs-string\">&quot;/hello2&quot;</span>)\n           .method(HttpMethod.GET)\n           .coroutineHandler(::nonSuspendHandler)              <span class=\"hljs-comment\">// (2)</span>\n\n       vertx.createHttpServer()\n           .requestHandler(router)\n           .listen(<span class=\"hljs-number\">8080</span>)\n           .await()\n   }\n\n   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">nonSuspendHandler</span><span class=\"hljs-params\">(ctx: <span class=\"hljs-type\">RoutingContext</span>)</span></span> {\n       ctx.end(<span class=\"hljs-string\">&quot;Hello from usual handler&quot;</span>)\n   }\n\n   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> Route.<span class=\"hljs-title\">coroutineHandler</span><span class=\"hljs-params\">(handler: <span class=\"hljs-type\">Handler</span>&lt;<span class=\"hljs-type\">RoutingContext</span>&gt;)</span></span>: Route = <span class=\"hljs-comment\">// (3)</span>\n       <span class=\"hljs-keyword\">this</span>.coroutineHandler(handler::handle)\n\n   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> Route.<span class=\"hljs-title\">coroutineHandler</span><span class=\"hljs-params\">(                                           <span class=\"hljs-comment\">// (4)</span>\n       handler: <span class=\"hljs-type\">suspend</span> (<span class=\"hljs-type\">RoutingContext</span>) -&gt; (<span class=\"hljs-type\">Unit</span>)\n   )</span></span>: Route = handler { ctx -&gt;\n       <span class=\"hljs-keyword\">val</span> span: Span = OpenTracingUtil.getSpan()                                <span class=\"hljs-comment\">// (5)</span>\n       launch(ctx.vertx().dispatcher() + SpanElement(tracer, span)) {            <span class=\"hljs-comment\">// (6)</span>\n           <span class=\"hljs-keyword\">val</span> spanElem = coroutineContext[SpanElement]                          <span class=\"hljs-comment\">// (7)</span>\n           <span class=\"hljs-keyword\">if</span> (spanElem == <span class=\"hljs-literal\">null</span>) {\n               handler(ctx)\n           } <span class=\"hljs-keyword\">else</span> {\n               <span class=\"hljs-keyword\">val</span> span = spanElem.span\n               <span class=\"hljs-keyword\">val</span> tracer = spanElem.tracer\n               <span class=\"hljs-keyword\">val</span> childSpan = span                                                <span class=\"hljs-comment\">// (8)</span>\n               <span class=\"hljs-keyword\">try</span> {\n                   withContext(SpanElement(tracer, childSpan)) { handler(ctx) }    <span class=\"hljs-comment\">// (9)</span>\n               } <span class=\"hljs-keyword\">finally</span> {\n                   <span class=\"hljs-comment\">// childSpan.finish()                                           // (10)</span>\n               }\n           }\n           <span class=\"hljs-comment\">// 或为了复用代码而创建一个帮助方法</span>\n           withContextTraced(coroutineContext) {\n               <span class=\"hljs-keyword\">try</span> {\n                   handler(ctx)\n               } <span class=\"hljs-keyword\">catch</span> (t: Throwable) {\n                   ctx.fail(t)\n               }\n           }\n       }\n   }\n}</code></pre>\n</div>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>使用 <code>coroutineHandler</code> 扩展方法来创建一个协程处理器。</p>\n</li>\n<li>\n<p>创建一个普通的异步处理器，并将其包装在一个协程中。</p>\n</li>\n<li>\n<p>使用扩展方法来讲 <code>Handler&lt;RoutingContext&gt;</code> 转化为一个可挂起的函数。</p>\n</li>\n<li>\n<p>声明一个用来在 Vert.x 的事件循环上创建并执行协程的扩展方法。</p>\n</li>\n<li>\n<p>自动从当前的 Vert.x 上下文中获取 <code>Span</code> 实例(该方法会自动这么做)。</p>\n</li>\n<li>\n<p>创建一个包装协程，并将当前的 <code>Span</code> 添加到 <code>CoroutineContext</code> 中。</p>\n</li>\n<li>\n<p>从协程上下文中恢复 <code>Span</code> 。</p>\n</li>\n<li>\n<p>复用 <code>span</code> 或使用 <code>tracer.buildSpan(\"\").asChildOf(span).start()</code> 方法创建一个新的 <code>Span</code>。</p>\n</li>\n<li>\n<p>将这个 <code>Span</code> 放入上下文中</p>\n</li>\n<li>\n<p>如果您创建了一个新的话，请终结掉之前的 <code>childSpan</code>。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>以下是一些有用的代码，您的实现可以参考：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">/**\n* 保存一个 tracer 和当前协程上下文中的 Span 的引用\n*/</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SpanElement</span></span>(<span class=\"hljs-keyword\">val</span> tracer: Tracer, <span class=\"hljs-keyword\">val</span> span: Span) :\n   ThreadContextElement&lt;Scope&gt;,\n   AbstractCoroutineContextElement(SpanElement) {\n\n   <span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> Key : CoroutineContext.Key&lt;SpanElement&gt;\n\n   <span class=\"hljs-comment\">/**\n   *  在协程挂起后，关闭 [Scope]\n   */</span>\n   <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">restoreThreadContext</span><span class=\"hljs-params\">(context: <span class=\"hljs-type\">CoroutineContext</span>, oldState: <span class=\"hljs-type\">Scope</span>)</span></span> {\n       oldState.close()\n   }\n\n   <span class=\"hljs-comment\">/**\n   * 当协程恢复后，创建新的 [Scope] ， scope 激活后可以提供 [span] 的实例\n   */</span>\n   <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">updateThreadContext</span><span class=\"hljs-params\">(context: <span class=\"hljs-type\">CoroutineContext</span>)</span></span>: Scope {\n       <span class=\"hljs-keyword\">return</span> tracer.activateSpan(span)\n   }\n}\n\n<span class=\"hljs-comment\">/**\n* 更高级的帮助代码，包含一些选项，并且展示了怎么使用 MDCContext 来将 Span 传递给 logger。\n*/</span>\n<span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-type\">&lt;T&gt;</span> <span class=\"hljs-title\">withContextTraced</span><span class=\"hljs-params\">(\n   context: <span class=\"hljs-type\">CoroutineContext</span>,\n   reuseParentSpan: <span class=\"hljs-type\">Boolean</span> = <span class=\"hljs-literal\">true</span>,\n   block: <span class=\"hljs-type\">suspend</span> <span class=\"hljs-type\">CoroutineScope</span>.() -&gt; <span class=\"hljs-type\">T</span>\n)</span></span>: T {\n   <span class=\"hljs-keyword\">return</span> coroutineScope {\n       <span class=\"hljs-keyword\">val</span> spanElem = <span class=\"hljs-keyword\">this</span>.coroutineContext[SpanElement]\n\n       <span class=\"hljs-keyword\">if</span> (spanElem == <span class=\"hljs-literal\">null</span>) {\n           logger.warn { <span class=\"hljs-string\">&quot;Calling &#x27;withTracer&#x27;, but no span found in context&quot;</span> }\n           withContext(context, block)\n       } <span class=\"hljs-keyword\">else</span> {\n           <span class=\"hljs-keyword\">val</span> childSpan = <span class=\"hljs-keyword\">if</span> (reuseParentSpan) spanElem.span\n           <span class=\"hljs-keyword\">else</span> spanElem.tracer.buildSpan(<span class=\"hljs-string\">&quot;&quot;</span>).asChildOf(spanElem.span).start()\n\n           <span class=\"hljs-keyword\">try</span> {\n               <span class=\"hljs-keyword\">val</span> mdcSpan = mapOf(MDC_SPAN_KEY to childSpan.toString())\n               withContext(context + SpanElement(spanElem.tracer, childSpan) + MDCContext(mdcSpan), block)\n           } <span class=\"hljs-keyword\">finally</span> {\n               <span class=\"hljs-keyword\">if</span> (!reuseParentSpan) childSpan.finish()\n           }\n       }\n   }\n}\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> MDC_SPAN_KEY = <span class=\"hljs-string\">&quot;request.span.id&quot;</span></code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.2.2"},"__N_SSG":true}