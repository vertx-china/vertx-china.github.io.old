{"pageProps":{"slug":"4.1.3/vertx-mssql-client/java","title":"响应式 MSSQL 客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_usage\">用法</a></li>\n<li><a href=\"#_getting_started\">由此开始</a></li>\n<li><a href=\"#_connecting_to_sql_server\">连接 SQL Server</a></li>\n<li><a href=\"#_configuration\">配置</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_object\">数据对象</a></li>\n<li><a href=\"#_connection_uri\">连接 URI</a></li>\n</ul>\n</li>\n<li><a href=\"#_connect_retries\">连接重试</a></li>\n<li><a href=\"#_running_queries\">执行查询</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_queries\">预查询</a></li>\n<li><a href=\"#_batches\">批处理</a></li>\n</ul>\n</li>\n<li><a href=\"#_working_with_identity_columns\">使用自增列</a></li>\n<li><a href=\"#_using_connections\">使用连接</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_a_connection\">获取一条连接</a></li>\n<li><a href=\"#_simplified_connection_api\">简化的连接API</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_transactions\">使用事务</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_transactions_with_connections\">连接中使用事务操作</a></li>\n<li><a href=\"#_simplified_transaction_api\">简化版事务API</a></li>\n</ul>\n</li>\n<li><a href=\"#_tracing_queries\">查询追踪</a></li>\n<li><a href=\"#_data_types_supported\">支持的数据类型</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_java_enum_types\">使用 Java 的 <code>枚举</code> 类型</a></li>\n<li><a href=\"#_handling_null\">处理空 <code>NULL</code></a></li>\n</ul>\n</li>\n<li><a href=\"#_collector_queries\">收集器查询</a></li>\n<li><a href=\"#_using_ssltls\">使用 SSL/TLS</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_encryption_level_negotiation\">加密等级协商</a></li>\n<li><a href=\"#_configuration_2\">配置</a></li>\n</ul>\n</li>\n<li><a href=\"#_advanced_pool_configuration\">高级连接池配置</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_server_load_balancing\">数据库服务负载均衡</a></li>\n<li><a href=\"#_pool_connection_initialization\">连接初始化</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>响应式 MSSQL 客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Reactive MSSQL 客户端是微软 SQL Server 的客户端，\n具有简单直接专注于可扩展性和低开销的 API。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>特性</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>事件驱动</p>\n</li>\n<li>\n<p>轻量级</p>\n</li>\n<li>\n<p>内置连接池</p>\n</li>\n<li>\n<p>支持内存直接映射到对象，避免了不必要的复制</p>\n</li>\n<li>\n<p>Java 8 Date 和 Time 支持</p>\n</li>\n<li>\n<p>RxJava API</p>\n</li>\n<li>\n<p>SSL/TLS</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><strong>暂不支持</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Prepared 查询缓存</p>\n</li>\n<li>\n<p>游标</p>\n</li>\n<li>\n<p>行流（Row streaming）</p>\n</li>\n<li>\n<p>不支持一些 <a href=\"https://github.com/eclipse-vertx/vertx-sql-client/issues/608#issuecomment-629390027\">数据类型</a></p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_usage\"><a class=\"anchor\" href=\"#_usage\"></a>用法</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用反应式 MSSQL 客户端，请将以下依赖项添加到构建描述文件中的 <em>dependencies</em> 部分：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mssql-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-mssql-client:4.1.3&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>由此开始</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>这是最简单的连接、查询和断开连接方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// 连接池参数</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 创建客户端池</span>\n<span class=\"hljs-type\">MSSQLPool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> MSSQLPool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// 一个简单的查询</span>\nclient\n  .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;julien&#x27;&quot;</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-type\">RowSet</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + result.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n\n  <span class=\"hljs-comment\">// 现在关闭池</span>\n  client.close();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_sql_server\"><a class=\"anchor\" href=\"#_connecting_to_sql_server\"></a>连接 SQL Server</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>大多数情况下，您将使用池连接到 MSSQL：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// 池参数</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 创建池化客户端</span>\n<span class=\"hljs-type\">MSSQLPool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> MSSQLPool.pool(connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>池化客户端使用连接池，任何操作都会从池中借用连接，\n随后执行操作，并最终执行完之后将其释放到池中。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 Vert.x 运行，您可以将它传递给您的 Vertx 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// 池选项</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-comment\">// 创建池化客户端</span>\n<span class=\"hljs-type\">MSSQLPool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> MSSQLPool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您不再需要它时，您需要释放池：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您需要在同一个连接上执行多个操作时，需要使用客户端\n<code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnection.html\">连接</a></code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以轻松地从池中获取一个：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// 池选项</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 创建池化客户端</span>\n<span class=\"hljs-type\">MSSQLPool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> MSSQLPool.pool(vertx, connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// 从池中获取连接</span>\nclient.getConnection().compose(conn -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;Got a connection from the pool&quot;</span>);\n\n  <span class=\"hljs-comment\">// 所有操作都在同一个连接上执行</span>\n  <span class=\"hljs-keyword\">return</span> conn\n    .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;julien&#x27;&quot;</span>)\n    .execute()\n    .compose(res -&gt; conn\n      .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;emad&#x27;&quot;</span>)\n      .execute())\n    .onComplete(ar -&gt; {\n      <span class=\"hljs-comment\">// 释放连接并将其归还给池</span>\n      conn.close();\n    });\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    System.out.println(<span class=\"hljs-string\">&quot;Done&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Something went wrong &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>完成连接后，您必须关闭它以将其释放到池中，以便可以重复使用。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>配置</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_data_object\"><a class=\"anchor\" href=\"#_data_object\"></a>数据对象</h3>\n<div class=\"paragraph\">\n<p>一种配置客户端的简单方法是指定一个 <code>MSSQLConnectOptions</code> 数据对象。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// 池参数</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 根据数据对象创建池</span>\n<span class=\"hljs-type\">MSSQLPool</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> MSSQLPool.pool(vertx, connectOptions, poolOptions);\n\npool.getConnection(ar -&gt; {\n  <span class=\"hljs-comment\">// 处理您的连接</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection_uri\"><a class=\"anchor\" href=\"#_connection_uri\"></a>连接 URI</h3>\n<div class=\"paragraph\">\n<p>一种替代用 <code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnectOptions.html\">MSSQLConnectOptions</a></code> 数据对象配置客户端的方案，便是您可使用连接 URI：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">connectionUri</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;sqlserver://dbuser:secretpassword@database.server.com:3211/mydb&quot;</span>;\n\n<span class=\"hljs-comment\">// 从连接 URI 创建池</span>\n<span class=\"hljs-type\">MSSQLPool</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> MSSQLPool.pool(connectionUri);\n\n<span class=\"hljs-comment\">// 从连接 URI 创建连接</span>\nMSSQLConnection.connect(vertx, connectionUri, res -&gt; {\n  <span class=\"hljs-comment\">// 处理您的连接</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>连接 URI 格式由客户端以惯用方式定义： <code>sqlserver://[user[:[password]]@]host[:port][/database][?attribute1=value1&amp;attribute2=value2&#8230;&#8203;]</code></p>\n</div>\n<div class=\"paragraph\">\n<p>当前，客户端在连接 uri 中支持以下参数关键字（key不区分大小写）：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>host</p>\n</li>\n<li>\n<p>port</p>\n</li>\n<li>\n<p>user</p>\n</li>\n<li>\n<p>password</p>\n</li>\n<li>\n<p>database</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connect_retries\"><a class=\"anchor\" href=\"#_connect_retries\"></a>连接重试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以配置客户端连接失败后重试。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options\n  .setReconnectAttempts(<span class=\"hljs-number\">2</span>)\n  .setReconnectInterval(<span class=\"hljs-number\">1000</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_queries\"><a class=\"anchor\" href=\"#_running_queries\"></a>执行查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您不需要事务或者只是执行一个单次查询操作，您可以直接在连接池里执行查询；\n连接池会使用某一条连接执行并给您返回结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>下边是如何执行一个简单的查询的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;julien&#x27;&quot;</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + result.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>预查询</h3>\n<div class=\"paragraph\">\n<p>执行预查询也是一样的操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>SQL字符通过位置引用实际的参数，并使用数据库的语法 `@1`, `@2`, etc…​</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=@p1&quot;</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + rows.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>查询相关的方法为 <em>SELECT</em> 类型的操作提供了异步的 <code><a href=\"../../apidocs/io/vertx/sqlclient/RowSet.html\">RowSet</a></code> 实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;SELECT first_name, last_name FROM users&quot;</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">&quot;User &quot;</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">&quot; &quot;</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者 <em>UPDATE</em>/<em>INSERT</em> 类型的查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO users (first_name, last_name) VALUES (@p1, @p2)&quot;</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>, <span class=\"hljs-string\">&quot;Viet&quot;</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Row对象（<code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code>）可以让您通过索引位置获取相应的数据</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">&quot;User &quot;</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">&quot; &quot;</span> + row.getString(<span class=\"hljs-number\">1</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者通过名称</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">&quot;User &quot;</span> + row.getString(<span class=\"hljs-string\">&quot;first_name&quot;</span>) + <span class=\"hljs-string\">&quot; &quot;</span> + row.getString(<span class=\"hljs-string\">&quot;last_name&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端在此处没有做特殊处理，无论您的SQL文本时什么，列名都将使用数据库表中的名称标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以直接访问得到多种类型</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">firstName</span> <span class=\"hljs-operator\">=</span> row.getString(<span class=\"hljs-string\">&quot;first_name&quot;</span>);\n<span class=\"hljs-type\">Boolean</span> <span class=\"hljs-variable\">male</span> <span class=\"hljs-operator\">=</span> row.getBoolean(<span class=\"hljs-string\">&quot;male&quot;</span>);\n<span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> row.getInteger(<span class=\"hljs-string\">&quot;age&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用缓存过的预处理语句去执行一次性的预查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connectOptions.setCachePreparedStatements(<span class=\"hljs-literal\">true</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id = @p1&quot;</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + rows.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以创建 <code>PreparedStatement</code> 并自主地管理它的生命周期。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sqlConnection\n  .prepare(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id = @p1&quot;</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-type\">PreparedStatement</span> <span class=\"hljs-variable\">preparedStatement</span> <span class=\"hljs-operator\">=</span> ar.result();\n      preparedStatement.query()\n        .execute(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>), ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n            System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + rows.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n            preparedStatement.close();\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar2.cause().getMessage());\n          }\n        });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batches\"><a class=\"anchor\" href=\"#_batches\"></a>批处理</h3>\n<div class=\"paragraph\">\n<p>您可以在预查询中执行批处理操作</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;Tuple&gt; batch = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\nbatch.add(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>, <span class=\"hljs-string\">&quot;Julien Viet&quot;</span>));\nbatch.add(Tuple.of(<span class=\"hljs-string\">&quot;emad&quot;</span>, <span class=\"hljs-string\">&quot;Emad Alblueshi&quot;</span>));\n\n<span class=\"hljs-comment\">// Execute the prepared batch</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO USERS (id, name) VALUES (@p1, @p2)&quot;</span>)\n  .executeBatch(batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// Process rows</span>\n    RowSet&lt;Row&gt; rows = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Batch failed &quot;</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_working_with_identity_columns\"><a class=\"anchor\" href=\"#_working_with_identity_columns\"></a>使用自增列</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以在插入新数据后使用 <code>OUTPUT</code> 子句来获取自增列的值</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO movies (title) OUTPUT INSERTED.id VALUES (@p1)&quot;</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">&quot;The Man Who Knew Too Much&quot;</span>), res -&gt; {\n    <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n      <span class=\"hljs-type\">Row</span> <span class=\"hljs-variable\">row</span> <span class=\"hljs-operator\">=</span> res.result().iterator().next();\n      System.out.println(row.getLong(<span class=\"hljs-string\">&quot;id&quot;</span>));\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_connections\"><a class=\"anchor\" href=\"#_using_connections\"></a>使用连接</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>获取一条连接</h3>\n<div class=\"paragraph\">\n<p>当您要执行查询（无事务）操作时，您可以创建一条或者从连接池里拿到一条连接。\n请注意在从拿到连接到将连接释放回连接池这之间的连接状态，服务端可能由于某些原因比如空闲时间超时，而关闭这条连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .getConnection()\n  .compose(connection -&gt;\n    connection\n      .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (@p1, @p2)&quot;</span>)\n      .executeBatch(Arrays.asList(\n        Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>, <span class=\"hljs-string\">&quot;Viet&quot;</span>),\n        Tuple.of(<span class=\"hljs-string\">&quot;Emad&quot;</span>, <span class=\"hljs-string\">&quot;Alblueshi&quot;</span>)\n      ))\n      .compose(res -&gt; connection\n        <span class=\"hljs-comment\">// Do something with rows</span>\n        .query(<span class=\"hljs-string\">&quot;SELECT COUNT(*) FROM Users&quot;</span>)\n        .execute()\n        .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n      .eventually(v -&gt; connection.close())\n  ).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;Insert users, now the number of users is &quot;</span> + count);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以通过连接对象创建预查询:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection\n  .prepare(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE first_name LIKE @p1&quot;</span>)\n  .compose(pq -&gt;\n    pq.query()\n      .execute(Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>))\n      .eventually(v -&gt; pq.close())\n  ).onSuccess(rows -&gt; {\n  <span class=\"hljs-comment\">// All rows</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_connection_api\"><a class=\"anchor\" href=\"#_simplified_connection_api\"></a>简化的连接API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withConnection-java.util.function.Function-io.vertx.core.Handler-\">withConnection</a></code>\n并以当前连接要执行的操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这样会从连接池里拿到一条连接，并使用当前连接执行目标操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种方式需要返回一个future对象来表示操作结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>当这个future操作完成后，当前连接会被释放会连接池同时您也可能拿到最终的执行结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withConnection(connection -&gt;\n  connection\n    .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (@p1, @p2)&quot;</span>)\n    .executeBatch(Arrays.asList(\n      Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>, <span class=\"hljs-string\">&quot;Viet&quot;</span>),\n      Tuple.of(<span class=\"hljs-string\">&quot;Emad&quot;</span>, <span class=\"hljs-string\">&quot;Alblueshi&quot;</span>)\n    ))\n    .compose(res -&gt; connection\n      <span class=\"hljs-comment\">// Do something with rows</span>\n      .query(<span class=\"hljs-string\">&quot;SELECT COUNT(*) FROM Users&quot;</span>)\n      .execute()\n      .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;Insert users, now the number of users is &quot;</span> + count);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_transactions\"><a class=\"anchor\" href=\"#_using_transactions\"></a>使用事务</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_transactions_with_connections\"><a class=\"anchor\" href=\"#_transactions_with_connections\"></a>连接中使用事务操作</h3>\n<div class=\"paragraph\">\n<p>您可以使用SQL语法 <code>BEGIN</code>/<code>COMMIT</code>/<code>ROLLBACK</code> 来执行事务操作，同时您必须使用\n<code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 并自己管理当前连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者您也可以使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 的事务API：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection()\n  <span class=\"hljs-comment\">// Transaction must use a connection</span>\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// Begin the transaction</span>\n    conn.begin()\n      .compose(tx -&gt; conn\n        <span class=\"hljs-comment\">// Various statements</span>\n        .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Julien&#x27;,&#x27;Viet&#x27;)&quot;</span>)\n        .execute()\n        .compose(res2 -&gt; conn\n          .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Andy&#x27;,&#x27;Guibert&#x27;)&quot;</span>)\n          .execute())\n        <span class=\"hljs-comment\">// Commit the transaction</span>\n        .compose(res3 -&gt; tx.commit()))\n      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n      .eventually(v -&gt; conn.close())\n      .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction succeeded&quot;</span>))\n      .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction failed: &quot;</span> + err.getMessage()));\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当数据库服务端返回当前事务已失败（比如常见的 <em>current transaction is aborted, commands ignored until end of transaction block</em>）\n，事务已回滚和 <code><a href=\"../../apidocs/io/vertx/sqlclient/Transaction.html#completion--\">completion</a></code> 方法的返回值future返回了\n<code><a href=\"../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html\">TransactionRollbackException</a></code> 异常时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">tx.completion()\n  .onFailure(err -&gt; {\n    System.out.println(<span class=\"hljs-string\">&quot;Transaction failed =&gt; rolled back&quot;</span>);\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_transaction_api\"><a class=\"anchor\" href=\"#_simplified_transaction_api\"></a>简化版事务API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withTransaction-java.util.function.Function-io.vertx.core.Handler-\">withTransaction</a></code> 方法\n并传递待执行的事务操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将会从连接池里拿到一条连接，开启事务并调用待执行操作，配合客户端一起执行该事务范围内\n的所有操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>待执行操作需要返回一个future来表示可能产生的结果：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当future成功时，客户端提交该事务</p>\n</li>\n<li>\n<p>当future失败时，客户端回滚该事务</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>事务操作完成后，连接会被释放回连接池，并且可以获取到最终的操作结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withTransaction(client -&gt; client\n  .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Julien&#x27;,&#x27;Viet&#x27;)&quot;</span>)\n  .execute()\n  .flatMap(res -&gt; client\n    .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Julien&#x27;,&#x27;Viet&#x27;)&quot;</span>)\n    .execute()\n    <span class=\"hljs-comment\">// Map to a message result</span>\n    .map(<span class=\"hljs-string\">&quot;Users inserted&quot;</span>)))\n  .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction succeeded&quot;</span>))\n  .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction failed: &quot;</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>查询追踪</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当Vert.x启用tracing功能时，SQL客户端可以跟踪查询的执行情况。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端会上报下列这些 <em>client</em> spans：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> 操作名称</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>db.user</code> ：数据库用户名</p>\n</li>\n<li>\n<p><code>db.instance</code> ：数据库实例</p>\n</li>\n<li>\n<p><code>db.statement</code> ：SQL语句</p>\n</li>\n<li>\n<p><code>db.type</code> ：<em>sql</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认的 tracing 策略时 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>，客户端\n在一个活跃trace里只创建一个span。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnectOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 方法来调整tracing策略，\n例如您可以设置为 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code>，\n客户端将始终上报span：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_data_types_supported\"><a class=\"anchor\" href=\"#_data_types_supported\"></a>支持的数据类型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当前，客户端支持以下 SQL Server 类型：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>TINYINT(<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>SMALLINT(<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>INT(<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>BIGINT(<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>BIT(<code>java.lang.Boolean</code>)</p>\n</li>\n<li>\n<p>REAL(<code>java.lang.Float</code>)</p>\n</li>\n<li>\n<p>DOUBLE(<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>NUMERIC/DECIMAL(<code><a href=\"../../apidocs/java/math/BigDecimal.html\">BigDecimal</a></code>)</p>\n</li>\n<li>\n<p>CHAR/VARCHAR(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>NCHAR/NVARCHAR(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>DATE(<code>java.time.LocalDate</code>)</p>\n</li>\n<li>\n<p>TIME(<code>java.time.LocalTime</code>)</p>\n</li>\n<li>\n<p>DATETIME2(<code>java.time.LocalDateTime</code>)</p>\n</li>\n<li>\n<p>DATETIMEOFFSET(<code>java.time.OffsetDateTime</code>)</p>\n</li>\n<li>\n<p>BINARY/VARBINARY(<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>元组（Tuple）解码在存储值时使用上述类型。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_java_enum_types\"><a class=\"anchor\" href=\"#_using_java_enum_types\"></a>使用 Java 的 <code>枚举</code> 类型</h3>\n<div class=\"paragraph\">\n<p>SQL Server 没有 <code>ENUM</code> 数据类型，但客户端可以将检索到的字符串/数字数据类型映射到枚举。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以像这样对 Java 枚举进行编码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO colors VALUES (@p1)&quot;</span>)\n  .execute(Tuple.of(Color.red),  res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以像这样解码 Java 枚举：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;SELECT color FROM colors&quot;</span>)\n  .execute()\n  .onComplete(res -&gt; {\n    <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n      RowSet&lt;Row&gt; rows = res.result();\n      <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n        System.out.println(row.get(Color.class, <span class=\"hljs-string\">&quot;color&quot;</span>));\n      }\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_null\"><a class=\"anchor\" href=\"#_handling_null\"></a>处理空 <code>NULL</code></h3>\n<div class=\"paragraph\">\n<p>如果您使用 <code>addXXX</code> 方法之一修改 <code>Tuple</code>，则 <code>null</code> 值被透明处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端可以在执行准备好的查询时推断正确的 SQL 类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Tuple</span> <span class=\"hljs-variable\">tuple</span> <span class=\"hljs-operator\">=</span> Tuple.tuple()\n  .addInteger(<span class=\"hljs-number\">17</span>)\n  .addString(<span class=\"hljs-string\">&quot;The Man Who Knew Too Much&quot;</span>)\n  .addString(<span class=\"hljs-literal\">null</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO movies (id, title, plot) VALUES (@p1, @p2, @p3)&quot;</span>)\n  .execute(tuple, res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>否则，您应该使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/data/NullValue.html\">NullValue</a></code> 常量和 <code><a href=\"../../apidocs/io/vertx/sqlclient/data/NullValue.html#of-java.lang.Class-\">NullValue.of</a></code> 方法之一以显式声明类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Tuple</span> <span class=\"hljs-variable\">tuple</span> <span class=\"hljs-operator\">=</span> Tuple.of(<span class=\"hljs-number\">17</span>, <span class=\"hljs-string\">&quot;The Man Who Knew Too Much&quot;</span>, NullValue.String);\nclient\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO movies (id, title, plot) VALUES (@p1, @p2, @p3)&quot;</span>)\n  .execute(tuple, res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>收集器查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以通过查询 API 使用 Java 收集器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, Map&lt;Long, String&gt;&gt; collector = Collectors.toMap(\n  row -&gt; row.getLong(<span class=\"hljs-string\">&quot;id&quot;</span>),\n  row -&gt; row.getString(<span class=\"hljs-string\">&quot;last_name&quot;</span>));\n\n<span class=\"hljs-comment\">// 使用收集器运行查询</span>\nclient.query(<span class=\"hljs-string\">&quot;SELECT * FROM users&quot;</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;Map&lt;Long, String&gt;&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// 获取收集器创建的映射（map）对象</span>\n      Map&lt;Long, String&gt; map = result.value();\n      System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + map);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>收集器处理时不得保留对 <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> 的引用，\n因为有一行用于处理整个集合。</p>\n</div>\n<div class=\"paragraph\">\n<p>Java <code>Collectors</code> 提供了许多有趣的预定义收集器，例如您可以\ncreate 直接从行集轻松创建字符串：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, String&gt; collector = Collectors.mapping(\n  row -&gt; row.getString(<span class=\"hljs-string\">&quot;last_name&quot;</span>),\n  Collectors.joining(<span class=\"hljs-string\">&quot;,&quot;</span>, <span class=\"hljs-string\">&quot;(&quot;</span>, <span class=\"hljs-string\">&quot;)&quot;</span>)\n);\n\n<span class=\"hljs-comment\">// 使用收集器运行查询</span>\nclient.query(<span class=\"hljs-string\">&quot;SELECT * FROM users&quot;</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;String&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// 获取收集器创建的字符串</span>\n      <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> result.value();\n      System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + list);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_ssltls\"><a class=\"anchor\" href=\"#_using_ssltls\"></a>使用 SSL/TLS</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_encryption_level_negotiation\"><a class=\"anchor\" href=\"#_encryption_level_negotiation\"></a>加密等级协商</h3>\n<div class=\"paragraph\">\n<p>当一个数据库连接建立时，客户端和服务端需要协商加密等级。</p>\n</div>\n<div class=\"paragraph\">\n<p>协商的加密等级取决于客户端的 <code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnectOptions.html\">MSSQLConnectOptions</a></code> 配置和服务端和配置：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>不加密： 如果客户端的 <code>ssl</code> 配置设置为 <code>false</code> ，并且服务端不支持加密</p>\n</li>\n<li>\n<p>只加密登录报文: 如果客户端的 <code>ssl</code> 配置设置为 <code>false</code> , 并且服务端支持加密</p>\n</li>\n<li>\n<p>加密整个连接通道: 如果客户端的 <code>ssl</code> 配置设置为 <code>true</code> , 并且服务端要求加密</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>如果客户端的 <code>ssl</code> 配置设置为 <code>true</code> ，并且服务端不支持加密时，加密等级协商会失败。\n在这种情况下，客户端会终止连接。</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuration_2\"><a class=\"anchor\" href=\"#_configuration_2\"></a>配置</h3>\n<div class=\"paragraph\">\n<p>为了设置客户端的 <code>ssl</code> 项配置, 使用 <code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnectOptions.html#setSsl-boolean-\">setSsl</a></code> 方法。\n默认情况下， <code>ssl</code> 配置为 <code>false</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>().setSsl(<span class=\"hljs-literal\">true</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当 <code>ssl</code> 配置为 <code>false</code> 时，客户端信任所有的服务端密钥。\n否则，客户端会验证主机名。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果客户端的 <code>ssl</code> 配置为 <code>true</code>， 并且服务端使用了自签名的密钥， 可以禁用主机名验证：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>()\n  .setSsl(<span class=\"hljs-literal\">true</span>)\n  .setTrustAll(<span class=\"hljs-literal\">true</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端也可以选择配置信任所有服务端的密钥，使用 <code><a href=\"../../apidocs/io/vertx/core/net/TrustOptions.html\">TrustOptions</a></code> 进行配置。\n例如，如果服务端密钥放置在一个 PEM 格式的文件中时，可以使用 <code><a href=\"../../apidocs/io/vertx/core/net/PemTrustOptions.html\">PemTrustOptions</a></code> 进行如下配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MSSQLConnectOptions</span>()\n  .setSsl(<span class=\"hljs-literal\">true</span>)\n  .setPemTrustOptions(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PemTrustOptions</span>().addCertPath(<span class=\"hljs-string\">&quot;/path/to/server-cert.pem&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于 Vert.x 中更高级的 SSL 支持，请参考 <a href=\"https://vertx.io/docs/vertx-core/java/#ssl\">Vert.x Core 文档</a>。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_advanced_pool_configuration\"><a class=\"anchor\" href=\"#_advanced_pool_configuration\"></a>高级连接池配置</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_server_load_balancing\"><a class=\"anchor\" href=\"#_server_load_balancing\"></a>数据库服务负载均衡</h3>\n<div class=\"paragraph\">\n<p>您可以使用包含多个数据库服务的列表来配置连接池而不是单个数据库服务。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MSSQLPool</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> MSSQLPool.pool(Arrays.asList(server1, server2, server3), options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当一个连接创建时，连接池使用(round-robin)轮询调度算法做负载均衡以选择不同的数据库服务</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n负载均衡是在创建连接时提供的，而不是在从连接池中获取连接时提供\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_pool_connection_initialization\"><a class=\"anchor\" href=\"#_pool_connection_initialization\"></a>连接初始化</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#connectHandler-io.vertx.core.Handler-\">connectHandler</a></code>\n方法在连接创建后和连接释放回连接池之前来与数据库连接交互</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.connectHandler(conn -&gt; {\n  conn.query(sql).execute().onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">//  将连接释放回连接池，以被该应用程序复用</span>\n    conn.close();\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>连接完成后，您应该释放该连接以通知连接池该数据库连接可以被使用</p>\n</div>\n</div>\n</div>\n</div>","version":"4.1.3"},"__N_SSG":true}