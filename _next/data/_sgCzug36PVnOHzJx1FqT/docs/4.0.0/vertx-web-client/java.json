{"pageProps":{"slug":"4.0.0/vertx-web-client/java","title":"Vert.x Web Client","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_the_web_client\">使用Web Client</a></li>\n<li><a href=\"#_re_cap_on_vert_x_core_http_client\">回顾 Vert.x Core的 HTTP Client</a></li>\n<li><a href=\"#_creating_a_web_client\">创建Web Client</a></li>\n<li><a href=\"#_making_requests\">发送请求</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_simple_requests_with_no_body\">无请求体的简单请求</a></li>\n<li><a href=\"#_writing_request_bodies\">填充请求体</a></li>\n<li><a href=\"#_writing_request_headers\">填充请求头</a></li>\n<li><a href=\"#_configure_the_request_to_add_authentication\">配置请求以添加身份验证</a></li>\n<li><a href=\"#_reusing_requests\">重用请求</a></li>\n<li><a href=\"#_timeouts\">超时</a></li>\n</ul>\n</li>\n<li><a href=\"#_handling_http_responses\">处理HTTP响应</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_decoding_responses\">响应解码</a></li>\n<li><a href=\"#response-predicates\">响应谓词</a></li>\n<li><a href=\"#_handling_30x_redirections\">处理 30x 重定向</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_https\">使用 HTTPS</a></li>\n<li><a href=\"#_sessions_management\">会话管理</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_websession\">创建一个 WebSession</a></li>\n<li><a href=\"#_making_requests_2\">发出请求</a></li>\n<li><a href=\"#_setting_session_level_headers\">设置会话级别headers</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxjava_2_api\">RxJava 2 API</a></li>\n<li><a href=\"#_domain_sockets\">域套接字</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Web Client</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web Client 是一个异步的 HTTP 和 HTTP/2 客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>Web Client使得发送 HTTP 请求以及从 Web 服务器接收 HTTP 响应变得更加便捷，同时提供了额外的高级功能，例如：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Json body的编码和解码</p>\n</li>\n<li>\n<p>请求和响应泵</p>\n</li>\n<li>\n<p>请求参数的处理</p>\n</li>\n<li>\n<p>统一的错误处理</p>\n</li>\n<li>\n<p>提交表单</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>制作Web Client的目的并非为了替换Vert.x Core中的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> ，而是基于该客户端，继承其配置和强大的功能，例如请求连接池（Pooling），HTTP/2的支持，流水线／管线的支持等。当您需要对 HTTP 请求和响应做细微粒度控制时，您应当使用 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>另外Web Client并未提供 WebSocket API，此时您应当使用 Vert.x Core的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> 。目前还无法处理cookies。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_web_client\"><a class=\"anchor\" href=\"#_using_the_web_client\"></a>使用Web Client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如需使用Vert.x Web Client，请先加入以下依赖,到您的build描述 <em>dependencies</em> 部分 ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件内):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件内):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-client:4.0.0'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_re_cap_on_vert_x_core_http_client\"><a class=\"anchor\" href=\"#_re_cap_on_vert_x_core_http_client\"></a>回顾 Vert.x Core的 HTTP Client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web Client使用Vert.x core的API，如果您对此还不熟悉，熟悉基于 Vert.x core的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> 基本概念是很有价值的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_web_client\"><a class=\"anchor\" href=\"#_creating_a_web_client\"></a>创建Web Client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以创建一个缺省 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您还可以使用配置项来创建客户端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClientOptions options = <span class=\"hljs-keyword\">new</span> WebClientOptions()\n  .setUserAgent(<span class=\"hljs-string\">\"My-App/1.2.3\"</span>);\noptions.setKeepAlive(<span class=\"hljs-keyword\">false</span>);\nWebClient client = WebClient.create(vertx, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Web Client配置项继承自 <code>HttpClient</code> 配置项，您可以设置其中任何一个项。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果已在程序中创建 <code>HttpClient</code>，可用以下方式复用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.wrap(httpClient);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n在大多数情况下，一个Web Client 应该在应用程序启动时创建，并重用它。\n否则，您将失去很多好处，例如连接池。如果实例未正确关闭，则可能会资源泄漏。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_making_requests\"><a class=\"anchor\" href=\"#_making_requests\"></a>发送请求</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_simple_requests_with_no_body\"><a class=\"anchor\" href=\"#_simple_requests_with_no_body\"></a>无请求体的简单请求</h3>\n<div class=\"paragraph\">\n<p>通常，您想发送一个无请求体的HTTP请求。以下是一般情况下的 HTTP GET， OPTIONS和HEAD 请求</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx);\n\n<span class=\"hljs-comment\">// 发送GET请求</span>\nclient\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send()\n  .onSuccess(response -&gt; System.out\n    .println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));\n\n<span class=\"hljs-comment\">// 发送HEAD请求</span>\nclient\n  .head(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send()\n  .onSuccess(response -&gt; System.out\n    .println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可用以下链式方式向请求URI添加查询参数</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .addQueryParam(<span class=\"hljs-string\">\"param\"</span>, <span class=\"hljs-string\">\"param_value\"</span>)\n  .send()\n  .onSuccess(response -&gt; System.out\n    .println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在请求URI中的参数将会被预填充</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client\n  .get(\n    <span class=\"hljs-number\">8080</span>,\n    <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>,\n    <span class=\"hljs-string\">\"/some-uri?param1=param1_value&amp;param2=param2_value\"</span>);\n\n<span class=\"hljs-comment\">// 添加 param3</span>\nrequest.addQueryParam(<span class=\"hljs-string\">\"param3\"</span>, <span class=\"hljs-string\">\"param3_value\"</span>);\n\n<span class=\"hljs-comment\">// 覆盖 param2</span>\nrequest.setQueryParam(<span class=\"hljs-string\">\"param2\"</span>, <span class=\"hljs-string\">\"another_param2_value\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>设置请求URI将会自动清除已有的查询参数</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\n\n<span class=\"hljs-comment\">// 添加 param1</span>\nrequest.addQueryParam(<span class=\"hljs-string\">\"param1\"</span>, <span class=\"hljs-string\">\"param1_value\"</span>);\n\n<span class=\"hljs-comment\">// 覆盖 param1 并添加 param2</span>\nrequest.uri(<span class=\"hljs-string\">\"/some-uri?param1=param1_value&amp;param2=param2_value\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_request_bodies\"><a class=\"anchor\" href=\"#_writing_request_bodies\"></a>填充请求体</h3>\n<div class=\"paragraph\">\n<p>如需要发送请求体，可使用相同的API，并在最后加上 <code>sendXXX</code> 方法，发送相应的请求体。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendBuffer-io.vertx.core.buffer.Buffer-io.vertx.core.Handler-\">sendBuffer</a></code> 发送一个buffer body</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendBuffer(buffer)\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>发送single buffer很有用，但是通常您不想完全将内容加载到内存中，因为它可能太大，或者您想同时处理多个请求，或者每个请求只想使用最小的（消耗）。\n为此，Web Client可以使用 <code>ReadStream&lt;Buffer&gt;</code> 的 (例如 <code><a href=\"../../apidocs/io/vertx/core/file/AsyncFile.html\">AsyncFile</a></code> 是一个ReadStream&lt;Buffer&gt; ) <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendStream-io.vertx.core.streams.ReadStream-io.vertx.core.Handler-\">sendStream</a></code> 方法发送。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendStream(stream)\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Web Client负责为您设置泵传输（transfer pump）。如果流长度未知则使用分块传输（chunked transfer）编码。</p>\n</div>\n<div class=\"paragraph\">\n<p>当您知道流的大小，您应该在HTTP header中设置 <code>content-length</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fs.open(<span class=\"hljs-string\">\"content.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), fileRes -&gt; {\n  <span class=\"hljs-keyword\">if</span> (fileRes.succeeded()) {\n    ReadStream&lt;Buffer&gt; fileStream = fileRes.result();\n\n    String fileLen = <span class=\"hljs-string\">\"1024\"</span>;\n\n    <span class=\"hljs-comment\">// 用POST方法发送文件</span>\n    client\n      .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n      .putHeader(<span class=\"hljs-string\">\"content-length\"</span>, fileLen)\n      .sendStream(fileStream)\n      .onSuccess(res -&gt; {\n        <span class=\"hljs-comment\">// OK</span>\n      })\n    ;\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个POST方法不会被分块传输。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_json_bodies\"><a class=\"anchor\" href=\"#_json_bodies\"></a>JSON bodies</h4>\n<div class=\"paragraph\">\n<p>有时您需要发送JSON body请求，可使用 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendJsonObject-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">sendJsonObject</a></code> 发送一个 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendJsonObject(\n    <span class=\"hljs-keyword\">new</span> JsonObject()\n      .put(<span class=\"hljs-string\">\"firstName\"</span>, <span class=\"hljs-string\">\"Dale\"</span>)\n      .put(<span class=\"hljs-string\">\"lastName\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在Java，Groovy以及Kotlin中，您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendJson-java.lang.Object-io.vertx.core.Handler-\">sendJson</a></code> 方法，它使用 <code><a href=\"../../apidocs/io/vertx/core/json/Json.html#encode-java.lang.Object-\">Json.encode</a></code> 方法映射一个 POJO (Plain Old Java Object) 到一个 Json 对象</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendJson(<span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-string\">\"Dale\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/core/json/Json.html#encode-java.lang.Object-\">Json.encode</a></code> 方法使用Jackson mapper将 POJO 编码成 JSON。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_form_submissions\"><a class=\"anchor\" href=\"#_form_submissions\"></a>表单提交</h4>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendForm-io.vertx.core.MultiMap-io.vertx.core.Handler-\">sendForm</a></code> 的变体发送http表单提交。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultiMap form = MultiMap.caseInsensitiveMultiMap();\nform.set(<span class=\"hljs-string\">\"firstName\"</span>, <span class=\"hljs-string\">\"Dale\"</span>);\nform.set(<span class=\"hljs-string\">\"lastName\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>);\n\n<span class=\"hljs-comment\">// 用URL编码方式提交表单</span>\nclient\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendForm(form)\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，提交表单header中的 <code>content-type</code> 属性值为 <code>application/x-www-form-urlencoded</code>，您还可将其替换为 <code>multipart/form-data</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultiMap form = MultiMap.caseInsensitiveMultiMap();\nform.set(<span class=\"hljs-string\">\"firstName\"</span>, <span class=\"hljs-string\">\"Dale\"</span>);\nform.set(<span class=\"hljs-string\">\"lastName\"</span>, <span class=\"hljs-string\">\"Cooper\"</span>);\n\n<span class=\"hljs-comment\">// 提交multipart form表单</span>\nclient\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"multipart/form-data\"</span>)\n  .sendForm(form)\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果你想上传文件的同时发送属性,您可以创建一个 <code><a href=\"../../apidocs/io/vertx/ext/web/multipart/MultipartForm.html\">MultipartForm</a></code> , 然后使用 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#sendMultipartForm-io.vertx.ext.web.multipart.MultipartForm-io.vertx.core.Handler-\">sendMultipartForm</a></code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultipartForm form = MultipartForm.create()\n  .attribute(<span class=\"hljs-string\">\"imageDescription\"</span>, <span class=\"hljs-string\">\"a very nice image\"</span>)\n  .binaryFileUpload(\n    <span class=\"hljs-string\">\"imageFile\"</span>,\n    <span class=\"hljs-string\">\"image.jpg\"</span>,\n    <span class=\"hljs-string\">\"/path/to/image\"</span>,\n    <span class=\"hljs-string\">\"image/jpeg\"</span>);\n\n<span class=\"hljs-comment\">// 提交multipart form表单</span>\nclient\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .sendMultipartForm(form)\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_request_headers\"><a class=\"anchor\" href=\"#_writing_request_headers\"></a>填充请求头</h3>\n<div class=\"paragraph\">\n<p>您可使用headers的multi-map 填充请求头：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\n\nMultiMap headers = request.headers();\nheaders.set(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>);\nheaders.set(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"foo\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>此处 Headers 是一个 <code><a href=\"../../apidocs/io/vertx/core/MultiMap.html\">MultiMap</a></code> 实例，提供了添加、设置以及删除头属性操作的入口。HTTP headers允许某个特定的key有多个值。</p>\n</div>\n<div class=\"paragraph\">\n<p>您还可使用 putHeader 写入headers属性：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\n\nrequest.putHeader(<span class=\"hljs-string\">\"content-type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>);\nrequest.putHeader(<span class=\"hljs-string\">\"other-header\"</span>, <span class=\"hljs-string\">\"foo\"</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configure_the_request_to_add_authentication\"><a class=\"anchor\" href=\"#_configure_the_request_to_add_authentication\"></a>配置请求以添加身份验证</h3>\n<div class=\"paragraph\">\n<p>可以通过设置正确的 headers 来手动执行身份验证，或我们的预定义方法 （我们强烈建议启用HTTPS，尤其是对于经过身份验证的请求）：\n在基本的HTTP身份验证中，请求包含以下形式的表单header字段 <code>Authorization: Basic &lt;credentials&gt;</code> ，credentials是base64编码的，由冒号连接的id和密码。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以像下面这样配置请求以添加基本访问验证：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .authentication(<span class=\"hljs-keyword\">new</span> UsernamePasswordCredentials(<span class=\"hljs-string\">\"myid\"</span>, <span class=\"hljs-string\">\"mypassword\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在OAuth 2.0种，请求包含以下形式的表单header字段 <code>Authorization: Bearer &lt;bearerToken&gt;</code> ，bearerToken是授权服务器发布的，用于访问受保护资源的不记名令牌。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以像下面这样配置请求，以添加bearer token访问验证：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; request = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .authentication(<span class=\"hljs-keyword\">new</span> TokenCredentials(<span class=\"hljs-string\">\"myBearerToken\"</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_reusing_requests\"><a class=\"anchor\" href=\"#_reusing_requests\"></a>重用请求</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#send-io.vertx.core.Handler-\">send</a></code> 方法可被安全的重复多次调用，这使得它可以很容易的配置以及重用 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html\">HttpRequest</a></code> 对象</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; get = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\n\nget\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });\n\n<span class=\"hljs-comment\">// 又一些请求</span>\nget\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>不过要当心 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html\">HttpRequest</a></code> 实例是可变的（mutable）.\n因此，您应该在修改已被缓存了的实例之前，使用 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#copy--\">copy</a></code> 方法。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpRequest&lt;Buffer&gt; get = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>);\n\nget\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });\n\n<span class=\"hljs-comment\">// \"get\" 请求实例保持未修改</span>\nget\n  .copy()\n  .putHeader(<span class=\"hljs-string\">\"a-header\"</span>, <span class=\"hljs-string\">\"with-some-value\"</span>)\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timeouts\"><a class=\"anchor\" href=\"#_timeouts\"></a>超时</h3>\n<div class=\"paragraph\">\n<p>您可通过 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpRequest.html#timeout-long-\">timeout</a></code>. 方法设置超时时间。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .timeout(<span class=\"hljs-number\">5000</span>)\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// OK</span>\n  })\n  .onFailure(err -&gt; {\n    <span class=\"hljs-comment\">// 当是由java.util.concurrent.TimeoutException导致时，或许是一个超时</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若请求在设定时间内没有返回任何数据，则一个异常将会传递给响应处理器。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_http_responses\"><a class=\"anchor\" href=\"#_handling_http_responses\"></a>处理HTTP响应</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Web Client请求发送之后，您总是在单个 <code><a href=\"../../apidocs/io/vertx/ext/web/client/HttpResponse.html\">HttpResponse</a></code> 中处理单个异步结果 。</p>\n</div>\n<div class=\"paragraph\">\n<p>当响应被成功接收到之后，相应的回调函数将会被调用。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send()\n  .onSuccess(res -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + res.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>默认状况下，仅当在网络级别发生错误时，Vert.x Web Client请求才以错误结尾。换言之，<code>404 Not Found</code> 响应或错误content type的响应，<strong>不</strong> 被视为失败。</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n响应会被完全缓冲，请使用 <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#pipe-io.vertx.core.streams.WriteStream-\">BodyCodec.pipe</a></code> 将响应接入写入流。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_decoding_responses\"><a class=\"anchor\" href=\"#_decoding_responses\"></a>响应解码</h3>\n<div class=\"paragraph\">\n<p>缺省状况下，Web Client提供一个response body作为 <code>Buffer</code> ，并且未运用任何解码器。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html\">BodyCodec</a></code> 实现以下自定义response body解码：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>文本字符串</p>\n</li>\n<li>\n<p>Json 对象</p>\n</li>\n<li>\n<p>Json 映射的 POJO</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>一个body解码器可以将任意二进制数据流解码为特定的对象实例，从而节省了您自己在响应处理器里解码的步骤。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#jsonObject--\">BodyCodec.jsonObject</a></code> 解码一个 Json 对象:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.jsonObject())\n  .send()\n  .onSuccess(res -&gt; {\n    JsonObject body = res.body();\n\n    System.out.println(\n      <span class=\"hljs-string\">\"Received response with status code\"</span> +\n        res.statusCode() +\n        <span class=\"hljs-string\">\" with body \"</span> +\n        body);\n  })\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在Java，Groovy以及Kotlin中，可以自定义Json映射POJO解码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.json(User<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))\n  .<span class=\"hljs-title\">send</span>()\n  .<span class=\"hljs-title\">onSuccess</span>(<span class=\"hljs-title\">res</span> -&gt; </span>{\n    User user = res.body();\n\n    System.out.println(\n      <span class=\"hljs-string\">\"Received response with status code\"</span> +\n        res.statusCode() +\n        <span class=\"hljs-string\">\" with body \"</span> +\n        user.getFirstName() +\n        <span class=\"hljs-string\">\" \"</span> +\n        user.getLastName());\n  })\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个编码器将响应缓存泵入到  <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 中，并且在异步结果响应中，发出操作成功或失败的信号。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.pipe(writeStream))\n  .send()\n  .onSuccess(res -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + res.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>经常会看到API返回一个JSON对象流。例如，Twitter API可以提供一个推文回馈。处理这个情况，您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#jsonStream-io.vertx.core.parsetools.JsonParser-\">BodyCodec.jsonStream</a></code>。传递一个JSON解析器，该解析器从HTTP响应中开始读取JSON流。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonParser parser = JsonParser.newParser().objectValueMode();\nparser.handler(event -&gt; {\n  JsonObject object = event.objectValue();\n  System.out.println(<span class=\"hljs-string\">\"Got \"</span> + object.encode());\n});\nclient\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.jsonStream(parser))\n  .send()\n  .onSuccess(res -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + res.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>最后，如您对响应结果不感兴趣，可用 <code><a href=\"../../apidocs/io/vertx/ext/web/codec/BodyCodec.html#none--\">BodyCodec.none</a></code> 简单的丢弃response body。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .as(BodyCodec.none())\n  .send()\n  .onSuccess(res -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + res.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>若无法预知响应内容类型，您依旧可以在获取结果之后，用 <code>bodyAsXXX()</code> 方法将其转换成指定的类型</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// 将结果解码为Json对象</span>\n    JsonObject body = res.bodyAsJsonObject();\n\n    System.out.println(\n      <span class=\"hljs-string\">\"Received response with status code\"</span> +\n        res.statusCode() +\n        <span class=\"hljs-string\">\" with body \"</span> +\n        body);\n  })\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n这种方式仅对响应结果为buffer有效。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"response-predicates\"><a class=\"anchor\" href=\"#response-predicates\"></a>响应谓词</h3>\n<div class=\"paragraph\">\n<p>默认的, 仅当在网络级别发生错误时，Vert.x Web Client请求才以错误结尾。</p>\n</div>\n<div class=\"paragraph\">\n<p>换言之， 您必须在收到响应后手动执行健全性检查:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-keyword\">if</span> (\n      res.statusCode() == <span class=\"hljs-number\">200</span> &amp;&amp;\n        res.getHeader(<span class=\"hljs-string\">\"content-type\"</span>).equals(<span class=\"hljs-string\">\"application/json\"</span>)) {\n      <span class=\"hljs-comment\">// 将结果解码为Json对象</span>\n      JsonObject body = res.bodyAsJsonObject();\n\n      System.out.println(\n        <span class=\"hljs-string\">\"Received response with status code\"</span> +\n          res.statusCode() +\n          <span class=\"hljs-string\">\" with body \"</span> +\n          body);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + res.statusCode());\n    }\n  })\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以灵活的替换成清晰简明的 <em>response predicates</em> 。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html\">Response predicates</a></code> 当响应不符合条件会使请求失败。</p>\n</div>\n<div class=\"paragraph\">\n<p>Web Client附带了一组开箱即用的谓词，可供使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .expect(ResponsePredicate.SC_SUCCESS)\n  .expect(ResponsePredicate.JSON)\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// 安全地将body解码为json对象</span>\n    JsonObject body = res.bodyAsJsonObject();\n    System.out.println(\n      <span class=\"hljs-string\">\"Received response with status code\"</span> +\n        res.statusCode() +\n        <span class=\"hljs-string\">\" with body \"</span> +\n        body);\n  })\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当现有谓词不满足您的需求时，您还可以创建自定义谓词：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Function&lt;HttpResponse&lt;Void&gt;, ResponsePredicateResult&gt; methodsPredicate =\n  resp -&gt; {\n    String methods = resp.getHeader(<span class=\"hljs-string\">\"Access-Control-Allow-Methods\"</span>);\n    <span class=\"hljs-keyword\">if</span> (methods != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-keyword\">if</span> (methods.contains(<span class=\"hljs-string\">\"POST\"</span>)) {\n        <span class=\"hljs-keyword\">return</span> ResponsePredicateResult.success();\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> ResponsePredicateResult.failure(<span class=\"hljs-string\">\"Does not work\"</span>);\n  };\n\n<span class=\"hljs-comment\">// 发送预检CORS请求</span>\nclient\n  .request(\n    HttpMethod.OPTIONS,\n    <span class=\"hljs-number\">8080</span>,\n    <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>,\n    <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"Origin\"</span>, <span class=\"hljs-string\">\"Server-b.com\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"Access-Control-Request-Method\"</span>, <span class=\"hljs-string\">\"POST\"</span>)\n  .expect(methodsPredicate)\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// 立即处理POST请求</span>\n  })\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n响应谓词是在收到响应体 <em>之前</em> 对其进行评估。 因此，您无法在谓词测试函数中检查response body。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_predefined_predicates\"><a class=\"anchor\" href=\"#_predefined_predicates\"></a>预定义谓词</h4>\n<div class=\"paragraph\">\n<p>为了方便起见，Web Client附带了一些常见用例的谓词。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于状态码, 例如 <code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html#SC_SUCCESS\">ResponsePredicate.SC_SUCCESS</a></code> ，验证响应具有 <code>2xx</code> 代码，您也可以自定义创建一个</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .expect(ResponsePredicate.status(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">202</span>))\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// ....</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于content types, 例如 <code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html#JSON\">ResponsePredicate.JSON</a></code> ，验证响应具有JSON数据，您也可以自定义创建一个</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .expect(ResponsePredicate.contentType(<span class=\"hljs-string\">\"some/content-type\"</span>))\n  .send()\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// ....</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请参考 <code><a href=\"../../apidocs/io/vertx/ext/web/client/predicate/ResponsePredicate.html\">ResponsePredicate</a></code> 文档获取预定义谓词的完整列表。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_creating_custom_failures\"><a class=\"anchor\" href=\"#_creating_custom_failures\"></a>创建自定义失败</h4>\n<div class=\"paragraph\">\n<p>默认情况下, 响应谓词 (包括预定义的) 使用默认的错误转换器，它将丢弃body并传递一条简单消息。您可以通过自定义异常类来替换错误转换器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ResponsePredicate predicate = ResponsePredicate.create(\n  ResponsePredicate.SC_SUCCESS,\n  result -&gt; <span class=\"hljs-keyword\">new</span> MyCustomException(result.message()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>许多Web API在错误响应中提供了详细信息。\n例如, <a href=\"https://developer.marvel.com/docs\">Marvel API</a> 使用此JSON对象格式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\">{\n <span class=\"hljs-string\">\"code\"</span>: <span class=\"hljs-string\">\"InvalidCredentials\"</span>,\n <span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"The passed API key is invalid.\"</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为避免丢失此信息, 在错误发生之前，可以在转换器被调用之前等待响应body被完全接收：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ErrorConverter converter = ErrorConverter.createFullBody(result -&gt; {\n\n  <span class=\"hljs-comment\">// 响应body被完全接收之后调用</span>\n  HttpResponse&lt;Buffer&gt; response = result.response();\n\n  <span class=\"hljs-keyword\">if</span> (response\n    .getHeader(<span class=\"hljs-string\">\"content-type\"</span>)\n    .equals(<span class=\"hljs-string\">\"application/json\"</span>)) {\n\n    <span class=\"hljs-comment\">// 错误body是JSON数据</span>\n    JsonObject body = response.bodyAsJsonObject();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyCustomException(\n      body.getString(<span class=\"hljs-string\">\"code\"</span>),\n      body.getString(<span class=\"hljs-string\">\"message\"</span>));\n  }\n\n  <span class=\"hljs-comment\">// 返回自定义的消息</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyCustomException(result.message());\n});\n\nResponsePredicate predicate = ResponsePredicate\n  .create(ResponsePredicate.SC_SUCCESS, converter);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n在Java中，当捕获了stack trace，创建异常可能会带来性能开销，所以您可能想要创建不捕获stack trace的异常。默认情况下，报告异常使用不捕获stack trace的异常。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_30x_redirections\"><a class=\"anchor\" href=\"#_handling_30x_redirections\"></a>处理 30x 重定向</h3>\n<div class=\"paragraph\">\n<p>默认情况下，客户端跟随着重定向，您可以在 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientOptions.html\">WebClientOptions</a></code> 配置默认行为 :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient\n  .create(vertx, <span class=\"hljs-keyword\">new</span> WebClientOptions().setFollowRedirects(<span class=\"hljs-keyword\">false</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端最多可以跟随 <code>16</code> 个请求重定向，可以在相同的配置中进行更改：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient\n  .create(vertx, <span class=\"hljs-keyword\">new</span> WebClientOptions().setMaxRedirects(<span class=\"hljs-number\">5</span>));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n出于安全原因,客户端不会使用除了GET或HEAD的方法来跟随着重定向请求\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_https\"><a class=\"anchor\" href=\"#_using_https\"></a>使用 HTTPS</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web Client 可以用跟 Vert.x <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> 完全一样的方式配置使用HTTPS。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以指定每个请求的行为</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .get(<span class=\"hljs-number\">443</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .ssl(<span class=\"hljs-keyword\">true</span>)\n  .send()\n  .onSuccess(res -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + res.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或使用带有绝对URI参数的创建方法</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .getAbs(<span class=\"hljs-string\">\"https://myserver.mycompany.com:4043/some-uri\"</span>)\n  .send()\n  .onSuccess(res -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + res.statusCode()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sessions_management\"><a class=\"anchor\" href=\"#_sessions_management\"></a>会话管理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web提供了Web会话管理设施；使用它，您需要对于每个用户（会话）创建一个 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code> ，并使用它来代替 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code> 。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_websession\"><a class=\"anchor\" href=\"#_creating_a_websession\"></a>创建一个 WebSession</h3>\n<div class=\"paragraph\">\n<p>您像下面一样创建一个 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code> 实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClient client = WebClient.create(vertx);\nWebClientSession session = WebClientSession.create(client);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_making_requests_2\"><a class=\"anchor\" href=\"#_making_requests_2\"></a>发出请求</h3>\n<div class=\"paragraph\">\n<p>一旦创建, <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code> 可以代替\n<code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code> 去做HTTP(s) 请求并且自动管理你正在调用的，从服务器收到的所有cookie。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_setting_session_level_headers\"><a class=\"anchor\" href=\"#_setting_session_level_headers\"></a>设置会话级别headers</h3>\n<div class=\"paragraph\">\n<p>您可以按以下步骤设置任何会话级别的headers到要添加的每个请求：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">WebClientSession session = WebClientSession.create(client);\nsession.addHeader(<span class=\"hljs-string\">\"my-jwt-token\"</span>, jwtToken);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后headers将被添加到每个请求中； 注意 这些headers将发送给所有主机; 如果你需要发送不同的headers到不同的主机, 您必须将它们手动添加到每个单个请求中，并且不添加到 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClientSession.html\">WebClientSession</a></code> 。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_2_api\"><a class=\"anchor\" href=\"#_rxjava_2_api\"></a>RxJava 2 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>RxJava <code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/client/HttpRequest.html\">HttpRequest</a></code> 提供了RX化的原始版本API，\n<code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/client/HttpRequest.html#rxSend--\">rxSend</a></code> 方法返回一个能够订阅到HTTP请求的 <code>Single&lt;HttpResponse&lt;Buffer&gt;&gt;</code> ，因此，<code>Single</code> 能被订阅多次。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpResponse&lt;Buffer&gt;&gt; single = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .rxSend();\n\n<span class=\"hljs-comment\">// Single订阅后，发送请求</span>\nsingle.subscribe(response -&gt; System.out.println(<span class=\"hljs-string\">\"Received 1st response with status code\"</span> + response.statusCode()), error -&gt; System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + error.getMessage()));\n\n<span class=\"hljs-comment\">// 发送另一个请求</span>\nsingle.subscribe(response -&gt; System.out.println(<span class=\"hljs-string\">\"Received 2nd response with status code\"</span> + response.statusCode()), error -&gt; System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + error.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>获得的 <code>Single</code> 可以与RxJava API自然地组合和链式调用</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; url = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .rxSend()\n  .map(HttpResponse::bodyAsString);\n\n<span class=\"hljs-comment\">// 使用flatMap操作，向Single的URL上发出请求</span>\nurl\n  .flatMap(u -&gt; client.getAbs(u).rxSend())\n  .subscribe(response -&gt; System.out.println(<span class=\"hljs-string\">\"Received response with status code\"</span> + response.statusCode()), error -&gt; System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + error.getMessage()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同样的API们是可用的</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpResponse&lt;JsonObject&gt;&gt; single = client\n  .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .putHeader(<span class=\"hljs-string\">\"some-header\"</span>, <span class=\"hljs-string\">\"header-value\"</span>)\n  .addQueryParam(<span class=\"hljs-string\">\"some-param\"</span>, <span class=\"hljs-string\">\"param value\"</span>)\n  .as(BodyCodec.jsonObject())\n  .rxSend();\nsingle.subscribe(resp -&gt; {\n  System.out.println(resp.statusCode());\n  System.out.println(resp.body());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/ext/web/client/HttpRequest.html#sendStream-io.reactivex.Flowable-io.vertx.core.Handler-\">sendStream</a></code> 应首选发送 <code>Flowable&lt;Buffer&gt;</code> body。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Buffer&gt; body = getPayload();\n\nSingle&lt;HttpResponse&lt;Buffer&gt;&gt; single = client\n  .post(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"myserver.mycompany.com\"</span>, <span class=\"hljs-string\">\"/some-uri\"</span>)\n  .rxSendStream(body);\nsingle.subscribe(resp -&gt; {\n  System.out.println(resp.statusCode());\n  System.out.println(resp.body());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>订阅后, <code>body</code> 将被订阅，其内容被用于请求。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_domain_sockets\"><a class=\"anchor\" href=\"#_domain_sockets\"></a>域套接字</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>自3.7.1后， Web Client 支持domain sockets, 例如，您可以跟 <a href=\"https://docs.docker.com/engine/reference/commandline/dockerd/\">local Docker daemon</a> 交流。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了达成这个目的, <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 实例必须使用native transport创建， 你可以阅读Vert.x核心文档，它清楚地说明了这一点。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SocketAddress serverAddress = SocketAddress\n  .domainSocketAddress(<span class=\"hljs-string\">\"/var/run/docker.sock\"</span>);\n\n<span class=\"hljs-comment\">// 我们仍然需要指定主机和端口，因此请求的HTTP header 是 localhost:8080</span>\n<span class=\"hljs-comment\">// 否则将是错误格式的HTTP请求</span>\n<span class=\"hljs-comment\">// 在此示例中，实际值并不重要</span>\nclient\n  .request(\n    HttpMethod.GET,\n    serverAddress,\n    <span class=\"hljs-number\">8080</span>,\n    <span class=\"hljs-string\">\"localhost\"</span>,\n    <span class=\"hljs-string\">\"/images/json\"</span>)\n  .expect(ResponsePredicate.SC_ACCEPTED)\n  .as(BodyCodec.jsonObject())\n  .send()\n  .onSuccess(res -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Current Docker images\"</span> + res.body()))\n  .onFailure(err -&gt;\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}