{"pageProps":{"slug":"vertx-oracle-client/java","title":"响应式的 Oracle 数据库客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_usage\">使用</a></li>\n<li><a href=\"#_getting_started\">开始使用</a></li>\n<li><a href=\"#_connecting_to_oracle\">连接 Oracle 数据库</a></li>\n<li><a href=\"#_pool_sharing\">可共享连接池</a></li>\n<li><a href=\"#_configuration\">配置</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_object\">Data Object</a></li>\n<li><a href=\"#_connection_uri\">连接 URI</a></li>\n</ul>\n</li>\n<li><a href=\"#_connect_retries\">重连</a></li>\n<li><a href=\"#_running_queries\">执行查询</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_queries\">预查询</a></li>\n<li><a href=\"#_batches\">批处理</a></li>\n</ul>\n</li>\n<li><a href=\"#_retrieving_generated_key_values\">检索生成的键值</a></li>\n<li><a href=\"#_using_connections\">使用连接</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_a_connection\">获取一条连接</a></li>\n<li><a href=\"#_simplified_connection_api\">简化的连接API</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_transactions\">使用事务</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_transactions_with_connections\">连接中使用事务操作</a></li>\n<li><a href=\"#_simplified_transaction_api\">简化版事务API</a></li>\n</ul>\n</li>\n<li><a href=\"#_cursors_and_streaming\">游标和流式操作</a></li>\n<li><a href=\"#_data_types_supported\">支持的数据类型</a></li>\n<li><a href=\"#_tracing_queries\">跟踪查询</a></li>\n<li><a href=\"#_collector_queries\">Collector 式查询</a></li>\n</ul>\n</div>","contents":"<h1>响应式的 Oracle 数据库客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>响应式的 Oracle 数据库客户端是一个以可扩展性和低开销为目标而专门为 Oracle 数据库设计的\n客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>特性</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>事件驱动</p>\n</li>\n<li>\n<p>内置连接池</p>\n</li>\n<li>\n<p>Java 8 Date 和 Time</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><strong>暂不支持</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>RxJava API</p>\n</li>\n<li>\n<p>预查询缓存</p>\n</li>\n<li>\n<p>指针</p>\n</li>\n<li>\n<p>行串流</p>\n</li>\n<li>\n<p>存储过程</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n该模块处于 tech preview 阶段\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_usage\"><a class=\"anchor\" href=\"#_usage\"></a>使用</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在您构建描述文件的 <em>dependencies</em> 里添加如下依赖来引入响应式 Oracle 客户端：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-oracle-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-oracle-client:4.2.6&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>开始使用</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如下是一种最为简单的连接、查询、关闭连接的方式</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OracleConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OracleConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1521</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the client pool</span>\n<span class=\"hljs-type\">OraclePool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> OraclePool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// A simple query</span>\nclient\n  .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;julien&#x27;&quot;</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + result.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n\n  <span class=\"hljs-comment\">// Now close the pool</span>\n  client.close();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_oracle\"><a class=\"anchor\" href=\"#_connecting_to_oracle\"></a>连接 Oracle 数据库</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>大多数情况下，您将使用连接池连接到 Oracle 数据库：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OracleConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OracleConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1521</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\n<span class=\"hljs-type\">OraclePool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> OraclePool.pool(connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>池化的 Oracle 数据库客户端使用连接池去执行数据库操作，\n所有操作都遵循从连接池里拿到连接、执行、释放连接到池里这三个步骤。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以传入一个连接池到正在运行的 Vert.x 实例里：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OracleConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OracleConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1521</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-comment\">// Create the pooled client</span>\n<span class=\"hljs-type\">OraclePool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> OraclePool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果不再需要连接池，您需要将其释放：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当您想要在同一条连接上执行多个操作时，您需要使用一个客户端的\n<code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">connection</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以很方便地从连接池里获取到一条数据库连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OracleConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OracleConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1521</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\n<span class=\"hljs-type\">OraclePool</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> OraclePool.pool(vertx, connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// Get a connection from the pool</span>\nclient.getConnection().compose(conn -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;Got a connection from the pool&quot;</span>);\n\n  <span class=\"hljs-comment\">// All operations execute on the same connection</span>\n  <span class=\"hljs-keyword\">return</span> conn\n    .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;julien&#x27;&quot;</span>)\n    .execute()\n    .compose(res -&gt; conn\n      .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;emad&#x27;&quot;</span>)\n      .execute())\n    .onComplete(ar -&gt; {\n      <span class=\"hljs-comment\">// Release the connection to the pool</span>\n      conn.close();\n    });\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    System.out.println(<span class=\"hljs-string\">&quot;Done&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Something went wrong &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了连接可以重用，一旦当前连接上的操作已经完成，您需要将数据库连接关闭并释放到连接池里。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pool_sharing\"><a class=\"anchor\" href=\"#_pool_sharing\"></a>可共享连接池</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Unresolved directive in index.adoc - include::pool_sharing.adoc[]</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您有如下几种配置客户端的可选方案。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_data_object\"><a class=\"anchor\" href=\"#_data_object\"></a>Data Object</h3>\n<div class=\"paragraph\">\n<p>通过指定 <code><a href=\"../../apidocs/io/vertx/oracleclient/OracleConnectOptions.html\">OracleConnectOptions</a></code> 数据对象是一种简单的客户端的配置方式。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OracleConnectOptions</span> <span class=\"hljs-variable\">connectOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OracleConnectOptions</span>()\n  .setPort(<span class=\"hljs-number\">1521</span>)\n  .setHost(<span class=\"hljs-string\">&quot;the-host&quot;</span>)\n  .setDatabase(<span class=\"hljs-string\">&quot;the-db&quot;</span>)\n  .setUser(<span class=\"hljs-string\">&quot;user&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>);\n\n<span class=\"hljs-comment\">// Pool Options</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pool from the data object</span>\n<span class=\"hljs-type\">OraclePool</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> OraclePool.pool(vertx, connectOptions, poolOptions);\n\npool.getConnection(ar -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection_uri\"><a class=\"anchor\" href=\"#_connection_uri\"></a>连接 URI</h3>\n<div class=\"paragraph\">\n<p>除了使用 <code><a href=\"../../apidocs/io/vertx/oracleclient/OracleConnectOptions.html\">OracleConnectOptions</a></code> 数据对象来配置连接，我们也支持使用连接 URI :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">connectionUri</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;oracle:thin:scott/tiger@myhost:1521:orcl&quot;</span>;\n\n<span class=\"hljs-comment\">// 数据库连接池设置</span>\n<span class=\"hljs-type\">PoolOptions</span> <span class=\"hljs-variable\">poolOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PoolOptions</span>().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// 使用连接 URI 创建连接池</span>\n<span class=\"hljs-type\">OraclePool</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> OraclePool.pool(connectionUri, poolOptions);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connect_retries\"><a class=\"anchor\" href=\"#_connect_retries\"></a>重连</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以配置客户端在建立连接失败的时候的重试策略。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options\n  .setReconnectAttempts(<span class=\"hljs-number\">2</span>)\n  .setReconnectInterval(<span class=\"hljs-number\">1000</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_queries\"><a class=\"anchor\" href=\"#_running_queries\"></a>执行查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您不需要事务或者只是执行一个单次查询操作，您可以直接在连接池里执行查询；\n连接池会使用某一条连接执行并给您返回结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>下边是如何执行一个简单的查询的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=&#x27;julien&#x27;&quot;</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + result.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>预查询</h3>\n<div class=\"paragraph\">\n<p>执行预查询也是一样的操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>SQL字符通过位置引用实际的参数，并使用数据库的语法 `?`</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id=?&quot;</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + rows.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>查询相关的方法为 <em>SELECT</em> 类型的操作提供了异步的 <code><a href=\"../../apidocs/io/vertx/sqlclient/RowSet.html\">RowSet</a></code> 实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;SELECT first_name, last_name FROM users&quot;</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">&quot;User &quot;</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">&quot; &quot;</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者 <em>UPDATE</em>/<em>INSERT</em> 类型的查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO users (first_name, last_name) VALUES (?, ?)&quot;</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>, <span class=\"hljs-string\">&quot;Viet&quot;</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Row对象（<code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code>）可以让您通过索引位置获取相应的数据</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">&quot;User &quot;</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">&quot; &quot;</span> + row.getString(<span class=\"hljs-number\">1</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者通过名称</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">&quot;User &quot;</span> + row.getString(<span class=\"hljs-string\">&quot;first_name&quot;</span>) + <span class=\"hljs-string\">&quot; &quot;</span> + row.getString(<span class=\"hljs-string\">&quot;last_name&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>客户端在此处没有做特殊处理，无论您的SQL文本时什么，列名都将使用数据库表中的名称标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以直接访问得到多种类型</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">firstName</span> <span class=\"hljs-operator\">=</span> row.getString(<span class=\"hljs-string\">&quot;first_name&quot;</span>);\n<span class=\"hljs-type\">Boolean</span> <span class=\"hljs-variable\">male</span> <span class=\"hljs-operator\">=</span> row.getBoolean(<span class=\"hljs-string\">&quot;male&quot;</span>);\n<span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> row.getInteger(<span class=\"hljs-string\">&quot;age&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用缓存过的预处理语句去执行一次性的预查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connectOptions.setCachePreparedStatements(<span class=\"hljs-literal\">true</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + rows.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以创建 <code>PreparedStatement</code> 并自主地管理它的生命周期。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sqlConnection\n  .prepare(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      <span class=\"hljs-type\">PreparedStatement</span> <span class=\"hljs-variable\">preparedStatement</span> <span class=\"hljs-operator\">=</span> ar.result();\n      preparedStatement.query()\n        .execute(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>), ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n            System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + rows.size() + <span class=\"hljs-string\">&quot; rows &quot;</span>);\n            preparedStatement.close();\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar2.cause().getMessage());\n          }\n        });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batches\"><a class=\"anchor\" href=\"#_batches\"></a>批处理</h3>\n<div class=\"paragraph\">\n<p>您可以在预查询中执行批处理操作</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;Tuple&gt; batch = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\nbatch.add(Tuple.of(<span class=\"hljs-string\">&quot;julien&quot;</span>, <span class=\"hljs-string\">&quot;Julien Viet&quot;</span>));\nbatch.add(Tuple.of(<span class=\"hljs-string\">&quot;emad&quot;</span>, <span class=\"hljs-string\">&quot;Emad Alblueshi&quot;</span>));\n\n<span class=\"hljs-comment\">// Execute the prepared batch</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO USERS (id, name) VALUES (?, ?)&quot;</span>)\n  .executeBatch(batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// Process rows</span>\n    RowSet&lt;Row&gt; rows = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Batch failed &quot;</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_retrieving_generated_key_values\"><a class=\"anchor\" href=\"#_retrieving_generated_key_values\"></a>检索生成的键值</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当执行 <code>INSERT</code> 查询时，您可以检索生成的键的值。</p>\n</div>\n<div class=\"paragraph\">\n<p>生成的键值会以 <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> 类型实例的形式返回。\n您可以通过调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlResult.html#property-io.vertx.sqlclient.PropertyKind-\">SqlResult.property(kind)</a></code> 方法并设置参数为 <code><a href=\"../../apidocs/io/vertx/oracleclient/OracleClient.html#GENERATED_KEYS\">OracleClient.GENERATED_KEYS</a></code> 对的方式来获取该实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过列名检索键值:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sql</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;INSERT INTO EntityWithIdentity (name, position) VALUES (?, ?)&quot;</span>;\n\n<span class=\"hljs-comment\">// 通过名称获取列的数据</span>\n<span class=\"hljs-type\">OraclePrepareOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OraclePrepareOptions</span>()\n  .setAutoGeneratedKeysIndexes(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonArray</span>().add(<span class=\"hljs-string\">&quot;ID&quot;</span>));\n\nclient.preparedQuery(sql, options).execute(Tuple.of(<span class=\"hljs-string\">&quot;john&quot;</span>, <span class=\"hljs-number\">3</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n\n    <span class=\"hljs-type\">Row</span> <span class=\"hljs-variable\">generated</span> <span class=\"hljs-operator\">=</span> result.property(OracleClient.GENERATED_KEYS);\n    <span class=\"hljs-type\">Long</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> generated.getLong(<span class=\"hljs-string\">&quot;ID&quot;</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者您也可以通过列索引的方式来获取:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sql</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;INSERT INTO EntityWithIdentity (name, position) VALUES (?, ?)&quot;</span>;\n\n<span class=\"hljs-comment\">// 通过索引获取列的数据</span>\n<span class=\"hljs-type\">OraclePrepareOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OraclePrepareOptions</span>()\n  .setAutoGeneratedKeysIndexes(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonArray</span>().add(<span class=\"hljs-string\">&quot;1&quot;</span>));\n\nclient.preparedQuery(sql, options).execute(Tuple.of(<span class=\"hljs-string\">&quot;john&quot;</span>, <span class=\"hljs-number\">3</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n\n    <span class=\"hljs-type\">Row</span> <span class=\"hljs-variable\">generated</span> <span class=\"hljs-operator\">=</span> result.property(OracleClient.GENERATED_KEYS);\n    <span class=\"hljs-type\">Long</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> generated.getLong(<span class=\"hljs-string\">&quot;ID&quot;</span>);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_connections\"><a class=\"anchor\" href=\"#_using_connections\"></a>使用连接</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>获取一条连接</h3>\n<div class=\"paragraph\">\n<p>当您要执行查询（无事务）操作时，您可以创建一条或者从连接池里拿到一条连接。\n请注意在从拿到连接到将连接释放回连接池这之间的连接状态，服务端可能由于某些原因比如空闲时间超时，而关闭这条连接。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .getConnection()\n  .compose(connection -&gt;\n    connection\n      .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (?, ?)&quot;</span>)\n      .executeBatch(Arrays.asList(\n        Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>, <span class=\"hljs-string\">&quot;Viet&quot;</span>),\n        Tuple.of(<span class=\"hljs-string\">&quot;Emad&quot;</span>, <span class=\"hljs-string\">&quot;Alblueshi&quot;</span>)\n      ))\n      .compose(res -&gt; connection\n        <span class=\"hljs-comment\">// Do something with rows</span>\n        .query(<span class=\"hljs-string\">&quot;SELECT COUNT(*) FROM Users&quot;</span>)\n        .execute()\n        .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n      .eventually(v -&gt; connection.close())\n  ).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;Insert users, now the number of users is &quot;</span> + count);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以通过连接对象创建预查询:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection\n  .prepare(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE first_name LIKE ?&quot;</span>)\n  .compose(pq -&gt;\n    pq.query()\n      .execute(Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>))\n      .eventually(v -&gt; pq.close())\n  ).onSuccess(rows -&gt; {\n  <span class=\"hljs-comment\">// All rows</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_connection_api\"><a class=\"anchor\" href=\"#_simplified_connection_api\"></a>简化的连接API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withConnection-java.util.function.Function-io.vertx.core.Handler-\">withConnection</a></code>\n并以当前连接要执行的操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这样会从连接池里拿到一条连接，并使用当前连接执行目标操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>这种方式需要返回一个future对象来表示操作结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>当这个future操作完成后，当前连接会被释放会连接池同时您也可能拿到最终的执行结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withConnection(connection -&gt;\n  connection\n    .preparedQuery(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (?, ?)&quot;</span>)\n    .executeBatch(Arrays.asList(\n      Tuple.of(<span class=\"hljs-string\">&quot;Julien&quot;</span>, <span class=\"hljs-string\">&quot;Viet&quot;</span>),\n      Tuple.of(<span class=\"hljs-string\">&quot;Emad&quot;</span>, <span class=\"hljs-string\">&quot;Alblueshi&quot;</span>)\n    ))\n    .compose(res -&gt; connection\n      <span class=\"hljs-comment\">// Do something with rows</span>\n      .query(<span class=\"hljs-string\">&quot;SELECT COUNT(*) FROM Users&quot;</span>)\n      .execute()\n      .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;Insert users, now the number of users is &quot;</span> + count);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_transactions\"><a class=\"anchor\" href=\"#_using_transactions\"></a>使用事务</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_transactions_with_connections\"><a class=\"anchor\" href=\"#_transactions_with_connections\"></a>连接中使用事务操作</h3>\n<div class=\"paragraph\">\n<p>您可以使用SQL语法 <code>BEGIN</code>/<code>COMMIT</code>/<code>ROLLBACK</code> 来执行事务操作，同时您必须使用\n<code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 并自己管理当前连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>或者您也可以使用 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> 的事务API：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection()\n  <span class=\"hljs-comment\">// Transaction must use a connection</span>\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// Begin the transaction</span>\n    conn.begin()\n      .compose(tx -&gt; conn\n        <span class=\"hljs-comment\">// Various statements</span>\n        .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Julien&#x27;,&#x27;Viet&#x27;)&quot;</span>)\n        .execute()\n        .compose(res2 -&gt; conn\n          .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Emad&#x27;,&#x27;Alblueshi&#x27;)&quot;</span>)\n          .execute())\n        <span class=\"hljs-comment\">// Commit the transaction</span>\n        .compose(res3 -&gt; tx.commit()))\n      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n      .eventually(v -&gt; conn.close())\n      .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction succeeded&quot;</span>))\n      .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction failed: &quot;</span> + err.getMessage()));\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当数据库服务端返回当前事务已失败（比如常见的 <em>current transaction is aborted, commands ignored until end of transaction block</em>）\n，事务已回滚和 <code><a href=\"../../apidocs/io/vertx/sqlclient/Transaction.html#completion--\">completion</a></code> 方法的返回值future返回了\n<code><a href=\"../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html\">TransactionRollbackException</a></code> 异常时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">tx.completion()\n  .onFailure(err -&gt; {\n    System.out.println(<span class=\"hljs-string\">&quot;Transaction failed =&gt; rolled back&quot;</span>);\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_transaction_api\"><a class=\"anchor\" href=\"#_simplified_transaction_api\"></a>简化版事务API</h3>\n<div class=\"paragraph\">\n<p>当您使用连接池时，您可以调用 <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withTransaction-java.util.function.Function-io.vertx.core.Handler-\">withTransaction</a></code> 方法\n并传递待执行的事务操作作为参数。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将会从连接池里拿到一条连接，开启事务并调用待执行操作，配合客户端一起执行该事务范围内\n的所有操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>待执行操作需要返回一个future来表示可能产生的结果：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当future成功时，客户端提交该事务</p>\n</li>\n<li>\n<p>当future失败时，客户端回滚该事务</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>事务操作完成后，连接会被释放回连接池，并且可以获取到最终的操作结果。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withTransaction(client -&gt; client\n  .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Julien&#x27;,&#x27;Viet&#x27;)&quot;</span>)\n  .execute()\n  .flatMap(res -&gt; client\n    .query(<span class=\"hljs-string\">&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Emad&#x27;,&#x27;Alblueshi&#x27;)&quot;</span>)\n    .execute()\n    <span class=\"hljs-comment\">// Map to a message result</span>\n    .map(<span class=\"hljs-string\">&quot;Users inserted&quot;</span>)))\n  .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction succeeded&quot;</span>))\n  .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">&quot;Transaction failed: &quot;</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cursors_and_streaming\"><a class=\"anchor\" href=\"#_cursors_and_streaming\"></a>游标和流式操作</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下预查询操作会拉去所有的行记录，您可以使用\n<code><a href=\"../../apidocs/io/vertx/sqlclient/Cursor.html\">游标</a></code> 来控制您想要读取的行数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE age &gt; ?&quot;</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    <span class=\"hljs-type\">PreparedStatement</span> <span class=\"hljs-variable\">pq</span> <span class=\"hljs-operator\">=</span> ar1.result();\n\n    <span class=\"hljs-comment\">// Create a cursor</span>\n    <span class=\"hljs-type\">Cursor</span> <span class=\"hljs-variable\">cursor</span> <span class=\"hljs-operator\">=</span> pq.cursor(Tuple.of(<span class=\"hljs-number\">18</span>));\n\n    <span class=\"hljs-comment\">// Read 50 rows</span>\n    cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        RowSet&lt;Row&gt; rows = ar2.result();\n\n        <span class=\"hljs-comment\">// Check for more ?</span>\n        <span class=\"hljs-keyword\">if</span> (cursor.hasMore()) {\n          <span class=\"hljs-comment\">// Repeat the process...</span>\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// No more rows - close the cursor</span>\n          cursor.close();\n        }\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>游标释放时需要同时执行关闭操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cursor.read(<span class=\"hljs-number\">50</span>, ar2 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n    <span class=\"hljs-comment\">// Close the cursor</span>\n    cursor.close();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>stream API也可以用于游标，尤其是在Rx版的客户端，可能更为方便。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.prepare(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE age &gt; ?&quot;</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    <span class=\"hljs-type\">PreparedStatement</span> <span class=\"hljs-variable\">pq</span> <span class=\"hljs-operator\">=</span> ar1.result();\n\n    <span class=\"hljs-comment\">// Fetch 50 rows at a time</span>\n    RowStream&lt;Row&gt; stream = pq.createStream(<span class=\"hljs-number\">50</span>, Tuple.of(<span class=\"hljs-number\">18</span>));\n\n    <span class=\"hljs-comment\">// Use the stream</span>\n    stream.exceptionHandler(err -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Error: &quot;</span> + err.getMessage());\n    });\n    stream.endHandler(v -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;End of stream&quot;</span>);\n    });\n    stream.handler(row -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;User: &quot;</span> + row.getString(<span class=\"hljs-string\">&quot;last_name&quot;</span>));\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上边的stream会批量读取 <code>50</code> 行并同时将其转换为流，当这些行记录被传递给处理器时，\n会以此类推地读取下一批的 <code>50</code> 行记录。</p>\n</div>\n<div class=\"paragraph\">\n<p>stream支持重启或暂停，已经加载到的行记录将会被保留在内存里直到被传递给处理器，此时\n游标也将终止遍历。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_data_types_supported\"><a class=\"anchor\" href=\"#_data_types_supported\"></a>支持的数据类型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>目前，客户端支持以下Oracle数据类型：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>CHAR/VARCHAR2(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>NCHAR/NVARCHAR2(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>NUMBER(<code><a href=\"../../apidocs/java/math/BigDecimal.html\">BigDecimal</a></code>)</p>\n</li>\n<li>\n<p>FLOAT(<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>DATE(<code>java.time.LocalDate</code>)</p>\n</li>\n<li>\n<p>TIMESTAMP(<code>java.time.LocalDateTime</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Tuple（元组）解码在存储值时使用上述类型。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>跟踪查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当Vert.x启用tracing功能时，SQL客户端可以跟踪查询的执行情况。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端会上报下列这些 <em>client</em> spans：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> 操作名称</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>db.user</code> ：数据库用户名</p>\n</li>\n<li>\n<p><code>db.instance</code> ：数据库实例</p>\n</li>\n<li>\n<p><code>db.statement</code> ：SQL语句</p>\n</li>\n<li>\n<p><code>db.type</code> ：<em>sql</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认的 tracing 策略时 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>，客户端\n在一个活跃trace里只创建一个span。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnectOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code> 方法来调整tracing策略，\n例如您可以设置为 <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code>，\n客户端将始终上报span：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector 式查询</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以将 Java 的 collector 与查询 API 结合使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, Map&lt;Long, String&gt;&gt; collector = Collectors.toMap(\n  row -&gt; row.getLong(<span class=\"hljs-string\">&quot;id&quot;</span>),\n  row -&gt; row.getString(<span class=\"hljs-string\">&quot;last_name&quot;</span>));\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">&quot;SELECT * FROM users&quot;</span>).collecting(collector).execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;Map&lt;Long, String&gt;&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the map created by the collector</span>\n      Map&lt;Long, String&gt; map = result.value();\n      System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + map);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>collector 式查询获取的结果集处理过程中不能再拿到 <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> 的引用，因为\noracle 数据库客户端在处理 collector 时，只会用一个 row 用于处理整个集合。</p>\n</div>\n<div class=\"paragraph\">\n<p>Java 的 <code>Collectors</code> 类提供了很多有趣的预定义的 collector，比如您可以很容易\n从 row 集合里得到一个字符串：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, String&gt; collector = Collectors.mapping(\n  row -&gt; row.getString(<span class=\"hljs-string\">&quot;last_name&quot;</span>),\n  Collectors.joining(<span class=\"hljs-string\">&quot;,&quot;</span>, <span class=\"hljs-string\">&quot;(&quot;</span>, <span class=\"hljs-string\">&quot;)&quot;</span>)\n);\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">&quot;SELECT * FROM users&quot;</span>).collecting(collector).execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;String&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the string created by the collector</span>\n      <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> result.value();\n      System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + list);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}