{"pageProps":{"slug":"4.0.0/vertx-health-check/java","title":"Vert.x 健康检查","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_health_checks\">如何使用 Vert.x 健康检查</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_the_health_check_object\">创建健康检查对象。</a></li>\n<li><a href=\"#_registering_the_vert_x_web_handler\">注册 Vert.x Web handler</a></li>\n</ul>\n</li>\n<li><a href=\"#_procedures\">例程（procedures）</a></li>\n<li><a href=\"#_http_responses_and_json_output\">HTTP 响应和 JSON 输出</a></li>\n<li><a href=\"#_examples_of_procedures\">例程示例</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_sql_client\">SQL client</a></li>\n<li><a href=\"#_service_availability\">服务可用性</a></li>\n<li><a href=\"#_event_bus\">事件总线</a></li>\n</ul>\n</li>\n<li><a href=\"#_authentication\">身份认证</a></li>\n<li><a href=\"#_exposing_health_checks_on_the_event_bus\">在事件总线上开放健康检查功能</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x 健康检查</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>该组件提供了一个简单的检视健康状况的途径。\n健康检查组件使用非常简单的措辞来表达应用程序的当前状况： <em>UP</em> 以及 <em>DOWN</em> 。\n健康检查组件可以单独使用，也可以和 Vert.x Web 或者事件总线联合使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>该组件提供一个 Vert.x Web handler 让您可以注册一些（检测）例程\n用于检测应用程序的健康状况。\n该 handler 计算出（健康状况的）最终状态并以 JSON 方式返回结果。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_health_checks\"><a class=\"anchor\" href=\"#_using_vert_x_health_checks\"></a>如何使用 Vert.x 健康检查</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>请注意，一般情况下您需要 Vert.x Web 模块来使用该组件。启用该组件只需要添加以下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-health-check<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-health-check:4.0.0&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_the_health_check_object\"><a class=\"anchor\" href=\"#_creating_the_health_check_object\"></a>创建健康检查对象。</h3>\n<div class=\"paragraph\">\n<p>最主要的对象是 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/HealthChecks.html\">HealthChecks</a></code> 。 您可以通过以下方式创建该对象的实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HealthChecks</span> <span class=\"hljs-variable\">hc</span> <span class=\"hljs-operator\">=</span> HealthChecks.create(vertx);\n\nhc.register(\n  <span class=\"hljs-string\">&quot;my-procedure&quot;</span>,\n  promise -&gt; promise.complete(Status.OK()));\n\n<span class=\"hljs-comment\">// 注册时指定超时时间参数。如果未能在超时时间之内完成，则视为故障。</span>\n<span class=\"hljs-comment\">// timeout 参数的单位是毫秒。</span>\nhc.register(\n  <span class=\"hljs-string\">&quot;my-procedure&quot;</span>,\n  <span class=\"hljs-number\">2000</span>,\n  promise -&gt; promise.complete(Status.OK()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦您创建了这个对象，您就可以注册或者注销（检测）例程。详情请见后面的章节。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_registering_the_vert_x_web_handler\"><a class=\"anchor\" href=\"#_registering_the_vert_x_web_handler\"></a>注册 Vert.x Web handler</h3>\n<div class=\"paragraph\">\n<p>您可以通过以下方式创建用于健康检查的 Vert.x Web handler ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>使用已有的 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/HealthChecks.html\">HealthChecks</a></code> 对象实例</p>\n</li>\n<li>\n<p>让 handler 为您创建一个新的对象实例。</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HealthCheckHandler</span> <span class=\"hljs-variable\">healthCheckHandler1</span> <span class=\"hljs-operator\">=</span> HealthCheckHandler.create(vertx);\n\n<span class=\"hljs-type\">HealthCheckHandler</span> <span class=\"hljs-variable\">healthCheckHandler2</span> <span class=\"hljs-operator\">=</span> HealthCheckHandler\n  .createWithHealthChecks(HealthChecks.create(vertx));\n\n<span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n<span class=\"hljs-comment\">// 向 router 添加路由规则</span>\n<span class=\"hljs-comment\">// 注册健康检查 handler</span>\nrouter.get(<span class=\"hljs-string\">&quot;/health*&quot;</span>).handler(healthCheckHandler1);\n<span class=\"hljs-comment\">// 或者</span>\nrouter.get(<span class=\"hljs-string\">&quot;/ping*&quot;</span>).handler(healthCheckHandler2);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以直接在 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/HealthCheckHandler.html\">HealthCheckHandler</a></code> 对象实例中注册例程。\n此外，如果您已经预先创建了 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/HealthChecks.html\">HealthChecks</a></code> 对象的实例，\n您可以直接在该对象中注册例程。\n在任何时刻都可以进行例程的注册和注销，即使在路由规则注册完成之后也可以：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HealthCheckHandler</span> <span class=\"hljs-variable\">healthCheckHandler</span> <span class=\"hljs-operator\">=</span> HealthCheckHandler.create(vertx);\n\n<span class=\"hljs-comment\">// 注册例程</span>\n<span class=\"hljs-comment\">// 在路由规则注册完成之后，甚至是运行时，也可以完成该操作</span>\nhealthCheckHandler.register(<span class=\"hljs-string\">&quot;my-procedure-name&quot;</span>, promise -&gt; {\n  <span class=\"hljs-comment\">// 进行检测 ....</span>\n  <span class=\"hljs-comment\">// 检测通过时执行</span>\n  promise.complete(Status.OK());\n  <span class=\"hljs-comment\">// 如果发生故障则执行：</span>\n  promise.complete(Status.KO());\n});\n\n<span class=\"hljs-comment\">// 注册另一个指定了超时时间（2秒）的例程。 如果该例程未能在</span>\n<span class=\"hljs-comment\">// 指定的超时时间内完成，则视为故障。</span>\nhealthCheckHandler.register(\n  <span class=\"hljs-string\">&quot;my-procedure-name-with-timeout&quot;</span>,\n  <span class=\"hljs-number\">2000</span>,\n  promise -&gt; {\n    <span class=\"hljs-comment\">// 进行检测 ....</span>\n    <span class=\"hljs-comment\">// 检测通过时执行</span>\n    promise.complete(Status.OK());\n    <span class=\"hljs-comment\">// 如果发生故障则执行：</span>\n    promise.complete(Status.KO());\n  });\n\nrouter.get(<span class=\"hljs-string\">&quot;/health&quot;</span>).handler(healthCheckHandler);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_procedures\"><a class=\"anchor\" href=\"#_procedures\"></a>例程（procedures）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>此处的例程是指一个检查系统某个表征现象的函数，用于推断当前的健康状况。\n它报告一个 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/Status.html\">Status</a></code> 对象用以指示该项检测是否通过。\n该函数将检测结果报告给它所对应的 <code><a href=\"../../apidocs/io/vertx/core/Promise.html\">Promise</a></code> ，并且请注意该函数不可以阻塞这个 <code><a href=\"../../apidocs/io/vertx/core/Promise.html\">Promise</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>当您注册了一个例程，您需要对其命名，并且要指定一个函数（handler）来执行该项检测。</p>\n</div>\n<div class=\"paragraph\">\n<p>推断健康状况的规则如下：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>如果对应的 promise 被标记为故障，则检测结果认定为 <em>KO</em></p>\n</li>\n<li>\n<p>如果对应的 promise 成功完成但是没有包含一个 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/Status.html\">Status</a></code> 对象，\n检测结果认定为 <em>OK</em>。</p>\n</li>\n<li>\n<p>如果对应的 promise 成功完成且包含一个标记为 <em>OK</em> 的 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/Status.html\">Status</a></code> 对象，\n检测结果认定为 <em>OK</em>。</p>\n</li>\n<li>\n<p>如果对应的 promise 成功完成且包含一个标记为 <em>KO</em> 的 <code><a href=\"../../apidocs/io/vertx/ext/healthchecks/Status.html\">Status</a></code> 对象，\n检测结果认定为 <em>KO</em>。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/healthchecks/Status.html\">Status</a></code> 对象可以提供额外的数据：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HealthCheckHandler</span> <span class=\"hljs-variable\">healthCheckHandler</span> <span class=\"hljs-operator\">=</span> HealthCheckHandler.create(vertx);\n\n<span class=\"hljs-comment\">// Status 对象能以 JSON 形式提供额外的数据</span>\nhealthCheckHandler.register(<span class=\"hljs-string\">&quot;my-procedure-name&quot;</span>, promise -&gt; {\n  promise.complete(Status.OK(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;available-memory&quot;</span>, <span class=\"hljs-string\">&quot;2mb&quot;</span>)));\n});\n\nhealthCheckHandler.register(<span class=\"hljs-string\">&quot;my-second-procedure-name&quot;</span>, promise -&gt; {\n  promise.complete(Status.KO(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;load&quot;</span>, <span class=\"hljs-number\">99</span>)));\n});\n\nrouter.get(<span class=\"hljs-string\">&quot;/health&quot;</span>).handler(healthCheckHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>例程可以进行分组管理。 例程的名称里可以指定分组信息。 分组的例程按照树形结构进行组织，\n并且树形结构被映射到 HTTP url 之上（如下所示）。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HealthCheckHandler</span> <span class=\"hljs-variable\">healthCheckHandler</span> <span class=\"hljs-operator\">=</span> HealthCheckHandler.create(vertx);\n\n<span class=\"hljs-comment\">// 注册例程</span>\n<span class=\"hljs-comment\">// 例程可以进行分组，以例程名称中的 “/” 分隔符来判断组别</span>\n<span class=\"hljs-comment\">// 一个分组中也可以包含另一个分组</span>\nhealthCheckHandler.register(\n  <span class=\"hljs-string\">&quot;a-group/my-procedure-name&quot;</span>,\n  promise -&gt; {\n    <span class=\"hljs-comment\">//....</span>\n  });\nhealthCheckHandler.register(\n  <span class=\"hljs-string\">&quot;a-group/a-second-group/my-second-procedure-name&quot;</span>,\n  promise -&gt; {\n    <span class=\"hljs-comment\">//....</span>\n  });\n\nrouter.get(<span class=\"hljs-string\">&quot;/health&quot;</span>).handler(healthCheckHandler);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_http_responses_and_json_output\"><a class=\"anchor\" href=\"#_http_responses_and_json_output\"></a>HTTP 响应和 JSON 输出</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>启用 Vert.x web handler 之后，可以通过对外开放的\n<code><a href=\"../../apidocs/io/vertx/ext/healthchecks/HealthCheckHandler.html\">HealthCheckHandler</a></code> 所对应的路由规则\n以 HTTP GET 或者 POST （取决于您注册的路由规则）的方式获取总体健康检查信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果没有注册任何例程， 则响应信息为 <code>204 - NO CONTENT</code> ， 表明系统状态为 <em>UP</em> 但是没有执行任何例程。\n此时响应信息不包含任何有效数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果注册了至少一个例程，该例程将被执行并计算出检测结果。\n响应码包括下列几种：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>200</code> : 一切正常</p>\n</li>\n<li>\n<p><code>503</code> : 至少有一个例程报告了不健康状态</p>\n</li>\n<li>\n<p><code>500</code> : 某个例程抛出了错误，或者未能及时报告状态</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>响应的内容是一个 JSON 文档，体现的是总体结果（<code>outcome</code>）。总体结果要么是 <code>UP</code> 要么是 <code>DOWN</code> 。\n此外还给出了一个 <code>checks</code> 数组用以显示每个执行过的例程的结果。\n如果某个例程报告了额外的数据，这些数据也会一并给出：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>{\n\"checks\" : [\n{\n  \"id\" : \"A\",\n  \"status\" : \"UP\"\n},\n{\n  \"id\" : \"B\",\n  \"status\" : \"DOWN\",\n  \"data\" : {\n    \"some-data\" : \"some-value\"\n  }\n}\n],\n\"outcome\" : \"DOWN\"\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果采用了分组/层级结构，则 <code>checks</code> 数组通过以下结构来描述：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>{\n\"checks\" : [\n{\n  \"id\" : \"my-group\",\n  \"status\" : \"UP\",\n  \"checks\" : [\n  {\n    \"id\" : \"check-2\",\n    \"status\" : \"UP\",\n  },\n  {\n    \"id\" : \"check-1\",\n    \"status\" : \"UP\"\n  }]\n}],\n\"outcome\" : \"UP\"\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果一个例程抛出了错误，或者报告了故障（异常），该 JSON 文档会在 <code>data</code> 字段下给出 <code>cause</code> 字段。\n如果某个例程未能及时上报结果，则结果将显示为 <code>Timeout</code> （超时）。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_examples_of_procedures\"><a class=\"anchor\" href=\"#_examples_of_procedures\"></a>例程示例</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>此章节提供一些通用的健康检查示例</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sql_client\"><a class=\"anchor\" href=\"#_sql_client\"></a>SQL client</h3>\n<div class=\"paragraph\">\n<p>该例子用以报告一个数据库连接是否成功建立：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">handler.register(<span class=\"hljs-string\">&quot;database&quot;</span>,\n  promise -&gt; pool.getConnection(connection -&gt; {\n    <span class=\"hljs-keyword\">if</span> (connection.failed()) {\n      promise.fail(connection.cause());\n    } <span class=\"hljs-keyword\">else</span> {\n      connection.result().close();\n      promise.complete(Status.OK());\n    }\n  }));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_service_availability\"><a class=\"anchor\" href=\"#_service_availability\"></a>服务可用性</h3>\n<div class=\"paragraph\">\n<p>该项检测用于报告某个服务（此处是指一个HTTP endpoint）在服务发现中是否可用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">handler.register(<span class=\"hljs-string\">&quot;my-service&quot;</span>,\n  promise -&gt;\n    HttpEndpoint.getClient(discovery, rec -&gt; <span class=\"hljs-string\">&quot;my-service&quot;</span>.equals(rec.getName()),\n      client -&gt; {\n        <span class=\"hljs-keyword\">if</span> (client.failed()) {\n          promise.fail(client.cause());\n        } <span class=\"hljs-keyword\">else</span> {\n          client.result().close();\n          promise.complete(Status.OK());\n        }\n      }));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_event_bus\"><a class=\"anchor\" href=\"#_event_bus\"></a>事件总线</h3>\n<div class=\"paragraph\">\n<p>该项检测用于报告某个事件总线上的某个消费者是否已经准备就绪。\n在这个例子中，是一个简单的 ping/pong 应答协议，您也可以换成别的更为复杂的场景。\n该项检测可以用于检查某个 verticle 是否已经准备就绪并且已在监听某个事件总线地址。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">handler.register(<span class=\"hljs-string\">&quot;receiver&quot;</span>,\n  promise -&gt;\n    vertx.eventBus().request(<span class=\"hljs-string\">&quot;health&quot;</span>, <span class=\"hljs-string\">&quot;ping&quot;</span>)\n      .onSuccess(msg -&gt; {\n        promise.complete(Status.OK());\n      })\n      .onFailure(err -&gt; {\n        promise.complete(Status.KO());\n      }));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authentication\"><a class=\"anchor\" href=\"#_authentication\"></a>身份认证</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当使用 Vert.x web handler 时，\n您可以传入一个 <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code> 对象用来对请求进行身份认证。\n详情请查阅 <code><a href=\"http://vertx.io/docs/#authentication_and_authorisation\">Vert.x Auth</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web handler 创建一个 JSON 对象包含以下内容：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>请求头</p>\n</li>\n<li>\n<p>请求参数</p>\n</li>\n<li>\n<p>表单参数（如果存在）</p>\n</li>\n<li>\n<p>JOSN 格式的内容（如果存在，并且请求的 content type 是 <code>application/json</code> ）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>上述对象会被传入身份认证方式提供者来对请求进行身份认证。\n如果认证失败，则会返回 <code>403 - FORBIDDEN</code> 响应。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_exposing_health_checks_on_the_event_bus\"><a class=\"anchor\" href=\"#_exposing_health_checks_on_the_event_bus\"></a>在事件总线上开放健康检查功能</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>利用 Vert.x web handler 通过 HTTP 方式开放健康检查功能是十分便捷的，但是通过别的方式开放这些数据可以发挥更大的作用。\n以下章节给出了如何在事件总线上开放健康检查数据的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.eventBus().consumer(<span class=\"hljs-string\">&quot;health&quot;</span>,\n  message -&gt; healthChecks.checkStatus()\n    .onSuccess(message::reply)\n    .onFailure(err -&gt; message.fail(<span class=\"hljs-number\">0</span>, err.getMessage())));</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}