{"pageProps":{"slug":"4.1.2/vertx-unit/java","title":"Vertx unit","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_introduction\">介绍</a></li>\n<li><a href=\"#_writing_a_test_suite\">编写一个测试套件</a></li>\n<li><a href=\"#_asserting\">断言</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_assertequals\">assertEquals</a></li>\n<li><a href=\"#_assertnotequals\">assertNotEquals</a></li>\n<li><a href=\"#_assertnull\">assertNull</a></li>\n<li><a href=\"#_assertnotnull\">assertNotNull</a></li>\n<li><a href=\"#_assertinrange\">assertInRange</a></li>\n<li><a href=\"#_asserttrue_and_assertfalse\">断言成功以及断言失败</a></li>\n<li><a href=\"#_failing\">失败</a></li>\n<li><a href=\"#_using_third_party_assertion_framework\">使用第三方断言框架</a></li>\n</ul>\n</li>\n<li><a href=\"#_asynchronous_testing\">异步测试</a></li>\n<li><a href=\"#_asynchronous_assertions\">异步断言</a></li>\n<li><a href=\"#_repeating_test\">重复测试</a></li>\n<li><a href=\"#_sharing_objects\">共享对象</a></li>\n<li><a href=\"#_running\">运行</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_test_suite_completion\">测试套件执行完毕</a></li>\n<li><a href=\"#_time_out\">超时</a></li>\n<li><a href=\"#_event_loop\">事件循环（Event loop）</a></li>\n</ul>\n</li>\n<li><a href=\"#_reporting\">测试报告</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_console_reporting\">控制台报告</a></li>\n<li><a href=\"#_file_reporting\">文件报告</a></li>\n<li><a href=\"#_log_reporting\">日志报告</a></li>\n<li><a href=\"#_event_bus_reporting\">事件总线报告</a></li>\n</ul>\n</li>\n<li><a href=\"#_vertx_integration\">Vertx 整合</a></li>\n<li><a href=\"#_junit_integration\">Junit 整合</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_running_a_test_on_a_vert_x_context\">在 Vert.x 上下文中执行一个测试</a></li>\n<li><a href=\"#_timeout\">超时</a></li>\n<li><a href=\"#_parameterized_tests\">参数化测试</a></li>\n<li><a href=\"#_repeating_a_test\">重复测试</a></li>\n<li><a href=\"#_using_with_other_assertion_libraries\">用其他断言库</a></li>\n</ul>\n</li>\n<li><a href=\"#_java_language_integration\">Java 语言整合</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_test_suite_integration\">测试套件整合</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vertx unit</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>异步多语言单元测试。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_introduction\"><a class=\"anchor\" href=\"#_introduction\"></a>介绍</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Unit 用多语言的异步API在JVM上 运行单元测试。\nVert.x Unit 借鉴了已有的测试框架，例如 <a href=\"http://junit.org\">JUnit</a> or <a href=\"http://qunitjs.com\">QUnit</a>\n并同时遵循了Vert.x的做法。</p>\n</div>\n<div class=\"paragraph\">\n<p>所以 Vert.x Unit 自然就成为了测试 Vert.x 应用的选择。</p>\n</div>\n<div class=\"paragraph\">\n<p>要使用 Vert.x Unit，\n那么请添加如下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在您的 <code>pom.xml</code> 文件）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-unit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在您的 <code>build.gradle</code> 文件）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">testCompile ${io.vertx}:${vertx-unit}:<span class=\"hljs-number\">4.1</span><span class=\"hljs-number\">.2</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Unit 能够以各种方式使用并可以在您代码中任何位置运行，它仅以正确的方式报告执行结果。\n以下示例展示了一个最简的测试用例套件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-string\">&quot;the_test_suite&quot;</span>);\nsuite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value&quot;</span>;\n  context.assertEquals(<span class=\"hljs-string\">&quot;value&quot;</span>, s);\n});\nsuite.run();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>run</code> 方法执行了整个套件并且执行套件中所有的测试用例。\n测试用例套件可能失败也可能通过。如果外界不关心测试结果，\n那么测试用例的通过与否便不重要。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-string\">&quot;the_test_suite&quot;</span>);\nsuite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value&quot;</span>;\n  context.assertEquals(<span class=\"hljs-string\">&quot;value&quot;</span>, s);\n});\nsuite.run(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TestOptions</span>().addReporter(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReportOptions</span>().setTo(<span class=\"hljs-string\">&quot;console&quot;</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>执行之时，测试套件会在控制台报告每一步的结果：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>Begin test suite the_test_suite\nBegin test my_test\nPassed my_test\nEnd test suite the_test_suite , run: 1, Failures: 0, Errors: 0</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>reporters</code> 选项配置了套件执行器的reporter，用以报告测试用例执行结果，\n更多信息详见 <a href=\"#reporting\">[reporting]</a> 章节</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_writing_a_test_suite\"><a class=\"anchor\" href=\"#_writing_a_test_suite\"></a>编写一个测试套件</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>测试套件是一系列测试用例组成的有名称的集合，测试用例则是一个直接回调。\n套件生命周期中可以设置回调函数，这些函数可以在执行测试用例前后执行，\n也可以在用作初始化/发布服务的套件前后。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-string\">&quot;the_test_suite&quot;</span>);\nsuite.test(<span class=\"hljs-string\">&quot;my_test_case_1&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 1</span>\n});\nsuite.test(<span class=\"hljs-string\">&quot;my_test_case_2&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 2</span>\n});\nsuite.test(<span class=\"hljs-string\">&quot;my_test_case_3&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 3</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>流式API让测试用例可以作链式调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-string\">&quot;the_test_suite&quot;</span>);\nsuite.test(<span class=\"hljs-string\">&quot;my_test_case_1&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 1</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_2&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 2</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_3&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 3</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>测试用例的声明顺序并不保证其执行顺序，所以测试用例不可以依赖于其他测试用例来运行。\n这不是一个好的做法。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Unit 提供了 <em>before</em> 和 <em>after</em> 回调来作总体的启动或清理资源操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-string\">&quot;the_test_suite&quot;</span>);\nsuite.before(context -&gt; {\n  <span class=\"hljs-comment\">// 测试套件启动</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_1&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 1</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_2&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 2</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_3&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 3</span>\n}).after(context -&gt; {\n  <span class=\"hljs-comment\">// 测试套件清理资源</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这些方法的声明顺序并不重要，示例中在用例之前声明 <em>before</em> ，\n在用例之后声明 <em>after</em> ，\n然而在运行套件之前，他们可以在任何位置声明，</p>\n</div>\n<div class=\"paragraph\">\n<p><em>before</em> 回调函数执行于所有测试用例之前，如果其运行失败，\n则整个测试套件将停止运行并报告失败结果。 <em>after</em> 回调函数在整个测试套件中最后执行，\n除非 <em>before</em> 回调函数运行失败。</p>\n</div>\n<div class=\"paragraph\">\n<p>类似的，Vert.x Unit 提供了 <em>beforeEach</em> 和 <em>afterEach</em> 回调，\n在每一个测试用例前后执行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-string\">&quot;the_test_suite&quot;</span>);\nsuite.beforeEach(context -&gt; {\n  <span class=\"hljs-comment\">// 测试用例启动</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_1&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 1</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_2&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 2</span>\n}).test(<span class=\"hljs-string\">&quot;my_test_case_3&quot;</span>, context -&gt; {\n  <span class=\"hljs-comment\">// Test 3</span>\n}).afterEach(context -&gt; {\n  <span class=\"hljs-comment\">// 测试用例资源清理</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>beforeEach</em> 回调函数执行于每一个测试用例之前，一旦其运行失败，那测试用例将不再被执行，\n并报告失败结果。 <em>afterEach</em> 回调函数仅在测试用例之后被执行，\n除非 <em>beforeEach</em> 函数运行失败。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_asserting\"><a class=\"anchor\" href=\"#_asserting\"></a>断言</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Unit 提供了 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\">TestContext</a></code> 对象用来在测试用例中作断言操作。\n<em>context</em> 对象提供了用于断言的常用方法。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_assertequals\"><a class=\"anchor\" href=\"#_assertequals\"></a>assertEquals</h3>\n<div class=\"paragraph\">\n<p>断言两个对象相等，适用于 <em>基本类型</em> 和 <em>json类型</em> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  context.assertEquals(<span class=\"hljs-number\">10</span>, callbackCount);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>有一个重载的方法用于提供测试信息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  context.assertEquals(<span class=\"hljs-number\">10</span>, callbackCount, <span class=\"hljs-string\">&quot;Should have been 10 instead of &quot;</span> + callbackCount);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通常地，每一个断言函数都提供了重载的版本。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_assertnotequals\"><a class=\"anchor\" href=\"#_assertnotequals\"></a>assertNotEquals</h3>\n<div class=\"paragraph\">\n<p>与 <em>assertEquals</em> 相反。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  context.assertNotEquals(<span class=\"hljs-number\">10</span>, callbackCount);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_assertnull\"><a class=\"anchor\" href=\"#_assertnull\"></a>assertNull</h3>\n<div class=\"paragraph\">\n<p>断言一个对象是null，适用于 <em>基本类型</em> 和 <em>json类型</em> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  context.assertNull(<span class=\"hljs-literal\">null</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_assertnotnull\"><a class=\"anchor\" href=\"#_assertnotnull\"></a>assertNotNull</h3>\n<div class=\"paragraph\">\n<p>与 <em>assertNull</em> 相反。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  context.assertNotNull(<span class=\"hljs-string\">&quot;not null!&quot;</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_assertinrange\"><a class=\"anchor\" href=\"#_assertinrange\"></a>assertInRange</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#assertInRange-double-double-double-\">assertInRange</a></code> 方法作用于实数范围。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>suite.test(\"my_test_case\", context -&gt; {\n\n  // 断言0.1 在误差范围 +/- 0.5范围内等于0.2\n\n  context.assertInRange(0.1, 0.2, 0.5);\n});</pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_asserttrue_and_assertfalse\"><a class=\"anchor\" href=\"#_asserttrue_and_assertfalse\"></a>断言成功以及断言失败</h3>\n<div class=\"paragraph\">\n<p>对于布尔表达式的断言。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  context.assertTrue(<span class=\"hljs-keyword\">var</span>);\n  context.assertFalse(value &gt; <span class=\"hljs-number\">10</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_failing\"><a class=\"anchor\" href=\"#_failing\"></a>失败</h3>\n<div class=\"paragraph\">\n<p>最后但并非最不重要的，<em>test</em> 提供了一个 <em>fail</em> 方法用来抛出断言错误的异常：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  context.fail(<span class=\"hljs-string\">&quot;That should never happen&quot;</span>);\n  <span class=\"hljs-comment\">// 剩下的代码不会执行。</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>失败</code> 对象本身既可以是 <em>string</em> 也可以是一个 <em>error</em> 。\n<em>error</em> 对象取决于所使用的编程语言，对于 Java 或者 Groovy 而言，可以是任何 <em>Throwable</em> 的子类，\n对于 JavaScript 则是一个 <em>error</em> ，对于 Ruby 则是一个 <em>Exception</em>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_third_party_assertion_framework\"><a class=\"anchor\" href=\"#_using_third_party_assertion_framework\"></a>使用第三方断言框架</h3>\n<div class=\"paragraph\">\n<p>您也可以用任何其他的断言框架，例如比较流行的 <em>hamcrest</em> 和 <em>assertj</em> 。\n我们建议您用 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#verify-io.vertx.core.Handler-\">verify</a></code> ，\n使用我们提供的 <em>处理器（Handler）</em> 来执行断言。\n这样的话，我们才能正确的处理异步测试的结束动作。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; context.verify(v -&gt; {\n  <span class=\"hljs-comment\">// 这里 junit中的 Assert 对象可以是 assertj hamcrest或其他库中的Assert对象</span>\n  <span class=\"hljs-comment\">// 甚至可以手动抛出 AssertionError</span>\n  Assert.assertNotNull(<span class=\"hljs-string\">&quot;not null!&quot;</span>);\n  Assert.assertEquals(<span class=\"hljs-number\">10</span>, callbackCount);\n}));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_asynchronous_testing\"><a class=\"anchor\" href=\"#_asynchronous_testing\"></a>异步测试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>前述示例的前提是，假设所有的测试用例在各自回调之后会结束，\n这是测试用例回调函数的默认行为。在测试用例回调函数之后结束测试是可取的，\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Async 对象异步的完成测试用例</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  <span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\n  eventBus.consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>, msg -&gt; {\n    <b class=\"conum\">(2)</b>\n    async.complete();\n  });\n  <b class=\"conum\">(1)</b>\n});</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>回调函数结束，但是测试用例没结束</p>\n</li>\n<li>\n<p>总线事件的回调函数来终止测试</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>用 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#async--\">async</a></code> 方法创建一个 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html\">Async</a></code> 对象表示测试用例还未结束。\n当执行 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html#complete--\">complete</a></code> 方法时，\n测试用例才算结束。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n当 <code>complete</code> 回调函数未被执行时，测试用例会在指定超时时间之后失败。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>同一个测试用例中可以创建多个 <code>Async</code> 对象，\n必须调用所有Async对象的 <em>completed</em> 方法来终止测试。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">多个Async对象合作</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n\n  <span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\n  client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>, context.asyncAssertSuccess(req -&gt; {\n      req.send(context.asyncAssertSuccess(resp -&gt; {\n        context.assertEquals(<span class=\"hljs-number\">200</span>, resp.statusCode());\n      }));\n    }));\n\n  <span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\n  vertx.eventBus().consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>, msg -&gt; {\n    async.complete();\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Async 对象也可以用在 <em>before</em> 或 <em>after</em> 回调中，\n这将很方便的在 <em>before</em> 回调中，实现依赖于多个异步结果的启动操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">执行测试用例之前异步启动 http server</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.before(context -&gt; {\n  <span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\n  <span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer();\n  server.requestHandler(requestHandler);\n  server.listen(<span class=\"hljs-number\">8080</span>, ar -&gt; {\n    context.assertTrue(ar.succeeded());\n    async.complete();\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以等待 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html\">Async</a></code> 直到其结束，\n类似Java的 count-down latch：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Wait for completion</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\n<span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer();\nserver.requestHandler(requestHandler);\nserver.listen(<span class=\"hljs-number\">8080</span>, ar -&gt; {\n  context.assertTrue(ar.succeeded());\n  async.complete();\n});\n\n<span class=\"hljs-comment\">// Wait until completion</span>\nasync.awaitSuccess();</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n该方法不应该在事件循环（event loop）上执行！\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Async 可以创建一个初始计数值，\n当用 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html#countDown--\">countDown</a></code> 方法将 count-down 的值减到0时：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">等待，直到count-down值为0</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer();\nserver.requestHandler(requestHandler);\nserver.listen(<span class=\"hljs-number\">8080</span>, ar -&gt; {\n  context.assertTrue(ar.succeeded());\n  async.countDown();\n});\n\nvertx.setTimer(<span class=\"hljs-number\">1000</span>, id -&gt; {\n  async.complete();\n});\n\n<span class=\"hljs-comment\">// Wait until completion of the timer and the http request</span>\nasync.awaitSuccess();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>调用Async的 <code>complete()</code> 方法会像往常一样结束，实际上它将count-down值直接设置为 <code>0</code> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_asynchronous_assertions\"><a class=\"anchor\" href=\"#_asynchronous_assertions\"></a>异步断言</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\">TestContext</a></code> 提供了很有用的方法，这些方法提供了强大的异步测试框架：</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess--\">asyncAssertSuccess</a></code> 方法返回一个类似 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html\">Async</a></code> {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象，\n它在运行成功时执行 <code>Async</code> 对象，并在失败时，\n让整个测试用例失败，并返回失败原因。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    async.complete();\n  } <span class=\"hljs-keyword\">else</span> {\n    context.fail(ar.cause());\n  }\n});\n\n<span class=\"hljs-comment\">// 可用如下代替</span>\n\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, context.asyncAssertSuccess());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess-io.vertx.core.Handler-\">asyncAssertSuccess</a></code> 方法返回一个类似于 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html\">Async</a></code> 的 {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象，\n运行成功时它执行了代理 {@literal Handler&lt;T&gt;} ，\n而在运行出错时让整个测试用例失败，并返回错误原因。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">AtomicBoolean</span> <span class=\"hljs-variable\">started</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicBoolean</span>();\n<span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\nvertx.deployVerticle(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbstractVerticle</span>() {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n    started.set(<span class=\"hljs-literal\">true</span>);\n  }\n}, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    context.assertTrue(started.get());\n    async.complete();\n  } <span class=\"hljs-keyword\">else</span> {\n    context.fail(ar.cause());\n  }\n});\n\n<span class=\"hljs-comment\">// Can be replaced by</span>\n\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, context.asyncAssertSuccess(id -&gt; {\n  context.assertTrue(started.get());\n}));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当 <code>Handler</code> 退出时，Async对象同时也会处于 <code>completed</code> 状态，除非Async对象在函数调用期间被创建，\n这会在 <em>链式</em> 异步操作时提供方便：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded()) {\n    vertx.deployVerticle(<span class=\"hljs-string\">&quot;my.otherverticle&quot;</span>, ar2 -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n        async.complete();\n      } <span class=\"hljs-keyword\">else</span> {\n        context.fail(ar2.cause());\n      }\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    context.fail(ar1.cause());\n  }\n});\n\n<span class=\"hljs-comment\">// Can be replaced by</span>\n\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, context.asyncAssertSuccess(id -&gt;\n        vertx.deployVerticle(<span class=\"hljs-string\">&quot;my_otherverticle&quot;</span>, context.asyncAssertSuccess())\n));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure--\">asyncAssertFailure</a></code> 方法返回了一个类似 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html\">Async</a></code> 的 {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象,\n它在运行失败时执行 <code>Async</code> ，\n并在成功时让测试用例失败。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    context.fail();\n  } <span class=\"hljs-keyword\">else</span> {\n    async.complete();\n  }\n});\n\n<span class=\"hljs-comment\">// 可用如下代替</span>\n\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, context.asyncAssertFailure());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure-io.vertx.core.Handler-\">asyncAssertFailure</a></code> 方法返回一个类似 <code><a href=\"../../apidocs/io/vertx/ext/unit/Async.html\">Async</a></code> 的  {@literal Handler&lt;AsyncResult&lt;T&gt;&gt;} 对象，\n它在运行失败时，\n执行代理处理器 {@literal Handler&lt;Throwable&gt;} ，\n并在执行成功时让测试用例失败。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    context.fail();\n  } <span class=\"hljs-keyword\">else</span> {\n    context.assertTrue(ar.cause() <span class=\"hljs-keyword\">instanceof</span> IllegalArgumentException);\n    async.complete();\n  }\n});\n\n<span class=\"hljs-comment\">// 可用如下代替</span>\n\nvertx.deployVerticle(<span class=\"hljs-string\">&quot;my.verticle&quot;</span>, context.asyncAssertFailure(cause -&gt; {\n  context.assertTrue(cause <span class=\"hljs-keyword\">instanceof</span> IllegalArgumentException);\n}));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>Handler</code> 退出时，这个Async也会处于完成状态，除非在执行过程中，创建了新的Async对象</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_repeating_test\"><a class=\"anchor\" href=\"#_repeating_test\"></a>重复测试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当测试随机条件或测试不经常失败时，例如在竞争条件下，\n为了增加测试失败的可能性，多次运行同一测试是个方便的方式。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">重复一个测试</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">TestSuite.create(<span class=\"hljs-string\">&quot;my_suite&quot;</span>).test(<span class=\"hljs-string\">&quot;my_test&quot;</span>, <span class=\"hljs-number\">1000</span>, context -&gt; {\n  <span class=\"hljs-comment\">// 这里会执行1000次</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果声明了 <em>beforeEach</em> 和 <em>afterEach</em> 回调，那么每当测试用例执行一次，它们也会被执行一次。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n重复的测试用例是顺序执行的\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sharing_objects\"><a class=\"anchor\" href=\"#_sharing_objects\"></a>共享对象</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\">TestContext</a></code> 对象提供了 <code>get</code>/<code>put</code>/<code>remove</code> 操作，用于在回调函数之间共享状态。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 <em>before</em> 回调函数中添加的任何对象都可以在其他回调函数中访问到。\n每一个测试用例都会操作一个共享状态的副本。所以，对于共享状态的更新仅仅在一个测试用例之内有效。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">在回调函数之间共享状态</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">TestSuite.create(<span class=\"hljs-string\">&quot;my_suite&quot;</span>).before(context -&gt; {\n\n  <span class=\"hljs-comment\">// cases host对于所有的测试用例可见</span>\n  context.put(<span class=\"hljs-string\">&quot;host&quot;</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>);\n\n}).beforeEach(context -&gt; {\n\n  <span class=\"hljs-comment\">// 为每一个测试用例生成一个port</span>\n  <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> helper.randomPort();\n\n  <span class=\"hljs-comment\">// 获取host</span>\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">host</span> <span class=\"hljs-operator\">=</span> context.get(<span class=\"hljs-string\">&quot;host&quot;</span>);\n\n  <span class=\"hljs-comment\">// 启动服务</span>\n  <span class=\"hljs-type\">Async</span> <span class=\"hljs-variable\">async</span> <span class=\"hljs-operator\">=</span> context.async();\n  <span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer();\n  server.requestHandler(req -&gt; {\n    req.response().setStatusCode(<span class=\"hljs-number\">200</span>).end();\n  });\n  server.listen(port, host, ar -&gt; {\n    context.assertTrue(ar.succeeded());\n    context.put(<span class=\"hljs-string\">&quot;port&quot;</span>, port);\n    async.complete();\n  });\n\n}).test(<span class=\"hljs-string\">&quot;my_test&quot;</span>, context -&gt; {\n\n  <span class=\"hljs-comment\">// 获取共享状态</span>\n  <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">port</span> <span class=\"hljs-operator\">=</span> context.get(<span class=\"hljs-string\">&quot;port&quot;</span>);\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">host</span> <span class=\"hljs-operator\">=</span> context.get(<span class=\"hljs-string\">&quot;host&quot;</span>);\n\n  <span class=\"hljs-comment\">// 发送请求</span>\n  <span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\n  client.request(HttpMethod.GET, port, host, <span class=\"hljs-string\">&quot;/resource&quot;</span>, context.asyncAssertSuccess(req -&gt; {\n    req.send(context.asyncAssertSuccess(resp -&gt; {\n      context.assertEquals(<span class=\"hljs-number\">200</span>, resp.statusCode());\n    }));\n  }));\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n只有java才能共享所有类型的对象，其他语言只能共享基本类型和json类型。\n其他类型对象的共享操作应该利用当前编程语言的特性来实现。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running\"><a class=\"anchor\" href=\"#_running\"></a>运行</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当创建了一个测试套件，除非调用 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestSuite.html#run--\">run</a></code> 方法，否则测试用例不会执行。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">运行一个测试套件</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.run();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个测试套件也可以用指定的 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 来运行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">提供一个Vertx对象来执行测试用例</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.run(vertx);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当使用 <code>Vertx</code> 对象来运行时，测试套件则会使用该Vert.x对象的 eventloop 来运行测试用例，\n更多信息详见 <a href=\"#event_loop\">[event_loop]</a> 一章。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个测试套件可以用Vert.x命令行接口来执行，即使用 <code>vertx test</code> 命令：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">用Vert.x CLI 执行测试用例</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code>&gt; vertx test the_test_suite.js\nBegin test suite the_test_suite\nSucceeded in deploying verticle\nBegin test my_test_case\nPassed my_test_case\nEnd test suite my_suite , run: 1, Failures: 0, Errors: 0</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这种测试套件仅仅需要通过 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestSuite.html#run--\">run</a></code> 命令来执行，\n<code>vertx test</code> 命令则负责配置报告和超时等。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-string\">&quot;the_test_suite&quot;</span>);\nsuite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, context -&gt; {\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value&quot;</span>;\n  context.assertEquals(<span class=\"hljs-string\">&quot;value&quot;</span>, s);\n});\nsuite.run();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx test</code> 命令扩展了 <code>vertx run</code> 命令。它改变了JVM的退出行为，\n当测试套件开始执行，并且返回了测试结果（例如success (0) or failure (1)）的时候，JVM才会退出。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n同一个Verticle中可以执行多个测试套件，\nVert.x Unit会等待所有的测试套件执行完成。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_test_suite_completion\"><a class=\"anchor\" href=\"#_test_suite_completion\"></a>测试套件执行完毕</h3>\n<div class=\"paragraph\">\n<p>我们没办法假设测试套件将何时执行完毕，\n如果有代码需要在测试用例执行完毕之后才执行，\n那么这段代码要声明在 <em>after</em> 回调函数中或者让其作为 <code><a href=\"../../apidocs/io/vertx/ext/unit/Completion.html\">Completion</a></code> 的回调。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">测试套件 <em>执行回调函数</em></div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestCompletion</span> <span class=\"hljs-variable\">completion</span> <span class=\"hljs-operator\">=</span> suite.run(vertx);\n\n<span class=\"hljs-comment\">// 普通的完成回调函数</span>\ncompletion.handler(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Test suite passed!&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Test suite failed:&quot;</span>);\n    ar.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/Completion.html\">Completion</a></code> 对象也提供了 <code><a href=\"../../apidocs/io/vertx/ext/unit/Completion.html#resolve-io.vertx.core.Promise-\">resolve</a></code> 方法，\n该方法接收 <code>Promise</code> 对象参数，这个 <code>Promise</code> 会在测试套件执行时被触发通知。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">用测试套件解析初始Promise</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestCompletion</span> <span class=\"hljs-variable\">completion</span> <span class=\"hljs-operator\">=</span> suite.run();\n\n<span class=\"hljs-comment\">// 当测试套件执行完毕，Promise则被解析</span>\ncompletion.resolve(startPromise);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这样可以轻松的创建一个 <em>test</em> Verticle，这个Verticle是由测试套件部署起来的，\n而部署Verticle的代码中可以很容易的知悉成功或者失败。</p>\n</div>\n<div class=\"paragraph\">\n<p>completion 对象也可以像 count-down latch 一样使用，他会阻塞直至测试套件执行完。\n这应该用于当前线程与测试套件线程不一样时的场景。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">阻塞至测试套件执行完毕</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Completion</span> <span class=\"hljs-variable\">completion</span> <span class=\"hljs-operator\">=</span> suite.run();\n\n<span class=\"hljs-comment\">//  阻塞至测试套件执行完毕</span>\ncompletion.await();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>await</code> 方法在线程被interrupt或者超时的时候抛出异常。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/Completion.html#awaitSuccess--\">awaitSuccess</a></code> 方法是一个变种，\n它在测试套件运行失败时抛出异常</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">阻塞至测试套件执行成功</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Completion</span> <span class=\"hljs-variable\">completion</span> <span class=\"hljs-operator\">=</span> suite.run();\n\n<span class=\"hljs-comment\">// 阻塞至测试套件执行成功 否则抛出异常</span>\ncompletion.awaitSuccess();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_time_out\"><a class=\"anchor\" href=\"#_time_out\"></a>超时</h3>\n<div class=\"paragraph\">\n<p>测试套件中的每一个测试用例都必须在超时时间内执行完毕。默认超时时间是 <em>2分钟</em> ，\n超时时间可以用 <em>test options</em> 来设置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">设置测试套件的超时时间</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TestOptions</span>().setTimeout(<span class=\"hljs-number\">10000</span>);\n\n<span class=\"hljs-comment\">// 10秒超时时间</span>\nsuite.run(options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_event_loop\"><a class=\"anchor\" href=\"#_event_loop\"></a>事件循环（Event loop）</h3>\n<div class=\"paragraph\">\n<p>Vert.x Unit 是一系列task的执行过程，每个task由前一个task的完成动作来触发。\n这些task负责平衡eventloop的调度，\n但是这取决于当前执行上下文（例如，测试套件在 <code>main</code> 方法中执行，或者嵌入一个verticle ）\n是否配置了 <code>Vertx</code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/TestOptions.html#setUseEventLoop-java.lang.Boolean-\">setUseEventLoop</a></code>\n以配置事件循环（event loop）的使用方式：</p>\n</div>\n<table class=\"tableblock frame-all grid-all stretch\">\n<caption class=\"title\">Table 1. 事件循环（Event loop）的使用</caption>\n<colgroup>\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n</colgroup>\n<thead>\n<tr>\n<th class=\"tableblock halign-left valign-top\"></th>\n<th class=\"tableblock halign-left valign-top\">useEventLoop:null</th>\n<th class=\"tableblock halign-left valign-top\">useEventLoop:true</th>\n<th class=\"tableblock halign-left valign-top\">useEventLoop:false</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><code>Vertx</code> instance</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">使用 vertx event loop</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">使用 vertx event loop</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">强制不使用 event loop</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">在 <code>Verticle</code> 中</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">使用当前 event loop</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">使用当前 event loop</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">强制不使用 event loop</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">在 <em>main</em> 方法中</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">不使用 event loop</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">错误</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">不使用 event loop</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"paragraph\">\n<p><code>useEventLoop</code> 默认为 <code>null</code> , 这说明，\n如果条件允许则使用一个event loop，当没有event loop 可用时，不使用event loop。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reporting\"><a class=\"anchor\" href=\"#_reporting\"></a>测试报告</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>测试报告是测试套件中的重要部分，\nVert.x Unit可以用不同配置来运行不同的 reporter。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，不配置reporter，但是当运行测试套件时，\n可以用 <em>test options</em> 来配置一个或多个 reporter：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">使用终端reporter并将其用作junit xml文件</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">ReportOptions</span> <span class=\"hljs-variable\">consoleReport</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReportOptions</span>().\n    setTo(<span class=\"hljs-string\">&quot;console&quot;</span>);\n\n<span class=\"hljs-comment\">// 将Junit报告信息文件放在当前目录</span>\n<span class=\"hljs-type\">ReportOptions</span> <span class=\"hljs-variable\">junitReport</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReportOptions</span>().\n    setTo(<span class=\"hljs-string\">&quot;file:.&quot;</span>).\n    setFormat(<span class=\"hljs-string\">&quot;junit&quot;</span>);\n\nsuite.run(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TestOptions</span>().\n        addReporter(consoleReport).\n        addReporter(junitReport)\n);</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_console_reporting\"><a class=\"anchor\" href=\"#_console_reporting\"></a>控制台报告</h3>\n<div class=\"paragraph\">\n<p>将信息报告至JVM的 <code>System.out</code> 和 <code>System.err</code> ：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">报告至</dt>\n<dd>\n<p><em>终端</em></p>\n</dd>\n<dt class=\"hdlist1\">格式</dt>\n<dd>\n<p><em>常规</em> 或 <em>junit</em></p>\n</dd>\n</dl>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_file_reporting\"><a class=\"anchor\" href=\"#_file_reporting\"></a>文件报告</h3>\n<div class=\"paragraph\">\n<p>如果想将报告输出至文件，您必须提供一个 <code>Vertx</code> 对象：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">to</dt>\n<dd>\n<p><em>file</em> <code>:</code> <em>dir name</em></p>\n</dd>\n<dt class=\"hdlist1\">格式</dt>\n<dd>\n<p><em>simple</em> 或 <em>junit</em></p>\n</dd>\n<dt class=\"hdlist1\">示例</dt>\n<dd>\n<p><code>file:.</code></p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>文件reporter会在配置的目录中创建文件，这些文件会以测试套件的名称和格式来命名\n（例如， <em>常规格式</em> 创建 <em>txt</em> 文件，_\njunit格式_ 创建 <em>xml</em> 文件）。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_log_reporting\"><a class=\"anchor\" href=\"#_log_reporting\"></a>日志报告</h3>\n<div class=\"paragraph\">\n<p>如果要向logger发送报告，您必须提供一个 <code>Vertx</code> 对象：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">to</dt>\n<dd>\n<p><em>log</em> <code>:</code> <em>logger name</em></p>\n</dd>\n<dt class=\"hdlist1\">示例</dt>\n<dd>\n<p><code>log:mylogger</code></p>\n</dd>\n</dl>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_event_bus_reporting\"><a class=\"anchor\" href=\"#_event_bus_reporting\"></a>事件总线报告</h3>\n<div class=\"paragraph\">\n<p>如果要向事件总线报告事件，那么您必须提供一个 <code>Vertx</code> 对象：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">to</dt>\n<dd>\n<p><em>bus</em> <code>:</code> <em>event bus address</em></p>\n</dd>\n<dt class=\"hdlist1\">示例</dt>\n<dd>\n<p><code>bus:the-address</code></p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>它将测试套件的执行过程和报告解耦合。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过事件总线发送的消息可以通过 <code><a href=\"../../apidocs/io/vertx/ext/unit/collect/EventBusCollector.html\">EventBusCollector</a></code> 来收集起来，\n并实现自定义报告</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">EventBusCollector</span> <span class=\"hljs-variable\">collector</span> <span class=\"hljs-operator\">=</span> EventBusCollector.create(\n    vertx,\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReportingOptions</span>().addReporter(\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReportOptions</span>().setTo(<span class=\"hljs-string\">&quot;file:report.xml&quot;</span>).setFormat(<span class=\"hljs-string\">&quot;junit&quot;</span>)));\n\ncollector.register(<span class=\"hljs-string\">&quot;the-address&quot;</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_vertx_integration\"><a class=\"anchor\" href=\"#_vertx_integration\"></a>Vertx 整合</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下，断言和失败必须在 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\">TestContext</a></code> 之内完成，另外 <em>断言失败</em> 仅仅在Vert.x Unit的调用下才会有效。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;my_test_case&quot;</span>, ctx -&gt; {\n\n  <span class=\"hljs-comment\">// &#x27;失败&#x27;会被Vert.x Unit 报告</span>\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(<span class=\"hljs-string\">&quot;it failed!&quot;</span>);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在一个常规的Vert.x回调中，会忽略失败：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.test(<span class=\"hljs-string\">&quot;test-server&quot;</span>, testContext -&gt; {\n  <span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer().requestHandler(req -&gt; {\n    <span class=\"hljs-keyword\">if</span> (req.path().equals(<span class=\"hljs-string\">&quot;/somepath&quot;</span>)) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Wrong path!&quot;</span>);\n    }\n    req.response().end();\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>从 Vert.x 3.3 版本开始，您可以设置一个全局异常处理器来报告 event loop 没有捕捉到的异常：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">suite.before(testContext -&gt; {\n\n  <span class=\"hljs-comment\">// 报告未被捕捉到到异常，以其作为 Vert.x Unit 失败事件</span>\n  vertx.exceptionHandler(testContext.exceptionHandler());\n});\n\nsuite.test(<span class=\"hljs-string\">&quot;test-server&quot;</span>, testContext -&gt; {\n  <span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer().requestHandler(req -&gt; {\n    <span class=\"hljs-keyword\">if</span> (req.path().equals(<span class=\"hljs-string\">&quot;/somepath&quot;</span>)) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Wrong path!&quot;</span>);\n    }\n    req.response().end();\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果异常处理器设置在 <em>before</em> 部分，那么 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\">TestContext</a></code> 则会在 <em>before</em>,\n<em>test</em> 和 <em>after</em> 部分之间共享。\n所以将异常处理器置于 <em>before</em> 部分是一个正确到做法</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_junit_integration\"><a class=\"anchor\" href=\"#_junit_integration\"></a>Junit 整合</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>尽管Vertx Unit是多语言的，且不是基于Junit的，但是您依然可以在Junit上运行Vert.x Unit测试套件以及测试用例，\n并允许您将测试用例整合到JUnit，允许整合到您的build system，也可以整合到IDE中。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">将一个Java类作为JUnit测试套件</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@RunWith(VertxUnitRunner.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JUnitTestSuite</span> {\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSomething</span><span class=\"hljs-params\">(TestContext context)</span> {\n    context.assertFalse(<span class=\"hljs-literal\">false</span>);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunner.html\">VertxUnitRunner</a></code> 使用Junit注解来对这个类进行解析，\n并创建该类对象之后创建测试套件。\n该类中的方法应该在参数中声明一个 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\">TestContext</a></code> 参数\n，不声明该参数也是可以的。\n然而 <code>TestContext</code> 是在异步测试过程中能够获取相关Vertx对象的唯一方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>在Groovy语言中，\n用 <code>io.vertx.groovy.ext.unit.junit.VertxUnitRunner</code> 也可以达到整合Junit的目的。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_running_a_test_on_a_vert_x_context\"><a class=\"anchor\" href=\"#_running_a_test_on_a_vert_x_context\"></a>在 Vert.x 上下文中执行一个测试</h3>\n<div class=\"paragraph\">\n<p>默认情况下执行测试方法的是Junit线程。\n<code><a href=\"../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html\">RunTestOnContext</a></code> Junit rule可以改变这个行为，使测试方法都运行于 Vert.x event loop 线程。</p>\n</div>\n<div class=\"paragraph\">\n<p>因此，当某状态在测试方法/Vert.x处理器之间共享时，您就需要小心了，因为他们并不是在同一个线程上运行的，\n例如，在Vert.x处理器中累加一个计数器然后在测试方法中断言计数器的值。\n使用恰当地同步机制是解决此问题的一种方式，\n另外还可以在Vert.x context中执行测试方法，这样共享状态则会在处理器之间传播。</p>\n</div>\n<div class=\"paragraph\">\n<p>以此目的，<code><a href=\"../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html\">RunTestOnContext</a></code> rule 需要一个 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 对象。\n您可以主动提供这个对象，如果不提供，这个 rule 会隐式创建它。\n这个对象可以在测试执行过程中获取，\n这也使该rule成为管理Vert.x实例的一种方式。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">运行一个Java类作为JUnit测试套件</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@RunWith(VertxUnitRunner.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RunOnContextJUnitTestSuite</span> {\n\n  <span class=\"hljs-meta\">@Rule</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">RunTestOnContext</span> <span class=\"hljs-variable\">rule</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RunTestOnContext</span>();\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSomething</span><span class=\"hljs-params\">(TestContext context)</span> {\n    <span class=\"hljs-comment\">// 使用这个隐式创建的vertx对象</span>\n    <span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> rule.vertx();\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>rule可以用 {@literal @Rule} 或 {@literal @ClassRule} 注解修饰，\n前者管理每个测试的Vert.x对象，后者则管理该测试类中所有测试方法相关的那一个Vertx对象。</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n切记，用这个rule的时候您不可以阻塞 event loop 。使用像 <code>CountDownLatch</code> 类的做法，\n则必须要小心。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timeout\"><a class=\"anchor\" href=\"#_timeout\"></a>超时</h3>\n<div class=\"paragraph\">\n<p>Vert.x Unit 默认超时时间两分钟，这可以用 <code>@Test</code> 注解中的 <code>timeout</code> 属性来指定：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">在测试方法级别配置超时时间</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JunitTestWithTimeout</span> {\n\n  <span class=\"hljs-meta\">@Test(timeout = 1000l)</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSomething</span><span class=\"hljs-params\">(TestContext context)</span> {\n    <span class=\"hljs-comment\">//...</span>\n  }\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于更全局的配置，可以用 <code><a href=\"../../apidocs/io/vertx/ext/unit/junit/Timeout.html\">Timeout</a></code> rule：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">类级别超时时间配置</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@RunWith(VertxUnitRunner.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TimeoutTestSuite</span> {\n\n  <span class=\"hljs-meta\">@Rule</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">Timeout</span> <span class=\"hljs-variable\">rule</span> <span class=\"hljs-operator\">=</span> Timeout.seconds(<span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSomething</span><span class=\"hljs-params\">(TestContext context)</span> {\n    <span class=\"hljs-comment\">//...</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<code>@Test</code> 的超时设置会覆盖 <code><a href=\"../../apidocs/io/vertx/ext/unit/junit/Timeout.html\">Timeout</a></code> rule 的配置。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_parameterized_tests\"><a class=\"anchor\" href=\"#_parameterized_tests\"></a>参数化测试</h3>\n<div class=\"paragraph\">\n<p>JUnit提供了非常有用的 <code>参数化</code> 测试，\nVert.x Unit 测试可以利用 <code><a href=\"../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunnerWithParametersFactory.html\">VertxUnitRunnerWithParametersFactory</a></code> 来指定执行器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">运行参数化的Vert.x Unit测试</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@RunWith(Parameterized.class)</span>\n<span class=\"hljs-meta\">@Parameterized</span>.UseParametersRunnerFactory(VertxUnitRunnerWithParametersFactory.class)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleParameterizedTest</span> {\n\n  <span class=\"hljs-meta\">@Parameterized</span>.Parameters\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Iterable&lt;Integer&gt; <span class=\"hljs-title function_\">data</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> Arrays.asList(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n  }\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">SimpleParameterizedTest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value)</span> {\n    <span class=\"hljs-comment\">//...</span>\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSomething</span><span class=\"hljs-params\">(TestContext context)</span> {\n    <span class=\"hljs-comment\">// 用当前值来执行测试方法</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Groovy语言中，您可以用 <code>io.vertx.groovy.ext.unit.junit.VertxUnitRunnerWithParametersFactory</code> 来实现参数化测试：</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_repeating_a_test\"><a class=\"anchor\" href=\"#_repeating_a_test\"></a>重复测试</h3>\n<div class=\"paragraph\">\n<p>当测试随机条件或测试不经常失败时，例如在竞争条件下，\n为了增加测试失败的可能性，多次运行同一测试是个方便的方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果用Junit，测试用例必须用 <code><a href=\"../../apidocs/io/vertx/ext/unit/junit/Repeat.html\">@Repeat</a></code> 注解修饰，来指定重复执行。\n测试用例也必须定义根据自身规则定义 <code><a href=\"../../apidocs/io/vertx/ext/unit/junit/RepeatRule.html\">RepeatRule</a></code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">用Junit重复测试</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@RunWith(VertxUnitRunner.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RepeatingTest</span> {\n\n  <span class=\"hljs-meta\">@Rule</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">RepeatRule</span> <span class=\"hljs-variable\">rule</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RepeatRule</span>();\n\n  <span class=\"hljs-meta\">@Repeat(1000)</span>\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSomething</span><span class=\"hljs-params\">(TestContext context)</span> {\n    <span class=\"hljs-comment\">// 执行1000次</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果声明了RepeatRule，那么 <em>before</em> 和 <em>after</em> 方法会在每次执行测试方法时都执行一次。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n重复测试是顺序执行\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_with_other_assertion_libraries\"><a class=\"anchor\" href=\"#_using_with_other_assertion_libraries\"></a>用其他断言库</h3>\n<div class=\"paragraph\">\n<p>Vert.x Unit 的可用性从 Vert.x 3.3 开始有了巨大的提升。您可以用\n<a href=\"http://hamcrest.org/\">Hamcrest</a> ，\n<a href=\"http://joel-costigliola.github.io/assertj/\">AssertJ</a> ，\n<a href=\"https://github.com/rest-assured/rest-assured/\">Rest Assured</a> ，甚至其他您想用的断言库来写测试用例。这是由 <a href=\"#vertx_integration\">[vertx_integration]</a> 章节里介绍的全局异常处理器的机制实现的。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以在 <a href=\"https://github.com/vert-x3/vertx-examples/tree/master/unit-examples\">vertx-examples</a> 工程中，\n找到Vert.x Unit中用 Hamcrest 和 AssertJ 的示例。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_java_language_integration\"><a class=\"anchor\" href=\"#_java_language_integration\"></a>Java 语言整合</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_test_suite_integration\"><a class=\"anchor\" href=\"#_test_suite_integration\"></a>测试套件整合</h3>\n<div class=\"paragraph\">\n<p>Java语言提供了class，\n而且可以用如下映射规则来直接利用Java class创建测试套件：</p>\n</div>\n<div class=\"paragraph\">\n<p>检查 <code>测试套件对象</code> 的参数和方法，保留带有 <code><a href=\"../../apidocs/io/vertx/ext/unit/TestContext.html\">TestContext</a></code> 参数的public且非静态方法并通过方法名映射到Vert.x Unit测试套件：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>before</code> : before callback</p>\n</li>\n<li>\n<p><code>after</code> : after callback</p>\n</li>\n<li>\n<p><code>beforeEach</code> : beforeEach callback</p>\n</li>\n<li>\n<p><code>afterEach</code> : afterEach callback</p>\n</li>\n<li>\n<p>以 <em>test</em> 开头的名称: 以方法名命名的测试用例</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">用Java类写的测试套件</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyTestSuite</span> {\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSomething</span><span class=\"hljs-params\">(TestContext context)</span> {\n    context.assertFalse(<span class=\"hljs-literal\">false</span>);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这个类可以很容易的转化成Vert.x 测试套件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">从Java对象创建测试套件</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TestSuite</span> <span class=\"hljs-variable\">suite</span> <span class=\"hljs-operator\">=</span> TestSuite.create(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyTestSuite</span>());</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.1.2"},"__N_SSG":true}