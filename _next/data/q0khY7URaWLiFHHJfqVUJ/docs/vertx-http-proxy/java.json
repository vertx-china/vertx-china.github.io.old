{"pageProps":{"slug":"vertx-http-proxy/java","title":"Vert.x Http Proxy","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_http_proxy\">使用 Vert.x Http Proxy</a></li>\n<li><a href=\"#_reverse_proxy_server\">反向代理服务器</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_websockets\">WebSockets</a></li>\n<li><a href=\"#_proxy_caching\">代理缓存</a></li>\n<li><a href=\"#_proxy_interception\">代理拦截</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Http Proxy</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Http Proxy 是一个基于 Vert.x 的反向代理服务器，其目的是实现可重用的反向代理逻辑，\n这样，使用者就可以关注更高层面的问题了</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n这个模块处于 <em>Tech Preview</em> 阶段，这意味着在不同版本之间 API 可能会不太一样\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_http_proxy\"><a class=\"anchor\" href=\"#_using_vert_x_http_proxy\"></a>使用 Vert.x Http Proxy</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用 Vert.x Http Proxy 之前，请把以下的依赖放到您的构建描述文件的 <em>依赖</em> 部分中</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-http-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-http-proxy:4.2.6&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reverse_proxy_server\"><a class=\"anchor\" href=\"#_reverse_proxy_server\"></a>反向代理服务器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了使用 Vert.x Http Proxy 实现一个反向代理，您需要了解这些名词：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><strong>Proxy Server</strong> 处理用户代理请求并将它们转发到 <strong>origin server</strong></p>\n</li>\n<li>\n<p><strong>Origin Server</strong> 处理来自 <strong>proxy server</strong> 的请求并做出相应响应</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>您可以创建一个 <strong>proxy server</strong>，监听 <code>8080</code> 端口并实现反向代理逻辑</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">proxyClient</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\n\n<span class=\"hljs-type\">HttpProxy</span> <span class=\"hljs-variable\">proxy</span> <span class=\"hljs-operator\">=</span> HttpProxy.reverseProxy(proxyClient);\nproxy.origin(<span class=\"hljs-number\">7070</span>, <span class=\"hljs-string\">&quot;origin&quot;</span>);\n\n<span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">proxyServer</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer();\n\nproxyServer.requestHandler(proxy).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>所有的（user-agent）用户代理请求都方便地转发到 <strong>origin server</strong> 。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websockets\"><a class=\"anchor\" href=\"#_websockets\"></a>WebSockets</h3>\n<div class=\"paragraph\">\n<p>该 HTTP 代理默认支持 WebSocket 协议。</p>\n</div>\n<div class=\"paragraph\">\n<p>WebSocket 的握手请求会被转发到源服务器 (包含 <code>connection</code> 头部) ，并且用户端\n和源服务器间会发生握手。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyOptions.html#setSupportWebSocket-boolean-\">setSupportWebSocket</a></code> 方法来设置其是否支持 WebSocket 协议。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_proxy_caching\"><a class=\"anchor\" href=\"#_proxy_caching\"></a>代理缓存</h3>\n<div class=\"paragraph\">\n<p>大部分情况下，代理不会缓存响应内容，并且会忽视大部分的缓存指令，您也可以使用缓存选项来开启缓存。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpProxy</span> <span class=\"hljs-variable\">proxy</span> <span class=\"hljs-operator\">=</span> HttpProxy.reverseProxy(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ProxyOptions</span>().setCacheOptions(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CacheOptions</span>()), proxyClient);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_proxy_interception\"><a class=\"anchor\" href=\"#_proxy_interception\"></a>代理拦截</h3>\n<div class=\"paragraph\">\n<p>拦截是使用新功能扩展代理的强大方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>你可以实现 <code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyInterceptor.html#handleProxyRequest-io.vertx.httpproxy.ProxyContext-\">handleProxyRequest</a></code> 对代理请求执行的任何操作</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ProxyInterceptor</span>() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> Future&lt;ProxyResponse&gt; <span class=\"hljs-title function_\">handleProxyRequest</span><span class=\"hljs-params\">(ProxyContext context)</span> {\n    <span class=\"hljs-type\">ProxyRequest</span> <span class=\"hljs-variable\">proxyRequest</span> <span class=\"hljs-operator\">=</span> context.request();\n\n    filter(proxyRequest.headers());\n\n    <span class=\"hljs-comment\">// 继续拦截链</span>\n    <span class=\"hljs-keyword\">return</span> context.sendRequest();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>代理响应也是如此</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ProxyInterceptor</span>() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> Future&lt;Void&gt; <span class=\"hljs-title function_\">handleProxyResponse</span><span class=\"hljs-params\">(ProxyContext context)</span> {\n    <span class=\"hljs-type\">ProxyResponse</span> <span class=\"hljs-variable\">proxyResponse</span> <span class=\"hljs-operator\">=</span> context.response();\n\n    filter(proxyResponse.headers());\n\n    <span class=\"hljs-comment\">//  继续拦截链</span>\n    <span class=\"hljs-keyword\">return</span> context.sendResponse();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_body_filtering\"><a class=\"anchor\" href=\"#_body_filtering\"></a>Body 过滤</h4>\n<div class=\"paragraph\">\n<p>你可以简单地用一个新的Body替换原来的 <code><a href=\"../../apidocs/io/vertx/httpproxy/Body.html\">Body</a></code> 来过滤body</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ProxyInterceptor</span>() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> Future&lt;Void&gt; <span class=\"hljs-title function_\">handleProxyResponse</span><span class=\"hljs-params\">(ProxyContext context)</span> {\n    <span class=\"hljs-type\">ProxyResponse</span> <span class=\"hljs-variable\">proxyResponse</span> <span class=\"hljs-operator\">=</span> context.response();\n\n    <span class=\"hljs-comment\">// 创建一个Body</span>\n    <span class=\"hljs-type\">Body</span> <span class=\"hljs-variable\">filteredBody</span> <span class=\"hljs-operator\">=</span> filter(proxyResponse.getBody());\n\n    <span class=\"hljs-comment\">// 然后使用它</span>\n    proxyResponse.setBody(filteredBody);\n\n    <span class=\"hljs-comment\">// 继续拦截链</span>\n    <span class=\"hljs-keyword\">return</span> context.sendResponse();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_interception_control\"><a class=\"anchor\" href=\"#_interception_control\"></a>拦截控制</h4>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyContext.html#sendRequest--\">sendRequest</a></code> 和 <code><a href=\"../../apidocs/io/vertx/httpproxy/ProxyContext.html#sendResponse--\">sendResponse</a></code> 继续当前拦截链，然后将结果发到（origin server）源服务器或者（user-agent）用户代理。</p>\n</div>\n<div class=\"paragraph\">\n<p>你可以更改控制器, 例如， 您可以立即向（user-agent）用户代理发送响应，而无需请求（origin server）源服务器</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">proxy.addInterceptor(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ProxyInterceptor</span>() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> Future&lt;ProxyResponse&gt; <span class=\"hljs-title function_\">handleProxyRequest</span><span class=\"hljs-params\">(ProxyContext context)</span> {\n\n    <span class=\"hljs-type\">ProxyRequest</span> <span class=\"hljs-variable\">proxyRequest</span> <span class=\"hljs-operator\">=</span> context.request();\n\n    <span class=\"hljs-comment\">// 释放资源</span>\n    proxyRequest.release();\n\n    <span class=\"hljs-comment\">// 创建一个响应并设置参数</span>\n    <span class=\"hljs-type\">ProxyResponse</span> <span class=\"hljs-variable\">proxyResponse</span> <span class=\"hljs-operator\">=</span> proxyRequest.response()\n      .setStatusCode(<span class=\"hljs-number\">200</span>)\n      .putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;text/plain&quot;</span>)\n      .setBody(Body.body(Buffer.buffer(<span class=\"hljs-string\">&quot;Hello World&quot;</span>)));\n\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(proxyResponse);\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}