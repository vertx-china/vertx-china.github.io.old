{"pageProps":{"slug":"4.2.2/vertx-web/java","title":"Vert.x-Web","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_web\">使用 Vert.x Web</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_development_mode\">开发模式</a></li>\n</ul>\n</li>\n<li><a href=\"#_re_cap_on_vert_x_core_http_servers\">回顾 Vert.x Core 的 HTTP 服务端</a></li>\n<li><a href=\"#_basic_vert_x_web_concepts\">Vert.x Web 的基本概念</a></li>\n<li><a href=\"#_handling_requests_and_calling_the_next_handler\">处理请求并调用下一个处理器</a></li>\n<li><a href=\"#_simple_responses\">简单的响应</a></li>\n<li><a href=\"#_using_blocking_handlers\">使用阻塞式处理器</a></li>\n<li><a href=\"#_routing_by_exact_path\">基于精确路径的路由</a></li>\n<li><a href=\"#_routing_by_paths_that_begin_with_something\">基于路径前缀的路由</a></li>\n<li><a href=\"#_capturing_path_parameters\">捕捉路径参数</a></li>\n<li><a href=\"#_routing_with_regular_expressions\">基于正则表达式的路由</a></li>\n<li><a href=\"#_capturing_path_parameters_with_regular_expressions\">通过正则表达式捕捉路径参数</a></li>\n<li><a href=\"#_using_named_capture_groups\">使用命名的捕捉组</a></li>\n<li><a href=\"#_routing_by_http_method\">基于 HTTP 方法的路由</a></li>\n<li><a href=\"#_route_order\">路由顺序</a></li>\n<li><a href=\"#_routing_based_on_mime_type_of_request\">基于请求MIME类型的路由</a></li>\n<li><a href=\"#_routing_based_on_mime_types_acceptable_by_the_client\">基于客户端可接收的MIME类型的路由</a></li>\n<li><a href=\"#_routing_based_on_virtualhost\">基于VirtualHost的路由</a></li>\n<li><a href=\"#_combining_routing_criteria\">组合多个路由条件</a></li>\n<li><a href=\"#_enabling_and_disabling_routes\">启用或者关闭Route</a></li>\n<li><a href=\"#_forward_support\">对Forward的支持</a></li>\n<li><a href=\"#_context_data\">上下文数据</a></li>\n<li><a href=\"#_metadata\">元数据</a></li>\n<li><a href=\"#_helper_functions\">帮手函数</a></li>\n<li><a href=\"#_reroute\">重新路由</a></li>\n<li><a href=\"#_sub_routers\">子路由器</a></li>\n<li><a href=\"#_localization_localization\">本地化</a></li>\n<li><a href=\"#_route_match_failures\">路由匹配失败</a></li>\n<li><a href=\"#_error_handling\">错误处理</a></li>\n<li><a href=\"#_request_body_handling\">请求体处理</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_the_request_body\">获取请求体</a></li>\n<li><a href=\"#_limiting_body_size\">限制请求体大小</a></li>\n<li><a href=\"#_merging_form_attributes\">合并表单属性</a></li>\n<li><a href=\"#_handling_file_uploads\">处理文件上传</a></li>\n</ul>\n</li>\n<li><a href=\"#_handling_cookies\">处理cookie</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_manipulating_cookies\">操作 cookies</a></li>\n</ul>\n</li>\n<li><a href=\"#_handling_sessions\">处理session</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_session_stores\">session储存</a></li>\n<li><a href=\"#_creating_the_session_handler\">创建session处理器</a></li>\n<li><a href=\"#_using_the_session\">使用session</a></li>\n<li><a href=\"#_session_timeout\">session 超时</a></li>\n</ul>\n</li>\n<li><a href=\"#_authentication_authorization\">认证/授权</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_an_authentication_handler\">创建一个身份认证处理器</a></li>\n<li><a href=\"#_handling_authentication_in_your_application\">在您的程序中处理身份认证</a></li>\n<li><a href=\"#_http_basic_authentication\">HTTP Basic Authentication</a></li>\n<li><a href=\"#_redirect_authentication_handler\">重定向身份认证</a></li>\n<li><a href=\"#_jwt_authentication\">JWT 认证</a></li>\n<li><a href=\"#_configuring_authorization\">配置授权</a></li>\n<li><a href=\"#_chaining_multiple_authentication_handlers\">链接多个身份验证处理器</a></li>\n</ul>\n</li>\n<li><a href=\"#_serving_static_resources\">处理静态资源</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_configuring_caching\">配置缓存</a></li>\n<li><a href=\"#_configuring_the_index_page\">配置主页</a></li>\n<li><a href=\"#_changing_the_web_root\">更改web root</a></li>\n<li><a href=\"#_serving_hidden_files\">处理隐藏文件</a></li>\n<li><a href=\"#_directory_listing\">目录列表</a></li>\n<li><a href=\"#_disabling_file_caching_on_disk\">关闭在磁盘上的文件缓存</a></li>\n</ul>\n</li>\n<li><a href=\"#_cors_handling\">跨域处理</a></li>\n<li><a href=\"#_multi_tenant\">多租户</a></li>\n<li><a href=\"#_templates\">模板</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_mvel_template_engine\">MVEL 模版引擎</a></li>\n<li><a href=\"#_jade_template_engine\">Jade 模版引擎（译者注：Jade 已更名为 Pug)</a></li>\n<li><a href=\"#_handlebars_template_engine\">Handlebars 模板引擎</a></li>\n<li><a href=\"#_thymeleaf_template_engine\">Thymeleaf 模板引擎</a></li>\n<li><a href=\"#_apache_freemarker_template_engine\">Apache FreeMarker 模版引擎</a></li>\n<li><a href=\"#_pebble_template_engine\">Pebble 模版引擎</a></li>\n<li><a href=\"#_rocker_template_engine\">Rocker 模版引擎</a></li>\n<li><a href=\"#_httl_template_engine\">HTTL 模版引擎</a></li>\n<li><a href=\"#_rythm_template_engine\">Rythm 模版引擎</a></li>\n<li><a href=\"#_caching\">缓存</a></li>\n</ul>\n</li>\n<li><a href=\"#_error_handler\">错误处理器</a></li>\n<li><a href=\"#_request_logger\">请求日志</a></li>\n<li><a href=\"#_serving_favicons\">提供网页图标</a></li>\n<li><a href=\"#_timeout_handler\">超时处理器</a></li>\n<li><a href=\"#_response_time_handler\">响应时间处理器</a></li>\n<li><a href=\"#_content_type_handler\">内容类型（Content type）处理器</a></li>\n<li><a href=\"#_sockjs\">SockJS</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_sockjs_handler\">SockJS 处理器</a></li>\n<li><a href=\"#_handling_sockjs_sockets\">处理 SockJS 套接字</a></li>\n<li><a href=\"#_the_client_side\">客户端</a></li>\n<li><a href=\"#_configuring_the_sockjs_handler\">配置 SockJS 处理器</a></li>\n<li><a href=\"#_writing_to_a_sockjs_socket_over_the_event_bus\">通过 event bus 写入 SockJS 套接字</a></li>\n</ul>\n</li>\n<li><a href=\"#_sockjs_event_bus_bridge\">SockJS 桥接 Event Bus</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_securing_the_bridge\">守护连接桥</a></li>\n<li><a href=\"#_requiring_authorization_for_messages\">消息授权</a></li>\n<li><a href=\"#_handling_event_bus_bridge_events\">处理事件总线桥事件</a></li>\n</ul>\n</li>\n<li><a href=\"#_csrf_cross_site_request_forgery\">CSRF跨站请求伪造</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_ajax\">使用 AJAX</a></li>\n</ul>\n</li>\n<li><a href=\"#_hsts_handler\">HSTS处理器</a></li>\n<li><a href=\"#_csp_handler\">CSP处理器</a></li>\n<li><a href=\"#_xframe_handler\">XFrame处理器</a></li>\n<li><a href=\"#_oauth2authhandler_handler\">OAuth2Auth处理器</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_a_real_world_example\">一个真实世界的例子</a></li>\n<li><a href=\"#_mixing_oauth2_and_jwt\">将OAuth2和JWT混合使用</a></li>\n<li><a href=\"#_webauthn\">WebAuthn</a></li>\n<li><a href=\"#_one_time_password_multi_factor_authentication\">一次性密码 (多重因子身份验证)</a></li>\n<li><a href=\"#_handling_http_method_overriding\">处理HTTP请求方法覆盖</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x-Web</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web是基于Vert.x的，用于构建Web应用程序的一系列构建模块。 可以将其视为一把构建现代的，\n可扩展的Web应用的瑞士军刀。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Core 提供了一系列相对底层的功能用于操作HTTP，\n对于一部分应用是足够的。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 基于 Vert.x Core 提供了一系列更丰富的功能，\n以便更容易地开发实际的 Web 应用。</p>\n</div>\n<div class=\"paragraph\">\n<p>它继承了 Vert.x 2.x 里的 <a href=\"http://pmlopes.github.io/yoke/\">Yoke</a> 的特点，灵感来自于 Node.js\n的框架 <a href=\"http://expressjs.com/\">Express</a> 和 Ruby 的框架 <a href=\"http://www.sinatrarb.com/\">Sinatra</a> 等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 的设计是强大的，非侵入式的, 并且是完全可插拔的。您可以只使用您需要的部分。\nVert.x Web 不是一个容器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 Vert.x Web 来构建经典的服务端 Web 应用， RESTful 应用， 实时的（服务端推送)\nWeb 应用, 或任何您所能想到的 Web 应用类型。\n应用类型的选择取决于您的喜好，而不是 Vert.x Web。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 非常适合编写 RESTful HTTP 微服务，<strong> 但我们不强制 </strong> 您必须把应用实现成这样。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 的一部分关键特性有：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>路由(基于方法,路径等)</p>\n</li>\n<li>\n<p>基于正则表达式的路径匹配</p>\n</li>\n<li>\n<p>从路径中提取参数</p>\n</li>\n<li>\n<p>内容协商</p>\n</li>\n<li>\n<p>处理消息体</p>\n</li>\n<li>\n<p>消息体的长度限制</p>\n</li>\n<li>\n<p>Multipart 表单</p>\n</li>\n<li>\n<p>Multipart 文件上传</p>\n</li>\n<li>\n<p>子路由</p>\n</li>\n<li>\n<p>支持本地会话和集群会话</p>\n</li>\n<li>\n<p>支持 CORS(跨域资源共享)</p>\n</li>\n<li>\n<p>错误页面处理器</p>\n</li>\n<li>\n<p>HTTP基本/摘要认证</p>\n</li>\n<li>\n<p>基于重定向的认证</p>\n</li>\n<li>\n<p>授权处理器</p>\n</li>\n<li>\n<p>基于 JWT 的授权</p>\n</li>\n<li>\n<p>用户/角色/权限授权</p>\n</li>\n<li>\n<p>网页图标处理器</p>\n</li>\n<li>\n<p>支持服务端模板渲染，包括以下开箱即用的模板引擎:</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Handlebars</p>\n</li>\n<li>\n<p>Jade</p>\n</li>\n<li>\n<p>MVEL</p>\n</li>\n<li>\n<p>Thymeleaf</p>\n</li>\n<li>\n<p>Apache FreeMarker</p>\n</li>\n<li>\n<p>Pebble</p>\n</li>\n<li>\n<p>Rocker</p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>响应时间处理器</p>\n</li>\n<li>\n<p>静态文件服务，包括缓存逻辑以及目录监听</p>\n</li>\n<li>\n<p>支持请求超时</p>\n</li>\n<li>\n<p>支持 SockJS</p>\n</li>\n<li>\n<p>桥接 Event-bus</p>\n</li>\n<li>\n<p>CSRF 跨域请求伪造</p>\n</li>\n<li>\n<p>虚拟主机</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web 的大部分特性是使用Handler实现的， 而且您随时可以实现您自己的处理器。\n我们预计随着时间的推移会有更多的处理器被实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们会在本手册里讨论所有上述的特性。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_web\"><a class=\"anchor\" href=\"#_using_vert_x_web\"></a>使用 Vert.x Web</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在使用 Vert.x Web 之前，需要为您的构建工具在描述文件中添加  <em>dependencies</em> 依赖项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件中)：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-web:4.2.2&#x27;</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_development_mode\"><a class=\"anchor\" href=\"#_development_mode\"></a>开发模式</h3>\n<div class=\"paragraph\">\n<p>Vert.x Web 默认使用生产模式。\n您可以通过设置 <code>dev</code> 值到下面的其中一个来切换开发模式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>VERTXWEB_ENVIRONMENT</code> 环境变量，或</p>\n</li>\n<li>\n<p><code>vertxweb.environment</code> 系统属性</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在开发模式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>模板引擎缓存被禁用</p>\n</li>\n<li>\n<p><code>ErrorHandler</code> 不显示异常详细信息</p>\n</li>\n<li>\n<p><code>StaticHandler</code> 不处理缓存头</p>\n</li>\n<li>\n<p>GraphQL开发工具被禁用</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_re_cap_on_vert_x_core_http_servers\"><a class=\"anchor\" href=\"#_re_cap_on_vert_x_core_http_servers\"></a>回顾 Vert.x Core 的 HTTP 服务端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web 使用并暴露了 Vert.x Core 的 API，\n所以熟悉基于 Vert.x Core 编写 HTTP 服务端的基本概念是很有价值的。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x core HTTP文档对此进行了详细介绍。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个用 Vert.x core 编写的 Hello World Web服务。暂不涉及Vert.x-Web：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer();\n\nserver.requestHandler(request -&gt; {\n\n  <span class=\"hljs-comment\">// 所有的请求都会调用这个处理器处理</span>\n  <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> request.response();\n  response.putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;text/plain&quot;</span>);\n\n  <span class=\"hljs-comment\">// 写入响应并结束处理</span>\n  response.end(<span class=\"hljs-string\">&quot;Hello World!&quot;</span>);\n});\n\nserver.listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们创建了一个 HTTP 服务器实例，并设置了一个请求处理器。\n所有的请求都会调用这个处理器处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>当请求到达时，我们设置响应的 Content Type 为 <code>text/plain</code> ， 并写入了 <code>Hello World!</code>\n然后结束了处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>之后，我们告诉服务器监听 <code>8080</code> 端口(默认的主机名是 <code>localhost</code> )。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以执行这段代码，并打开浏览器访问 <code><a href=\"http://localhost:8080\" class=\"bare\">http://localhost:8080</a></code> 来验证它是否如预期一样工作。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_basic_vert_x_web_concepts\"><a class=\"anchor\" href=\"#_basic_vert_x_web_concepts\"></a>Vert.x Web 的基本概念</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>高屋建瓴 (Here&#8217;s the 10000 foot view)：</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">路由器 Router</a></code> 是 Vert.x Web 的核心概念之一。 它是一个维护了零或多个\n<code><a href=\"../../apidocs/io/vertx/ext/web/Route.html\">路由 Routes</a></code> 的对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个 router 接收 HTTP 请求，并查找首个匹配该请求的route, 然后将请求传递给这个route</p>\n</div>\n<div class=\"paragraph\">\n<p><code>Route</code> 可以持有一个与之关联的 <em>handler</em> 用于接收请求。 您可以通过这个处理器对请求 <em>做一些事情</em>,\n然后结束响应或者把请求传递给下一个匹配的处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一个简单的路由示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer();\n\n<span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\nrouter.route().handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有的请求都会调用这个处理器处理</span>\n  <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n  response.putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;text/plain&quot;</span>);\n\n  <span class=\"hljs-comment\">// 写入响应并结束处理</span>\n  response.end(<span class=\"hljs-string\">&quot;Hello World from Vert.x-Web!&quot;</span>);\n});\n\nserver.requestHandler(router).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>它做了和上文使用 Vert.x Core 实现的 hello world HTTP 服务基本相同的事情，\n只是这一次换成了 Vert.x Web。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们像以前一样创建一个HTTP服务器，然后我们创建一个 router。当我们完成这些之后，\n我们创建一个简单的没有匹配条件的 rout，它能够匹配 <em>全部</em> 到来的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>然后，我们为该路由指定一个处理器。该处理器将处理所有到来的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>传递给处理器的对象是 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> -\n它包含标准的 Vert.x <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerResponse.html\">HttpServerResponse</a></code>\n还有其他各种有用的东西，让使用Vert.x-Web变得更加简单。</p>\n</div>\n<div class=\"paragraph\">\n<p>每个被路由的请求， 都有一个唯一的路由上下文实例，\n并将这个实例传递给该请求的所有处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>当我们建立了处理器之后，我们设置 HTTP 服务器的请求处理器，\n使所有的请求都通过 <code><a href=\"../../apidocs/io/vertx/core/Handler.html#handle-java.lang.Object-\">handle</a></code> 处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些是最基本的，下面我们来看一下更多的细节：</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_requests_and_calling_the_next_handler\"><a class=\"anchor\" href=\"#_handling_requests_and_calling_the_next_handler\"></a>处理请求并调用下一个处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当 Vert.x Web 决定路由一个请求到匹配的route，\n它会调用对应处理器并将一个 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 实例传递给它.route可以具有不同的处理器，\n您可以叠加使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route。html#handler-io.vertx.core.Handler-\">handler</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>如果您不在处理器里结束这个响应，您需要调用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\">next</a></code>\n方法让其他匹配的 route 来处理请求(如果有)。</p>\n</div>\n<div class=\"paragraph\">\n<p>您不需要在处理器执行完毕时调用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\">next</a></code> 。\n您可以在之后需要的时间点调用它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>);\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n  <span class=\"hljs-comment\">// 开启分块响应，</span>\n  <span class=\"hljs-comment\">// 因为我们将在执行其他处理器时添加数据</span>\n  <span class=\"hljs-comment\">// 仅当有多个处理器输出时</span>\n  response.setChunked(<span class=\"hljs-literal\">true</span>);\n\n  response.write(<span class=\"hljs-string\">&quot;route1\\n&quot;</span>);\n\n  <span class=\"hljs-comment\">// 延迟5秒后调用下一匹配route</span>\n  ctx.vertx().setTimer(<span class=\"hljs-number\">5000</span>, tid -&gt; ctx.next());\n});\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n  response.write(<span class=\"hljs-string\">&quot;route2\\n&quot;</span>);\n\n  <span class=\"hljs-comment\">// 延迟5秒后调用下一匹配route</span>\n  ctx.vertx().setTimer(<span class=\"hljs-number\">5000</span>, tid -&gt; ctx.next());\n});\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n  response.write(<span class=\"hljs-string\">&quot;route3&quot;</span>);\n\n  <span class=\"hljs-comment\">// 现在结束响应</span>\n  ctx.response().end();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述的例子中， <code>route1</code> 向响应里写入了数据， 5秒之后 <code>route2</code> 向响应里写入了数据，\n再5秒之后 <code>route3</code> 向响应里写入了数据并结束了响应。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n所有发生的这些没有线程阻塞。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_simple_responses\"><a class=\"anchor\" href=\"#_simple_responses\"></a>简单的响应</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>处理器非常强大， 因为它们允许您构建非常复杂的应用程序。 为了保证简单的响应，\n例如直接从vert.x API返回异步响应，\nrouter 包含一个快捷的处理器：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>响应返回JSON。</p>\n</li>\n<li>\n<p>如果处理过程中发生错误，一个适当的错误会返回。</p>\n</li>\n<li>\n<p>如果序列化JSON中发生错误，一个适当的错误会返回。</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">&quot;/some/path&quot;</span>)\n  <span class=\"hljs-comment\">// 这个处理器将保证这个响应会被序列化成json</span>\n  <span class=\"hljs-comment\">// content type被设置成 &quot;application/json&quot;</span>\n  .respond(\n    ctx -&gt; Future.succeededFuture(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;world&quot;</span>)));\n\nrouter\n  .get(<span class=\"hljs-string\">&quot;/some/path&quot;</span>)\n  <span class=\"hljs-comment\">// 这个处理器将保证这个Pojo会被序列化成json</span>\n  <span class=\"hljs-comment\">// content type被设置成 &quot;application/json&quot;</span>\n  .respond(\n    ctx -&gt; Future.succeededFuture(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pojo</span>()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>不过， 如果提供的函数支持调用 <code>write</code> 或 <code>end</code> ， 您还可以将其用于非JSON响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">&quot;/some/path&quot;</span>)\n  .respond(\n    ctx -&gt; ctx\n      .response()\n        .putHeader(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;text/plain&quot;</span>)\n        .end(<span class=\"hljs-string\">&quot;hello world!&quot;</span>));\n\nrouter\n  .get(<span class=\"hljs-string\">&quot;/some/path&quot;</span>)\n  <span class=\"hljs-comment\">// 在这种情况下，处理器确保连接被终止</span>\n  .respond(\n    ctx -&gt; ctx\n      .response()\n        .setChunked(<span class=\"hljs-literal\">true</span>)\n        .write(<span class=\"hljs-string\">&quot;Write some text...&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_blocking_handlers\"><a class=\"anchor\" href=\"#_using_blocking_handlers\"></a>使用阻塞式处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>某些时候您可能需要在处理器里执行一些需要阻塞 Event Loop 的操作，\n比如调用某个传统的阻塞式 API 或者执行密集计算。</p>\n</div>\n<div class=\"paragraph\">\n<p>您不能在普通的处理器里执行这些操作， 因此我们提供了将route设置成阻塞式处理器的功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>阻塞式处理器和普通处理器很像，\n区别是 Vert.x 会使用 Worker Pool 中的线程而不是 Event Loop 线程来处理请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-\">blockingHandler</a></code> 方法来建立阻塞式处理器。\n以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().blockingHandler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 执行某些同步的耗时操作</span>\n  service.doSomethingThatBlocks();\n\n  <span class=\"hljs-comment\">// 调用下一个处理器</span>\n  ctx.next();\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，在同一个 Context (例如同一个 Verticle 实例) 上执行的所有阻塞式处理器是顺序的，\n也就意味着只有一个处理器执行完了才会继续执行下一个。 如果您不关心执行的顺序，\n并且不介意阻塞式处理器以并行的方式执行， 您可以在使用\n<code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#blockingHandler-io.vertx.core.Handler-boolean-\">blockingHandler</a></code> 时，设置阻塞式处理器的 <code>ordered</code> 为 false。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果您需要在一个阻塞处理器中处理一个 multipart 类型的表单数据，\n您需要首先使用一个非阻塞的处理器来调用 <code>setExpectMultipart(true)</code> 。以下是例子：\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.post(<span class=\"hljs-string\">&quot;/some/endpoint&quot;</span>).handler(ctx -&gt; {\n  ctx.request().setExpectMultipart(<span class=\"hljs-literal\">true</span>);\n  ctx.next();\n}).blockingHandler(ctx -&gt; {\n  <span class=\"hljs-comment\">// ... 执行某些阻塞操作</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_by_exact_path\"><a class=\"anchor\" href=\"#_routing_by_exact_path\"></a>基于精确路径的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>可以将 <code>Route</code> 设置为根据需要所匹配的 URI。\n在这种情况下它只会匹配路径一致的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>在下面这个例子中，处理器会被路径为 <code>/some/path/</code> 的请求调用。 我们会忽略结尾的 <code>/</code> ，\n所以路径 <code>/some/path</code> 或者 <code>/some/path//</code> 的请求也是匹配的</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route().path(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器会被以下路径的请求调用：</span>\n\n  <span class=\"hljs-comment\">// `/some/path/`</span>\n  <span class=\"hljs-comment\">// `/some/path//`</span>\n  <span class=\"hljs-comment\">//</span>\n  <span class=\"hljs-comment\">// 但不包括:</span>\n  <span class=\"hljs-comment\">// `/some/path` 路径末尾的斜线会被严格限制</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir`</span>\n});\n\n<span class=\"hljs-comment\">// 路径结尾没有斜线的不会被严格限制</span>\n<span class=\"hljs-comment\">// 这意味着结尾的斜线是可选的</span>\n<span class=\"hljs-comment\">// 无论怎样都会匹配</span>\n<span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route2</span> <span class=\"hljs-operator\">=</span> router.route().path(<span class=\"hljs-string\">&quot;/some/path&quot;</span>);\n\nroute2.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器会被以下路径的请求调用：</span>\n\n  <span class=\"hljs-comment\">// `/some/path`</span>\n  <span class=\"hljs-comment\">// `/some/path/`</span>\n  <span class=\"hljs-comment\">// `/some/path//`</span>\n  <span class=\"hljs-comment\">//</span>\n  <span class=\"hljs-comment\">// 但不包括:</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir`</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_by_paths_that_begin_with_something\"><a class=\"anchor\" href=\"#_routing_by_paths_that_begin_with_something\"></a>基于路径前缀的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您经常需要为所有以某些路径开始的请求设置 <code>Route</code> 。 您可以使用正则表达式来实现，\n但更简单的方式是在声明 <code>Route</code> 的路径时使用一个 <code>*</code> 作为结尾。</p>\n</div>\n<div class=\"paragraph\">\n<p>在下面的例子中处理器会匹配所有 URI 以\n<code>/some/path</code> 开头的请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如 <code>/some/path/foo.html</code> 和 <code>/some/path/otherdir/blah.css</code> 都会匹配。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route().path(<span class=\"hljs-string\">&quot;/some/path/*&quot;</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器处理会被所有以</span>\n  <span class=\"hljs-comment\">// `/some/path/` 开头的请求调用， 例如：</span>\n\n  <span class=\"hljs-comment\">// `/some/path/`</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir`</span>\n  <span class=\"hljs-comment\">// `/some/path/subdir/blah.html`</span>\n  <span class=\"hljs-comment\">//</span>\n  <span class=\"hljs-comment\">// 但同时：</span>\n  <span class=\"hljs-comment\">// `/some/path` 最终的斜杆总是可选的并配有通配符，</span>\n  <span class=\"hljs-comment\">//              以保持与许多客户端库的兼容性。</span>\n  <span class=\"hljs-comment\">// 但 **不包括**：</span>\n  <span class=\"hljs-comment\">// `/some/patha`</span>\n  <span class=\"hljs-comment\">// `/some/patha/`</span>\n  <span class=\"hljs-comment\">// 等等……</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以在创建 <code>Route</code> 的时候指定任意的路径：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route(<span class=\"hljs-string\">&quot;/some/path/*&quot;</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 这个处理器的调用规则和上面的例子一样</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_capturing_path_parameters\"><a class=\"anchor\" href=\"#_capturing_path_parameters\"></a>捕捉路径参数</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>可以通过占位符声明路径参数并在处理请求时通过\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#pathParam-java.lang.String-\">pathParam</a></code> 。 方法获取</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(HttpMethod.POST, <span class=\"hljs-string\">&quot;/catalogue/products/:productType/:productID/&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">productType</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;productType&quot;</span>);\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">productID</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;productID&quot;</span>);\n\n    <span class=\"hljs-comment\">// 执行某些操作...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>占位符由 <code>:</code> 和参数名构成。 参数名由字母，数字和下划线构成。\n在某些情况下，这会受到一定限制，因而用户可以切换至包括2个额外字符“-”和“ $”的扩展名称规则。\n扩展参数规则可用如下系统属性启用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Dio.vertx.web.route.param.extended-pattern=true</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述例子中， 如果一个 POST 请求的路径为  <code>/catalogue/products/tools/drill123/</code> ， 那么会匹配这个 <code>Route</code> ，\n并且会接收参数 <code>productType</code> 的值为 <code>tools</code> ，参数 <code>productID</code> 的值为 <code>drill123</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>参数并不一定是路径段。例如，以下路径参数同样有效：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(HttpMethod.GET, <span class=\"hljs-string\">&quot;/flights/:from-:to&quot;</span>)\n  .handler(ctx -&gt; {\n    <span class=\"hljs-comment\">// 在处理发送至/flights/AMS-SFO的请求时，将会设置：</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">from</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;from&quot;</span>); <span class=\"hljs-comment\">// AMS</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">to</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;to&quot;</span>); <span class=\"hljs-comment\">// SFO</span>\n    <span class=\"hljs-comment\">// 记住一点，如果不切换至参数命名的 “extend/扩展” 模式的话，</span>\n    <span class=\"hljs-comment\">// 这将不会起作用。</span>\n    <span class=\"hljs-comment\">// 因为在那种情况下，“-” 符号并不被认为是分隔符，</span>\n    <span class=\"hljs-comment\">// 而是参数名的一部分。</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n您也可以将 * 捕获为路径参数 * 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_with_regular_expressions\"><a class=\"anchor\" href=\"#_routing_with_regular_expressions\"></a>基于正则表达式的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>同样也可用正则表达式匹配路由的 URI 路径。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route().pathRegex(<span class=\"hljs-string\">&quot;.*foo&quot;</span>);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 以下路径的请求都会调用这个处理器：</span>\n\n  <span class=\"hljs-comment\">// /some/path/foo</span>\n  <span class=\"hljs-comment\">// /foo</span>\n  <span class=\"hljs-comment\">// /foo/bar/wibble/foo</span>\n  <span class=\"hljs-comment\">// /bar/foo</span>\n\n  <span class=\"hljs-comment\">// 但不包括：</span>\n  <span class=\"hljs-comment\">// /bar/wibble</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者在创建 route 时指定正则表达式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.routeWithRegex(<span class=\"hljs-string\">&quot;.*foo&quot;</span>);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 这个路由器的调用规则和上面的例子一样</span>\n\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_capturing_path_parameters_with_regular_expressions\"><a class=\"anchor\" href=\"#_capturing_path_parameters_with_regular_expressions\"></a>通过正则表达式捕捉路径参数</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您也可以通过正则表达式声明捕捉路径参数，以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.routeWithRegex(<span class=\"hljs-string\">&quot;.*foo&quot;</span>);\n\n<span class=\"hljs-comment\">// 这个正则表达式可以匹配路径类似于：</span>\n<span class=\"hljs-comment\">// `/foo/bar` 的请求</span>\n<span class=\"hljs-comment\">// `foo` 可以通过参数 param0 获取，`bar` 可以通过参数 param1 获取</span>\nroute.pathRegex(<span class=\"hljs-string\">&quot;\\\\/([^\\\\/]+)\\\\/([^\\\\/]+)&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">productType</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;param0&quot;</span>);\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">productID</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;param1&quot;</span>);\n\n  <span class=\"hljs-comment\">// 执行某些操作……</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述的例子中，如果一个请求的路径为 <code>/tools/drill123/</code>，那么会匹配这个 <code>route</code>，\n并且会接收到参数 <code>productType</code> 的值为 <code>tools</code>，参数 <code>productID</code> 的值为 <code>drill123</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>捕捉（译者注：这里指的是捕捉参数这一行为）在正则表达式中用捕捉组表示（即用圆括号括住捕捉）</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_named_capture_groups\"><a class=\"anchor\" href=\"#_using_named_capture_groups\"></a>使用命名的捕捉组</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用序号参数名在某些场景下可能会比较麻烦。\n亦可在正则表达式路径中使用命名的捕捉组。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .routeWithRegex(<span class=\"hljs-string\">&quot;\\\\/(?&lt;productType&gt;[^\\\\/]+)\\\\/(?&lt;productID&gt;[^\\\\/]+)&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">productType</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;productType&quot;</span>);\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">productID</span> <span class=\"hljs-operator\">=</span> ctx.pathParam(<span class=\"hljs-string\">&quot;productID&quot;</span>);\n\n    <span class=\"hljs-comment\">// 执行某些操作……</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述的例子中，命名捕捉组将路径参数映射到同名的捕捉组中。</p>\n</div>\n<div class=\"paragraph\">\n<p>此外，您仍可以使用普通捕捉组访问组参数（例如：<code>params0, params1&#8230;&#8203;</code>）</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_by_http_method\"><a class=\"anchor\" href=\"#_routing_by_http_method\"></a>基于 HTTP 方法的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Route 默认会匹配所有的 HTTP 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您只想让 route 匹配特定的 HTTP 方法，那么您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-\">method</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route().method(HttpMethod.POST);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有的 POST 请求都会调用这个处理器</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者您可以在创建 Route 时和路径一起指定：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route(HttpMethod.POST, <span class=\"hljs-string\">&quot;/some/path/&quot;</span>);\n\nroute.handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 所有路径为 `/some/path/`</span>\n  <span class=\"hljs-comment\">// 的 POST 请求都会调用这个处理器</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您想让 Route 指定 HTTP 方法，您也可以使用对应的 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#get--\">get</a></code>，\n<code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#post--\">post</a></code> 以及 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#put--\">put</a></code> 等方法。\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get().handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有 GET 请求都会调用这个处理器</span>\n\n});\n\nrouter.get(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有路径以 `/some/path/` 开始的</span>\n  <span class=\"hljs-comment\">// GET 请求都会调用这个处理器</span>\n\n});\n\nrouter.getWithRegex(<span class=\"hljs-string\">&quot;.*foo&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有路径以 `foo` 结尾的</span>\n  <span class=\"hljs-comment\">// GET 请求都会调用这个处理器</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您想要让 route 匹配不止一个 HTTP 方法，\n您可多次调用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#method-io.vertx.core.http.HttpMethod-\">method</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route().method(HttpMethod.POST).method(HttpMethod.PUT);\n\nroute.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 所有 GET 或 POST 请求都会调用这个处理器</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您的应用程序需要自定义 HTTP 动词，例如， <code>基于Web的分布式编写和版本控制（WebDAV）</code> 服务器中，\n您可这样自定义动词：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.route()\n  .method(HttpMethod.valueOf(<span class=\"hljs-string\">&quot;MKCOL&quot;</span>))\n  .handler(ctx -&gt; {\n    <span class=\"hljs-comment\">// 所有 MKCOL 请求都会调用这个处理器</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n请务必留意，像 rerouting 等特性不接受自定义 http 方法，\n这些操作在检测到自定义动词时将会使用 <code>OTHER</code> 值以替代自定义名。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_route_order\"><a class=\"anchor\" href=\"#_route_order\"></a>路由顺序</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下Route按照其加入到Router的顺序进行匹配</p>\n</div>\n<div class=\"paragraph\">\n<p>路由器会逐级检查每条Route否匹配\n如果匹配的话，该Route的handler将被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果这个handler接下来会调用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#next--\">next</a></code> 方法\n则下一个匹配的路由(如果有的话)的handler将被调用。等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>这里有一个例子来说明</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n    <span class=\"hljs-comment\">//启动response的分块响应功能，</span>\n    <span class=\"hljs-comment\">//因为我们将在多个handler中将添加数据</span>\n    <span class=\"hljs-comment\">//只需要一次，并且只在多个处理程序进行输出时才需要。</span>\n    response.setChunked(<span class=\"hljs-literal\">true</span>);\n\n    response.write(<span class=\"hljs-string\">&quot;route1\\n&quot;</span>);\n\n    <span class=\"hljs-comment\">//现在我们将调用下一个匹配的Route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n    response.write(<span class=\"hljs-string\">&quot;route2\\n&quot;</span>);\n\n    <span class=\"hljs-comment\">//现在我们将调用下一个匹配的Route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n    response.write(<span class=\"hljs-string\">&quot;route3&quot;</span>);\n\n    <span class=\"hljs-comment\">// 现在我们结束响应</span>\n    ctx.response().end();\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上面的例子里面，响应将包含这些内容</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>route1\nroute2\nroute3</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于任何以' /some/path '开头的请求，路由都是按照这个顺序被调用的</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您想要覆盖默认的Route顺序，您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#order-int-\">order</a></code>\n指定一个整数类型的值</p>\n</div>\n<div class=\"paragraph\">\n<p>Route在创建时被分配的顺序与它们被添加到Router的顺序相对应\n第一个Route编号为 <code>0</code>，第二个Route编号为 <code>1</code>，以此类推。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过给Route指定order您可以覆盖默认值，order可以为负值，举个例子\n如果想要确保一个Route在order为 <code>0</code> 的Route之前执行则可以这样做</p>\n</div>\n<div class=\"paragraph\">\n<p>让我们更改route2的order值让他在route1之前执行</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>)\n  .order(<span class=\"hljs-number\">1</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n    response.write(<span class=\"hljs-string\">&quot;route1\\n&quot;</span>);\n\n    <span class=\"hljs-comment\">// 现在调用下一个匹配的Route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>)\n  .order(<span class=\"hljs-number\">0</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n    <span class=\"hljs-comment\">// 启动response的分块响应功能，</span>\n    <span class=\"hljs-comment\">// 因为我们将在多个handler中将添加数据</span>\n    <span class=\"hljs-comment\">// 只需要一次，并且只在多个处理程序进行输出时才需要。</span>\n    response.setChunked(<span class=\"hljs-literal\">true</span>);\n\n    response.write(<span class=\"hljs-string\">&quot;route2\\n&quot;</span>);\n\n    <span class=\"hljs-comment\">// Now call the next matching route</span>\n    ctx.next();\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">&quot;/some/path/&quot;</span>)\n  .order(<span class=\"hljs-number\">2</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n    response.write(<span class=\"hljs-string\">&quot;route3&quot;</span>);\n\n    <span class=\"hljs-comment\">// Now end the response</span>\n    ctx.response().end();\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后响应将包含以下内容</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>route2\nroute1\nroute3</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果两个匹配的Route都具有相同的order值，则按照他们添加的顺序被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以指定一个路由最后调用，参考 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#last--\">last</a></code></p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n只能在配置handler之前指定路由顺序！\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_based_on_mime_type_of_request\"><a class=\"anchor\" href=\"#_routing_based_on_mime_type_of_request\"></a>基于请求MIME类型的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>通过使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-\">consumes</a></code>，您可以指定route将与的哪种请求MIME类型相匹配。</p>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，请求将包含一个 <code>content-type</code> 请求头，指定请求体的MIME类型\n这将匹配 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#consumes-java.lang.String-\">consumes</a></code> 指定的值。</p>\n</div>\n<div class=\"paragraph\">\n<p>基本上，<code>consumes</code> 用于描述这个handler将可以 <em>处理</em> 哪些MIME类型</p>\n</div>\n<div class=\"paragraph\">\n<p>匹配可以在精确的MIME类型匹配上进行：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">&quot;text/html&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">//这个handler将会被</span>\n    <span class=\"hljs-comment\">//content-type 请求头设置为`text/html`的任意请求调用</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以指定多个精确的匹配：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">&quot;text/html&quot;</span>)\n  .consumes(<span class=\"hljs-string\">&quot;text/plain&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// 这个handler将会被</span>\n    <span class=\"hljs-comment\">// content-type 请求头设置为`text/html`或者`text/plain`的任意请求调用</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>支持子类型通配符的匹配：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">&quot;text/*&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">//这个handler将会被</span>\n    <span class=\"hljs-comment\">//顶级类型为`text` 例如</span>\n    <span class=\"hljs-comment\">//content-type被设置为`text/html` 或者 `text/plain`的任意请求</span>\n    <span class=\"hljs-comment\">//匹配</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>而且您也可以匹配顶级类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .consumes(<span class=\"hljs-string\">&quot;*/json&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">//这个handler将会被子类型为json的任意请求调用</span>\n    <span class=\"hljs-comment\">//例如content-type请求头设置为`text/json`或者</span>\n    <span class=\"hljs-comment\">// `application/json` 都会匹配</span>\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您没有在consumer中指定一个 <code>/</code> ，它会假定您指的是子类型</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_based_on_mime_types_acceptable_by_the_client\"><a class=\"anchor\" href=\"#_routing_based_on_mime_types_acceptable_by_the_client\"></a>基于客户端可接收的MIME类型的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>HTTP <code>accept</code> 请求头用于表示客户端可以接受响应的MIME类型</p>\n</div>\n<div class=\"paragraph\">\n<p>一个 <code>accept</code> 请求头可以包含多个MIME类型，其之间用 &#8216;,&#8217; 分割</p>\n</div>\n<div class=\"paragraph\">\n<p>MIME类型还可以附加一个 <code>q</code> 值，这表示如果有多个响应MIME类型与接受请求头匹配，则指定一个权重\nq值是0到1.0之间的数字。\n如果省略，则默认为1.0。</p>\n</div>\n<div class=\"paragraph\">\n<p>举个例子，下面的 <code>accept</code> 请求头则指定客户端将只能接收 <code>text/plain</code> 的MIME类型数据：</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: text/plain</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端将接受 <code>text/plain</code> 或 <code>text/html</code> ，没有优先级：</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: text/plain, text/html</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端将接受 <code>text/plain</code> 或 <code>text/html</code> ，但因为 <code>text/html</code> 有一个更高的\n<code>q</code> 值(默认q=1.0)，所以客户端会优先接收 <code>text/html</code> ：</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: text/plain; q=0.9, text/html</p>\n</div>\n<div class=\"paragraph\">\n<p>如果服务端可以同时提供 text/plain 和 text/html，在这个例子里面它应当提供 text/html。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#produces-java.lang.String-\">produces</a></code> 您可以决定Route可以产生那个(哪些) MIME 类型 例如\n下面这个handler会产生一个MIME类型为 <code>application/json</code> 的响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .produces(<span class=\"hljs-string\">&quot;application/json&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n    response.putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;application/json&quot;</span>);\n    response.end(someJSON);\n\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，Route将匹配带有 <code>accept</code> 请求头且匹配 <code>application/json</code> 的任何请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>这有一些 <code>accept</code> 请求头将如何匹配的例子：</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: application/json\nAccept: application/*\nAccept: application/json, text/html\nAccept: application/json;q=0.7, text/html;q=0.8, text/plain</p>\n</div>\n<div class=\"paragraph\">\n<p>您还可以将您的路由标记为生成多个MIME类型。如果是这样，那么使用\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--\">getAcceptableContentType</a></code>\n找出实际被接收的MIME类型。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .produces(<span class=\"hljs-string\">&quot;application/json&quot;</span>)\n  .produces(<span class=\"hljs-string\">&quot;text/html&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> ctx.response();\n\n    <span class=\"hljs-comment\">// 获取真正可接受的MIME类型</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">acceptableContentType</span> <span class=\"hljs-operator\">=</span> ctx.getAcceptableContentType();\n\n    response.putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, acceptableContentType);\n    response.end(whatever);\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上面的例子中，如果您发送了一个带有以下 <code>accept</code> 请求头的请求：</p>\n</div>\n<div class=\"paragraph\">\n<p>Accept: application/json; q=0.7, text/html</p>\n</div>\n<div class=\"paragraph\">\n<p>然后路由将匹配，<code>acceptableContentType</code> 将包含 <code>text/html</code>\n两个都是可以接受的但是它有更高的 <code>q</code> 值。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_routing_based_on_virtualhost\"><a class=\"anchor\" href=\"#_routing_based_on_virtualhost\"></a>基于VirtualHost的路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以配置一个 <code>Route</code> 将与请求主机名匹配</p>\n</div>\n<div class=\"paragraph\">\n<p>请求会根据 <code>Host</code> 请求头进行匹配检查，这种模式允许使用 <code><strong></code> 通配符\n举个例子 <code></strong>.vertx.io</code> 或像 <code>www.vertx.io</code> 的完整域名。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().virtualHost(<span class=\"hljs-string\">&quot;*.vertx.io&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">//如果请求符合 *.vertx.io，则做一些事情</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_combining_routing_criteria\"><a class=\"anchor\" href=\"#_combining_routing_criteria\"></a>组合多个路由条件</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以用不同方式组合上面所有的路由条件，举个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(HttpMethod.PUT, <span class=\"hljs-string\">&quot;myapi/orders&quot;</span>)\n  .consumes(<span class=\"hljs-string\">&quot;application/json&quot;</span>)\n  .produces(<span class=\"hljs-string\">&quot;application/json&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// 这个将匹配PUT方法，</span>\n    <span class=\"hljs-comment\">// 请求路径以&quot;myapi/orders&quot;开头且 content-type为&quot;application/json&quot;</span>\n    <span class=\"hljs-comment\">// 和 accept请求头为&quot;application/json&quot;的任意请求</span>\n\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_enabling_and_disabling_routes\"><a class=\"anchor\" href=\"#_enabling_and_disabling_routes\"></a>启用或者关闭Route</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#disable--\">disable</a></code> 关闭一个Route。一个被关闭的Route将会在匹配过程中被忽略。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#enable--\">enable</a></code> 重新启用一个被关闭的Route。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_forward_support\"><a class=\"anchor\" href=\"#_forward_support\"></a>对Forward的支持</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您的应用可能由Proxy服务器所代理，比如 <code>HAProxy</code>。在此设置下工作时，获取客户端连接细节将不能正确返回预期结果\n举个例子，\n客户端的主机ip地址可能是代理服务器的ip地址，而不是实际客户端的ip地址</p>\n</div>\n<div class=\"paragraph\">\n<p>为了获取正确的连接信息，一个特殊的请求头 <code>Forward</code> 已经被标准化，以包括正确的\n信息。虽然这个标准不是很老，但是很多代理已经使用其他请求头，通常\n以前缀 <code>X-Forward</code> 开头。Vert.x web允许使用和解析这些请求头信息，但不是默认的。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些请求头在默认情况下禁用的原因是为了防止恶意应用程序伪造它们的来源\n和隐藏他们真正的来源。</p>\n</div>\n<div class=\"paragraph\">\n<p>如前所述，默认情况下forward是禁用的，要启用，您应该使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.allowForward(AllowForwardHeaders.FORWARD);\n\n<span class=\"hljs-comment\">// 您现在可以允许解析forward请求头了</span>\n<span class=\"hljs-comment\">// 在这种情况下，只会考虑&quot;X-Forward&quot;请求头</span>\nrouter.allowForward(AllowForwardHeaders.X_FORWARD);\n\n<span class=\"hljs-comment\">//我们现在可以允许forward请求头解析</span>\n<span class=\"hljs-comment\">//在这个例子中是&quot;Forward&quot;请求头和&quot;X-Forward&quot;请求头</span>\n<span class=\"hljs-comment\">//将被解析，但是来自&quot;Forward&quot;的值优先</span>\n<span class=\"hljs-comment\">//这意味着如果发生冲突(2个请求头的值相同)</span>\n<span class=\"hljs-comment\">//接收&quot;Forward&quot;值，忽略&quot;X-Forward&quot;。</span>\nrouter.allowForward(AllowForwardHeaders.ALL);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同样的规则也适用于显式禁用请求头的解析:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.allowForward(AllowForwardHeaders.NONE);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>要阅读更多关于请求头格式的格式，请查看</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://tools.ietf.org/html/rfc7239#section-4\" class=\"bare\">https://tools.ietf.org/html/rfc7239#section-4</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded\" class=\"bare\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在幕后，这个特性所做的是改变您的连接(HTTP或WebSocket)的以下值：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>protocol</p>\n</li>\n<li>\n<p>host name</p>\n</li>\n<li>\n<p>host port</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_context_data\"><a class=\"anchor\" href=\"#_context_data\"></a>上下文数据</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 保存任何\n在请求生命周期内您想在多个handler之间共享的数据</p>\n</div>\n<div class=\"paragraph\">\n<p>下面是一个例子，其中一个handler在上下文数据中设置一些数据，然后一个后续的处理程序获取它：</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#put-java.lang.String-java.lang.Object-\">put</a></code> 添加任何对象， 然后使用\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#get-java.lang.String-\">get</a></code> 获取任何来自于上下文的对象</p>\n</div>\n<div class=\"paragraph\">\n<p>一个发送到 <code>/some/path/other</code> 的请求将匹配这两个Route。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">&quot;/some/path&quot;</span>).handler(ctx -&gt; {\n\n  ctx.put(<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);\n  ctx.next();\n\n});\n\nrouter.get(<span class=\"hljs-string\">&quot;/some/path/other&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">bar</span> <span class=\"hljs-operator\">=</span> ctx.get(<span class=\"hljs-string\">&quot;foo&quot;</span>);\n  <span class=\"hljs-comment\">// 用bar对象做一些事情</span>\n  ctx.response().end();\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#data--\">data</a></code> 获取全部的上下文数据 map</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_metadata\"><a class=\"anchor\" href=\"#_metadata\"></a>元数据</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>虽然上下文数据已经允许您在请求-响应生命周期内存储数据，但有时重要的是能获取\n运行时的元数据。例如，为了构建 API 文档，或保存一个给定的路由规则\n的特定配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>元数据的作用方式与上下文数据类似。您可以通过其 <code>Map</code> 类型接口或使用\n <code>Router</code> 和 <code>Route</code> 接口上的特定 getter 和 setter 来获取数据</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .route(<span class=\"hljs-string\">&quot;/metadata/route&quot;</span>)\n  .putMetadata(<span class=\"hljs-string\">&quot;metadata-key&quot;</span>, <span class=\"hljs-string\">&quot;123&quot;</span>)\n  .handler(ctx -&gt; {\n    <span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> ctx.currentRoute();\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> route.getMetadata(<span class=\"hljs-string\">&quot;metadata-key&quot;</span>); <span class=\"hljs-comment\">// 123</span>\n    <span class=\"hljs-comment\">// 结束请求，并返回 123</span>\n    ctx.end(value);\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_helper_functions\"><a class=\"anchor\" href=\"#_helper_functions\"></a>帮手函数</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>虽然路由上下文将允许您获取基础请求和响应对象，\n但有时如果有一些捷径可以帮助您完成常见的任务，您的工作效率会更高。\n有几个帮手存在于上下文中可以便于完成这项任务。</p>\n</div>\n<div class=\"paragraph\">\n<p>提供一个“附件”，附件是一种响应，它将触发浏览器打开配置为处理特定MIME类型的操作系统应用程序。\n假设您正在生成一个PDF文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx\n  .attachment(<span class=\"hljs-string\">&quot;weekly-report.pdf&quot;</span>)\n  .end(pdfBuffer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>执行重定向到另一个页面或主机。一个例子是重定向到应用程序的HTTPS变体：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.redirect(<span class=\"hljs-string\">&quot;https://securesite.com/&quot;</span>);\n\n<span class=\"hljs-comment\">//对于目标为“back”有一个特殊的处理。</span>\n<span class=\"hljs-comment\">//在这种情况下，重定向会将用户发送到</span>\n<span class=\"hljs-comment\">//referrer url或 &quot;/&quot;如果没有referrer。</span>\n\nctx.redirect(<span class=\"hljs-string\">&quot;back&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>向客户端发送一个JSON响应：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.json(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;vert.x&quot;</span>));\n<span class=\"hljs-comment\">// 也可以用于数组</span>\nctx.json(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonArray</span>().add(<span class=\"hljs-string\">&quot;vertx&quot;</span>).add(<span class=\"hljs-string\">&quot;web&quot;</span>));\n<span class=\"hljs-comment\">//或者用于任意对象</span>\n<span class=\"hljs-comment\">//其将根据运行时的json编码器进行转化</span>\nctx.json(someObject);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>常规的content-type校验：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.is(<span class=\"hljs-string\">&quot;html&quot;</span>); <span class=\"hljs-comment\">// =&gt; true</span>\nctx.is(<span class=\"hljs-string\">&quot;text/html&quot;</span>); <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">//当content-type为application/json时</span>\nctx.is(<span class=\"hljs-string\">&quot;application/json&quot;</span>); <span class=\"hljs-comment\">// =&gt; true</span>\nctx.is(<span class=\"hljs-string\">&quot;html&quot;</span>); <span class=\"hljs-comment\">// =&gt; false</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>验证有关缓存头和last modified/etag的当前值的请求是否\"新鲜\"</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.lastModified(<span class=\"hljs-string\">&quot;Wed, 13 Jul 2011 18:30:00 GMT&quot;</span>);\n<span class=\"hljs-comment\">// 现在将使用它来验证请求的新鲜度</span>\n<span class=\"hljs-keyword\">if</span> (ctx.isFresh()) {\n  <span class=\"hljs-comment\">//客户端缓存值是新鲜的，</span>\n  <span class=\"hljs-comment\">//也许我们可以停止并返回304？</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>和其他一些简单的无需解释的快捷方式</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ctx.etag(<span class=\"hljs-string\">&quot;W/123456789&quot;</span>);\n\n<span class=\"hljs-comment\">// 设置last modified 的值</span>\nctx.lastModified(<span class=\"hljs-string\">&quot;Wed, 13 Jul 2011 18:30:00 GMT&quot;</span>);\n\n<span class=\"hljs-comment\">// 便捷结束响应</span>\nctx.end();\nctx.end(<span class=\"hljs-string\">&quot;body&quot;</span>);\nctx.end(buffer);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reroute\"><a class=\"anchor\" href=\"#_reroute\"></a>重新路由</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>到目前为止，所有路由机制都允许您以顺序的方式处理请求，\n但是有时您可能希望后退。由于上下文没有公开有关上一个或下一个handler的任何信息，\n主要是因为此信息是动态的，\n因此有一种方法可以从当前路由器的开头重新启动整个路由。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">&quot;/some/path&quot;</span>).handler(ctx -&gt; {\n\n  ctx.put(<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);\n  ctx.next();\n\n});\n\nrouter\n  .get(<span class=\"hljs-string\">&quot;/some/path/B&quot;</span>)\n  .handler(ctx -&gt; ctx.response().end());\n\nrouter\n  .get(<span class=\"hljs-string\">&quot;/some/path&quot;</span>)\n  .handler(ctx -&gt; ctx.reroute(<span class=\"hljs-string\">&quot;/some/path/B&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>因此，从代码中您可以看到，如果请求首先到达 <code>/some/path</code> 且最先向上下文中添加一个值，\n然后移至下一个handler，该处理程序将请求重新路由至 <code>/some/path/B</code>，从而终止请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以基于新路径或基于新路径和方法重新路由。\n但是请注意，基于方法的重新路由可能会引入安全性问题，因为例如通常安全的GET请求可能会变为DELETE。</p>\n</div>\n<div class=\"paragraph\">\n<p>失败处理程序上也允许重新路由，但是由于重新路由的性质，当被调用时，当前状态代码和失败原因将会重置\n为了在需要时重新路由的处理程序应生成正确的状态代码，\n例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">&quot;/my-pretty-notfound-handler&quot;</span>).handler(ctx -&gt; ctx.response()\n  .setStatusCode(<span class=\"hljs-number\">404</span>)\n  .end(<span class=\"hljs-string\">&quot;NOT FOUND fancy html here!!!&quot;</span>));\n\nrouter.get().failureHandler(ctx -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ctx.statusCode() == <span class=\"hljs-number\">404</span>) {\n    ctx.reroute(<span class=\"hljs-string\">&quot;/my-pretty-notfound-handler&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    ctx.next();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>应当清楚的是，重新路由可以在 <code>路径</code> 上使用，因此，如果您需要在重新路由之间保留或添加状态，则应使用 <code>RoutingContext</code> 对象。\n例如，您想使用额外的参数重新路由到新路径：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.get(<span class=\"hljs-string\">&quot;/final-target&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 在这里做一些事情</span>\n});\n\n<span class=\"hljs-comment\">// 将会带着查询字符串重定向到 /final-target</span>\nrouter.get().handler(ctx -&gt; ctx.reroute(<span class=\"hljs-string\">&quot;/final-target?variable=value&quot;</span>));\n\n<span class=\"hljs-comment\">// 一个更安全的方法是将变量添加至上下文中</span>\nrouter.get().handler(ctx -&gt; ctx\n  .put(<span class=\"hljs-string\">&quot;variable&quot;</span>, <span class=\"hljs-string\">&quot;value&quot;</span>)\n  .reroute(<span class=\"hljs-string\">&quot;/final-target&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>重新路由也会重新解析查询参数。请注意，先前的查询参数将被丢弃。\n该方法还将静默地丢弃并忽略路径中的任何html片段。\n这是为了使重新路由的语义在常规请求和重新路由之间保持一致。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果需要将更多信息传递给新请求，\n则应使用在HTTP事务的整个生命周期中保留的上下文。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sub_routers\"><a class=\"anchor\" href=\"#_sub_routers\"></a>子路由器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>有时，如果您有很多handler，则可以将它们拆分为多个Router。\n如果要在不同路径根的不同应用程序中重用一组handler，这也很有用。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，您可以将Router挂载在另一个Router <em>挂载点</em> 上。安装的Router称为 <em>子路由器</em>。\n子路由器可以挂载其他子路由器，因此您可以根据需要拥有多个级别的子路由器。</p>\n</div>\n<div class=\"paragraph\">\n<p>让我们看一个简单的子路由挂载在其他路由上面的例子</p>\n</div>\n<div class=\"paragraph\">\n<p>该子路由器将维护简单的虚构REST API对应的handler。我们将其挂载在另一个路由器上。\n其未显示REST API的完整实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个子路由器</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">restAPI</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\nrestAPI.get(<span class=\"hljs-string\">&quot;/products/:productID&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// TODO 处理产品查找</span>\n  ctx.response().write(productJSON);\n\n});\n\nrestAPI.put(<span class=\"hljs-string\">&quot;/products/:productID&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// TODO 添加一个新产品</span>\n  ctx.response().end();\n\n});\n\nrestAPI.delete(<span class=\"hljs-string\">&quot;/products/:productID&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// TODO 删除一个产品</span>\n  ctx.response().end();\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果将此路由器用作顶级路由器，\n则对诸如 <code>/products/product1234</code> 之类的url的GET/PUT/DELETE请求将调用该API。</p>\n</div>\n<div class=\"paragraph\">\n<p>但是，假设我们已经有另一个路由器描述的网站：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">mainRouter</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-comment\">// 处理静态资源</span>\nmainRouter.route(<span class=\"hljs-string\">&quot;/static/*&quot;</span>).handler(myStaticHandler);\n\nmainRouter.route(<span class=\"hljs-string\">&quot;.*\\\\.templ&quot;</span>).handler(myTemplateHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在，我们可以将子路由器挂载在主路由器上，挂载点在本例中为 <code>/productsAPI</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mainRouter.mountSubRouter(<span class=\"hljs-string\">&quot;/productsAPI&quot;</span>, restAPI);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这意味着现在可以通过以下路径访问REST API：<code>/productsAPI/products/product1234</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用子路由器之前，必须满足一些规则</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>路由路径必须以通配符结尾。</p>\n</li>\n<li>\n<p>允许使用参数，但不能完全的使用正则表达式模式。</p>\n</li>\n<li>\n<p>在此调用之前或之后，只能注册1个处理程序（但它们可以在同一路径的新路由对象上注册）</p>\n</li>\n<li>\n<p>每个路径对象仅1个路由器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>验证是在将路由器添加到http服务器时进行的。这意味着由于子路由器的动态特性，在构建期间无法获得任何验证错误。\n它们取决于要验证的上下文。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_localization_localization\"><a class=\"anchor\" href=\"#_localization_localization\"></a>本地化</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web解析 <code>Accept-Language</code> 请求头，\n并提供一些帮助方法来确定哪个是客户端的首选语言环境或按质量排序的首选语言环境列表。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.get(<span class=\"hljs-string\">&quot;/localized&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 尽管通过switch运行循环可能看起来很奇怪，</span>\n  <span class=\"hljs-comment\">// 但我们可以确保在使用用户语言进行响应时，</span>\n  <span class=\"hljs-comment\">// 保留了语言环境的优先顺序。</span>\n  <span class=\"hljs-keyword\">for</span> (LanguageHeader language : ctx.acceptableLanguages()) {\n    <span class=\"hljs-keyword\">switch</span> (language.tag()) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;en&quot;</span>:\n        ctx.response().end(<span class=\"hljs-string\">&quot;Hello!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;fr&quot;</span>:\n        ctx.response().end(<span class=\"hljs-string\">&quot;Bonjour!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;pt&quot;</span>:\n        ctx.response().end(<span class=\"hljs-string\">&quot;Olá!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;es&quot;</span>:\n        ctx.response().end(<span class=\"hljs-string\">&quot;Hola!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n  }\n  <span class=\"hljs-comment\">// 我们不知道用户使用的语言，因此请告知</span>\n  ctx.response().end(<span class=\"hljs-string\">&quot;Sorry we don&#x27;t speak: &quot;</span> + ctx.preferredLanguage());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>主要方法 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#acceptableLanguages--\">acceptableLanguages</a></code> 将返回用户理解的语言环境的有序列表，\n如果您只对用户偏爱的语言环境感兴趣，则使用这个帮手方法\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#preferredLanguage--\">preferredLanguage</a></code> 其将返回列表的第1个元素，\n如果用户未提供语言环境，则返回\"null\"。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_route_match_failures\"><a class=\"anchor\" href=\"#_route_match_failures\"></a>路由匹配失败</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果没有路由符合任何特定请求，则Vert.x-Web将根据匹配失败发出错误消息</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>404 没有匹配的路径</p>\n</li>\n<li>\n<p>405 路径匹配但是请求方法不匹配</p>\n</li>\n<li>\n<p>406 路径匹配，请求方法匹配但是它无法提供内容类型与 <code>Accept</code> 请求头匹配的响应</p>\n</li>\n<li>\n<p>415 路径匹配，请求方法匹配但是它不能接受 <code>Content-type</code></p>\n</li>\n<li>\n<p>400 路径匹配，请求方法匹配但是它接收空方法体</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code> 手动管理这些错误。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_error_handling\"><a class=\"anchor\" href=\"#_error_handling\"></a>错误处理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>除了设置处理程序以处理请求之外，您还可以设置处理程序以处理路由过程中的错误</p>\n</div>\n<div class=\"paragraph\">\n<p>Failure 处理器与普通处理器（handler）有完全相同的路由匹配条件</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您可以提供一个错误处理器，该处理程序仅处理某些路径或某些HTTP方法上的错误。</p>\n</div>\n<div class=\"paragraph\">\n<p>这使您可以为应用程序的不同部分设置不同的错误处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个示例错误处理器，仅在将GET请求路由到以 <code>/somepath/</code> 开头的路径时发生的失败时\n才会调用该错误处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route</span> <span class=\"hljs-operator\">=</span> router.get(<span class=\"hljs-string\">&quot;/somepath/*&quot;</span>);\n\nroute.failureHandler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 以 &#x27;/somepath/&#x27;</span>\n  <span class=\"hljs-comment\">// 开头的路径时发生的错误时</span>\n  <span class=\"hljs-comment\">// 这个将会被调用</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果handler引发异常，或者如果handler调用\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#fail-int-\">fail</a></code> 并指定HTTP状态代码来故意发出失败信号， 则会触发错误处理路由。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果从handler中捕获到异常，则将导致失败，并发出状态代码 <code>500</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>处理错误时，将向故障处理器传递路由上下文，该路由上下文还允许获取故障或故障代码，\n以便错误处理器可以使用它来生成失败响应。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route1</span> <span class=\"hljs-operator\">=</span> router.get(<span class=\"hljs-string\">&quot;/somepath/path1/&quot;</span>);\n\nroute1.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 让我们抛出一个RuntimeException</span>\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(<span class=\"hljs-string\">&quot;something happened!&quot;</span>);\n\n});\n\n<span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route2</span> <span class=\"hljs-operator\">=</span> router.get(<span class=\"hljs-string\">&quot;/somepath/path2&quot;</span>);\n\nroute2.handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 这是一个故意使请求传递状态码的错误</span>\n  <span class=\"hljs-comment\">// 比如 403-访问被拒绝</span>\n  ctx.fail(<span class=\"hljs-number\">403</span>);\n\n});\n\n<span class=\"hljs-comment\">// 定义一个错误处理器</span>\n<span class=\"hljs-comment\">// 它将会被上面handler里面发生的任何异常触发</span>\n<span class=\"hljs-type\">Route</span> <span class=\"hljs-variable\">route3</span> <span class=\"hljs-operator\">=</span> router.get(<span class=\"hljs-string\">&quot;/somepath/*&quot;</span>);\n\nroute3.failureHandler(failureRoutingContext -&gt; {\n\n  <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">statusCode</span> <span class=\"hljs-operator\">=</span> failureRoutingContext.statusCode();\n\n  <span class=\"hljs-comment\">// RuntimeException的状态码将为500</span>\n  <span class=\"hljs-comment\">// 或403，表示其他失败</span>\n  <span class=\"hljs-type\">HttpServerResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> failureRoutingContext.response();\n  response.setStatusCode(statusCode).end(<span class=\"hljs-string\">&quot;Sorry! Not today&quot;</span>);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果在错误处理器执行时在状态消息头中出现非法字符，则发生错误，\n那么原始状态消息将从错误代码更改为默认消息。\n这是保持HTTP协议语义正常工作的一种折衷，\n而不是在没有正确完成协议的情况下突然崩溃并关闭套接字。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_request_body_handling\"><a class=\"anchor\" href=\"#_request_body_handling\"></a>请求体处理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> 允许您获取请求体，\n限制请求体大小和处理文件上传</p>\n</div>\n<div class=\"paragraph\">\n<p>您应该确保对于任何需要此功能的请求，请求体处理器都应在匹配的路由上</p>\n</div>\n<div class=\"paragraph\">\n<p>使用此处理器需要将其尽快安装在路由器中，\n因为它需要安装处理程序以使用HTTP请求体，并且必须在执行任何异步调用之前完成此操作。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(BodyHandler.create());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果之前需要异步调用，则应暂停 <code>HttpServerRequest</code> 然后再恢复，\n以便在请求体处理器准备好处理它们之前，不传递请求事件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">HttpServerRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> ctx.request();\n\n  <span class=\"hljs-comment\">// 暂停请求</span>\n  request.pause();\n\n  someAsyncCall(result -&gt; {\n\n    <span class=\"hljs-comment\">// 恢复请求</span>\n    request.resume();\n\n    <span class=\"hljs-comment\">// 继续处理</span>\n    ctx.next();\n  });\n});\n\n<span class=\"hljs-comment\">// 这个请求体处理器将会被所有的Route调用</span>\nrouter.route().handler(BodyHandler.create());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n上传可能是DDoS攻击的来源，为了减少攻击面，建议\n设置合适的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-\">setBodyLimit</a></code> (例如 10MB的上传限制 或者\n100KB的json大小限制).\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_getting_the_request_body\"><a class=\"anchor\" href=\"#_getting_the_request_body\"></a>获取请求体</h3>\n<div class=\"paragraph\">\n<p>如果您知道请求体是个JSON，然后您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsJson-int-\">getBodyAsJson</a></code> ，\n如果您知道他是个字符串，您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBodyAsString--\">getBodyAsString</a></code>，\n或者使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getBody--\">getBody</a></code>  获取buffer</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_limiting_body_size\"><a class=\"anchor\" href=\"#_limiting_body_size\"></a>限制请求体大小</h3>\n<div class=\"paragraph\">\n<p>为了限制请求体大小，创建请求体处理器然后使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setBodyLimit-long-\">setBodyLimit</a></code> 指定最大请求体大小\n这对于防止过大请求体导致耗尽内存很有用</p>\n</div>\n<div class=\"paragraph\">\n<p>如果尝试发送大于最大大小的请求体，\n则会发送HTTP状态代码413- <code>Request Entity Too Large</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下没有最大请求体大小限制</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_merging_form_attributes\"><a class=\"anchor\" href=\"#_merging_form_attributes\"></a>合并表单属性</h3>\n<div class=\"paragraph\">\n<p>默认情况下，请求体处理器会将所有表单属性合并到请求参数中。\n如果您不想这样做，您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html#setMergeFormAttributes-boolean-\">setMergeFormAttributes</a></code> 关闭这个功能</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_file_uploads\"><a class=\"anchor\" href=\"#_handling_file_uploads\"></a>处理文件上传</h3>\n<div class=\"paragraph\">\n<p>请求体处理器还用于处理多部分文件的上传。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果请求体处理器处于与请求匹配的路由上，\n则任何文件上传将自动流式传输到文件上传目录，该目录默认情况下为 <code>file-uploads</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>每一个文件都会自动生成一个文件名，而且文件上传将通过 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#fileUploads--\">fileUploads</a></code>\n在路由上下文中可用。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(BodyHandler.create());\n\nrouter.post(<span class=\"hljs-string\">&quot;/some/path/uploads&quot;</span>).handler(ctx -&gt; {\n\n  Set&lt;FileUpload&gt; uploads = ctx.fileUploads();\n  <span class=\"hljs-comment\">// 使用uploads做一些事情</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>每个文件上传均由一个 <code><a href=\"../../apidocs/io/vertx/ext/web/FileUpload.html\">FileUpload</a></code> 实例描述，\n该实例允许访问各种属性，例如名称，文件名和大小。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_cookies\"><a class=\"anchor\" href=\"#_handling_cookies\"></a>处理cookie</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web 有开箱即用的cookie支持</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_manipulating_cookies\"><a class=\"anchor\" href=\"#_manipulating_cookies\"></a>操作 cookies</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getCookie-java.lang.String-\">getCookie</a></code> 按名获取一个cookie\n或者使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#cookieMap--\">cookieMap</a></code> 获取整个set集合。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#removeCookie-java.lang.String-\">removeCookie</a></code> 移除一个cookie。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#addCookie-io.vertx.core.http.Cookie-\">addCookie</a></code>，添加一个cookie。</p>\n</div>\n<div class=\"paragraph\">\n<p>当写入响应头后，这组Cookie会自动写回到响应中，\n以便浏览器可以存储它们。</p>\n</div>\n<div class=\"paragraph\">\n<p>cookie被 <code><a href=\"../../apidocs/io/vertx/core/http/Cookie.html\">Cookie</a></code> 实例所描述。 它允许您获取名称、\n值、域、路径和其他cookie属性</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个查询并添加cookie的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Cookie</span> <span class=\"hljs-variable\">someCookie</span> <span class=\"hljs-operator\">=</span> ctx.request().getCookie(<span class=\"hljs-string\">&quot;mycookie&quot;</span>);\n<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">cookieValue</span> <span class=\"hljs-operator\">=</span> someCookie.getValue();\n\n<span class=\"hljs-comment\">// 使用cookie做一些事情</span>\n\n<span class=\"hljs-comment\">// 添加一个cookie——它将自动写回到响应中</span>\nctx.response().addCookie(Cookie.cookie(<span class=\"hljs-string\">&quot;othercookie&quot;</span>, <span class=\"hljs-string\">&quot;somevalue&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handling_sessions\"><a class=\"anchor\" href=\"#_handling_sessions\"></a>处理session</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web 提供了开箱即用的 session 支持</p>\n</div>\n<div class=\"paragraph\">\n<p>session 存活在在浏览器会话周期的 HTTP 请求之间，\n它给予了您一个可以储存 session 作用域信息的地方，比如购物车</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web 使用 session cookie 来识别 session\n这个 session cookie 是临时的，而且当其关闭的时候您的浏览器会将其删除</p>\n</div>\n<div class=\"paragraph\">\n<p>我们并不会将您 session 中的真实数据放到 session cookie 中——cookie 只是简单的使用标记符在服务器上寻找实际的 session\n这个标记符是一个使用安全随机数生成的随机 UUID\n所以它应该实际上是不可被推测出来的</p>\n</div>\n<div class=\"paragraph\">\n<p>cookie 在 HTTP 请求和响应中通过网络传递，因此明智的做法是在使用会话时始终使用 HTTPS 协议。\n如果您尝试通过直接 HTTP 使用会话，则 Vert.x 会警告您。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了启用您应用程序中的 session，\n您必须在应用程序逻辑之前的匹配路由上具有一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/SessionHandler.html\">SessionHandler</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>这个 session 处理器用于处理 session cookie 的生成和寻找对应的 session\n所以您无需自己去做这些事情</p>\n</div>\n<div class=\"paragraph\">\n<p>在响应头发回给客户端之后，session 中的数据会自动地保存在 session 储存器中\n但是请注意，因为这个机制，\n它并不保证这个数据在客户端收到响应之前完全保留\n在这个场景中您可以强制刷新一下\n除非刷新操作失败，否则这将禁用自动保存过程。\n这样可以在完成响应之前控制状态，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">ChainAuthHandler</span> <span class=\"hljs-variable\">chain</span> <span class=\"hljs-operator\">=</span>\n  ChainAuthHandler.any()\n    .add(authNHandlerA)\n    .add(ChainAuthHandler.all()\n      .add(authNHandlerB)\n      .add(authNHandlerC));\n\n<span class=\"hljs-comment\">// 保护您的路由</span>\nrouter.route(<span class=\"hljs-string\">&quot;/secure/resource&quot;</span>).handler(chain);\n<span class=\"hljs-comment\">// 您的应用</span>\nrouter.route(<span class=\"hljs-string\">&quot;/secure/resource&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// do something...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，Vert.x session处理器的状态使用cookie存储session ID。session ID是一个唯一的字符串，用于识别两次访问之间的单个访问者 。\n但是，如果客户端的网络浏览器不支持cookie或访问者已在网络浏览器的设置中禁用了cookie，则我们无法在客户端的计算机上存储session ID。\n在这种情况下，将为每个请求创建新的会话。\n这种行为是无用的，因为我们无法记住两个请求之间特定访问者的信息。\n我们可以说，默认情况下，如果浏览器不支持cookie，则session将无法工作。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web支持不使用cookie的session，称为\"无cookie\"session。\n作为替代，Vert.x Web可以将session ID嵌入页面URL内。这样，所有页面链接都将包含session ID字符串。\n当访问者单击其中的某些链接时，它将从页面URL读取session ID，因此我们不需要cookie支持即可进行功能性session。</p>\n</div>\n<div class=\"paragraph\">\n<p>启动无cookies session</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .handler(SessionHandler.create(store).setCookieless(<span class=\"hljs-literal\">true</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>知道在这种情况下session ID会被应用传递给最终的用户这一点非常重要，通常来讲通过把他渲染到 HTML 页面或者脚本上\n有一些非常重要的规则，session ID 会由\n<code>/optional/path/prefix'('sessionId')'/path/suffix</code> 上的以下模式标识。</p>\n</div>\n<div class=\"paragraph\">\n<p>举个例子，给出一个路径 <code><a href=\"http://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/\" class=\"bare\">http://localhost:2677/WebSite1/(S(3abhbgwjg33aqrt3uat2kh4d))/api/</a></code> ,\nsession ID在这种情况下，是 <code>3abhbgwjg33aqrt3uat2kh4d</code></p>\n</div>\n<div class=\"paragraph\">\n<p>如果两个用户共享一个相同的 session ID，\n他们也将共享同样的 session 变量，而且网站会将其认为是同一个访问者。\n如果 session 被用于储存私密或敏感的数据，或者允许访问网站的受限区域，这将是一个安全危机，\n当使用 cookie 时，session ID可以通过 SSL 和标记 cookie 为 secure 进行保护。\n但是在无 cookie session的情况下，session id 是 URL 的一部分，而且这非常容易受到攻击</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_session_stores\"><a class=\"anchor\" href=\"#_session_stores\"></a>session储存</h3>\n<div class=\"paragraph\">\n<p>创建一个session处理器，您需要一个session储存器实例。\n这个session储存器是一个可以为您的应用储存实际session的对象</p>\n</div>\n<div class=\"paragraph\">\n<p>session存储器负责保存安全的伪随机数生成器，以保证安全的session ID。\n此PRNG独立于储存器，这意味着从储存器A获得的会话ID不能获取储存器B的会话ID，\n因为它们具有不同的种子和状态。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，PRNG使用混合模式，生成种子的时候会阻塞，生成时并不阻塞\nPRNG也将每5分钟重新设置64位新的熵。而且这也可以通过系统属性进行设置</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>io.vertx.ext.auth.prng.algorithm 比如: SHA1PRNG</p>\n</li>\n<li>\n<p>io.vertx.ext.auth.prng.seed.interval 比如: 1000 (every second)</p>\n</li>\n<li>\n<p>io.vertx.ext.auth.prng.seed.bits 比如: 128</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>除非您注意到PRNG算法会影响应用程序的性能，\n否则大多数用户都不需要配置这些值。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web具有两个开箱即用的sesion存储实现，如果您愿意，也可以编写自己的会话存储</p>\n</div>\n<div class=\"paragraph\">\n<p>这些实现应遵循 <code>ServiceLoader</code> 约定，\n所有从类路径下运行时可以用的储存都将被暴露出来\n当有多个实现可用时，第一个可以实例化并成功配置的实现将成为默认设置。\n如果没有可用的，则默认值取决于创建Vert.x的模式。\n如果集群模式可用，则默认配置为为集群储存，否则为本地存储。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_local_session_store\"><a class=\"anchor\" href=\"#_local_session_store\"></a>本地session储存</h4>\n<div class=\"paragraph\">\n<p>通过这个储存器，session可以在内存中本地化储存，而且只在这个实例中可用</p>\n</div>\n<div class=\"paragraph\">\n<p>如果只有一个Vert.x实例正在应用程序中使用粘性session，\n并且已将负载均衡器配置为始终将HTTP请求路由到同一Vert.x实例，则此存储是合适的。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您不能确保所有请求都将在同一服务器上终止，请不要使用此存储\n因为服务器可能会在不知道对应session的情况下，终结您的请求</p>\n</div>\n<div class=\"paragraph\">\n<p>本地session储存器通过shared local map实现，而且会由回收器清理过期的session</p>\n</div>\n<div class=\"paragraph\">\n<p>回收间隔将可以用json信息进行设置，它所对应的key值为 <code>reaperInterval</code> .</p>\n</div>\n<div class=\"paragraph\">\n<p>下面是一个创建本地 <code><a href=\"../../apidocs/io/vertx/ext/web/sstore/SessionStore.html\">session储存器</a></code> 的例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">SessionStore</span> <span class=\"hljs-variable\">store1</span> <span class=\"hljs-operator\">=</span> LocalSessionStore.create(vertx);\n\n<span class=\"hljs-comment\">// 创建一个指定local shared map名的本地session储存</span>\n<span class=\"hljs-comment\">// 如果您有多个应用在同一个Vert.x 实例中而且您想使用为不同的应用不同的map，</span>\n<span class=\"hljs-comment\">// 这将非常有用</span>\n<span class=\"hljs-type\">SessionStore</span> <span class=\"hljs-variable\">store2</span> <span class=\"hljs-operator\">=</span> LocalSessionStore.create(\n  vertx,\n  <span class=\"hljs-string\">&quot;myapp3.sessionmap&quot;</span>);\n\n<span class=\"hljs-comment\">// 创建一个本地session储存器，</span>\n<span class=\"hljs-comment\">// 其制定了local shared map名和设置了10s的清理周期用于清理过期session</span>\n<span class=\"hljs-type\">SessionStore</span> <span class=\"hljs-variable\">store3</span> <span class=\"hljs-operator\">=</span> LocalSessionStore.create(\n  vertx,\n  <span class=\"hljs-string\">&quot;myapp3.sessionmap&quot;</span>,\n  <span class=\"hljs-number\">10000</span>);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_clustered_session_store\"><a class=\"anchor\" href=\"#_clustered_session_store\"></a>集群session储存器</h4>\n<div class=\"paragraph\">\n<p>通过这个储存器，session可以储存在分布式map中，其可以跨Vert.x集群使用</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您 <em>不</em> 使用粘性会话，即您的负载均衡器将来自同一浏览器的不同请求分发到不同的服务器\n，则此存储是合适的。</p>\n</div>\n<div class=\"paragraph\">\n<p>您的session在集群的任意一个节点只要通过这个储存器都是可用的</p>\n</div>\n<div class=\"paragraph\">\n<p>使用集群session储存器，您需要保证您的Vert.x实例是集群的</p>\n</div>\n<div class=\"paragraph\">\n<p>这有一些创建集群 <code><a href=\"../../apidocs/io/vertx/ext/web/sstore/SessionStore.html\">sessionstore</a></code> 的例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx.clusteredVertx(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VertxOptions</span>(), res -&gt; {\n\n  <span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> res.result();\n\n  <span class=\"hljs-comment\">// 使用默认配置创建集群session储存</span>\n  <span class=\"hljs-type\">SessionStore</span> <span class=\"hljs-variable\">store1</span> <span class=\"hljs-operator\">=</span> ClusteredSessionStore.create(vertx);\n\n  <span class=\"hljs-comment\">// 指分布式map的名字创建集群session存储器</span>\n  <span class=\"hljs-comment\">// 如果您有多个应用在同一个集群中而且您想使用为不同的应用不同的map，</span>\n  <span class=\"hljs-comment\">// 这将非常有用</span>\n  <span class=\"hljs-type\">SessionStore</span> <span class=\"hljs-variable\">store2</span> <span class=\"hljs-operator\">=</span> ClusteredSessionStore.create(\n    vertx,\n    <span class=\"hljs-string\">&quot;myclusteredapp3.sessionmap&quot;</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_other_stores\"><a class=\"anchor\" href=\"#_other_stores\"></a>其他储存方式</h4>\n<div class=\"paragraph\">\n<p>其他储存方式也是可行的,这些储存可通过导入正确的jar包到您的项目里面使用。\n一个这种储存的例子就是cookie储存器。\n此存储的优点是不需要后端或服务器端状态，这在某些情况下很有用，\n<strong>但是</strong> 所有会话数据都将通过Cookie发送回客户端， 因此，\n如果您需要存储私有信息，则不应使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用粘性会话，则此存储是合适的，\n即您的负载均衡器将来自同一浏览器的不同请求分发到不同的服务器。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于会话存储在Cookie中，因此会话也可以在服务器崩溃后幸免</p>\n</div>\n<div class=\"paragraph\">\n<p>第二个已知的实现是Redis session储存器。\n该储存器的工作方式与普通集群存储区相同，然而顾名思义，它使用 redis 作为后端将会话数据集中存储。</p>\n</div>\n<div class=\"paragraph\">\n<p>此外，亦提供 Infinispan 会话存储（详情如下）。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些储存器可在这些坐标上可用：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>groupId: <code>io.vertx</code></p>\n</li>\n<li>\n<p>artifactId: <code>vertx-web-sstore-{cookie|redis|infinispan}</code></p>\n</li>\n</ul>\n</div>\n<div class=\"sect4\">\n<h5 id=\"_infinispan_web_session_store\"><a class=\"anchor\" href=\"#_infinispan_web_session_store\"></a>Infinispan 网络会话存储</h5>\n<div class=\"paragraph\">\n<p>依赖于 <a href=\"https://infinispan.org/\">Infinispan</a> Java 客户端的一种 <code><a href=\"../../apidocs/io/vertx/ext/web/sstore/SessionStore.html\">SessionStore</a></code> 实现。</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n此模块具有 <em>Tech Preview</em> 状态，这意味着 API 可能会在后续版本中更改。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect5\">\n<h6 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>由此开始</h6>\n<div class=\"paragraph\">\n<p>要使用此模块，请将以下内容添加到 Maven POM 文件的 <em>dependencies</em> 部分中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-sstore-infinispan<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者，您使用的是 Gradle：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-web-sstore-infinispan:4.2.2&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect5\">\n<h6 id=\"_using\"><a class=\"anchor\" href=\"#_using\"></a>使用</h6>\n<div class=\"paragraph\">\n<p>如果这个会话存储是您所有依赖项中唯一的一项，那么您可以用一种通用的方式将其初始化：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">config</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n  .put(<span class=\"hljs-string\">&quot;servers&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonArray</span>()\n    .add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n      .put(<span class=\"hljs-string\">&quot;host&quot;</span>, <span class=\"hljs-string\">&quot;server1.datagrid.mycorp.int&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>))\n    .add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n      .put(<span class=\"hljs-string\">&quot;host&quot;</span>, <span class=\"hljs-string\">&quot;server2.datagrid.mycorp.int&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>))\n  );\n<span class=\"hljs-type\">SessionStore</span> <span class=\"hljs-variable\">store</span> <span class=\"hljs-operator\">=</span> SessionStore.create(vertx, config);\n<span class=\"hljs-type\">SessionHandler</span> <span class=\"hljs-variable\">sessionHandler</span> <span class=\"hljs-operator\">=</span> SessionHandler.create(store);\nrouter.route().handler(sessionHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者，使用明确的 <code><a href=\"../../apidocs/io/vertx/ext/web/sstore/infinispan/InfinispanSessionStore.html\">InfinispanSessionStore</a></code> 类型。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">config</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n  .put(<span class=\"hljs-string\">&quot;servers&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonArray</span>()\n    .add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n      .put(<span class=\"hljs-string\">&quot;host&quot;</span>, <span class=\"hljs-string\">&quot;server1.datagrid.mycorp.int&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>))\n    .add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n      .put(<span class=\"hljs-string\">&quot;host&quot;</span>, <span class=\"hljs-string\">&quot;server2.datagrid.mycorp.int&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>))\n  );\n<span class=\"hljs-type\">InfinispanSessionStore</span> <span class=\"hljs-variable\">store</span> <span class=\"hljs-operator\">=</span> InfinispanSessionStore.create(vertx, config);\n<span class=\"hljs-type\">SessionHandler</span> <span class=\"hljs-variable\">sessionHandler</span> <span class=\"hljs-operator\">=</span> SessionHandler.create(store);\nrouter.route().handler(sessionHandler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect5\">\n<h6 id=\"_configuring\"><a class=\"anchor\" href=\"#_configuring\"></a>配置</h6>\n<div class=\"sect6\">\n<h7 id=\"_config_entries\"><a class=\"anchor\" href=\"#_config_entries\"></a>配置条目（entry）</h7>\n<div class=\"paragraph\">\n<p>根条目是：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>servers</code>：强制/必填的，服务器定义的 JSON 数组（见下文）</p>\n</li>\n<li>\n<p><code>cacheName</code>：可选的，用于存储会话数据的缓存名称（默认为 <code>vertx-web.sessions</code>）</p>\n</li>\n<li>\n<p><code>retryTimeout</code>：可选的，会话处理程序从存储中检索值时所使用的重试超时时间（以毫秒为单位）（<code>5000</code>）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>用于服务器定义的条目是：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>uri</code> ：可选的，一个 <a href=\"https://infinispan.org/blog/2020/05/26/hotrod-uri/\">Hot Rod URI</a></p>\n</li>\n<li>\n<p><code>host</code>：可选的（默认为 <code>localhost</code>）</p>\n</li>\n<li>\n<p><code>port</code>：可选的（默认为 <code>11222</code>）</p>\n</li>\n<li>\n<p><code>clientIntelligence</code>：可选的（以下值之一 <code>BASIC</code>，<code>TOPOLOGY_AWARE</code>，<code>HASH_DISTRIBUTION_AWARE</code>）</p>\n</li>\n<li>\n<p><code>username</code>：强制的</p>\n</li>\n<li>\n<p><code>password</code>：强制的</p>\n</li>\n<li>\n<p><code>realm</code>：可选的（默认为 <code>default</code>）</p>\n</li>\n<li>\n<p><code>saslMechanism</code>：可选的（默认为 <code>DIGEST-MD5</code>）</p>\n</li>\n<li>\n<p><code>saslQop</code>：可选的（以下值之一 <code>AUTH</code>，<code>AUTH_INT</code>，<code>AUTH_CONF</code>）</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n如果设置了 <code>uri</code> 条目，则其他条目将被忽略。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect6\">\n<h7 id=\"_custom_infinispan_client\"><a class=\"anchor\" href=\"#_custom_infinispan_client\"></a>自定义 Infinispan 客户端</h7>\n<div class=\"paragraph\">\n<p>对于高级配置要求，\n您可以提供自定义的 <a href=\"https://docs.jboss.org/infinispan/12.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html\"><code>RemoteCacheManager</code></a>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">InfinispanSessionStore</span> <span class=\"hljs-variable\">sessionStore</span> <span class=\"hljs-operator\">=</span> InfinispanSessionStore.create(vertx, config, remoteCacheManager);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_the_session_handler\"><a class=\"anchor\" href=\"#_creating_the_session_handler\"></a>创建session处理器</h3>\n<div class=\"paragraph\">\n<p>一旦您创建好session储存器，您就可以开始创建session处理器了，并且把他添加到Route中。\n那您应该确保将会话处理程序路由到应用程序处理程序之前。</p>\n</div>\n<div class=\"paragraph\">\n<p>这里有个例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-comment\">//使用默认配置创建一个集群session储存器</span>\n<span class=\"hljs-type\">SessionStore</span> <span class=\"hljs-variable\">store</span> <span class=\"hljs-operator\">=</span> ClusteredSessionStore.create(vertx);\n\n<span class=\"hljs-type\">SessionHandler</span> <span class=\"hljs-variable\">sessionHandler</span> <span class=\"hljs-operator\">=</span> SessionHandler.create(store);\n\n<span class=\"hljs-comment\">// session处理器控制用于session的cookie</span>\n<span class=\"hljs-comment\">// 举个例子，它可以包含同站策略（译者注：即samesite policy）的配置</span>\n<span class=\"hljs-comment\">// 比如这个，使用严格模式的同站策略</span>\nsessionHandler.setCookieSameSite(CookieSameSite.STRICT);\n\n<span class=\"hljs-comment\">// 确保所有请求都可以路由经过这个session处理器</span>\nrouter.route().handler(sessionHandler);\n\n<span class=\"hljs-comment\">// 现在您的应用程序可以开始处理了</span>\nrouter.route(<span class=\"hljs-string\">&quot;/somepath/blah/&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">Session</span> <span class=\"hljs-variable\">session</span> <span class=\"hljs-operator\">=</span> ctx.session();\n  session.put(<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);\n  <span class=\"hljs-comment\">// 等等</span>\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>session处理器会确保您的session会从session储存器中被自动地找出来(或者当session不存在时创建一个)，\n然后在到达您的应用程序处理器之前将其放置在路由上下文中</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_the_session\"><a class=\"anchor\" href=\"#_using_the_session\"></a>使用session</h3>\n<div class=\"paragraph\">\n<p>在您的处理器中，您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#session--\">session</a></code> 获取到 session 实例</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#put-java.lang.String-java.lang.Object-\">put</a></code> 将数据放到 session 中，\n您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#get-java.lang.String-\">get</a></code> 从 session 中获取数据\n同时您也可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#remove-java.lang.String-\">remove</a></code> 从 session 中移除数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>session 中对象的键往往是字符串类型。\n对于本地 session 储存器，其值可以是任何类型，对于集群 session 储存器中它可以是任何基础类型或 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code>, <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code>,\n<code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> 亦或者一个可序列化的类型，因为这些值为了在集群间传递必须进行序列化。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个操作session中数据的例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(sessionHandler);\n\n<span class=\"hljs-comment\">//现在是您的程序在处理</span>\nrouter.route(<span class=\"hljs-string\">&quot;/somepath/blah&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-type\">Session</span> <span class=\"hljs-variable\">session</span> <span class=\"hljs-operator\">=</span> ctx.session();\n\n  <span class=\"hljs-comment\">// 放置一些数据到session中</span>\n  session.put(<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);\n\n  <span class=\"hljs-comment\">// 从session获取数据</span>\n  <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> session.get(<span class=\"hljs-string\">&quot;age&quot;</span>);\n\n  <span class=\"hljs-comment\">// 从session中移除数据</span>\n  <span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> session.remove(<span class=\"hljs-string\">&quot;myobj&quot;</span>);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在响应完成之后 session 会被自动写回到储存器中</p>\n</div>\n<div class=\"paragraph\">\n<p>您通过 <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#destroy--\">destroy</a></code> 手动销毁 session\n它会将 session 从上下文和 session 储存器中移除\n请注意，如果没有 session，则将为通过 session 处理器的下一个来自浏览器的请求自动创建一个新会话。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_session_timeout\"><a class=\"anchor\" href=\"#_session_timeout\"></a>session 超时</h3>\n<div class=\"paragraph\">\n<p>如果session的未访问时间超过超时时间，则session将自动超时。\n当一个session超时时，它将会被从储存中移除</p>\n</div>\n<div class=\"paragraph\">\n<p>当请求到达，session被查找以及当响应完成且会话被存储回存储器中时，\nsession将被自动标记为已访问。</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/Session.html#setAccessed--\">setAccessed</a></code> 手动为session打上已访问标记</p>\n</div>\n<div class=\"paragraph\">\n<p>当创建session处理器时可以设置session的超时时间，其默认值为30分钟</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_authentication_authorization\"><a class=\"anchor\" href=\"#_authentication_authorization\"></a>认证/授权</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Verx.x带有一些现成的处理器，用于处理身份验证和授权\n在Vert.x web中，这两个词的含义是：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><strong>身份认证</strong> - 表明用户是谁</p>\n</li>\n<li>\n<p><strong>授权</strong> - 表明用户可以做什么</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>而 <strong>身份认证</strong> 是严格到一个众所周知的协议，比如</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>HTTP Basic Authentication</p>\n</li>\n<li>\n<p>HTTP Digest Authentication</p>\n</li>\n<li>\n<p>OAuth2 Authentication</p>\n</li>\n<li>\n<p>&#8230;&#8203;</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><strong>授权</strong> 在vert.x中是相当通用的，无论优先级如何都可以使用\n然而，在这两种情况下使用相同的提供者模块也是可能的，也是有效的用例。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_an_authentication_handler\"><a class=\"anchor\" href=\"#_creating_an_authentication_handler\"></a>创建一个身份认证处理器</h3>\n<div class=\"paragraph\">\n<p>创建一个验证处理器您需要一个 <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code> 的实例。\n身份认证提供者被用于认证用户身份。Vert.x在vertx-auth项目里面提供了几个开箱即用的身份认证提供者实例，\n有关身份认证提供者以及如何使用和配置它们的完整信息，\n请查阅身份认证文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>这里有一些关于创建提供身份认证的basic auth处理器的例子。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\n<span class=\"hljs-type\">AuthenticationHandler</span> <span class=\"hljs-variable\">basicAuthHandler</span> <span class=\"hljs-operator\">=</span> BasicAuthHandler.create(authProvider);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_authentication_in_your_application\"><a class=\"anchor\" href=\"#_handling_authentication_in_your_application\"></a>在您的程序中处理身份认证</h3>\n<div class=\"paragraph\">\n<p>假设您希望对以 <code>/private/</code> 开头的路径的所有请求都经过身份认证。\n为此，请确保在这些路径上，身份认证处理程序位于应用程序处理程序之前：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\n<span class=\"hljs-type\">AuthenticationHandler</span> <span class=\"hljs-variable\">basicAuthHandler</span> <span class=\"hljs-operator\">=</span> BasicAuthHandler.create(authProvider);\n\n<span class=\"hljs-comment\">// 所有以&#x27;/private/&#x27;路径开头的请求都会被保护</span>\nrouter.route(<span class=\"hljs-string\">&quot;/private/*&quot;</span>).handler(basicAuthHandler);\n\nrouter.route(<span class=\"hljs-string\">&quot;/someotherpath&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 这里是公开访问的地方 —— 不需要登录</span>\n\n});\n\nrouter.route(<span class=\"hljs-string\">&quot;/private/somepath&quot;</span>).handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 这里需要登录</span>\n\n  <span class=\"hljs-comment\">// 这里的值为true</span>\n  <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isAuthenticated</span> <span class=\"hljs-operator\">=</span> ctx.user() != <span class=\"hljs-literal\">null</span>;\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果身份认证处理器成功认证了用户，它将注入一个 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html\">User</a></code>\n对象到  <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 中，因此它可以在您的处理器中通过\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#user--\">user</a></code> 获取到。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果希望将User对象存储在session中，以便在请求之间可用，因此不必在每个请求上进行身份验证，\n则应确保在身份认证处理器之前具有session处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>一旦您拥有了您的user对象，您还可以以编程方式使用其上的方法来授权用户</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您想要注销一个用户您可以调用 在路由上下文中调用\n<code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#clearUser--\">clearUser</a></code></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_basic_authentication\"><a class=\"anchor\" href=\"#_http_basic_authentication\"></a>HTTP Basic Authentication</h3>\n<div class=\"paragraph\">\n<p><a href=\"http://en.wikipedia.org/wiki/Basic_access_authentication\">HTTP Basic Authentication</a>\n是一种适用于简单应用程序的简单身份认证方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用basic authentication时，凭据将以非加密方式通过HTTP标头通过网络发送，\n因此，必须使用HTTPS而不是HTTP为应用程序提供服务。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用basic authentication时，如果用户请求需要身份认证的资源，\n则basic auth处理器将发送带有标头 <code>WWW-Authenticate</code> 的 <code>401</code> 响应。\n这会提示浏览器显示登录对话框，并提示用户输入用户名和密码。</p>\n</div>\n<div class=\"paragraph\">\n<p>用户会再次向资源发出请求，这次设置了 <code>Authorization</code> 标头，\n其中包含以Base64编码的用户名和密码。</p>\n</div>\n<div class=\"paragraph\">\n<p>当basic auth处理器收到这个信息时，它会用用户名和密码调用配置好的 <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code>\n来认证用户。如果身份认证成功，\n则允许请求路由继续到应用程序处理器，\n否则返回 <code>403</code> 响应以表示拒绝访问。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_redirect_authentication_handler\"><a class=\"anchor\" href=\"#_redirect_authentication_handler\"></a>重定向身份认证</h3>\n<div class=\"paragraph\">\n<p>使用重定向身份认证处理的情况下，如果用户尝试访问受保护的资源并且未登录，\n则将用户重定向到登录页面</p>\n</div>\n<div class=\"paragraph\">\n<p>然后，用户填写登录表单并提交。\n这由服务器进行处理，服务器对用户进行身份认证，如果通过身份认证，则将用户重定向回原始资源。</p>\n</div>\n<div class=\"paragraph\">\n<p>要使用重定向身份验证，您可以配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html\">RedirectAuthHandler</a></code> 实例，\n而不是basic authentication处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您还需要设置处理器以处理于您的实际登录页面，以及一个处理器来处理实际登录本身。\n为了处理登录，我们为此提供了一个预先构建的处理程序 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/FormLoginHandler.html\">FormLoginHandler</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>这里有一个简单app的例子，在默认重定向url <code>/loginpage</code> 上使用重定向认证处理器</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\n<span class=\"hljs-comment\">// 所有以&#x27;/private/&#x27;路径开头的请求都会被保护</span>\nrouter\n  .route(<span class=\"hljs-string\">&quot;/private/*&quot;</span>)\n  .handler(RedirectAuthHandler.create(authProvider));\n\n<span class=\"hljs-comment\">// 处理实际的登录请求</span>\n<span class=\"hljs-comment\">// 您其中一个页面必须要POST表单登陆数据</span>\nrouter.post(<span class=\"hljs-string\">&quot;/login&quot;</span>).handler(FormLoginHandler.create(authProvider));\n\n<span class=\"hljs-comment\">// 设置静态服务器处理静态资源</span>\nrouter.route().handler(StaticHandler.create());\n\nrouter\n  .route(<span class=\"hljs-string\">&quot;/someotherpath&quot;</span>)\n  .handler(ctx -&gt; {\n    <span class=\"hljs-comment\">//  这里是公开访问的地方 —— 不需要登录</span>\n  });\n\nrouter\n  .route(<span class=\"hljs-string\">&quot;/private/somepath&quot;</span>)\n  .handler(ctx -&gt; {\n\n    <span class=\"hljs-comment\">// 这里需要登录</span>\n\n    <span class=\"hljs-comment\">// 这里的值是true</span>\n    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isAuthenticated</span> <span class=\"hljs-operator\">=</span> ctx.user() != <span class=\"hljs-literal\">null</span>;\n\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_jwt_authentication\"><a class=\"anchor\" href=\"#_jwt_authentication\"></a>JWT 认证</h3>\n<div class=\"paragraph\">\n<p>使用JWT身份认证可以通过权限保护资源，并且拒绝没有足够权限的用户访问。\n您需要添加 <code>io.vertx：vertx-auth-jwt：4.2.2</code> 依赖项才能使用 <code>JWTAuthProvider</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用这个处理器需要包含两步</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>设置处理器以发放token（或依赖第三方）</p>\n</li>\n<li>\n<p>设置处理器过滤请求</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>请注意，这两个处理器仅应在HTTPS上可用，如果不这样做，会导致允许嗅探正在传输的token，\n从而导致会话劫持攻击。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个如何发放token的例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">JWTAuthOptions</span> <span class=\"hljs-variable\">authConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JWTAuthOptions</span>()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">KeyStoreOptions</span>()\n    .setType(<span class=\"hljs-string\">&quot;jceks&quot;</span>)\n    .setPath(<span class=\"hljs-string\">&quot;keystore.jceks&quot;</span>)\n    .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>));\n\n<span class=\"hljs-type\">JWTAuth</span> <span class=\"hljs-variable\">jwt</span> <span class=\"hljs-operator\">=</span> JWTAuth.create(vertx, authConfig);\n\nrouter.route(<span class=\"hljs-string\">&quot;/login&quot;</span>).handler(ctx -&gt; {\n <span class=\"hljs-comment\">//这是个例子，身份认证应当使用其他的提供者</span>\n  <span class=\"hljs-keyword\">if</span> (\n    <span class=\"hljs-string\">&quot;paulo&quot;</span>.equals(ctx.request().getParam(<span class=\"hljs-string\">&quot;username&quot;</span>)) &amp;&amp;\n      <span class=\"hljs-string\">&quot;secret&quot;</span>.equals(ctx.request().getParam(<span class=\"hljs-string\">&quot;password&quot;</span>))) {\n    ctx.response()\n      .end(jwt.generateToken(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;sub&quot;</span>, <span class=\"hljs-string\">&quot;paulo&quot;</span>)));\n  } <span class=\"hljs-keyword\">else</span> {\n    ctx.fail(<span class=\"hljs-number\">401</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在您的客户端拥有token，那么对于 <strong>所有</strong> 后续请求，HTTP标头\n<code>Authorization</code> 都填充有：<code>Bearer &lt;token&gt;</code>，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">JWTAuthOptions</span> <span class=\"hljs-variable\">authConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JWTAuthOptions</span>()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">KeyStoreOptions</span>()\n    .setType(<span class=\"hljs-string\">&quot;jceks&quot;</span>)\n    .setPath(<span class=\"hljs-string\">&quot;keystore.jceks&quot;</span>)\n    .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>));\n\n<span class=\"hljs-type\">JWTAuth</span> <span class=\"hljs-variable\">authProvider</span> <span class=\"hljs-operator\">=</span> JWTAuth.create(vertx, authConfig);\n\nrouter.route(<span class=\"hljs-string\">&quot;/protected/*&quot;</span>).handler(JWTAuthHandler.create(authProvider));\n\nrouter.route(<span class=\"hljs-string\">&quot;/protected/somepage&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 一些处理器代码</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>JWT允许您将所需的任何信息添加到token本身。\n这样一来，服务器中就不存在状态，这样就可以允许您扩展应用程序而无需集群的会话数据。\n为了将数据添加到token，在token创建期间，只需将数据添加到JsonObject参数即可：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">JWTAuthOptions</span> <span class=\"hljs-variable\">authConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JWTAuthOptions</span>()\n  .setKeyStore(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">KeyStoreOptions</span>()\n    .setType(<span class=\"hljs-string\">&quot;jceks&quot;</span>)\n    .setPath(<span class=\"hljs-string\">&quot;keystore.jceks&quot;</span>)\n    .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>));\n\n<span class=\"hljs-type\">JWTAuth</span> <span class=\"hljs-variable\">authProvider</span> <span class=\"hljs-operator\">=</span> JWTAuth.create(vertx, authConfig);\n\nauthProvider\n  .generateToken(\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n      .put(<span class=\"hljs-string\">&quot;sub&quot;</span>, <span class=\"hljs-string\">&quot;paulo&quot;</span>)\n      .put(<span class=\"hljs-string\">&quot;someKey&quot;</span>, <span class=\"hljs-string\">&quot;some value&quot;</span>),\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JWTOptions</span>());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>和消费时一样：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;RoutingContext&gt; handler = ctx -&gt; {\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">theSubject</span> <span class=\"hljs-operator\">=</span> ctx.user().principal().getString(<span class=\"hljs-string\">&quot;sub&quot;</span>);\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">someKey</span> <span class=\"hljs-operator\">=</span> ctx.user().principal().getString(<span class=\"hljs-string\">&quot;someKey&quot;</span>);\n};</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_authorization\"><a class=\"anchor\" href=\"#_configuring_authorization\"></a>配置授权</h3>\n<div class=\"paragraph\">\n<p>到目前为止，所有示例都涉及身份认证。与用户打交道时，授权是下一个合乎逻辑的步骤。\n虽然身份认证确实是特定于协议的，但授权是独立的，\n所有信息均从 <code>User</code> 对象中提取。</p>\n</div>\n<div class=\"paragraph\">\n<p>在此之前，需要将授权加载到该同一对象。为了做到这一点，应该使用\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/AuthorizationHandler.html\">AuthorizationHandler</a></code>。\n授权处理器将从给定的 <code><a href=\"../../apidocs/io/vertx/ext/auth/authorization/AuthorizationProvider.html\">AuthorizationProvider</a></code> 中加载所有已知的授权</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(\n  <span class=\"hljs-comment\">// 创建将执行认证的处理器</span>\n  AuthorizationHandler.create(\n    <span class=\"hljs-comment\">// 认证什么</span>\n    PermissionBasedAuthorization.create(<span class=\"hljs-string\">&quot;can-do-work&quot;</span>))\n    <span class=\"hljs-comment\">// 在哪里查找用户的授权</span>\n    .addAuthorizationProvider(authProvider));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以在1个以上的源上执行查找，只需继续向处理程序中添加 <code>addAuthorizationProvider(provider)</code> 即可。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个配置应用程序的示例，因为该应用程序的不同部分需要不同的权限。\n请注意，权限的含义由您使用的底层身份验证处理器确定。\n例如。一些可能支持基于角色权限的模型，但是其他可能使用其他模型。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">&quot;/listproducts/*&quot;</span>).handler(\n  <span class=\"hljs-comment\">// 创建将执行认证的处理器</span>\n  AuthorizationHandler.create(\n    <span class=\"hljs-comment\">// 认证什么</span>\n    PermissionBasedAuthorization.create(<span class=\"hljs-string\">&quot;list_products&quot;</span>))\n    <span class=\"hljs-comment\">// 在哪里查找用户的授权</span>\n    .addAuthorizationProvider(authProvider));\n\n<span class=\"hljs-comment\">// 只有 &quot;admin&quot;可以访问 /private/settings</span>\nrouter.route(<span class=\"hljs-string\">&quot;/private/settings/*&quot;</span>).handler(\n  <span class=\"hljs-comment\">// 创建将执行认证的处理器</span>\n  AuthorizationHandler.create(\n    <span class=\"hljs-comment\">// 认证什么</span>\n    RoleBasedAuthorization.create(<span class=\"hljs-string\">&quot;admin&quot;</span>))\n    .addAuthorizationProvider(authProvider));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_chaining_multiple_authentication_handlers\"><a class=\"anchor\" href=\"#_chaining_multiple_authentication_handlers\"></a>链接多个身份验证处理器</h3>\n<div class=\"paragraph\">\n<p>有时您想在单个应用程序中支持多种身份认证机制。 为此，\n您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ChainAuthHandler.html\">ChainAuthHandler</a></code> 。\n链式身份认证处理器将尝试对一系列处理程序执行身份认证。</p>\n</div>\n<div class=\"paragraph\">\n<p>重要的是要知道某些处理器需要特定的提供者，例如：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/JWTAuthHandler.html\">JWTAuthHandler</a></code> 需要 <code><a href=\"../../apidocs/io/vertx/ext/auth/jwt/JWTAuth.html\">JWTAuth</a></code> 。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/DigestAuthHandler.html\">DigestAuthHandler</a></code> 需要 <code><a href=\"../../apidocs/io/vertx/ext/auth/htdigest/HtdigestAuth.html\">HtdigestAuth</a></code> 。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/OAuth2AuthHandler.html\">OAuth2AuthHandler</a></code> 需要 <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/OAuth2Auth.html\">OAuth2Auth</a></code> 。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/WebAuthnHandler.html\">WebAuthnHandler</a></code> 需要 <code><a href=\"../../apidocs/io/vertx/ext/auth/webauthn/WebAuthn.html\">WebAuthn</a></code> 。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>因此，不希望在所有处理程序之间共享提供者。\n在某些情况下，可以跨处理程序共享提供者，例如：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/BasicAuthHandler.html\">BasicAuthHandler</a></code> 可以接受任何提供者。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/RedirectAuthHandler.html\">RedirectAuthHandler</a></code> 可以接受任何提供者。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>假设您要创建一个接受 <code>HTTP Basic Authentication</code> 和 <code>Form Redirect</code> 的应用程序。\n您将链配置为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">ChainAuthHandler</span> <span class=\"hljs-variable\">chain</span> <span class=\"hljs-operator\">=</span> ChainAuthHandler.any();\n\n<span class=\"hljs-comment\">// 将http basic认证处理器添加到处理器链路中</span>\nchain.add(BasicAuthHandler.create(provider));\n<span class=\"hljs-comment\">// 将表单重定向认证处理器添加到处理器链路中</span>\nchain.add(RedirectAuthHandler.create(provider));\n\n<span class=\"hljs-comment\">// 保护您的路由</span>\nrouter.route(<span class=\"hljs-string\">&quot;/secure/resource&quot;</span>).handler(chain);\n<span class=\"hljs-comment\">// 您的app</span>\nrouter.route(<span class=\"hljs-string\">&quot;/secure/resource&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 做一些事情</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>因此，当用户发出没有 <code>Authorization</code> 标头的请求时，\n这意味着该链将无法使用basic auth处理器进行身份验证，并将尝试使用重定向处理器进行身份证。\n由于重定向处理器始终会将您重定向到发送您在处理器中配置的发送登录表单那里</p>\n</div>\n<div class=\"paragraph\">\n<p>就像vertx-web中的常规路由一样，身份认证链是一个序列。\n因此，如果您希望回退到浏览器中，使用HTTP Basic身份认证而不是重定向来询问用户凭据，\n那么您所需要做的就是反转加入到处理器链路的顺序。</p>\n</div>\n<div class=\"paragraph\">\n<p>现在假设您在请求中向请求头 <code>Authorization</code> 提供了值 <code>Basic [token]</code>。\n在这种情况下，basic auth处理器将尝试进行身份认证，如果成功，处理器链路将停止，并且vertx-web将继续处理您的处理程序。\n如果token无效，例如用户名密码错误，则链路将继续执行至下面的节点。\n在此特定情况就是重定向身份验证处理程序。</p>\n</div>\n<div class=\"paragraph\">\n<p>复杂的处理器链路也是可行的，举个例子，创建一个逻辑序列比如：<code>HandlerA</code> 或 （ <code>HandlerB</code> 和 <code>HandlerC</code> ）。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">ChainAuthHandler</span> <span class=\"hljs-variable\">chain</span> <span class=\"hljs-operator\">=</span>\n  ChainAuthHandler.any()\n    .add(authNHandlerA)\n    .add(ChainAuthHandler.all()\n      .add(authNHandlerB)\n      .add(authNHandlerC));\n\n<span class=\"hljs-comment\">// 保护您的代码</span>\nrouter.route(<span class=\"hljs-string\">&quot;/secure/resource&quot;</span>).handler(chain);\n<span class=\"hljs-comment\">// 您的app</span>\nrouter.route(<span class=\"hljs-string\">&quot;/secure/resource&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 做一些事情</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_serving_static_resources\"><a class=\"anchor\" href=\"#_serving_static_resources\"></a>处理静态资源</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web带有开箱即用的处理器，用于处理静态Web资源，\n因此您可以非常轻松地编写静态Web服务器。</p>\n</div>\n<div class=\"paragraph\">\n<p>您需要一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html\">StaticHandler</a></code> 实例处理静态资源，比如 <code>.html</code>,\n<code>.css</code>, <code>.js</code> 或者其他任意静态资源。</p>\n</div>\n<div class=\"paragraph\">\n<p>对静态处理器处理的路径的任何请求都由文件系统上的目录或类路径提供文件。\n默认静态文件目录为 <code>webroot</code>，但可以配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>在下面的示例中，所有对以 <code>/static/</code> 开头的路径的请求都将从目录 <code>webroot</code> 得到响应：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">&quot;/static/*&quot;</span>).handler(StaticHandler.create());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>例如，如果请求路径为 <code>static/css/mystyles.css</code>，\n则静态服务将在目录 <code>webroot/css/mystyle.css</code> 中查找文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>它还会在类路径中寻找一个名为 <code>webroot/css/mystyle.css</code> 的文件。这意味着您可以将所有静态资源打包到一个jar文件（或fatjar）中，\n然后像这样分发它们。</p>\n</div>\n<div class=\"paragraph\">\n<p>当Vert.x首次在类路径中找到资源时，它将提取该资源并将其缓存在磁盘上的临时目录中\n，因此不必每次都这样做。</p>\n</div>\n<div class=\"paragraph\">\n<p>处理器会处理范围感知的请求。当客户端向静态资源发出请求时，\n处理程序将通过在 <code>Accept-Ranges</code> 标头上声明该单元来通知其可以处理范围感知的请求。\n包含带有正确单位以及起始索引和结束索引的 <code>Range</code>\n标头的进一步请求将收到带有正确 <code>Content-Range</code> 标头的部分响应。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_caching\"><a class=\"anchor\" href=\"#_configuring_caching\"></a>配置缓存</h3>\n<div class=\"paragraph\">\n<p>默认情况下，静态处理程序将设置缓存头，以使浏览器能够有效地缓存文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web 设置 <code>cache-control</code>,<code>last-modified</code>, 和 <code>date</code> 头</p>\n</div>\n<div class=\"paragraph\">\n<p><code>cache-control</code> 默认情况下被设置为 <code>max-age=86400</code>。这相当于一天\n如果您需要，这也可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxAgeSeconds-long-\">setMaxAgeSeconds</a></code> 配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果浏览器发送带有 <code>if-modified-since</code> 标头的GET或HEAD请求，并且自该日期以来资源没有被修改，\n则返回 <code>304</code> 状态码，指示浏览器使用其本地缓存的资源。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果不需要处理缓存头，则可以使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCachingEnabled-boolean-\">setCachingEnabled</a></code> 将其禁用。</p>\n</div>\n<div class=\"paragraph\">\n<p>启用缓存处理后，Vert.x-Web将在内存中缓存资源的上次修改日期，\n这样可以避免每次访问磁盘时都要检查实际的上次修改日期。</p>\n</div>\n<div class=\"paragraph\">\n<p>缓存中的条目有一个到期时间，在此时间之后，\n将再次检查磁盘上的文件并更新缓存中的条目</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您知道文件永远不会在磁盘上更改，那么缓存条目将永远不会过期。\n这是默认值。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您知道文件在服务器运行时可能会在磁盘上更改， 则可以通过\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setFilesReadOnly-boolean-\">setFilesReadOnly</a></code> 设置文件只读属性为false。</p>\n</div>\n<div class=\"paragraph\">\n<p>要启用一次可以在内存中缓存的最大条目数，可以使用\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setMaxCacheSize-int-\">setMaxCacheSize</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setCacheEntryTimeout-long-\">setCacheEntryTimeout</a></code> 配置缓存项的过期时间。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_the_index_page\"><a class=\"anchor\" href=\"#_configuring_the_index_page\"></a>配置主页</h3>\n<div class=\"paragraph\">\n<p>对根路径 <code>/</code> 的任何请求都将导致主页得到处理。默认情况下主页是 <code>index.html</code>\n它可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIndexPage-java.lang.String-\">setIndexPage</a></code>.配置</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_changing_the_web_root\"><a class=\"anchor\" href=\"#_changing_the_web_root\"></a>更改web root</h3>\n<div class=\"paragraph\">\n<p>默认情况下，静态资源将从目录 <code>webroot</code> 提供。可以通过\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setWebRoot-java.lang.String-\">setWebRoot</a></code> 进行配置这个。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_serving_hidden_files\"><a class=\"anchor\" href=\"#_serving_hidden_files\"></a>处理隐藏文件</h3>\n<div class=\"paragraph\">\n<p>默认情况下，服务器将提供隐藏文件（以 <code>.</code> 开头的文件）。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您不希望提供隐藏文件，则可以使用以下命令对其进行配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setIncludeHidden-boolean-\">setIncludeHidden</a></code>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_directory_listing\"><a class=\"anchor\" href=\"#_directory_listing\"></a>目录列表</h3>\n<div class=\"paragraph\">\n<p>服务器还可以执行目录列表。默认情况下，目录列表处于禁用状态，可以使用\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryListing-boolean-\">setDirectoryListing</a></code> 启用他</p>\n</div>\n<div class=\"paragraph\">\n<p>当目录列表被启用时，返回的内容取决于 <code>accept</code> 标头中的内容类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 <code>text/html</code> 目录列表，可以使用\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/StaticHandler.html#setDirectoryTemplate-java.lang.String-\">setDirectoryTemplate</a></code> 配置用于呈现目录列表页面的模板</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_disabling_file_caching_on_disk\"><a class=\"anchor\" href=\"#_disabling_file_caching_on_disk\"></a>关闭在磁盘上的文件缓存</h3>\n<div class=\"paragraph\">\n<p>默认情况下，Vert.x将把从类路径提供的文件缓存到当前工作目录中名为\n<code>.vertx</code> 的目录的子目录中的磁盘上的文件中。 当在生产环境中将服务部署为Fatjar时，这尤其有用，\n因为每次生产时从类路径提供文件的速度都会很慢。</p>\n</div>\n<div class=\"paragraph\">\n<p>在开发中，这可能会引起问题，就像在服务器运行时更新静态内容一样，\n只会提供缓存的文件而不是实际更新的文件</p>\n</div>\n<div class=\"paragraph\">\n<p>要禁用文件缓存，您可以将vert.x选项的属性 <code>fileResolverCachingEnabled</code> 设置为false。\n为了向后兼容，该值还将默认为系统属性 <code>vertx.disableFileCaching</code> 的值。\n例如。您可以在IDE中设置运行配置，以便在运行主类时进行设置。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cors_handling\"><a class=\"anchor\" href=\"#_cors_handling\"></a>跨域处理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">Cross Origin Resource Sharing</a>是一种安全的机制，\n用于允许从一个域请求资源并从另一个域提供资源。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web包含一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/CorsHandler.html\">CorsHandler</a></code> ，用于帮您处理CORS协议</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个例子</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route()\n  .handler(\n    CorsHandler.create(<span class=\"hljs-string\">&quot;vertx\\\\.io&quot;</span>)\n      .allowedMethod(HttpMethod.GET));\n\nrouter.route().handler(ctx -&gt; {\n\n  <span class=\"hljs-comment\">// 您的app处理器</span>\n\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_multi_tenant\"><a class=\"anchor\" href=\"#_multi_tenant\"></a>多租户</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在某些情况下，您的应用程序需要处理的不仅仅是一个租户。\n在这种情况下，将提供一个助手处理器，以简化应用程序的设置。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果租户是通过HTTP标头（例如 <code>X-Tenant</code> ）标识的，\n则创建处理程序非常简单：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(MultiTenantHandler.create(<span class=\"hljs-string\">&quot;X-Tenant&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>现在，您应该注册为给定租户执行的处理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MultiTenantHandler.create(<span class=\"hljs-string\">&quot;X-Tenant&quot;</span>)\n  .addTenantHandler(<span class=\"hljs-string\">&quot;tenant-A&quot;</span>, ctx -&gt; {\n    <span class=\"hljs-comment\">// 为租户A做一些事情</span>\n  })\n  .addTenantHandler(<span class=\"hljs-string\">&quot;tenant-B&quot;</span>, ctx -&gt; {\n    <span class=\"hljs-comment\">// 为租户B做一些事情</span>\n  })\n  <span class=\"hljs-comment\">// optionally</span>\n  .addDefaultHandler(ctx -&gt; {\n    <span class=\"hljs-comment\">// 当没有租户匹配时，做一些事情</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这对于安全情况很有用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">gitHubAuthProvider</span> <span class=\"hljs-operator\">=</span> GithubAuth\n  .create(vertx, <span class=\"hljs-string\">&quot;CLIENT_ID&quot;</span>, <span class=\"hljs-string\">&quot;CLIENT_SECRET&quot;</span>);\n\n<span class=\"hljs-comment\">// 在我们运行的服务器上创建一个oauth2处理器</span>\n<span class=\"hljs-comment\">// 第二个参数是回调的完整网址</span>\n<span class=\"hljs-comment\">// 和您在提供者管理平台输入的一致</span>\n<span class=\"hljs-type\">OAuth2AuthHandler</span> <span class=\"hljs-variable\">githubOAuth2</span> <span class=\"hljs-operator\">=</span> OAuth2AuthHandler.create(\n  vertx,\n  gitHubAuthProvider,\n  <span class=\"hljs-string\">&quot;https://myserver.com/github-callback&quot;</span>);\n\n<span class=\"hljs-comment\">// 设置回调处理程序以接收GitHub回调</span>\ngithubOAuth2.setupCallback(router.route(<span class=\"hljs-string\">&quot;/github-callback&quot;</span>));\n\n<span class=\"hljs-comment\">// 创建一个OAuth2提供者，ClintID和ClientSecret</span>\n<span class=\"hljs-comment\">// 应该向Google请求</span>\n<span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">googleAuthProvider</span> <span class=\"hljs-operator\">=</span> OAuth2Auth.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n  .setClientId(<span class=\"hljs-string\">&quot;CLIENT_ID&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;CLIENT_SECRET&quot;</span>)\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setSite(<span class=\"hljs-string\">&quot;https://accounts.google.com&quot;</span>)\n  .setTokenPath(<span class=\"hljs-string\">&quot;https://www.googleapis.com/oauth2/v3/token&quot;</span>)\n  .setAuthorizationPath(<span class=\"hljs-string\">&quot;/o/oauth2/auth&quot;</span>));\n\n<span class=\"hljs-comment\">// 在我们的&quot;http://localhost:8080&quot;域上创建oauth2处理器</span>\n<span class=\"hljs-type\">OAuth2AuthHandler</span> <span class=\"hljs-variable\">googleOAuth2</span> <span class=\"hljs-operator\">=</span> OAuth2AuthHandler.create(\n  vertx,\n  googleAuthProvider,\n  <span class=\"hljs-string\">&quot;https://myserver.com/google-callback&quot;</span>);\n\n<span class=\"hljs-comment\">// 设置回调处理程序以接收Google回调</span>\ngoogleOAuth2.setupCallback(router.route(<span class=\"hljs-string\">&quot;/google-callback&quot;</span>));\n\n<span class=\"hljs-comment\">// 此时，两个回调端点已注册：</span>\n\n<span class=\"hljs-comment\">// /github-callback -&gt; 处理 github Oauth2 回调</span>\n<span class=\"hljs-comment\">// /google-callback -&gt; 处理 google Oauth2 回调</span>\n\n<span class=\"hljs-comment\">// 由于回调是由IdP进行的，因此没有标头来标识源，</span>\n<span class=\"hljs-comment\">// 因此需要自定义URL</span>\n\n<span class=\"hljs-comment\">// 但是对于我们的应用程序，我们可以对其进行控制，</span>\n<span class=\"hljs-comment\">// 因此稍后我们可以为合适的租户添加合适的处理程序</span>\n\nrouter.route().handler(\n  MultiTenantHandler.create(<span class=\"hljs-string\">&quot;X-Tenant&quot;</span>)\n    <span class=\"hljs-comment\">// 使用github的租户走这个方法</span>\n    .addTenantHandler(<span class=\"hljs-string\">&quot;github&quot;</span>, githubOAuth2)\n    <span class=\"hljs-comment\">// 使用google的租户走这个方法</span>\n    .addTenantHandler(<span class=\"hljs-string\">&quot;google&quot;</span>, googleOAuth2)\n    <span class=\"hljs-comment\">// 其余的都会被禁止</span>\n    .addDefaultHandler(ctx -&gt; ctx.fail(<span class=\"hljs-number\">401</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>可以随时从上下文中读取租户ID，例如，\n确定要加载的资源或要连接的数据库：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 默认键是 &quot;tenant&quot;，</span>\n  <span class=\"hljs-comment\">// 其是在MultiTenantHandler.TENANT中定义的，</span>\n  <span class=\"hljs-comment\">// 但此值可以在创建时在工厂方法中进行修改</span>\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">tenant</span> <span class=\"hljs-operator\">=</span> ctx.get(MultiTenantHandler.TENANT);\n\n  <span class=\"hljs-keyword\">switch</span>(tenant) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;google&quot;</span>:\n      <span class=\"hljs-comment\">// 为google用户做一些事情</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;github&quot;</span>:\n      <span class=\"hljs-comment\">// 为github用户做一些事情</span>\n      <span class=\"hljs-keyword\">break</span>;\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>多租户是一个功能强大的处理器，将允许应用程序并排运行，但是它不提供沙箱执行。\n不应将其用作隔离，因为错误编写的应用程序可能会在租户之间泄漏状态。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_templates\"><a class=\"anchor\" href=\"#_templates\"></a>模板</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web 为若干流行的模板引擎提供了开箱即用的支持，通过这种方式来提供生成动态页面的能力。\n您也可以很容易地添加您自己的实现。</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html\">TemplateEngine</a></code> 定义了使用模板引擎的接口。\n当渲染模板时会调用 <code><a href=\"../../apidocs/io/vertx/ext/web/common/template/TemplateEngine.html#render-io.vertx.core.json.JsonObject-java.lang.String-io.vertx.core.Handler-\">render</a></code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>最简单的使用模板的方式不是直接调用模板引擎，而是使用模板处理器\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/TemplateHandler.html\">TemplateHandler</a></code> 。\n这个处理器会根据 HTTP 请求的路径来调用模板引擎。</p>\n</div>\n<div class=\"paragraph\">\n<p>缺省情况下，模板处理器会在 <code>templates</code> 目录中查找模板文件。这是可以配置的。</p>\n</div>\n<div class=\"paragraph\">\n<p>该处理器会返回渲染的结果，并默认设置 Content-Type 消息头为 <code>text/html</code> 。这也是可以配置的。</p>\n</div>\n<div class=\"paragraph\">\n<p>您需要在创建模板处理器时提供您想要使用的模板引擎实例。\nVert.x Web 并未嵌入模板引擎的实现，您需要配置项目来访问它们。\nVert.x Web 提供了每一种模板引擎的配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TemplateEngine</span> <span class=\"hljs-variable\">engine</span> <span class=\"hljs-operator\">=</span> HandlebarsTemplateEngine.create();\n<span class=\"hljs-type\">TemplateHandler</span> <span class=\"hljs-variable\">handler</span> <span class=\"hljs-operator\">=</span> TemplateHandler.create(engine);\n\n<span class=\"hljs-comment\">// 这会将所有以 `/dynamic` 开头的 GET 请求路由到模板处理器上</span>\n<span class=\"hljs-comment\">// 例如 /dynamic/graph.hbs 会查找模板 /templates/graph.hbs</span>\nrouter.get(<span class=\"hljs-string\">&quot;/dynamic/*&quot;</span>).handler(handler);\n\n<span class=\"hljs-comment\">// 将所有以 `.hbs` 结尾的 GET 请求路由到模板处理器上</span>\nrouter.getWithRegex(<span class=\"hljs-string\">&quot;.+\\\\.hbs&quot;</span>).handler(handler);</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mvel_template_engine\"><a class=\"anchor\" href=\"#_mvel_template_engine\"></a>MVEL 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 MVEL 模板引擎：\n<code>io.vertx:vertx-web-templ-mvel:4.2.2</code>。 并通过此方法以创建 MVEL 模板引擎实例：\n<code>io.vertx.ext.web.templ.mvel.MVELTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 MVEL 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.templ</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 MVEL 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>The request path is @{context.request().path()}\n\nThe variable 'foo' from the session is @{context.session().get('foo')}\n\nThe value 'bar' from the context data is @{context.get('bar')}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 MVEL 模板，\n请参考 <a href=\"http://mvel.codehaus.org/MVEL+2.0+Templating+Guide\">MVEL 模板文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_jade_template_engine\"><a class=\"anchor\" href=\"#_jade_template_engine\"></a>Jade 模版引擎（译者注：Jade 已更名为 Pug)</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Jade 模板引擎：\n<code>io.vertx:vertx-web-templ-jade:4.2.2</code>。 并通过此方法以创建 Jade 模板引擎实例：\n<code>io.vertx.ext.web.templ.jade.JadeTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Jade 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.jade</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Jade 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>!!! 5\nhtml\n head\n   title= context.get('foo') + context.request().path()\n body</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Jade 模板，\n请参考 <a href=\"https://github.com/neuland/jade4j\">Jade4j 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handlebars_template_engine\"><a class=\"anchor\" href=\"#_handlebars_template_engine\"></a>Handlebars 模板引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Handlebars 模板引擎：\n<code>io.vertx:vertx-web-templ-handlebars:4.2.2</code>。 并通过此方法以创建 Handlebars 模板引擎实例：\n<code>io.vertx.ext.web.templ.handlebars.HandlebarsTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Handlebars 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.hbs</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>Handlebars 不允许在模板中随意地调用对象的方法，\n因此我们不能像对待其他模板引擎一样将RoutingContext传递到引擎里并让模板来识别它。</p>\n</div>\n<div class=\"paragraph\">\n<p>替代方案是，可以使用模版中的上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#data--\">data</a></code> 对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您要访问某些RoutingContext里不存在的信息，\n比如请求的路径、请求参数或者会话等，您需要在模板处理器执行之前将他们添加到上下文data里，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">TemplateHandler</span> <span class=\"hljs-variable\">handler</span> <span class=\"hljs-operator\">=</span> TemplateHandler.create(engine);\n\nrouter.get(<span class=\"hljs-string\">&quot;/dynamic&quot;</span>).handler(ctx -&gt; {\n\n  ctx.put(<span class=\"hljs-string\">&quot;request_path&quot;</span>, ctx.request().path());\n  ctx.put(<span class=\"hljs-string\">&quot;session_data&quot;</span>, ctx.session().data());\n\n  ctx.next();\n});\n\nrouter.get(<span class=\"hljs-string\">&quot;/dynamic/&quot;</span>).handler(handler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Handlebars 模板，\n请参考 <a href=\"https://github.com/jknack/handlebars.java\">Handlebars Java 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_thymeleaf_template_engine\"><a class=\"anchor\" href=\"#_thymeleaf_template_engine\"></a>Thymeleaf 模板引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Thymeleaf 模板引擎：\n<code>io.vertx:vertx-web-templ-thymeleaf:4.2.2</code>。 并通过此方法以创建 Thymeleaf 模板引擎实例：\n<code>io.vertx.ext.web.templ.thymeleaf.ThymeleafTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Thymeleaf 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.html</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Thymeleaf 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\n&lt;p th:text=\"${context.get('foo')}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.get('bar')}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.normalizedPath()}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().get('param1')}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().get('param2')}\"&gt;&lt;/p&gt;\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Thymeleaf 模板，\n请参考 <a href=\"http://www.thymeleaf.org/\">Thymeleaf 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_apache_freemarker_template_engine\"><a class=\"anchor\" href=\"#_apache_freemarker_template_engine\"></a>Apache FreeMarker 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Apache FreeMarker ：\n<code>io.vertx:vertx-web-templ-freemarker:4.2.2</code>。 并通过此方法以创建 Apache FreeMarker 模板引擎实例：\n<code>io.vertx.ext.web.templ.Engine#create()</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Apache FreeMarker 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.ftl</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Apache FreeMarker 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\n&lt;p th:text=\"${context.foo}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.bar}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.normalizedPath()}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().param1}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"${context.request().params().param2}\"&gt;&lt;/p&gt;\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Apache FreeMarker 模板，\n请参考 <a href=\"http://www.freemarker.org/\">Apache FreeMarker 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_pebble_template_engine\"><a class=\"anchor\" href=\"#_pebble_template_engine\"></a>Pebble 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Pebble ：\n<code>io.vertx:vertx-web-templ-pebble:4.2.2</code>。 并通过此方法以创建 Pebble 模板引擎实例：\n<code>io.vertx.ext.web.templ.pebble.PebbleTemplateEngine#create(vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Pebble 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.ped</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 Pebble 模板中可以通过 <code>context</code> 上下文变量来访问路由上下文 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code> 对象。\n这意味着您可使用任何基于上下文里的信息来渲染模板，\n包括请求、响应、会话或者上下文数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\n&lt;p th:text=\"{{context.foo}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.bar}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.normalizedPath()}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.request().params().param1}}\"&gt;&lt;/p&gt;\n&lt;p th:text=\"{{context.request().params().param2}}\"&gt;&lt;/p&gt;\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 Pebble 模板，\n请参考 <a href=\"http://www.mitchellbosecke.com/pebble/home/\">Pebble 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rocker_template_engine\"><a class=\"anchor\" href=\"#_rocker_template_engine\"></a>Rocker 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Rocker：<code>io.vertx:vertx-web-templ-rocker:4.2.2</code>。\n并通过此方法以创建 Rocker 模板引擎实例：<code>io.vertx.ext.web.templ.rocker#create()</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>Rocker会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。\n假定已知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\")\n .put(\"context\", new JsonObject().put(\"path\", \"/foo/bar\"));\n\nengine.render(context, \"somedir/TestRockerTemplate2\", render -&gt; {\n // (...)\n});\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>那么相对应的模版文件 <code>somedir/TestRockerTemplate2.rocker.html</code> 可写作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>@import io.vertx.core.json.JsonObject\n@args (JsonObject context, String foo, String bar)\nHello @foo and @bar\nRequest path is @context.getString(\"path\")</pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_httl_template_engine\"><a class=\"anchor\" href=\"#_httl_template_engine\"></a>HTTL 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 HTTL ：\n<code>io.vertx:vertx-web-templ-httl:4.2.2</code>。 并通过此方法以创建 HTTL 模板引擎实例：\n<code>io.vertx.ext.web.templ.httl.HTTLTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 HTTL 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.httl</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>HTTL会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。\n假定已知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\nTemplateEngine engine = HTTLTemplateEngine.create(vertx);\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\");\n\nengine.render(context, \"somedir/test-httl-template1.httl\", render -&gt; {\n // (...)\n});\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>那么相对应的模版文件 <code>somedir/test-httl-template1.httl</code> 可写作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>&lt;!-- #set(String foo, String bar) --&gt;\nHello ${foo} and ${bar}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 HTTL 模板，\n请参考 <a href=\"https://httl.github.io/en/\">HTTL 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rythm_template_engine\"><a class=\"anchor\" href=\"#_rythm_template_engine\"></a>Rythm 模版引擎</h3>\n<div class=\"paragraph\">\n<p>您需要在项目中添加以下 <em>依赖</em> 以使用 Rythm ：\n<code>io.vertx:vertx-web-templ-rythm:4.2.2</code>。 并通过此方法以创建 Rythm 模板引擎实例：\n<code>io.vertx.ext.web.templ.rythm.RythmTemplateEngine#create(io.vertx.core.Vertx)</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>在使用 Rythm 模板引擎时，如果不指定模板文件的扩展名，\n则默认会查找扩展名为 <code>.html</code> 的文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>Rythm会将JSON上下文对象的值传递给 <code>render</code> 方法作为模版的参数。\n假定已知：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>[snip]\nTemplateEngine engine = RythmTemplateEngine.create(vertx);\nfinal JsonObject context = new JsonObject()\n .put(\"foo\", \"badger\")\n .put(\"bar\", \"fox\");\n\nengine.render(context, \"somedir/test-rythm-template1.html\", render -&gt; {\n // (...)\n});\n[snip]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>那么相对应的模版文件 <code>somedir/test-rythm-template1.httl</code> 可写作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>&lt;!-- #set(String foo, String bar) --&gt;\nHello @foo and @bar</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关于如何编写 HTTL 模板，请参考 <a href=\"http://www.rythmengine.org/\">RythmEngine 文档</a>。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_caching\"><a class=\"anchor\" href=\"#_caching\"></a>缓存</h3>\n<div class=\"paragraph\">\n<p>许多引擎支持将编译好的模版存入缓存。该缓存存放在Vert.x的可分享的数据local map里。\n这样引擎便可在多个verticle中安全高效地使用该缓存。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_disabling_caching\"><a class=\"anchor\" href=\"#_disabling_caching\"></a>禁用缓存</h4>\n<div class=\"paragraph\">\n<p>在开发时，为了让每一次请求可以读取最新的模板，您可能希望禁用模板的缓存。\n您可通过设置系统变量：<code>vertxweb.environment</code> 或环境变量\n<code>VERTXWEB_ENVIRONMENT</code> 为 <code>dev</code> 或 <code>development</code> 将其禁用。缓存默认是启用的。</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_error_handler\"><a class=\"anchor\" href=\"#_error_handler\"></a>错误处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可使用模版处理器自行渲染错误页面，\n但是Vert.x-Web同样为您提供了开箱即用且“好看的”错误处理器，可为您渲染错误页面。</p>\n</div>\n<div class=\"paragraph\">\n<p>该处理器是 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ErrorHandler.html\">ErrorHandler</a></code>。\n要使用该错误处理器，仅需要将其设置为您希望覆盖的错误路径的失败处理器即可（译者注：例如router.route(\"/*\").failureHandler(ErrorHandler.create(vertx))）。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_request_logger\"><a class=\"anchor\" href=\"#_request_logger\"></a>请求日志</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web通过内置处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/LoggerHandler.html\">LoggerHandler</a></code> 来记录请求日志。\n您需在挂载任何可能导致 <code>RoutingContext</code> 失败的处理器之前挂载该处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，请求日志将会被记录到Vert.x logger中，亦可通过更改配置使用JUL logging, log4j 或 SLF4J记录。</p>\n</div>\n<div class=\"paragraph\">\n<p>详见 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/LoggerFormat.html\">LoggerFormat</a></code>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_serving_favicons\"><a class=\"anchor\" href=\"#_serving_favicons\"></a>提供网页图标</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web通过内置处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/FaviconHandler.html\">FaviconHandler</a></code> 以提供网页图标。</p>\n</div>\n<div class=\"paragraph\">\n<p>图标可以指定为文件系统上的某个路径，否则 Vert.x Web 默认会在 classpath 上寻找名为 <code>favicon.ico</code> 的文件。\n这意味着您可以将图标打包到包含您应用的 jar 包里。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_timeout_handler\"><a class=\"anchor\" href=\"#_timeout_handler\"></a>超时处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-Web内置一个超时处理器以处理超时请求。</p>\n</div>\n<div class=\"paragraph\">\n<p>可通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/TimeoutHandler.html\">TimeoutHandler</a></code> 配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果一个请求超时，则会给客户端返回一个 503 的响应。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面的例子设置了一个超时处理器。对于所有以 <code>/foo</code> 路径开头的请求，\n都会在执行时间超过 5 秒之后自动超时。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">&quot;/foo/&quot;</span>).handler(TimeoutHandler.create(<span class=\"hljs-number\">5000</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_response_time_handler\"><a class=\"anchor\" href=\"#_response_time_handler\"></a>响应时间处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>该处理器会将从接收到请求到写入响应的消息头之间的毫秒数写入到响应的 <code>x-response-time</code> 里，\n例如：</p>\n</div>\n<div class=\"paragraph\">\n<p>x-response-time: 1456ms</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_content_type_handler\"><a class=\"anchor\" href=\"#_content_type_handler\"></a>内容类型（Content type）处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>ResponseContentTypeHandler</code> 会自动设置响应的 <code>Content-Type</code> 消息头。\n假设我们要构建一个 RESTful 的 Web 应用，我们需要在所有处理器里设置消息类型：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router\n  .get(<span class=\"hljs-string\">&quot;/api/books&quot;</span>)\n  .produces(<span class=\"hljs-string\">&quot;application/json&quot;</span>)\n  .handler(ctx -&gt; findBooks()\n    .onSuccess(books -&gt; ctx.response()\n      .putHeader(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;application/json&quot;</span>)\n      .end(toJson(books))).onFailure(ctx::fail));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>随着 API 接口数量的增长，设置内容类型会变得很麻烦。\n可以通过在相应的 Route 上添加 <code>ResponseContentTypeHandler</code> 来避免这个问题：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">&quot;/api/*&quot;</span>).handler(ResponseContentTypeHandler.create());\nrouter\n  .get(<span class=\"hljs-string\">&quot;/api/books&quot;</span>)\n  .produces(<span class=\"hljs-string\">&quot;application/json&quot;</span>)\n  .handler(ctx -&gt; findBooks()\n    .onSuccess(books -&gt; ctx.response()\n      .end(toJson(books))).onFailure(ctx::fail));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>处理器会通过 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html#getAcceptableContentType--\">getAcceptableContentType</a></code> 方法来选择适当的内容类型。\n因此，您可以很容易地使用同一个处理器以提供不同类型的数据：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route(<span class=\"hljs-string\">&quot;/api/*&quot;</span>).handler(ResponseContentTypeHandler.create());\n\nrouter\n  .get(<span class=\"hljs-string\">&quot;/api/books&quot;</span>)\n  .produces(<span class=\"hljs-string\">&quot;text/xml&quot;</span>)\n  .produces(<span class=\"hljs-string\">&quot;application/json&quot;</span>)\n  .handler(ctx -&gt; findBooks()\n    .onSuccess(books -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ctx.getAcceptableContentType().equals(<span class=\"hljs-string\">&quot;text/xml&quot;</span>)) {\n        ctx.response().end(toXML(books));\n      } <span class=\"hljs-keyword\">else</span> {\n        ctx.response().end(toJson(books));\n      }\n    })\n    .onFailure(ctx::fail));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sockjs\"><a class=\"anchor\" href=\"#_sockjs\"></a>SockJS</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>SockJS 是一个客户端的 JavaScript 库以及协议，它提供了类似 WebSocket 的接口以方便您与 SockJS 服务器创建连接，\n而无需您关心浏览器或网络是否允许真正的 WebSocket。</p>\n</div>\n<div class=\"paragraph\">\n<p>它提供了若干不同的传输方式，\n并在运行时根据浏览器和网络的兼容性来选择使用哪种传输方式处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>然而这一切对您而言是透明的，您只需要简单地使用类似 WebSocket 的接口 <em>即可</em>。</p>\n</div>\n<div class=\"paragraph\">\n<p>请参阅 <a href=\"https://github.com/sockjs/sockjs-client\"> SockJS 网站</a>以获取更多关于SockJS的信息。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sockjs_handler\"><a class=\"anchor\" href=\"#_sockjs_handler\"></a>SockJS 处理器</h3>\n<div class=\"paragraph\">\n<p>Vert.x 提供了一个开箱即用的处理器 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\">SockJSHandler</a></code>\n以便您在 Vert.x-Web 应用中使用 SockJS。</p>\n</div>\n<div class=\"paragraph\">\n<p>您需要通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#create-io.vertx.core.Vertx-\">SockJSHandler.create</a></code> 方法为每一个 SockJS 的应用创建处理器。\n您也可以在创建处理器时通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\">SockJSHandlerOptions</a></code>\n对象来指定配置选项。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">SockJSHandlerOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSHandlerOptions</span>()\n  .setHeartbeatInterval(<span class=\"hljs-number\">2000</span>);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx, options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_sockjs_sockets\"><a class=\"anchor\" href=\"#_handling_sockjs_sockets\"></a>处理 SockJS 套接字</h3>\n<div class=\"paragraph\">\n<p>您可以在服务器端设置一个 SockJS 处理器，\n这个处理器会在客户端创建连接时被调用：</p>\n</div>\n<div class=\"paragraph\">\n<p>传递给处理器的是 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html\">SockJSSocket</a></code> 对象。\n这是一个类似套接字的接口，您可以像使用 <code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> 或\n<code><a href=\"../../apidocs/io/vertx/core/http/WebSocket.html\">WebSocket</a></code> 那样通过它来读写数据。它实现了 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 接口，因此您可以将它套用（pump）到其他读写流上。\n若 SockJS 连接使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#routingContext--\">routingContext</a></code> 加载，\n那么便可在手动管理会话（session）时访问 <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code>。\n由此您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webSession--\">webSession</a></code> 和\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#webUser--\">webUser</a></code> 管理用户和会话。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面的例子中的 SockJS 处理器直接使用了它读取到的数据进行回写：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">SockJSHandlerOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSHandlerOptions</span>()\n  .setHeartbeatInterval(<span class=\"hljs-number\">2000</span>);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx, options);\n\nrouter.mountSubRouter(<span class=\"hljs-string\">&quot;/myapp&quot;</span>, sockJSHandler.socketHandler(sockJSSocket -&gt; {\n\n  <span class=\"hljs-comment\">// 将数据回写</span>\n  sockJSSocket.handler(sockJSSocket::write);\n\n}));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_client_side\"><a class=\"anchor\" href=\"#_the_client_side\"></a>客户端</h3>\n<div class=\"paragraph\">\n<p>在客户端 JavaScript 环境里您需要通过 SockJS 的客户端库来建立连接。\n这是SockJS 客户端的地址 <a href=\"https://www.npmjs.com/package/sockjs-client\">https://www.npmjs.com/package/sockjs-client</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可直接在捆绑软件或构建工具中直接引用它。\n或者您想在 <code>HTML</code> 文档中直接使用 <code>CDN</code> 版本，那么首先需要引入 sockjs 的依赖：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n ...\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>完整的使用细节可参阅 <a href=\"https://github.com/sockjs/sockjs-client\">SockJS 网站</a>，\n但简而言之可像这样使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-js\" data-lang=\"js\"><span class=\"hljs-keyword\">var</span> sock = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJS</span>(<span class=\"hljs-string\">&#x27;http://mydomain.com/myapp&#x27;</span>);\n\nsock.<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;open&#x27;</span>);\n};\n\nsock.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) {\n <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, e.<span class=\"hljs-property\">data</span>);\n};\n\nsock.<span class=\"hljs-property\">onevent</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event, message</span>) {\n <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;event: %o, message:%o&#x27;</span>, event, message);\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 为了标记消息已被处理了</span>\n};\n\nsock.<span class=\"hljs-property\">onunhandled</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>) {\n <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;this message has no address:&#x27;</span>, json);\n};\n\nsock.<span class=\"hljs-property\">onclose</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>);\n};\n\nsock.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);\n\nsock.<span class=\"hljs-title function_\">close</span>();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_the_sockjs_handler\"><a class=\"anchor\" href=\"#_configuring_the_sockjs_handler\"></a>配置 SockJS 处理器</h3>\n<div class=\"paragraph\">\n<p>可使用 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\">SockJSHandlerOptions</a></code> 为处理器配置各种选项。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n默认情况下， 配置中并不包含一个默认的 <code>Origin</code> 属性。为了防御浏览器发送的 WebSocket\n跨域劫持攻击，我们建议您将 <code>Origin</code> 属性设置为您应用的\n网络源。这会强制服务器检查 WebSocket 的 <code>Origin</code> 以验证连接是否来自您的应用。这项检查非常重要，因为\n浏览器的同源策略并不限制 WebSocket 连接，因此一个攻击者可以轻松地在一个\n恶意网页上创建一个请求并连接您服务器上 sockJS 桥接器提供的 <code>ws://</code> 或 <code>wss://</code> 接口。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_writing_to_a_sockjs_socket_over_the_event_bus\"><a class=\"anchor\" href=\"#_writing_to_a_sockjs_socket_over_the_event_bus\"></a>通过 event bus 写入 SockJS 套接字</h3>\n<div class=\"paragraph\">\n<p>在创建 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html\">SockJSSocket</a></code> 的时候，可为其注册一个 event bus 上的事件处理器。\n该处理器的地址就是 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSSocket.html#writeHandlerID--\">writeHandlerID</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，不允许注册事件处理器。\n需要通过 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html\">SockJSHandlerOptions</a></code> 以启用该设置。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">SockJSHandlerOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSHandlerOptions</span>().setRegisterWriteHandler(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx, options);\n\nrouter.mountSubRouter(<span class=\"hljs-string\">&quot;/myapp&quot;</span>, sockJSHandler.socketHandler(sockJSSocket -&gt; {\n\n  <span class=\"hljs-comment\">// 获取 writeHandlerID 并将其存放 (例如放在本地 map 里)</span>\n  <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">writeHandlerID</span> <span class=\"hljs-operator\">=</span> sockJSSocket.writeHandlerID();\n\n}));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n默认情况下，处理器仅在本地注册。\n集群可通过配置 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandlerOptions.html#setLocalWriteHandler-boolean-\">setLocalWriteHandler</a></code> 为false启用。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>随后将数据写入 <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code> 便可发送给 SockJS 套接字。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">eventBus.send(writeHandlerID, Buffer.buffer(<span class=\"hljs-string\">&quot;foo&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sockjs_event_bus_bridge\"><a class=\"anchor\" href=\"#_sockjs_event_bus_bridge\"></a>SockJS 桥接 Event Bus</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web 提供了一个内置的被称为事件总线桥（event bus bridge）的 SockJS 套接字处理器。\n该处理器有效地将服务器端的 Vert.x 的事件总线延伸到客户端的 JavaScript 运行环境里。</p>\n</div>\n<div class=\"paragraph\">\n<p>这将创建一个分布式的事件总线。\n该 event bus 不仅可以在服务器端多个 Vert.x 实例中使用，还可以通过运行在浏览器里的 JavaScript 访问。</p>\n</div>\n<div class=\"paragraph\">\n<p>由此，我们可以建立起一个连接多个浏览器和服务器群的庞大的分布式 event bus。\n浏览器只需与服务器集群建立连接，无需每次都与固定的某个服务器建立连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些是通过 Vert.x 提供的一个简单的客户端 JavaScript 库 <code>vertx-eventbus.js</code> 来实现的。\n它提供了一系列与服务器端的 Vert.x event-bus 极为类似的 API。\n通过这些 API 您可以发送或发布消息，或注册处理器来接收消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>该 JavaScript 库使用了 JavaScript 的 SockJS 客户端，与另外一端的 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\">SockJS 处理器</a></code> 建立起 SockJS 连接，\n并将事件总线上的流量通过管道（tunnel）传送至该客户端。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个特殊的 SockJS 套接字处理器因此被安装到 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html\">SockJS 处理器</a></code> 上，\n而该处理器将会处理 SockJS 的数据，并将建立起与服务器端的事件总线的连接桥。</p>\n</div>\n<div class=\"paragraph\">\n<p>启用该连接桥您只需要在\nSockJS 处理器中调用\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-\">bridge</a></code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx);\n<span class=\"hljs-type\">SockJSBridgeOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSBridgeOptions</span>();\n<span class=\"hljs-comment\">// 将连接桥挂载到路由器上</span>\nrouter.mountSubRouter(<span class=\"hljs-string\">&quot;/eventbus&quot;</span>, sockJSHandler.bridge(options));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在客户端的 JavaScript 中，您可以使用 <a href=\"http://npmjs.com/package/@vertx/eventbus-bridge-client.js\">@vertx/eventbus-bridge-client.js</a>\n库以创建跟事件总线的连接，并以此发送和接收消息。 该库可在 <a href=\"http://npmjs.com/package/@vertx/eventbus-bridge-client.js\">NPM</a> 上找到。\n您可直接在捆绑软件或构建工具中直接引用它，但同时它亦可以在 CDN 中使用\n（就像之前的 sockJS 例子）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#x27;https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js&#x27;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n\n<span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventBus</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/eventbus&#x27;</span>);\n\neb.<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-function\">() =&gt;</span> {\n\n <span class=\"hljs-comment\">// 设置一个处理器以接收消息</span>\n eb.<span class=\"hljs-title function_\">registerHandler</span>(<span class=\"hljs-string\">&#x27;some-address&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, message</span>) =&gt;</span> {\n   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;received a message: &#x27;</span> + <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(message));\n });\n\n <span class=\"hljs-comment\">// 发送消息</span>\n eb.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;some-address&#x27;</span>, {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tim&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">587</span>});\n\n}\n\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该例子中首先创建了一个 event bus 实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventBus</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/eventbus&#x27;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>构造器中的参数是连接 event bus 的URI。\n因为我们建立的连接桥是以 <code>eventbus</code> 为前缀，所以我们将会成功建立连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>您在连接开启之前无法做任何事。当连接开启时 <code>onopen</code> 处理器将会被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>连接桥支持自动重连，可设置延迟和退避选项。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventBus</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/eventbus&#x27;</span>);\neb.<span class=\"hljs-title function_\">enableReconnect</span>(<span class=\"hljs-literal\">true</span>);\neb.<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {}; <span class=\"hljs-comment\">// 在此处设立处理器，每次建立连接或重连时候调用</span>\neb.<span class=\"hljs-property\">onreconnect</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {}; <span class=\"hljs-comment\">// 可选，仅在重连时被调用</span>\n\n<span class=\"hljs-comment\">// 或者，传入一个 options 对象</span>\n<span class=\"hljs-keyword\">var</span> options = {\n   <span class=\"hljs-attr\">vertxbus_reconnect_attempts_max</span>: <span class=\"hljs-title class_\">Infinity</span>, <span class=\"hljs-comment\">// 重连尝试最多次数</span>\n   <span class=\"hljs-attr\">vertxbus_reconnect_delay_min</span>: <span class=\"hljs-number\">1000</span>, <span class=\"hljs-comment\">// 在第一次尝试重连之前的初始延迟（单位为毫秒）</span>\n   <span class=\"hljs-attr\">vertxbus_reconnect_delay_max</span>: <span class=\"hljs-number\">5000</span>, <span class=\"hljs-comment\">// 尝试重连之间的最大延迟（单位为毫秒）</span>\n   <span class=\"hljs-attr\">vertxbus_reconnect_exponent</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// 指数退避因子</span>\n   <span class=\"hljs-attr\">vertxbus_randomization_factor</span>: <span class=\"hljs-number\">0.5</span> <span class=\"hljs-comment\">// 介于0和1之间的随机因子</span>\n};\n\n<span class=\"hljs-keyword\">var</span> eb2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventBus</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/eventbus&#x27;</span>, options);\neb2.<span class=\"hljs-title function_\">enableReconnect</span>(<span class=\"hljs-literal\">true</span>);\n<span class=\"hljs-comment\">// 创建处理器……</span></code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_securing_the_bridge\"><a class=\"anchor\" href=\"#_securing_the_bridge\"></a>守护连接桥</h3>\n<div class=\"paragraph\">\n<p>如果您像上面的例子一样建立连接桥但未开启守护机制，此时您试图通过该桥发送消息，\n您会发现消息神秘地失踪了。发生了什么？</p>\n</div>\n<div class=\"paragraph\">\n<p>对于大多数的应用，您恐怕不希望客户端的 JavaScript\n代码可以发送任何消息到任意服务端处理器或其他所有浏览器上。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，您可能在事件总线上注册了一个服务，用于访问或删除数据。\n我们并不希望出现恶意的行为或有害的客户端能够利用该服务删除数据库中所有的数据！</p>\n</div>\n<div class=\"paragraph\">\n<p>此外，我们恐怕也不希望任意一个客户端都能监听任意一个事件总线地址。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了解决这个问题，SockJs连接桥默认会拒绝所有的消息。\n您需要告诉连接桥哪些消息是可以通过的。（例外情况是，所有的回复消息都是可以通过的）。</p>\n</div>\n<div class=\"paragraph\">\n<p>换句话说，连接桥的行为就像是配置了缺省策略为 <em>全部拒绝</em> 策略的防火墙。</p>\n</div>\n<div class=\"paragraph\">\n<p>为连接桥配置哪些消息可以通过是很简单的一件事。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以通过调用连接桥时传入的\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSBridgeOptions.html\">SockJSBridgeOptions</a></code> 来配置 <em>匹配</em> 规则以指定哪些输入和输出的流量是允许通过的。</p>\n</div>\n<div class=\"paragraph\">\n<p>每一个匹配规则对应一个 <code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html\">PermittedOptions</a></code> 对象：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddress-java.lang.String-\">setAddress</a></code></dt>\n<dd>\n<p>该配置规则精确地定义了消息可以被发送到哪些地址。\n如您需要通过精确地址来控制消息的话，使用该选项。</p>\n</dd>\n<dt class=\"hdlist1\"><code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setAddressRegex-java.lang.String-\">setAddressRegex</a></code></dt>\n<dd>\n<p>该配置规则通过正则表达式来定义消息可以被发送到哪些地址。如您需要通过正则表达式来控制消息的话，请使用这个选项。\n如果指定了 <code>address</code> ，则该选项会被忽略。</p>\n</dd>\n<dt class=\"hdlist1\"><code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setMatch-io.vertx.core.json.JsonObject-\">setMatch</a></code></dt>\n<dd>\n<p>该配置规则通过消息的结构来控制消息是否可被发送。该配置中定义的每一个字段必须在消息中存在，且值一致。\n目前仅适用于 JSON 格式的消息。</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>对于一个 <em>输入</em> 的消息（例如通过客户端 JavaScript 发送到服务器）\n当消息抵达时，Vert.x Web 会检查每一条输入许可。如果存在匹配规则，则消息可以通过。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于一个 <em>输出</em> 的消息（例如通过服务器端发送给客户端 JavaScript）\n当消息发送时，Vert.x Web 会检查每一条输出许可。如果存在匹配，则消息可以通过。</p>\n</div>\n<div class=\"paragraph\">\n<p>实际的匹配过程如下：</p>\n</div>\n<div class=\"paragraph\">\n<p>如果指定了 <code>address</code> 字段，并且消息的目标地址与 <code>address</code> <em>精确</em> 匹配，\n则匹配成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果没有指定 <code>address</code> 但指定了 <code>addressRegex</code> 字段，并且消息的目标地址匹配了 <code>address_re</code> 里的正则表达式，\n则匹配成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果指定了 <code>match</code> 字段，则消息的结构也必须匹配。\n消息需包含有 match 对象中的所有键值对，方能匹配成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx);\n\n\n<span class=\"hljs-comment\">// 允许客户端向地址 `demo.orderMgr` 发送消息</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">inboundPermitted1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddress(<span class=\"hljs-string\">&quot;demo.orderMgr&quot;</span>);\n\n<span class=\"hljs-comment\">// 允许客户端向地址 `demo.persistor` 发送</span>\n<span class=\"hljs-comment\">// 包含有 `action` 的值为 `find`、</span>\n<span class=\"hljs-comment\">// `collecton` 的值为 `albums` 的消息。</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">inboundPermitted2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddress(<span class=\"hljs-string\">&quot;demo.persistor&quot;</span>)\n  .setMatch(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;action&quot;</span>, <span class=\"hljs-string\">&quot;find&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;collection&quot;</span>, <span class=\"hljs-string\">&quot;albums&quot;</span>));\n\n<span class=\"hljs-comment\">// 允许 `wibble` 值为 `foo` 的消息。</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">inboundPermitted3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setMatch(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;wibble&quot;</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>));\n\n<span class=\"hljs-comment\">// 让我们定义 服务端 -&gt; 客户端 发送消息匹配规则</span>\n\n<span class=\"hljs-comment\">// 允许向客户端发送地址为 `ticker.mystock` 的消息</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">outboundPermitted1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddress(<span class=\"hljs-string\">&quot;ticker.mystock&quot;</span>);\n\n<span class=\"hljs-comment\">// 允许向客户端发送地址以 `news.` 开头的消息</span>\n<span class=\"hljs-comment\">//（例如 news.europe, news.usa, 等）</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">outboundPermitted2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddressRegex(<span class=\"hljs-string\">&quot;news\\\\..+&quot;</span>);\n\n<span class=\"hljs-comment\">// 让我们定义 客户端 -&gt; 客户端 发送消息匹配规则</span>\n<span class=\"hljs-type\">SockJSBridgeOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSBridgeOptions</span>().\n  addInboundPermitted(inboundPermitted1).\n  addInboundPermitted(inboundPermitted1).\n  addInboundPermitted(inboundPermitted3).\n  addOutboundPermitted(outboundPermitted1).\n  addOutboundPermitted(outboundPermitted2);\n\n<span class=\"hljs-comment\">// 将连接桥挂载到路由器上</span>\nrouter.mountSubRouter(<span class=\"hljs-string\">&quot;/eventbus&quot;</span>, sockJSHandler.bridge(options));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_requiring_authorization_for_messages\"><a class=\"anchor\" href=\"#_requiring_authorization_for_messages\"></a>消息授权</h3>\n<div class=\"paragraph\">\n<p>连接桥可使用 Vert.x Web 的授权功能以配置消息的访问权限，\n同时支持输入和输出的消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，您可通过向上文所述的匹配规则中加入额外的字段\n以指定匹配需要哪些权限。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过 <code><a href=\"../../apidocs/io/vertx/ext/bridge/PermittedOptions.html#setRequiredAuthority-java.lang.String-\">setRequiredAuthority</a></code>\n方法来指定对于登录用户，需要具有哪些权限才允许访问这个消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">inboundPermitted</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddress(<span class=\"hljs-string\">&quot;demo.orderService&quot;</span>);\n\n<span class=\"hljs-comment\">// 仅限用户已登录并且拥有权限 `place_orders`</span>\ninboundPermitted.setRequiredAuthority(<span class=\"hljs-string\">&quot;place_orders&quot;</span>);\n\n<span class=\"hljs-type\">SockJSBridgeOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSBridgeOptions</span>()\n  .addInboundPermitted(inboundPermitted);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>用户需要登录，并被授权才能够访问消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>因此，您需要配置一个 Vert.x 认证处理器来处理登录和授权。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-comment\">// 允许客户端向 `demo.orderService` 发送消息</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">inboundPermitted</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddress(<span class=\"hljs-string\">&quot;demo.orderService&quot;</span>);\n\n<span class=\"hljs-comment\">// 仅限用户已登录并且拥有权限 `place_orders`</span>\ninboundPermitted.setRequiredAuthority(<span class=\"hljs-string\">&quot;place_orders&quot;</span>);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx);\n\n<span class=\"hljs-comment\">// 设置基础认证处理器：</span>\n\nrouter.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n\n<span class=\"hljs-type\">AuthenticationHandler</span> <span class=\"hljs-variable\">basicAuthHandler</span> <span class=\"hljs-operator\">=</span> BasicAuthHandler.create(authProvider);\n\nrouter.route(<span class=\"hljs-string\">&quot;/eventbus/*&quot;</span>).handler(basicAuthHandler);\n\n<span class=\"hljs-comment\">// 将连接桥挂载到路由器上</span>\nrouter.mountSubRouter(\n  <span class=\"hljs-string\">&quot;/eventbus&quot;</span>,\n  sockJSHandler.bridge(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSBridgeOptions</span>()\n    .addInboundPermitted(inboundPermitted)));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_event_bus_bridge_events\"><a class=\"anchor\" href=\"#_handling_event_bus_bridge_events\"></a>处理事件总线桥事件</h3>\n<div class=\"paragraph\">\n<p>如果您希望在桥时上发生事件时收到通知，可以提供一个处理器在调用\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/SockJSHandler.html#bridge-io.vertx.ext.web.handler.sockjs.SockJSBridgeOptions-io.vertx.core.Handler-\">bridge</a></code> 时调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>每当桥上发生事件时，它将被传递给处理程序。这个事件通过一个\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/sockjs/BridgeEvent.html\">BridgeEvent</a></code> 实例进行描述。</p>\n</div>\n<div class=\"paragraph\">\n<p>事件可以是下面的类型中的一种：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">SOCKET_CREATED</dt>\n<dd>\n<p>创建新的 SockJS 套接字时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">SOCKET_IDLE</dt>\n<dd>\n<p>当 SockJS 套接字闲置的时间比最初配置的时间长时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">SOCKET_PING</dt>\n<dd>\n<p>当为 SockJS 套接字更新最后的 ping 时间戳时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">SOCKET_CLOSED</dt>\n<dd>\n<p>关闭 SockJS 套接字时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">SOCKET_ERROR</dt>\n<dd>\n<p>当底层传输出错时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">SEND</dt>\n<dd>\n<p>尝试将消息从客户端发送到服务器时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">PUBLISH</dt>\n<dd>\n<p>尝试将消息从客户端发布到服务器时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">RECEIVE</dt>\n<dd>\n<p>尝试将消息从服务器传递到客户端时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">REGISTER</dt>\n<dd>\n<p>当客户端尝试注册处理程序时，将发生此事件.</p>\n</dd>\n<dt class=\"hdlist1\">UNREGISTER</dt>\n<dd>\n<p>当客户端尝试注销处理程序时，将发生此事件.</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>event可以通过 <code><a href=\"../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#type--\">type</a></code> 让您获取到类型，\n并通过 <code><a href=\"../../apidocs/io/vertx/ext/bridge/BaseBridgeEvent.html#getRawMessage--\">getRawMessage</a></code> 检查事件的原始消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>原始消息是具有以下结构的JSON对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{\n \"type\": \"send\"|\"publish\"|\"receive\"|\"register\"|\"unregister\",\n \"address\": 发送/发布/注册/注销的信息总线地址\n \"body\": 消息体\n}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意：<code>SOCKET_ERROR</code> 事件可能会包含消息。在这种情况下检查type属性，可能会引入一种新的\n消息。一个 <code>err</code> 消息。这是当一个套接字异常时会生成的一个合成消息。该消息将会\n遵循桥接数据传输格式，并像下面的示例一样：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{\n \"type\": \"err\",\n \"failureType\": \"socketException\",\n \"message\": \"可选的，来自被引发的异常的消息\"\n}</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>事件也是 <code><a href=\"../../apidocs/io/vertx/core/Promise.html\">Promise</a></code> 的一个实例。\n处理完事件后，您可以使用 <code>true</code> 来完成promise，以启用进一步的处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您不希望处理该事件，则可以使用 <code>false</code> 来完成promise。您可以自己过滤桥上面传递的信息，\n这是一个很有用的特性，\n或者应用一些细粒度的授权或指标。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是一个示例，其中我们拒绝所有流经桥的消息（如果其中包含单词\"Armadillos\"）。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-comment\">// 让从客户端发送到 &quot;demo.orderMgr&quot;的任何消息通过</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">inboundPermitted</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddress(<span class=\"hljs-string\">&quot;demo.someService&quot;</span>);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx);\n<span class=\"hljs-type\">SockJSBridgeOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSBridgeOptions</span>()\n  .addInboundPermitted(inboundPermitted);\n\n<span class=\"hljs-comment\">// 将桥挂载到路由上</span>\nrouter\n  .mountSubRouter(<span class=\"hljs-string\">&quot;/eventbus&quot;</span>, sockJSHandler\n    .bridge(options, be -&gt; {\n      <span class=\"hljs-keyword\">if</span> (be.type() == BridgeEventType.PUBLISH ||\n        be.type() == BridgeEventType.RECEIVE) {\n\n        <span class=\"hljs-keyword\">if</span> (be.getRawMessage().getString(<span class=\"hljs-string\">&quot;body&quot;</span>).equals(<span class=\"hljs-string\">&quot;armadillos&quot;</span>)) {\n          <span class=\"hljs-comment\">// Reject it</span>\n          be.complete(<span class=\"hljs-literal\">false</span>);\n          <span class=\"hljs-keyword\">return</span>;\n        }\n      }\n      be.complete(<span class=\"hljs-literal\">true</span>);\n    }));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这是如何配置和处理SOCKET_IDLE桥事件类型的示例。\n注意 <code>setPingTimeout(5000)</code>，它代表如果ping消息在5秒钟内没有从客户端到达，\n则将触发SOCKET_IDLE桥事件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-comment\">// 初始化SockJS处理器</span>\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx);\n<span class=\"hljs-type\">SockJSBridgeOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSBridgeOptions</span>()\n  .addInboundPermitted(inboundPermitted)\n  .setPingTimeout(<span class=\"hljs-number\">5000</span>);\n\n<span class=\"hljs-comment\">// 挂载桥到路由上</span>\nrouter\n  .mountSubRouter(<span class=\"hljs-string\">&quot;/eventbus&quot;</span>, sockJSHandler.bridge(options, be -&gt; {\n    <span class=\"hljs-keyword\">if</span> (be.type() == BridgeEventType.SOCKET_IDLE) {\n      <span class=\"hljs-comment\">// 做一些自定义处理</span>\n    }\n\n    be.complete(<span class=\"hljs-literal\">true</span>);\n  }));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在客户端JavaScript中，您可以使用 <code>vertx-eventbus.js</code> 库创建与事件总线的连接并发送和接收消息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://unpkg.io/sockjs-client@1.5.0/dist/sockjs.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#x27;https://unpkg.io/@vertx/eventbus-bridge-client.js@1.0.0-1/vertx-eventbus.js&#x27;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n\n<span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventBus</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/eventbus&#x27;</span>, {<span class=\"hljs-string\">&quot;vertxbus_ping_interval&quot;</span>: <span class=\"hljs-number\">300000</span>}); <span class=\"hljs-comment\">// sends ping every 5 minutes.</span>\n\neb.<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n\n<span class=\"hljs-comment\">// 设置接收消息的处理器</span>\neb.<span class=\"hljs-title function_\">registerHandler</span>(<span class=\"hljs-string\">&#x27;some-address&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error, message</span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;received a message: &#x27;</span> + <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(message));\n});\n\n<span class=\"hljs-comment\">// 发送信息</span>\neb.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;some-address&#x27;</span>, {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tim&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">587</span>});\n}\n\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该示例所做的第一件事是创建事件总线的实例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventBus</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/eventbus&#x27;</span>, {<span class=\"hljs-string\">&quot;vertxbus_ping_interval&quot;</span>: <span class=\"hljs-number\">300000</span>});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>构造函数的第二个参数告诉sockjs库每5分钟发送一次ping消息。\n由于服务器已配置为每5秒执行一次ping操作，因此会在服务器上触发 <code>SOCKET_IDLE</code></p>\n</div>\n<div class=\"paragraph\">\n<p>您还可以修改原始消息，例如改变请求体。\n对于从客户端传入的消息，您还可以在消息中添加头，下面是一个示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Router</span> <span class=\"hljs-variable\">router</span> <span class=\"hljs-operator\">=</span> Router.router(vertx);\n\n<span class=\"hljs-comment\">// 让从客户端发送到 &#x27;demo.orderService&#x27; 的任何消息通过</span>\n<span class=\"hljs-type\">PermittedOptions</span> <span class=\"hljs-variable\">inboundPermitted</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>()\n  .setAddress(<span class=\"hljs-string\">&quot;demo.orderService&quot;</span>);\n\n<span class=\"hljs-type\">SockJSHandler</span> <span class=\"hljs-variable\">sockJSHandler</span> <span class=\"hljs-operator\">=</span> SockJSHandler.create(vertx);\n<span class=\"hljs-type\">SockJSBridgeOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SockJSBridgeOptions</span>()\n  .addInboundPermitted(inboundPermitted);\n\n<span class=\"hljs-comment\">// 将桥挂载到路由上</span>\nrouter.mountSubRouter(\n  <span class=\"hljs-string\">&quot;/eventbus&quot;</span>,\n  sockJSHandler.bridge(options, be -&gt; {\n    <span class=\"hljs-keyword\">if</span> (\n      be.type() == BridgeEventType.PUBLISH ||\n        be.type() == BridgeEventType.SEND) {\n\n      <span class=\"hljs-comment\">// 添加一些头</span>\n      <span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">headers</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>()\n        .put(<span class=\"hljs-string\">&quot;header1&quot;</span>, <span class=\"hljs-string\">&quot;val&quot;</span>)\n        .put(<span class=\"hljs-string\">&quot;header2&quot;</span>, <span class=\"hljs-string\">&quot;val2&quot;</span>);\n\n      <span class=\"hljs-type\">JsonObject</span> <span class=\"hljs-variable\">rawMessage</span> <span class=\"hljs-operator\">=</span> be.getRawMessage();\n      rawMessage.put(<span class=\"hljs-string\">&quot;headers&quot;</span>, headers);\n      be.setRawMessage(rawMessage);\n    }\n    be.complete(<span class=\"hljs-literal\">true</span>);\n  }));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_csrf_cross_site_request_forgery\"><a class=\"anchor\" href=\"#_csrf_cross_site_request_forgery\"></a>CSRF跨站请求伪造</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>CSRF或有时也称为XSRF是一种技术，未经授权的站点可以通过该技术获取用户的私人数据\nVert.x-Web包含了一个 <code><a href=\"../../apidocs/io/vertx/ext/web/handler/CSRFHandler.html\">CSRFHandler</a></code>，\n您可以使用它防止跨站伪造请求</p>\n</div>\n<div class=\"paragraph\">\n<p>在此处理程序的每个get请求上，都会使用唯一token将cookie添加到响应中。\n然后，希望客户端在标头中返回此token。\n由于发送了cookie，因此要求cookie处理程序也存在于路由上。</p>\n</div>\n<div class=\"paragraph\">\n<p>在开发依赖于User-Agent来执行 <code>POST</code> 操作的非单页应用程序时，\n无法在HTML表单上指定标头。 为了解决此问题，还将并且仅当在表单属性中不存在与标头同名的标头时，\n才检查标头值，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;/submit&quot;</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">&quot;POST&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;hidden&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;X-XSRF-TOKEN&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;abracadabra&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>用户有责任为表单字段填写正确的值。\n倾向于使用仅HTML解决方案的用户可以通过从路由上下文中获取键为 <code>X-XSRF-TOKEN</code>\n或在实例化 <code>CSRFHandler</code> 对象时选择的标头名称下来填充此值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(CSRFHandler.create(vertx, <span class=\"hljs-string\">&quot;abracadabra&quot;</span>));\nrouter.route().handler(ctx -&gt; {\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意，此处理程序是session感知的。\n如果有可用的session，则在 <code>POST</code> 操作期间可能会省略表单参数或头，因为将从会话中读取该参数或头。\n这也意味着token将仅在session升级时重新生成。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意，为提高安全性，建议用户旋转对token进行签名的密钥 。\n可以通过替换处理器或使用新配置重新启动应用程序来在线完成此操作。\n点击劫持仍然可能影响应用程序。 如果这是关键应用程序，请考虑设置标头 <code>X-Frame-Options</code> ，如以下描述中所述：\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\" class=\"bare\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options</a></p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_ajax\"><a class=\"anchor\" href=\"#_using_ajax\"></a>使用 AJAX</h3>\n<div class=\"paragraph\">\n<p>当通过ajax访问受保护的路由时，两个csrf token都需要在请求中传递。\n通常这是使用请求标头完成的，因为添加请求标头通常可以轻松地在中心位置完成，\n而无需修改有效负载。</p>\n</div>\n<div class=\"paragraph\">\n<p>CSRF token是从服务器端上下文中的键 <code>X-XSRF-TOKEN</code> 下获得的（除非您指定其他名称）。\n通常需要通过将令牌包含在初始页面内容中来将此token公开给客户端。\n一种可能性是将其存储在HTML &lt;meta&gt;标记中，\n然后在其中可以通过JavaScript在请求时检索值。</p>\n</div>\n<div class=\"paragraph\">\n<p>您的视图中可以包含以下内容（下面的示例）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;csrf-token&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;${X-XSRF-TOKEN}&quot;</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以下是使用Fetch API将页面 &lt;meta&gt;\n标记中的CSRF token通过POST请求/process路由的例子:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-js\" data-lang=\"js\"><span class=\"hljs-comment\">// 获取&lt;meta&gt;标签中的CSRF token</span>\n<span class=\"hljs-keyword\">var</span> token = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;meta[name=&quot;csrf-token&quot;]&#x27;</span>).<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&#x27;content&#x27;</span>)\n\n<span class=\"hljs-comment\">// 使用Fetch API发送请求</span>\n<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/process&#x27;</span>, {\n <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&#x27;same-origin&#x27;</span>, <span class=\"hljs-comment\">// &lt;-- 在请求中包含cookie</span>\n <span class=\"hljs-attr\">headers</span>: {\n   <span class=\"hljs-string\">&#x27;X-XSRF-TOKEN&#x27;</span>: token <span class=\"hljs-comment\">// &lt;-- 将CSRF token放到header中</span>\n },\n <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n <span class=\"hljs-attr\">body</span>: {\n   <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span>\n }\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_hsts_handler\"><a class=\"anchor\" href=\"#_hsts_handler\"></a>HSTS处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>HTTP严格传输安全性（HSTS）是一种Web安全策略机制，\n可帮助保护网站免受中间人攻击，例如协议降级攻击和cookie劫持。\n它允许Web服务器声明Web浏览器（或其他符合要求的用户代理）应仅使用提供传输层安全性 （TLS/SSL）的HTTPS连接自动与其进行交互，\n这与单独使用不安全的HTTP不同。HSTS是IETF标准的跟踪协议，\n在RFC 6797中进行了确定。</p>\n</div>\n<div class=\"paragraph\">\n<p>该处理器只需一步即可为您的应用程序配置正确的标头</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(HSTSHandler.create());</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_csp_handler\"><a class=\"anchor\" href=\"#_csp_handler\"></a>CSP处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>内容安全策略（CSP）是安全性的附加层，有助于检测和缓解某些类型的攻击，\n包括跨站点脚本（XSS）和数据注入攻击。 这些攻击可用于从数据盗窃，\n站点攻击到恶意软件分发的各种方面</p>\n</div>\n<div class=\"paragraph\">\n<p>CSP设计为完全向后兼容。\n不支持它的浏览器仍然可以与实现它的服务器一起使用，反之亦然：\n不支持CSP的浏览器只是忽略它，照常运行，默认为Web内容的标准同源策略。 如果该站点不提供CSP标头，\n则浏览器同样会使用标准的同源策略。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(\n  CSPHandler.create()\n    .addDirective(<span class=\"hljs-string\">&quot;default-src&quot;</span>, <span class=\"hljs-string\">&quot;*.trusted.com&quot;</span>));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_xframe_handler\"><a class=\"anchor\" href=\"#_xframe_handler\"></a>XFrame处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>X-Frame-Options</code> HTTP响应标头可用于指示是否应允许浏览器在\n<code>frame</code> ，<code>iframe</code>，<code>embed</code> 或 <code>object</code> 中呈现页面。\n网站可以通过确保其内容未嵌入其他网站来避免点击劫持攻击。</p>\n</div>\n<div class=\"paragraph\">\n<p>仅当访问文档的用户使用支持 <code>X-Frame-Options</code> 的浏览器时，\n才提供附加的安全性。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果指定 <code>DENY</code>，则从其他站点加载时，不仅在fram中加载页面失败，而且从同一站点加载时，也会失败。\n另一方面，如果您指定 <code>SAMEORIGIN</code> ，则只要frame中包含该页面的站点与提供该页面的站点相同，\n您仍可以在frame中使用该页面。</p>\n</div>\n<div class=\"paragraph\">\n<p>此处理器将一步为您的应用程序配置正确的标头</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(XFrameHandler.create(XFrameHandler.DENY));</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_oauth2authhandler_handler\"><a class=\"anchor\" href=\"#_oauth2authhandler_handler\"></a>OAuth2Auth处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>OAuth2AuthHandler</code> 允许使用OAuth2协议快速设置安全路由。该处理器简化了authCode流。\n一个使用它来保护某些资源并通过GitHub进行身份验证的示例是这样的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">authProvider</span> <span class=\"hljs-operator\">=</span> GithubAuth\n  .create(vertx, <span class=\"hljs-string\">&quot;CLIENT_ID&quot;</span>, <span class=\"hljs-string\">&quot;CLIENT_SECRET&quot;</span>);\n\n<span class=\"hljs-comment\">// 在您运行的服务器上创建oauth2处理器</span>\n<span class=\"hljs-comment\">// the second argument is the full url to the 第二个参数是一个完全的url</span>\n<span class=\"hljs-comment\">//  这个url用于回调，和您在提供者管理控制台输入的一致</span>\n<span class=\"hljs-type\">OAuth2AuthHandler</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> OAuth2AuthHandler\n  .create(vertx, authProvider, <span class=\"hljs-string\">&quot;https://myserver.com/callback&quot;</span>);\n\n<span class=\"hljs-comment\">// 为接收GitHb回调设置回调处理器</span>\noauth2.setupCallback(router.route(<span class=\"hljs-string\">&quot;/callback&quot;</span>));\n\n<span class=\"hljs-comment\">// 保护 /protected 下的一切资源</span>\nrouter.route(<span class=\"hljs-string\">&quot;/protected/*&quot;</span>).handler(oauth2);\n<span class=\"hljs-comment\">// mount some handler under the protected zone</span>\nrouter\n  .route(<span class=\"hljs-string\">&quot;/protected/somepage&quot;</span>)\n  .handler(ctx -&gt; ctx.response().end(<span class=\"hljs-string\">&quot;Welcome to the protected resource!&quot;</span>));\n\n<span class=\"hljs-comment\">// 欢迎页面</span>\nrouter\n  .get(<span class=\"hljs-string\">&quot;/&quot;</span>)\n  .handler(ctx -&gt; ctx.response()\n    .putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>)\n    .end(<span class=\"hljs-string\">&quot;Hello&lt;br&gt;&lt;a href=\\&quot;/protected/somepage\\&quot;&gt;Protected by Github&lt;/a&gt;&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>OAuth2AuthHandler将设置适当的回调OAuth2处理器，\n因此用户不需要处理授权服务器响应的验证 。 知道授权服务器响应仅有效一次非常重要，\n这意味着如果客户端发出重新加载回调URL的请求，则它将被断言为无效请求，\n因为验证将失效</p>\n</div>\n<div class=\"paragraph\">\n<p>一条经验法则是，一旦执行了有效的回调，就将客户端重定向到受保护的资源\n此重定向还应该创建一个session cookie（或其他session机制），\n因此不需要用户为每个请求进行身份验证。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于OAuth2规范的性质，使用其他OAuth2提供者需要进行一些细微的更改\n但是vertx-auth为您提供了许多现成的实现：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Azure Active Directory <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/AzureADAuth.html\">AzureADAuth</a></code></p>\n</li>\n<li>\n<p>Box.com <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/BoxAuth.html\">BoxAuth</a></code></p>\n</li>\n<li>\n<p>Dropbox <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/DropboxAuth.html\">DropboxAuth</a></code></p>\n</li>\n<li>\n<p>Facebook <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FacebookAuth.html\">FacebookAuth</a></code></p>\n</li>\n<li>\n<p>Foursquare <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/FoursquareAuth.html\">FoursquareAuth</a></code></p>\n</li>\n<li>\n<p>Github <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GithubAuth.html\">GithubAuth</a></code></p>\n</li>\n<li>\n<p>Google <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/GoogleAuth.html\">GoogleAuth</a></code></p>\n</li>\n<li>\n<p>Instagram <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/InstagramAuth.html\">InstagramAuth</a></code></p>\n</li>\n<li>\n<p>Keycloak <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/KeycloakAuth.html\">KeycloakAuth</a></code></p>\n</li>\n<li>\n<p>LinkedIn <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/LinkedInAuth.html\">LinkedInAuth</a></code></p>\n</li>\n<li>\n<p>Mailchimp <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/MailchimpAuth.html\">MailchimpAuth</a></code></p>\n</li>\n<li>\n<p>Salesforce <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SalesforceAuth.html\">SalesforceAuth</a></code></p>\n</li>\n<li>\n<p>Shopify <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/ShopifyAuth.html\">ShopifyAuth</a></code></p>\n</li>\n<li>\n<p>Soundcloud <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/SoundcloudAuth.html\">SoundcloudAuth</a></code></p>\n</li>\n<li>\n<p>Stripe <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/StripeAuth.html\">StripeAuth</a></code></p>\n</li>\n<li>\n<p>Twitter <code><a href=\"../../apidocs/io/vertx/ext/auth/oauth2/providers/TwitterAuth.html\">TwitterAuth</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>但是，如果您使用的是未列出的提供者，则仍然可以使用基本API来做到这一点，如下所示：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">authProvider</span> <span class=\"hljs-operator\">=</span> OAuth2Auth.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OAuth2Options</span>()\n  .setClientId(<span class=\"hljs-string\">&quot;CLIENT_ID&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;CLIENT_SECRET&quot;</span>)\n  .setFlow(OAuth2FlowType.AUTH_CODE)\n  .setSite(<span class=\"hljs-string\">&quot;https://accounts.google.com&quot;</span>)\n  .setTokenPath(<span class=\"hljs-string\">&quot;https://www.googleapis.com/oauth2/v3/token&quot;</span>)\n  .setAuthorizationPath(<span class=\"hljs-string\">&quot;/o/oauth2/auth&quot;</span>));\n\n<span class=\"hljs-comment\">// 在我们的&quot;http://localhost:8080&quot;域上创建oauth2处理器</span>\n<span class=\"hljs-type\">OAuth2AuthHandler</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> OAuth2AuthHandler\n  .create(vertx, authProvider, <span class=\"hljs-string\">&quot;http://localhost:8080&quot;</span>);\n\n<span class=\"hljs-comment\">// 这是它的范围</span>\noauth2.withScope(<span class=\"hljs-string\">&quot;profile&quot;</span>);\n\n<span class=\"hljs-comment\">// 为Google回调设置回调处理器</span>\noauth2.setupCallback(router.get(<span class=\"hljs-string\">&quot;/callback&quot;</span>));\n\n<span class=\"hljs-comment\">// 保护 /protected 下的一切资源</span>\nrouter.route(<span class=\"hljs-string\">&quot;/protected/*&quot;</span>).handler(oauth2);\n<span class=\"hljs-comment\">// 在受保护的区域挂载一些处理器</span>\nrouter\n  .route(<span class=\"hljs-string\">&quot;/protected/somepage&quot;</span>)\n  .handler(ctx -&gt; ctx.response().end(<span class=\"hljs-string\">&quot;Welcome to the protected resource!&quot;</span>));\n\n<span class=\"hljs-comment\">// 欢迎页</span>\nrouter\n  .get(<span class=\"hljs-string\">&quot;/&quot;</span>)\n  .handler(ctx -&gt; ctx.response()\n    .putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>)\n    .end(<span class=\"hljs-string\">&quot;Hello&lt;br&gt;&lt;a href=\\&quot;/protected/somepage\\&quot;&gt;Protected by Google&lt;/a&gt;&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您将需要手动提供提供商的所有详细信息，但最终结果是相同的。</p>\n</div>\n<div class=\"paragraph\">\n<p>处理器会将您的应用程序固定为配置的回调URL。\n用法很简单，只需为处理程序提供一个路由实例，所有设置便会为您完成。\n在典型的用例中，您的提供者将询问您应用程序的回调URL是什么，然后您输入一个URL，例如：<code><a href=\"https://myserver.comcallback\" class=\"bare\">https://myserver.comcallback</a></code>。\n这是处理程序的第二个参数，现在您只需要设置它即可 。\n为了使最终用户更轻松，您所需要做的就是调用setupCallback方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是将处理器固定到服务器 <code><a href=\"https://myserver.com:8447/callback\" class=\"bare\">https://myserver.com:8447/callback</a></code> 的方式。 请注意，\n端口号并不是强制为默认值，http的默认端口号是80，https的默认端口号是443。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2AuthHandler</span> <span class=\"hljs-variable\">oauth2</span> <span class=\"hljs-operator\">=</span> OAuth2AuthHandler\n  .create(vertx, provider, <span class=\"hljs-string\">&quot;https://myserver.com:8447/callback&quot;</span>);\n\n<span class=\"hljs-comment\">// 现在允许处理器为您设置回调url</span>\noauth2.setupCallback(router.route(<span class=\"hljs-string\">&quot;/callback&quot;</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在该示例中，路由对象是由 <code>Router.route()</code> 内联创建的，\n但是，如果您想完全控制处理程序的调用顺序（例如，希望在链中尽快调用它），\n则可以可以始终在此之前创建Route对象，并将其的引用传递给这个方法</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_a_real_world_example\"><a class=\"anchor\" href=\"#_a_real_world_example\"></a>一个真实世界的例子</h3>\n<div class=\"paragraph\">\n<p>到目前为止，您已经学习了如何使用Oauth2处理器，但是您会注意到，对于每个请求，您都需要进行身份验证。\n这是因为处理器没有状态，并且在示例中没有应用状态管理。</p>\n</div>\n<div class=\"paragraph\">\n<p>尽管建议对面向API的端点不使用任何状态，\n例如，对于面向用户的端点使用JWT（我们将在后面介绍），我们可以将身份验证结果存储在session中。\n为此，我们需要一个类似于以下代码段的应用程序：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">OAuth2Auth</span> <span class=\"hljs-variable\">authProvider</span> <span class=\"hljs-operator\">=</span>\n  GithubAuth\n    .create(vertx, <span class=\"hljs-string\">&quot;CLIENTID&quot;</span>, <span class=\"hljs-string\">&quot;CLIENT SECRET&quot;</span>);\n<span class=\"hljs-comment\">// 我们也需要一个用户session处理器</span>\n<span class=\"hljs-comment\">// 其用来确保用户数据可以在请求之间储存在session中</span>\nrouter.route()\n  .handler(SessionHandler.create(LocalSessionStore.create(vertx)));\n<span class=\"hljs-comment\">// 我们现在保护 &quot;/protected&quot; 下的一切资源</span>\nrouter.route(<span class=\"hljs-string\">&quot;/protected&quot;</span>).handler(\n  OAuth2AuthHandler.create(\n    vertx,\n      authProvider,\n      <span class=\"hljs-string\">&quot;http://localhost:8080/callback&quot;</span>)\n    <span class=\"hljs-comment\">// 我们现在配置oauth2处理器</span>\n    <span class=\"hljs-comment\">// 设置回调处理器</span>\n    <span class=\"hljs-comment\">// 回调处理器必须符合oauth2提供者的规范</span>\n    .setupCallback(router.route(<span class=\"hljs-string\">&quot;/callback&quot;</span>))\n    <span class=\"hljs-comment\">// 对于这个资源，</span>\n    <span class=\"hljs-comment\">// 我们要求用户具有查看用户电子邮件的权限</span>\n    .withScope(<span class=\"hljs-string\">&quot;user:email&quot;</span>)\n);\n<span class=\"hljs-comment\">// 应用程序的入口点</span>\n<span class=\"hljs-comment\">// 其会渲染一个自定义的模板</span>\nrouter.get(<span class=\"hljs-string\">&quot;/&quot;</span>).handler(ctx -&gt; ctx.response()\n  .putHeader(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>)\n  .end(\n    <span class=\"hljs-string\">&quot;&lt;html&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;  &lt;body&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;    &lt;p&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;      Well, hello there!\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;    &lt;/p&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;    &lt;p&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;      We&#x27;re going to the protected resource, if there is no\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;      user in the session we will talk to the GitHub API. Ready?\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;      &lt;a href=\\&quot;/protected\\&quot;&gt;Click here&lt;/a&gt; to begin!&lt;/a&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;    &lt;/p&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;    &lt;p&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;      &lt;b&gt;If that link doesn&#x27;t work&lt;/b&gt;, remember to provide your\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;      own &lt;a href=\\&quot;https://github.com/settings/applications/new\\&quot;&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;      Client ID&lt;/a&gt;!\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;    &lt;/p&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;  &lt;/body&gt;\\n&quot;</span> +\n      <span class=\"hljs-string\">&quot;&lt;/html&gt;&quot;</span>));\n<span class=\"hljs-comment\">// 受保护的资源</span>\nrouter.get(<span class=\"hljs-string\">&quot;/protected&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 此时，您的user对象应包含</span>\n  <span class=\"hljs-comment\">// 从Oauth2响应中的信息,因为这是受保护的资源</span>\n  <span class=\"hljs-comment\">// 如上面在处理程序配置中指定的，用户对象永远不会为null</span>\n  <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> ctx.user();\n  <span class=\"hljs-comment\">// 只是将其转储到客户端以进行演示</span>\n  ctx.response().end(user.toString());\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mixing_oauth2_and_jwt\"><a class=\"anchor\" href=\"#_mixing_oauth2_and_jwt\"></a>将OAuth2和JWT混合使用</h3>\n<div class=\"paragraph\">\n<p>一些提供者将JWT token用作访问token，这是 <a href=\"https://tools.ietf.org/html/rfc6750\">RFC6750</a> 的功能，\n当要混合基于客户端的身份验证和API授权时，此功能非常有用。 例如，\n假如您有一个提供一些受保护的HTML文档的应用程序，但您还希望它可供API使用。\n在这种情况下，API无法轻松执行OAuth2所需的重定向握手，\n但可以使用事先提供的token。</p>\n</div>\n<div class=\"paragraph\">\n<p>只要提供者被配置为支持JWT，这个处理器就会自动处理此问题。</p>\n</div>\n<div class=\"paragraph\">\n<p>在现实生活中，这意味着您的API可以使用标头 <code>Authorization</code> ，\n其值为 <code>Bearer BASE64 ACCESS_TOKEN</code> ，来访问受保护的资源。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_webauthn\"><a class=\"anchor\" href=\"#_webauthn\"></a>WebAuthn</h3>\n<div class=\"paragraph\">\n<p>我们的网络信息存在依赖于过时而且脆弱的密码概念的问题。\n密码是介于恶意用户和您的银行帐户或社交媒体帐户之间的东西。 密码很难维护。很难将它们存储在服务器上\n（密码被盗）。他们很难记住，或者不告诉别人（网络钓鱼攻击）。</p>\n</div>\n<div class=\"paragraph\">\n<p>但是现在有一个更好的方法！一个无需密码的世界，它是浏览器上运行的W3C和FIDO Alliance的标准</p>\n</div>\n<div class=\"paragraph\">\n<p>WebAuthn是一种API，它允许服务器使用公钥加密（而不是密码）来注册和验证用户 ，\n这种API使用用户可访问的方法借助身份认证设备，\n比如yubikey token或者您的手机，进行加密</p>\n</div>\n<div class=\"paragraph\">\n<p>该协议至少要求将第一个回调挂载在路由上：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><code>/webauthn/response</code> 用于执行所有验证的回调</p>\n</li>\n<li>\n<p><code>/webauthn/login</code> 允许用户启动登录流程的端点（可选，但如果没有它，它将无法登录）</p>\n</li>\n<li>\n<p><code>/webauthn/register</code> 允许用户注册新的身份标识的端点（可选，如果数据已经存储，则不需要该端点）</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>这是一个受保护的应用程序的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">WebAuthn</span> <span class=\"hljs-variable\">webAuthn</span> <span class=\"hljs-operator\">=</span> WebAuthn.create(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebAuthnOptions</span>()\n    .setRelyingParty(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RelyingParty</span>().setName(<span class=\"hljs-string\">&quot;Vert.x WebAuthN Demo&quot;</span>))\n    <span class=\"hljs-comment\">// 哪种认证类型是您想要的，是您关心的？</span>\n    <span class=\"hljs-comment\">// # 密钥</span>\n    .setAuthenticatorAttachment(AuthenticatorAttachment.CROSS_PLATFORM)\n    <span class=\"hljs-comment\">// # 指纹</span>\n    .setAuthenticatorAttachment(AuthenticatorAttachment.PLATFORM)\n    .setUserVerification(UserVerification.REQUIRED))\n  <span class=\"hljs-comment\">// 从哪里加载证书？</span>\n  .authenticatorFetcher(fetcher)\n  <span class=\"hljs-comment\">// 更新认证状态</span>\n  .authenticatorUpdater(updater);\n\n<span class=\"hljs-comment\">// 解析请求体</span>\nrouter.post()\n  .handler(BodyHandler.create());\n<span class=\"hljs-comment\">// 添加session处理器</span>\nrouter.route()\n  .handler(SessionHandler\n    .create(LocalSessionStore.create(vertx)));\n\n<span class=\"hljs-comment\">// 安全处理器</span>\n<span class=\"hljs-type\">WebAuthnHandler</span> <span class=\"hljs-variable\">webAuthNHandler</span> <span class=\"hljs-operator\">=</span> WebAuthnHandler.create(webAuthn)\n  .setOrigin(<span class=\"hljs-string\">&quot;https://192.168.178.74.xip.io:8443&quot;</span>)\n  <span class=\"hljs-comment\">// 需要回调</span>\n  .setupCallback(router.post(<span class=\"hljs-string\">&quot;/webauthn/response&quot;</span>))\n  <span class=\"hljs-comment\">// 可选的注册回调</span>\n  .setupCredentialsCreateCallback(router.post(<span class=\"hljs-string\">&quot;/webauthn/register&quot;</span>))\n  <span class=\"hljs-comment\">// 可选的登录回调</span>\n  .setupCredentialsGetCallback(router.post(<span class=\"hljs-string\">&quot;/webauthn/login&quot;</span>));\n\n<span class=\"hljs-comment\">// 保护其余的Route</span>\nrouter.route().handler(webAuthNHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该应用程序在后端不安全，但是需要在客户端执行一些代码 。\n需要一些具有以下两个功能的样板</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-comment\">/**\n* 将公钥证书转化为可序列化的JSON\n* <span class=\"hljs-doctag\">@param</span>  {<span class=\"hljs-type\">Object</span>} pubKeyCred 公钥证书\n* <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-type\">Object</span>}            - 编码为JSON的公钥证书\n*/</span>\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">publicKeyCredentialToJSON</span> = (<span class=\"hljs-params\">pubKeyCred</span>) =&gt; {\n <span class=\"hljs-keyword\">if</span> (pubKeyCred <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>) {\n   <span class=\"hljs-keyword\">let</span> arr = [];\n   <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> pubKeyCred) { arr.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-title function_\">publicKeyCredentialToJSON</span>(i)) }\n\n   <span class=\"hljs-keyword\">return</span> arr\n }\n\n <span class=\"hljs-keyword\">if</span> (pubKeyCred <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ArrayBuffer</span>) {\n   <span class=\"hljs-keyword\">return</span> base64url.<span class=\"hljs-title function_\">encode</span>(pubKeyCred)\n }\n\n <span class=\"hljs-keyword\">if</span> (pubKeyCred <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>) {\n   <span class=\"hljs-keyword\">let</span> obj = {};\n\n   <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> pubKeyCred) {\n     obj[key] = <span class=\"hljs-title function_\">publicKeyCredentialToJSON</span>(pubKeyCred[key])\n   }\n\n   <span class=\"hljs-keyword\">return</span> obj\n }\n\n <span class=\"hljs-keyword\">return</span> pubKeyCred\n};\n\n<span class=\"hljs-comment\">/**\n* 生成安全随机数的Buffer\n* <span class=\"hljs-doctag\">@param</span>  {<span class=\"hljs-type\">Number</span>} <span class=\"hljs-variable\">len</span> - buffer的长度（默认为32byte）\n* <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-type\">Uint8Array</span>} - 随机字符串\n*/</span>\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">generateRandomBuffer</span> = (<span class=\"hljs-params\">len</span>) =&gt; {\n len = len || <span class=\"hljs-number\">32</span>;\n\n <span class=\"hljs-keyword\">let</span> randomBuffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Uint8Array</span>(len);\n <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">crypto</span>.<span class=\"hljs-title function_\">getRandomValues</span>(randomBuffer);\n\n <span class=\"hljs-keyword\">return</span> randomBuffer\n};\n\n<span class=\"hljs-comment\">/**\n* 解码arrayBuffer必填字段\n*/</span>\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">preformatMakeCredReq</span> = (<span class=\"hljs-params\">makeCredReq</span>) =&gt; {\n makeCredReq.<span class=\"hljs-property\">challenge</span> = base64url.<span class=\"hljs-title function_\">decode</span>(makeCredReq.<span class=\"hljs-property\">challenge</span>);\n makeCredReq.<span class=\"hljs-property\">user</span>.<span class=\"hljs-property\">id</span> = base64url.<span class=\"hljs-title function_\">decode</span>(makeCredReq.<span class=\"hljs-property\">user</span>.<span class=\"hljs-property\">id</span>);\n\n <span class=\"hljs-keyword\">return</span> makeCredReq\n};\n\n<span class=\"hljs-comment\">/**\n* 解码arrayBuffer必填字段\n*/</span>\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">preformatGetAssertReq</span> = (<span class=\"hljs-params\">getAssert</span>) =&gt; {\n getAssert.<span class=\"hljs-property\">challenge</span> = base64url.<span class=\"hljs-title function_\">decode</span>(getAssert.<span class=\"hljs-property\">challenge</span>);\n\n <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> allowCred <span class=\"hljs-keyword\">of</span> getAssert.<span class=\"hljs-property\">allowCredentials</span>) {\n   allowCred.<span class=\"hljs-property\">id</span> = base64url.<span class=\"hljs-title function_\">decode</span>(allowCred.<span class=\"hljs-property\">id</span>)\n }\n\n <span class=\"hljs-keyword\">return</span> getAssert\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这些功能将帮助您与服务器进行交互。话不多说。让我们从登录用户开始：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-comment\">// 使用之前定义的函数</span>\n<span class=\"hljs-title function_\">getGetAssertionChallenge</span>({<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;your-user-name&#x27;</span>})\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// base64必须解码为JavaScript Buffer</span>\n <span class=\"hljs-keyword\">let</span> publicKey = <span class=\"hljs-title function_\">preformatGetAssertReq</span>(response);\n <span class=\"hljs-comment\">// 这个响应之后会传给浏览器</span>\n <span class=\"hljs-comment\">// 用于通过于您的token/手机等互动产生断言</span>\n <span class=\"hljs-keyword\">return</span> navigator.<span class=\"hljs-property\">credentials</span>.<span class=\"hljs-title function_\">get</span>({publicKey})\n})\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// 将响应的buffer转为base64和json</span>\n <span class=\"hljs-keyword\">let</span> getAssertionResponse = <span class=\"hljs-title function_\">publicKeyCredentialToJSON</span>(response);\n <span class=\"hljs-comment\">// 向服务器传送数据</span>\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">sendWebAuthnResponse</span>(getAssertionResponse)\n})\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// 成功</span>\n <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;Login success&#x27;</span>)\n})\n.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> <span class=\"hljs-title function_\">alert</span>(error));\n\n<span class=\"hljs-comment\">// 工具函数</span>\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">sendWebAuthnResponse</span> = (<span class=\"hljs-params\">body</span>) =&gt; {\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/webauthn/response&#x27;</span>, {\n   <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n   <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&#x27;include&#x27;</span>,\n   <span class=\"hljs-attr\">headers</span>: {\n     <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>\n   },\n   <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(body)\n })\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) {\n       <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Server responded with error: <span class=\"hljs-subst\">${response.statusText}</span>`</span>);\n     }\n     <span class=\"hljs-keyword\">return</span> response;\n   })\n};\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">getGetAssertionChallenge</span> = (<span class=\"hljs-params\">formBody</span>) =&gt; {\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/webauthn/login&#x27;</span>, {\n   <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n   <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&#x27;include&#x27;</span>,\n   <span class=\"hljs-attr\">headers</span>: {\n     <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>\n   },\n   <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(formBody)\n })\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) {\n       <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Server responded with error: <span class=\"hljs-subst\">${response.statusText}</span>`</span>);\n     }\n     <span class=\"hljs-keyword\">return</span> response;\n   })\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> response.<span class=\"hljs-title function_\">json</span>())\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>上面的示例已经涵盖了66％的API，涵盖了3个端点中的2个。\n最后的端点是用户注册。用户注册是将新密钥注册到服务器凭证存储中并映射到用户的过程，\n当然，在客户端上创建了私钥并将其与服务器相关联，\n但是此密钥从未离开硬件令牌或手机安全芯片。</p>\n</div>\n<div class=\"paragraph\">\n<p>要注册用户并重用上面已经定义的大多数功能，请执行以下操作：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-comment\">/* 处理注册表 */</span>\n<span class=\"hljs-title function_\">getMakeCredentialsChallenge</span>({<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;myalias&#x27;</span>, <span class=\"hljs-attr\">displayName</span>: <span class=\"hljs-string\">&#x27;Paulo Lopes&#x27;</span>})\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// 将询问和id转为buffer并执行注册</span>\n <span class=\"hljs-keyword\">let</span> publicKey = <span class=\"hljs-title function_\">preformatMakeCredReq</span>(response);\n <span class=\"hljs-comment\">//  创建一个新的密钥对</span>\n <span class=\"hljs-keyword\">return</span> navigator.<span class=\"hljs-property\">credentials</span>.<span class=\"hljs-title function_\">create</span>({publicKey})\n})\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-comment\">// 将响应从buffer转为json</span>\n <span class=\"hljs-keyword\">let</span> makeCredResponse = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">publicKeyCredentialToJSON</span>(response);\n <span class=\"hljs-comment\">//  传送给服务器以辨认用户身份</span>\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">sendWebAuthnResponse</span>(makeCredResponse)\n})\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;Registration completed&#x27;</span>)\n})\n.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> <span class=\"hljs-title function_\">alert</span>(error));\n\n<span class=\"hljs-comment\">// 工具函数</span>\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">getMakeCredentialsChallenge</span> = (<span class=\"hljs-params\">formBody</span>) =&gt; {\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/webauthn/register&#x27;</span>, {\n   <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n   <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&#x27;include&#x27;</span>,\n   <span class=\"hljs-attr\">headers</span>: {\n     <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>\n   },\n   <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(formBody)\n })\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) {\n       <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Server responded with error: <span class=\"hljs-subst\">${response.statusText}</span>`</span>);\n     }\n     <span class=\"hljs-keyword\">return</span> response;\n   })\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> response.<span class=\"hljs-title function_\">json</span>())\n};</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n由于 API 的安全性，浏览器将不允许您在纯文本 HTTP 上使用此 API。\n所有请求都必须通过 HTTPS。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nWebAuthN 需要具有有效 TLS 证书的 HTTPS，\n您也可以在开发过程中使用自签名证书。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_one_time_password_multi_factor_authentication\"><a class=\"anchor\" href=\"#_one_time_password_multi_factor_authentication\"></a>一次性密码 (多重因子身份验证)</h3>\n<div class=\"paragraph\">\n<p>Vert.x 也支持多重因子身份验证（译者注：简称 MFA）。有两种使用 MFA 的方式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>HOTP</code> - 基于哈希的一次性密码</p>\n</li>\n<li>\n<p><code>TOTP</code> - 基于时间的一次性密码</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这些使用 MFA 的方式用法相同，因此您可以在构造方法级别\n选择一个您需要的使用方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个处理器的工作方式如下：</p>\n</div>\n<div class=\"paragraph\">\n<p>如果当前请求中不包含 <code><a href=\"../../apidocs/io/vertx/ext/auth/User.html\">User</a></code> ，那么处理器会假定用户之前没有经过\n身份认证。这意味着请求将立即终止，并且返回的 HTTP 状态码为 401。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果当前请求中包含用户，但对象中缺少具有匹配类型(<code>hotp</code>/<code>totp</code>)的 <code>mfa</code> 属性，请求会\n被重定向至身份验证 url (如果提供了的话)，否则请求也会被立即终止。这个 url 应该提供一种方式\n以供用户输入验证码，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>OTP Authenticator Verification Example Page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;/otp/verify&quot;</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">&quot;post&quot;</span> <span class=\"hljs-attr\">enctype</span>=<span class=\"hljs-string\">&quot;multipart/form-data&quot;</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Code:<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;code&quot;</span>/&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;Submit&quot;</span>/&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>用户输入完验证码后，请求会被重定向至初始的 url，如果不知道初始 url 的话，请求会被重定向至 <code>/</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>当然以上流程假定身份验证程序或设备已经配置好了。为了配置一个新的\n应用或设备，一个示例 HTML 网页代码如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-html\" data-lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>OTP Authenticator Registration Example Page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Scan this QR Code in Google Authenticator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;qrcode&quot;</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>- or enter this key manually -<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;url&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;url&#x27;</span>);\n <span class=\"hljs-keyword\">const</span> qrcode = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;qrcode&#x27;</span>);\n\n <span class=\"hljs-title function_\">fetch</span>(\n   <span class=\"hljs-string\">&#x27;/otp/register&#x27;</span>,\n   {\n     <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n     <span class=\"hljs-attr\">headers</span>: {\n       <span class=\"hljs-string\">&#x27;Accept&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>\n     }\n   })\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n     <span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">status</span> === <span class=\"hljs-number\">200</span>) {\n       <span class=\"hljs-keyword\">return</span> res;\n     }\n     <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(res.<span class=\"hljs-property\">statusText</span>);\n   })\n   .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err))\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.<span class=\"hljs-title function_\">json</span>())\n   .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">json</span> =&gt;</span> {\n     key.<span class=\"hljs-property\">innerText</span> = json.<span class=\"hljs-property\">url</span>;\n     qrcode.<span class=\"hljs-property\">src</span> =\n       <span class=\"hljs-string\">&#x27;https://chart.googleapis.com/chart?chs=166x166&amp;chld=L|0&amp;cht=qr&amp;chl=&#x27;</span> +\n       <span class=\"hljs-built_in\">encodeURIComponent</span>(json.<span class=\"hljs-property\">url</span>);\n   });\n </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以上示例代码中的重点是脚本会发送一个 <code>POST</code> 请求给配置好的注册回调。\n如果请求中用户仍然没有通过身份验证，那么注册回调将再次返回 HTTP 状态码 401。而如果\n身份验证成功，程序会返回一段 JSON 数据，其包含有一个 url，和一些额外的元数据。这个 url 用于配置身份验证器，\n验证的方式可以是手动输入数据，也可以是在显示一个二维码。要显示的二维码可以在前端渲染，\n也可以在后端渲染。简单起见，以上示例使用了 google charts API 来在\n浏览器上渲染二维码</p>\n</div>\n<div class=\"paragraph\">\n<p>最后，这就是您在 vert.x 应用程序中使用处理程序的方式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.post()\n  .handler(BodyHandler.create());\n<span class=\"hljs-comment\">// add a session handler (OTP requires state)</span>\nrouter.route()\n  .handler(SessionHandler\n    .create(LocalSessionStore.create(vertx))\n    .setCookieSameSite(CookieSameSite.STRICT));\n\n<span class=\"hljs-comment\">// add the first authentication mode, for example HTTP Basic Authentication</span>\nrouter.route()\n  .handler(basicAuthHandler);\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">OtpAuthHandler</span> <span class=\"hljs-variable\">otp</span> <span class=\"hljs-operator\">=</span> OtpAuthHandler\n  .create(TotpAuth.create()\n    .authenticatorFetcher(authr -&gt; {\n      <span class=\"hljs-comment\">// fetch authenticators from a database</span>\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">io</span>.vertx.ext.auth.otp.Authenticator());\n    })\n    .authenticatorUpdater(authr -&gt; {\n      <span class=\"hljs-comment\">// update or insert authenticators from a database</span>\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture();\n    }));\n\notp\n  <span class=\"hljs-comment\">// the issuer for the application</span>\n  .issuer(<span class=\"hljs-string\">&quot;Vert.x Demo&quot;</span>)\n  <span class=\"hljs-comment\">// handle code verification responses</span>\n  .verifyUrl(<span class=\"hljs-string\">&quot;/verify-otp.html&quot;</span>)\n  <span class=\"hljs-comment\">// handle registration of authenticators</span>\n  .setupRegisterCallback(router.post(<span class=\"hljs-string\">&quot;/otp/register&quot;</span>))\n  <span class=\"hljs-comment\">// handle verification of authenticators</span>\n  .setupCallback(router.post(<span class=\"hljs-string\">&quot;/otp/verify&quot;</span>));\n\n<span class=\"hljs-comment\">// secure the rest of the routes</span>\nrouter.route()\n  .handler(otp);\n\n<span class=\"hljs-comment\">// To view protected details, user must be authenticated and</span>\n<span class=\"hljs-comment\">// using 2nd factor authentication</span>\nrouter.get(<span class=\"hljs-string\">&quot;/protected&quot;</span>)\n  .handler(ctx -&gt; {\n    ctx.end(<span class=\"hljs-string\">&quot;Super secret content&quot;</span>);\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_http_method_overriding\"><a class=\"anchor\" href=\"#_handling_http_method_overriding\"></a>处理HTTP请求方法覆盖</h3>\n<div class=\"paragraph\">\n<p>许多公司和其他服务都限制了它们允许外部使用的REST HTTP方法。有些不太严密的可以允许使用任意的方法，大多数仅允许一个很小但不错的集合，有些则只允许GET和POST。造成这种限制的原因各不相同：浏览器或客户端限制或非常严格的公司防火墙。仅具有GET和POST的Web服务不能很好地表达REST的思想。PUT，DELETE，OPTIONS等对于指定对资源执行的操作非常有用。为了解决这个问题，它创建了X-HTTP-METHOD-OVERRIDE HTTP标头作为解决方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过使用GET/POST发送请求以及该请求应在X-HTTP-METHOD-OVERRIDE HTTP标头内设置真正的请求方法，服务器应识别该标头并重定向到适当的方法</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x允许这样做，只需：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(MethodOverrideHandler.create());\n\nrouter.route(HttpMethod.GET, <span class=\"hljs-string\">&quot;/&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 做 GET 相关操作……</span>\n});\n\nrouter.route(HttpMethod.POST, <span class=\"hljs-string\">&quot;/&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 做 POST 相关操作……</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>由于它将重定向请求，因此明智的做法是避免不必要地触发请求处理器，因此最好将MethodOverrideHandler添加为第一个处理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>另外，请注意：这可能会成为不怀好意的人的攻击对象！</p>\n</div>\n<div class=\"paragraph\">\n<p>为了缓解这种问题，默认情况下，MethodOverrideHandler附带了一个安全降级策略。这项策略规定，在以下情况下，X-HTTP-METHOD-OVERRIDE中包含的方法可以覆盖原始方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>覆盖方法是幂等的; 或者</p>\n</li>\n<li>\n<p>覆盖方法是安全的，并且要覆盖的方法不是幂等的; 或者</p>\n</li>\n<li>\n<p>被覆盖的方法不安全.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>尽管我们不建议这样做，但Vert.x不会强迫您采取任何措施。如果您希望允许任何覆盖，则：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">router.route().handler(MethodOverrideHandler.create(<span class=\"hljs-literal\">false</span>));\n\nrouter.route(HttpMethod.GET, <span class=\"hljs-string\">&quot;/&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 做 GET 相关操作……</span>\n});\n\nrouter.route(HttpMethod.POST, <span class=\"hljs-string\">&quot;/&quot;</span>).handler(ctx -&gt; {\n  <span class=\"hljs-comment\">// 做 POST 相关操作……</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.2.2"},"__N_SSG":true}