{"pageProps":{"slug":"4.2.2/vertx-stomp/java","title":"Vert.x-Stomp","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vertx_stomp\">使用 vertx-stomp</a></li>\n<li><a href=\"#_stomp_server\">STOMP 服务器</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_stomp_server\">创建 STOMP 服务器</a></li>\n<li><a href=\"#_closing_a_stomp_server\">关闭 STOMP 服务器</a></li>\n<li><a href=\"#_configuration\">配置服务端</a></li>\n<li><a href=\"#_subscriptions\">订阅</a></li>\n<li><a href=\"#_type_of_destinations\">消息目的地点类型</a></li>\n<li><a href=\"#_providing_your_own_type_of_destination\">提供您自定义的目的地点类型</a></li>\n<li><a href=\"#_acknowledgment\">确认消息</a></li>\n<li><a href=\"#_customizing_the_stomp_server\">自定义 STOMP 服务器配置</a></li>\n</ul>\n</li>\n<li><a href=\"#_stomp_client\">STOMP 客户端</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_stomp_client\">创建 STOMP 客户端</a></li>\n<li><a href=\"#_closing_a_stomp_client\">关闭 STOMP 客户端</a></li>\n<li><a href=\"#_handling_errors\">错误处理</a></li>\n<li><a href=\"#_configuration_2\">配置客户端</a></li>\n<li><a href=\"#_subscribing_to_destinations\">订阅</a></li>\n<li><a href=\"#_sending_messages\">发送消息</a></li>\n<li><a href=\"#_acknowledgements\">确认消息</a></li>\n<li><a href=\"#_transactions\">事务</a></li>\n<li><a href=\"#_receipt\">确认消息</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_stomp_server_as_a_bridge_to_the_vert_x_event_bus\">使用 STOMP 服务器桥接 Vert.x 事件总线</a></li>\n<li><a href=\"#_using_the_stomp_server_with_web_sockets\">使用基于 websocket 的 STOMP 服务器</a></li>\n<li><a href=\"#_registering_received_and_writing_frame_handlers\">注册接收消息处理器和写入消息处理器</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x-Stomp</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>STOMP 即简单(流)文本定向消息。 STOMP\n提供了一种可交互的消息管线，因此 STOMP 客户端可以与任意的 STOMP 消息中介（broker） 通信，并\n基于各种不同的语言，平台与消息中介实现信息的交互和操作。 参阅 <a href=\"https://stomp.github.io/index.html\" class=\"bare\">https://stomp.github.io/index.html</a> 了解更多关于 STOMP 的信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vertx-Stomp 提供了 STOMP 客户端和服务端的实现。 您可以使用其他客户端连接 Vert.x 的 STOMP 服务端，也可以\n使用 Vert.x 的 STOMP 客户端连接其他服务端实现。 Vert.x 提供的服务端和客户端都支持 STOMP 的 1.0，1.1 和 1.2\n版本  (参见 <a href=\"https://stomp.github.io/stomp-specification-1.2.html)。\" class=\"bare\">https://stomp.github.io/stomp-specification-1.2.html)。</a> 该 STOMP 服务端也可以用于跟\nVert.x 的事件总线桥接, 或者直接与 websocket 客户端建立连接 (使用 StompJS)</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vertx_stomp\"><a class=\"anchor\" href=\"#_using_vertx_stomp\"></a>使用 vertx-stomp</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了使用 Vert.x Stomp 服务端和客户端, 需要将以下依赖项添加到您的项目构建描述文件\n的 <em>依赖配置</em> 中:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (在您的 <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-stomp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.2.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (在您的 <code>build.gradle</code> 文件中):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-stomp:4.2.2&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_stomp_server\"><a class=\"anchor\" href=\"#_stomp_server\"></a>STOMP 服务器</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_creating_a_stomp_server\"><a class=\"anchor\" href=\"#_creating_a_stomp_server\"></a>创建 STOMP 服务器</h3>\n<div class=\"paragraph\">\n<p>以下是使用默认配置去创建 STOMP 服务器的最简单的方法:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx))\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这会创建一个符合 STOMP 标准的服务器， 它会监听 <code>localhost:61613</code> 地址</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServer.html#listen-int-java.lang.String-\">listen</a></code> 方法\n去配置服务器监听的主机地址和端口:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx))\n    .listen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">&quot;0.0.0.0&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您设置端口号为 <code>-1</code> , TCP 服务器将无法启动。 如果您使用到了 websocket 桥接\n这会很有用。 使用以下方式设置回调处理器，以便在服务器就绪时被调用:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">StompServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx))\n    .listen(ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.failed()) {\n        System.out.println(<span class=\"hljs-string\">&quot;Failing to start the STOMP server : &quot;</span> + ar.cause().getMessage());\n      } <span class=\"hljs-keyword\">else</span> {\n        System.out.println(<span class=\"hljs-string\">&quot;Ready to receive STOMP frames&quot;</span>);\n      }\n    });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该回调处理器接收一个类型是 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServer.html\">StompServer</a></code> 的引用参数</p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerOptions.html\">StompServerOptions</a></code> 配置服务器监听的主机地址和端口:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompServerOptions</span>().setPort(<span class=\"hljs-number\">1234</span>).setHost(<span class=\"hljs-string\">&quot;0.0.0.0&quot;</span>))\n    .handler(StompServerHandler.create(vertx))\n    .listen();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_closing_a_stomp_server\"><a class=\"anchor\" href=\"#_closing_a_stomp_server\"></a>关闭 STOMP 服务器</h3>\n<div class=\"paragraph\">\n<p>使用如下方式关闭 STOMP 服务器:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.close(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;The STOMP server has been closed&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;The STOMP server failed to close : &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>配置服务端</h3>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerOptions.html\">StompServerOptions</a></code> 配置 STOMP 服务器的多项参数</p>\n</div>\n<div class=\"paragraph\">\n<p>首先，STOMP 服务器是基于\n<code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html\">NetServer</a></code> 的， 因此您可以在  <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerOptions.html\">StompServerOptions</a></code> 中配置\n底层使用的 <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html\">NetServer</a></code>。或者您也可以将\n您想要使用的 <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html\">NetServer</a></code> 实例作为参数传入:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx, netServer)\n    .handler(StompServerHandler.create(vertx))\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该配置类 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerOptions.html\">StompServerOptions</a></code> 可以让您设置以下选项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>STOMP 服务器默认监听的主机地址和端口 - 默认为 <code>0.0.0.0:61613</code>.</p>\n</li>\n<li>\n<p>STOMP 服务器是否使用安全验证 - 默认为 <code>false</code></p>\n</li>\n<li>\n<p>STOMP 协议消息体的最大尺寸限制 - 默认为 10 Mb</p>\n</li>\n<li>\n<p>STOMP 协议消息体的最大首部限制 - 默认为 1000</p>\n</li>\n<li>\n<p>STOMP 协议消息体中首部行长度的最大限制 - 默认为 10240</p>\n</li>\n<li>\n<p>STOMP 协议的心跳时间 - 默认为 <code>1000, 1000</code></p>\n</li>\n<li>\n<p>支持的 STOMP 协议版本 (默认为 1.0, 1.1 和 1.2)</p>\n</li>\n<li>\n<p>STOMP 协议中事务所支持的最大消息数量 (默认为 1000)</p>\n</li>\n<li>\n<p>分块传输的最大尺寸 - 默认为 1000 (参见 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerOptions.html#setTransactionChunkSize-int-\">setTransactionChunkSize</a></code> )</p>\n</li>\n<li>\n<p>一个客户端可以使用的最大订阅数量 - 默认为 1000</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>如下所示，使用 JsonObject 配置 STOMP 协议的心跳时间：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompServerOptions</span>().setHeartbeat(\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;x&quot;</span>, <span class=\"hljs-number\">1000</span>).put(<span class=\"hljs-string\">&quot;y&quot;</span>, <span class=\"hljs-number\">1000</span>)))\n    .handler(StompServerHandler.create(vertx))\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>要使用安全认证功能，需要提供 <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code> 以处理\n认证请求：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompServerOptions</span>().setSecured(<span class=\"hljs-literal\">true</span>))\n    .handler(StompServerHandler.create(vertx).authProvider(provider))\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多关于 <code><a href=\"../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html\">AuthenticationProvider</a></code> 的信息请参考\n<a href=\"http://vertx.io/docs/#authentication_and_authorisation\">此文档</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>如果一个消息体的大小超过了限制, 那么它会被拒绝接收，并且客户端会收到一个 <code>ERROR</code> 消息。 按照协议\n要求，在发送这种错误消息后，客户端的连接需要立即关闭。 如果发送的消息不符合其他\n要求的限制，客户端也需要立即关闭。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_subscriptions\"><a class=\"anchor\" href=\"#_subscriptions\"></a>订阅</h3>\n<div class=\"paragraph\">\n<p>默认的 STOMP 服务器将订阅的目的地点作为普通的字符串处理。 因此它不会对其进行解析\n和分级。 默认的 STOMP 服务器使用 <em>topic</em> 模式处理订阅 (因此消息会被分发给所有\n对应的订阅客户端)</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_type_of_destinations\"><a class=\"anchor\" href=\"#_type_of_destinations\"></a>消息目的地点类型</h3>\n<div class=\"paragraph\">\n<p>默认情况下， STOMP 服务器将消息发送的 <em>目的地点</em> 作为 topic 类型处理。 因此消息会被发送给所有的订阅者。 您可以\n配置 STOMP 服务器将消息发送的目的地作为 queue 类型处理, 或两种模式都支持：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx)\n        .destinationFactory((v, name) -&gt; {\n          <span class=\"hljs-keyword\">if</span> (name.startsWith(<span class=\"hljs-string\">&quot;/queue&quot;</span>)) {\n            <span class=\"hljs-keyword\">return</span> Destination.queue(vertx, name);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> Destination.topic(vertx, name);\n          }\n        }))\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在以上代码中， 所有以 <code>/queue</code> 开头的目的地点均被作为 queue 类型处理，而其他的目的地点被当作 topic 类型。 目的地点是在 STOMP 服务器\n第一次接收到对应的订阅消息时被创建的</p>\n</div>\n<div class=\"paragraph\">\n<p>STOMP 服务器通过返回 <code>null</code> 以拒绝目的地点的创建：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx)\n        .destinationFactory((v, name) -&gt; {\n          <span class=\"hljs-keyword\">if</span> (name.startsWith(<span class=\"hljs-string\">&quot;/forbidden&quot;</span>)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (name.startsWith(<span class=\"hljs-string\">&quot;/queue&quot;</span>)) {\n            <span class=\"hljs-keyword\">return</span> Destination.queue(vertx, name);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> Destination.topic(vertx, name);\n          }\n        }))\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下， 订阅客户端会收到一个 <code>ERROR</code> 消息</p>\n</div>\n<div class=\"paragraph\">\n<p>queue 类型的目的地点使用轮询调度策略向订阅者分发消息</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_providing_your_own_type_of_destination\"><a class=\"anchor\" href=\"#_providing_your_own_type_of_destination\"></a>提供您自定义的目的地点类型</h3>\n<div class=\"paragraph\">\n<p>Vert.x 提供的 STOMP 有意没有实现任何高级特性。 如果您需要更高级的消息分发策略，\n可以提供自定义的 <code><a href=\"../../apidocs/io/vertx/ext/stomp/DestinationFactory.html\">DestinationFactory</a></code> 实现\n以返回您自定义的 <code><a href=\"../../apidocs/io/vertx/ext/stomp/Destination.html\">Destination</a></code> 实例。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_acknowledgment\"><a class=\"anchor\" href=\"#_acknowledgment\"></a>确认消息</h3>\n<div class=\"paragraph\">\n<p>默认情况下， STOMP 服务器如果没有收到一个消息的确认消息不会做任何处理。 您可以通过提供您自定义的\n <code><a href=\"../../apidocs/io/vertx/ext/stomp/Destination.html\">Destination</a></code> 以实现对确认消息的处理</p>\n</div>\n<div class=\"paragraph\">\n<p>自定义的目的地点类型应该实现</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerHandler.html#onAck-io.vertx.ext.stomp.StompServerConnection-io.vertx.ext.stomp.Frame-java.util.List-\">onAck</a></code>\n和\n<code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerHandler.html#onNack-io.vertx.ext.stomp.StompServerConnection-io.vertx.ext.stomp.Frame-java.util.List-\">onNack</a></code>\n方法以供 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServerHandler.html\">StompServerHandler</a></code> 实现特定行为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx)\n        .onAckHandler(acknowledgement -&gt; {\n          <span class=\"hljs-comment\">// Action to execute when the frames (one in `client-individual` mode, several</span>\n          <span class=\"hljs-comment\">// in `client` mode are acknowledged.</span>\n        })\n        .onNackHandler(acknowledgement -&gt; {\n          <span class=\"hljs-comment\">// Action to execute when the frames (1 in `client-individual` mode, several in</span>\n          <span class=\"hljs-comment\">// `client` mode are not acknowledged.</span>\n        }))\n    .listen();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_customizing_the_stomp_server\"><a class=\"anchor\" href=\"#_customizing_the_stomp_server\"></a>自定义 STOMP 服务器配置</h3>\n<div class=\"paragraph\">\n<p>除了上文所述的回调, 您还可以配置 STOMP 服务器的几乎所有配置, 例如收到\n指定消息类型的响应动作, 发送给客户端的 <code>ping</code> 消息 (为了实现\n心跳)。以下是示例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx)\n            .closeHandler(connection -&gt; {\n              <span class=\"hljs-comment\">// 客户端关闭的回调</span>\n            })\n            .beginHandler(frame -&gt; {\n              <span class=\"hljs-comment\">// 开始传输事务的回调</span>\n            })\n            .commitHandler(frame -&gt; {\n                  <span class=\"hljs-comment\">// 传输事务完成的回调</span>\n                }\n            )\n        <span class=\"hljs-comment\">//...</span>\n    ).listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>注意，改变默认的实现可能会导致对 STOMP 标准的破坏。 所以请参考\n默认的实现。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_stomp_client\"><a class=\"anchor\" href=\"#_stomp_client\"></a>STOMP 客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>STOMP 客户端可以连接到 STOMP 服务器并且接受和发送数据。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_stomp_client\"><a class=\"anchor\" href=\"#_creating_a_stomp_client\"></a>创建 STOMP 客户端</h3>\n<div class=\"paragraph\">\n<p>通过以下方式使用默认配置创建 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClient.html\">StompClient</a></code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以上的代码片段创建了一个客户端连接到 \"0.0.0.0:61613\"。 一旦连接成功, 您就可以获得一个\n<code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientConnection.html\">StompClientConnection</a></code> 实例用于和服务端交互。 您可以\n通过以下方式配置客户端的连接地址和端口：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect(<span class=\"hljs-number\">61613</span>, <span class=\"hljs-string\">&quot;0.0.0.0&quot;</span>)\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了捕获因为安全认证原因导致的异常， 或其他因为交互时\n产生的异常而返回的错误信息, 您可以提供一个 <em>异常处理器</em> 给 Stomp 客户端。 所有\n被该 STOMP 客户端创建的连接都会默认继承该异常处理器 (但他们也可以各自单独设置异常处理器)：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .errorFrameHandler(frame -&gt; {\n    <span class=\"hljs-comment\">// 接受错误消息</span>\n  })\n  .connect(<span class=\"hljs-number\">61613</span>, <span class=\"hljs-string\">&quot;0.0.0.0&quot;</span>)\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以使用 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientOptions.html\">StompClientOptions</a></code> 来配置 STOMP 客户端的连接地址和端口:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient\n  .create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompClientOptions</span>().setHost(<span class=\"hljs-string\">&quot;localhost&quot;</span>).setPort(<span class=\"hljs-number\">1234</span>))\n  .connect()\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_closing_a_stomp_client\"><a class=\"anchor\" href=\"#_closing_a_stomp_client\"></a>关闭 STOMP 客户端</h3>\n<div class=\"paragraph\">\n<p>您可以关闭 STOMP 客户端:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">StompClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> StompClient\n  .create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompClientOptions</span>().setHost(<span class=\"hljs-string\">&quot;localhost&quot;</span>).setPort(<span class=\"hljs-number\">1234</span>));\n\nclient\n  .connect()\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));\n\nclient.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然而, 使用以上方式关闭客户端不会告知 STOMP 服务器断开连接。 为了显式的断开连接， 您应当\n使用 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientConnection.html#disconnect--\">disconnect</a></code> 方法:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient\n  .create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompClientOptions</span>().setHost(<span class=\"hljs-string\">&quot;localhost&quot;</span>).setPort(<span class=\"hljs-number\">1234</span>))\n  .connect()\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n    connection.disconnect();\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用了心跳并且 STOMP 客户端在配置的心跳时间内没有检测到服务端的活动， 连接\n会自动关闭</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_errors\"><a class=\"anchor\" href=\"#_handling_errors\"></a>错误处理</h3>\n<div class=\"paragraph\">\n<p>对于 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientConnection.html\">StompClientConnection</a></code> 的实例, 您可以注册一个错误处理器用于接收\n服务端发送的 <code>ERROR</code> 消息。 注意服务端会在发送该错误消息后关闭连接：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient\n  .create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompClientOptions</span>().setHost(<span class=\"hljs-string\">&quot;localhost&quot;</span>).setPort(<span class=\"hljs-number\">1234</span>))\n  .connect()\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n    connection\n      .errorHandler(frame -&gt;\n        System.out.println(<span class=\"hljs-string\">&quot;ERROR frame received : &quot;</span> + frame));\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果客户端发现当前的连接被丢弃时会收到通知。 STOMP 客户端通过心跳机制\n监视连接是否失效。 当 STOMP 服务器在心跳时间窗口内没有发送心跳, 那么连接会被\n关闭并且 <code>connectionDroppedHandler</code> 会被调用 (如果设置了的话)。 为了设置 <code>connectionDroppedHandler</code>, 您需要调用\n<code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientConnection.html#connectionDroppedHandler-io.vertx.core.Handler-\">connectionDroppedHandler</a></code> 方法。该处理器可以起到\n让该 STOMP 客户端实例重新连接服务器的作用。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n\n    connection.connectionDroppedHandler(con -&gt; {\n      <span class=\"hljs-comment\">// 该连接已被丢失</span>\n      <span class=\"hljs-comment\">// 您需要重新建立连接或切换使用另一个连接</span>\n    });\n\n    connection.send(<span class=\"hljs-string\">&quot;/queue&quot;</span>, Buffer.buffer(<span class=\"hljs-string\">&quot;Hello&quot;</span>))\n      .onSuccess(frame -&gt; System.out.println(<span class=\"hljs-string\">&quot;Message processed by the server&quot;</span>)\n      );\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuration_2\"><a class=\"anchor\" href=\"#_configuration_2\"></a>配置客户端</h3>\n<div class=\"paragraph\">\n<p>您可以通过在创建 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClient.html\">StompClient</a></code> 时传入\n<code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientOptions.html\">StompClientOptions</a></code> 以自定义多项配置。 由于\nSTOMP 客户端底层依赖了 <code><a href=\"../../apidocs/io/vertx/core/net/NetClient.html\">NetClient</a></code>， 因此您可以在 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientOptions.html\">StompClientOptions</a></code> 中配置\n底层的 NetClient。 或者您也可以在 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClient.html#connect-io.vertx.core.net.NetClient-io.vertx.core.Handler-\">connect</a></code> 方法中\n传入一个\n您想使用的 <code><a href=\"../../apidocs/io/vertx/core/net/NetClient.html\">NetClient</a></code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect(netClient)\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n    connection\n      .errorHandler(frame -&gt;\n        System.out.println(<span class=\"hljs-string\">&quot;ERROR frame received : &quot;</span> + frame));\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/stomp/StompClientOptions.html\">StompClientOptions</a></code> 可以配置：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>连接 STOMP 服务器的地址和端口</p>\n</li>\n<li>\n<p>连接 STOMP 服务器的登录和密码</p>\n</li>\n<li>\n<p>如果没有显式设置 <code>content-length</code> 首部，是否自动添加 (默认开启)</p>\n</li>\n<li>\n<p>是否用 <code>STOMP</code> 指令来替换 <code>CONNECT</code> 指令 (默认关闭)</p>\n</li>\n<li>\n<p>在 <code>CONNECT</code> 消息中 <code>host</code> 首部是否被忽略  (默认关闭)</p>\n</li>\n<li>\n<p>心跳时间配置 (默认为 1000, 1000)</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_subscribing_to_destinations\"><a class=\"anchor\" href=\"#_subscribing_to_destinations\"></a>订阅</h3>\n<div class=\"paragraph\">\n<p>为了订阅消息的目的地点，使用</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n    connection.subscribe(<span class=\"hljs-string\">&quot;/queue&quot;</span>, frame -&gt;\n      System.out.println(<span class=\"hljs-string\">&quot;Just received a frame from /queue : &quot;</span> + frame));\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>为了取消订阅，使用:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n    <span class=\"hljs-comment\">// 使用连接</span>\n    connection.subscribe(<span class=\"hljs-string\">&quot;/queue&quot;</span>, frame -&gt;\n      System.out.println(<span class=\"hljs-string\">&quot;Just received a frame from /queue : &quot;</span> + frame));\n\n    <span class=\"hljs-comment\">// ....</span>\n\n    connection.unsubscribe(<span class=\"hljs-string\">&quot;/queue&quot;</span>);\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sending_messages\"><a class=\"anchor\" href=\"#_sending_messages\"></a>发送消息</h3>\n<div class=\"paragraph\">\n<p>为了发送消息，使用:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n    Map&lt;String, String&gt; headers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n    headers.put(<span class=\"hljs-string\">&quot;header1&quot;</span>, <span class=\"hljs-string\">&quot;value1&quot;</span>);\n    connection.send(<span class=\"hljs-string\">&quot;/queue&quot;</span>, headers, Buffer.buffer(<span class=\"hljs-string\">&quot;Hello&quot;</span>));\n    <span class=\"hljs-comment\">//没有首部:</span>\n    connection.send(<span class=\"hljs-string\">&quot;/queue&quot;</span>, Buffer.buffer(<span class=\"hljs-string\">&quot;World&quot;</span>));\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在 Java 和 Groovy 语言中， 您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/stomp/utils/Headers.html\">Headers</a></code> 类用于简化首部的创建</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_acknowledgements\"><a class=\"anchor\" href=\"#_acknowledgements\"></a>确认消息</h3>\n<div class=\"paragraph\">\n<p>STOMP 客户端可以发送 <code>ACK</code> 和 <code>NACK</code> 消息：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n    connection.subscribe(<span class=\"hljs-string\">&quot;/queue&quot;</span>, frame -&gt; {\n      connection.ack(frame.getAck());\n      <span class=\"hljs-comment\">// 或者</span>\n      connection.nack(frame.getAck());\n    });\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_transactions\"><a class=\"anchor\" href=\"#_transactions\"></a>事务</h3>\n<div class=\"paragraph\">\n<p>STOMP 客户端也可以创建事务。 <code>ACK</code>, <code>NACK</code> 和 <code>SEND</code> 消息只有在事务被提交时才会\n发送。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n    Map&lt;String, String&gt; headers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n    headers.put(<span class=\"hljs-string\">&quot;transaction&quot;</span>, <span class=\"hljs-string\">&quot;my-transaction&quot;</span>);\n    connection.beginTX(<span class=\"hljs-string\">&quot;my-transaction&quot;</span>);\n    connection.send(<span class=\"hljs-string\">&quot;/queue&quot;</span>, headers, Buffer.buffer(<span class=\"hljs-string\">&quot;Hello&quot;</span>));\n    connection.send(<span class=\"hljs-string\">&quot;/queue&quot;</span>, headers, Buffer.buffer(<span class=\"hljs-string\">&quot;World&quot;</span>));\n    connection.send(<span class=\"hljs-string\">&quot;/queue&quot;</span>, headers, Buffer.buffer(<span class=\"hljs-string\">&quot;!!!&quot;</span>));\n    connection.commit(<span class=\"hljs-string\">&quot;my-transaction&quot;</span>);\n    <span class=\"hljs-comment\">// 或者</span>\n    connection.abort(<span class=\"hljs-string\">&quot;my-transaction&quot;</span>);\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_receipt\"><a class=\"anchor\" href=\"#_receipt\"></a>确认消息</h3>\n<div class=\"paragraph\">\n<p>每次发送指令可以设置一个 <em>确认</em> 处理器, 该处理器会在服务端确认处理完消息后被调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">StompClient.create(vertx)\n  .connect()\n  .onSuccess(connection -&gt; {\n    connection\n      .send(<span class=\"hljs-string\">&quot;/queue&quot;</span>, Buffer.buffer(<span class=\"hljs-string\">&quot;Hello&quot;</span>))\n      .onSuccess(frame -&gt;\n        System.out.println(<span class=\"hljs-string\">&quot;Message processed by the server&quot;</span>));\n  })\n  .onFailure(err -&gt;\n    System.out.println(\n      <span class=\"hljs-string\">&quot;Failed to connect to the STOMP server: &quot;</span> + err.toString()));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_stomp_server_as_a_bridge_to_the_vert_x_event_bus\"><a class=\"anchor\" href=\"#_using_the_stomp_server_as_a_bridge_to_the_vert_x_event_bus\"></a>使用 STOMP 服务器桥接 Vert.x 事件总线</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>STOMP 服务器可以桥接 Vert.x 的事件总线。 这种桥接是双向的，这意味着 STOMP 消息\n可以被转换为事件总线中的消息，并且事件总线中的消息可以被转化为 STOMP 消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了使用桥接， 您需要配置入站和出站地址。 入站地址是指需要转入事件总线的\n STOMP 消息的目的地点。 这些 STOMP 消息的目的地点会被作为事件总线的地址。 出站地址\n是指需要被转化为 STOMP 消息的事件总线地址。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx)\n        .bridge(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BridgeOptions</span>()\n            .addInboundPermitted(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>().setAddress(<span class=\"hljs-string\">&quot;/toBus&quot;</span>))\n            .addOutboundPermitted(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>().setAddress(<span class=\"hljs-string\">&quot;/toStomp&quot;</span>))\n        )\n    )\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下， 桥接使用 发布/订阅 模式发送消息 (topic 模式)。 您也可以配置它使用点对点模式去发送\n消息， 这样就只会有一个 STOMP 客户端或事件总线的消费者被调用:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx)\n            .bridge(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BridgeOptions</span>()\n                    .addInboundPermitted(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>().setAddress(<span class=\"hljs-string\">&quot;/toBus&quot;</span>))\n                    .addOutboundPermitted(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>().setAddress(<span class=\"hljs-string\">&quot;/toStomp&quot;</span>))\n                    .setPointToPoint(<span class=\"hljs-literal\">true</span>)\n            )\n    )\n    .listen();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>出入站的许可字符串可以作为一个 \"正则字符串\" 或者一个 <em>匹配项</em>。 <em>匹配项</em> 是指\n消息体需要满足的特定结构。 以下代码展示了消息体必须拥有字段 \"foo\" ，并且其\n值为 \"bar\"。 结构匹配当前只支持 Json 数据类型。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx)\n        .bridge(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BridgeOptions</span>()\n            .addInboundPermitted(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>().setAddress(<span class=\"hljs-string\">&quot;/toBus&quot;</span>)\n                .setMatch(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>)))\n            .addOutboundPermitted(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PermittedOptions</span>().setAddress(<span class=\"hljs-string\">&quot;/toStomp&quot;</span>))\n            .setPointToPoint(<span class=\"hljs-literal\">true</span>)\n        )\n    )\n    .listen();</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_stomp_server_with_web_sockets\"><a class=\"anchor\" href=\"#_using_the_stomp_server_with_web_sockets\"></a>使用基于 websocket 的 STOMP 服务器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果您想使用一个 Javascript 客户端 (在 node.js 或浏览器中) 直接连接 STOMP 服务器, 您可以使用\nwebsocket。 STOMP 协议目前完成了适配，可以基于 websocket 工作，参见\n<a href=\"http://jmesnil.net/stomp-websocket/doc/\">StompJS</a> 。 使用 JavaScript 客户端直接连接到 STOMP 服务器并且\n使用 websocket 协议发送消息。 这样也可以使用 websocket 接收 STOMP 消息。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了配置服务器使用 StompJS, 您需要：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>使用 websocket 桥接并且配置 websocket 需要监听的路径 (默认为 <code>/stomp</code>)</p>\n</li>\n<li>\n<p>在您的应用中引入 <a href=\"http://jmesnil.net/stomp-websocket/doc/#download\">StompJS</a> (您的应用可以是\nHTML 页面上的脚本, 或者一个 node 模块 (<a href=\"https://www.npmjs.com/package/stompjs\" class=\"bare\">https://www.npmjs.com/package/stompjs</a>)</p>\n</li>\n<li>\n<p>连接到服务器</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>为了完成第一步， 您首先需要创建一个 HTTP 服务器, 并且将\n<code><a href=\"../../apidocs/io/vertx/ext/stomp/StompServer.html#webSocketHandler--\">webSocketHandler</a></code> 的结果传递给\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpServer.html#webSocketHandler-io.vertx.core.Handler-\">webSocketHandler</a></code> 方法:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">StompServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> StompServer.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StompServerOptions</span>()\n    .setPort(-<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 禁用 tcp 端口，这一项是可选的</span>\n    .setWebsocketBridge(<span class=\"hljs-literal\">true</span>) <span class=\"hljs-comment\">// 开启 websocket 支持</span>\n    .setWebsocketPath(<span class=\"hljs-string\">&quot;/stomp&quot;</span>)) <span class=\"hljs-comment\">// 配置 websocket 路径，默认是 /stomp</span>\n    .handler(StompServerHandler.create(vertx));\n\nFuture&lt;HttpServer&gt; http = vertx.createHttpServer(\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerOptions</span>().setWebSocketSubProtocols(Arrays.asList(<span class=\"hljs-string\">&quot;v10.stomp&quot;</span>, <span class=\"hljs-string\">&quot;v11.stomp&quot;</span>))\n)\n    .webSocketHandler(server.webSocketHandler())\n    .listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>不要忘了声明要支持的子协议， 否则连接会被拒绝。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下示例代码来自  <a href=\"http://jmesnil.net/stomp-websocket/doc/\">the StompJS documentation</a> ，展示了 STOMP 客户端如何连接\n到服务器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-string\">&quot;ws://localhost:8080/stomp&quot;</span>;\n<span class=\"hljs-keyword\">var</span> client = <span class=\"hljs-title class_\">Stomp</span>.<span class=\"hljs-title function_\">client</span>(url);\n<span class=\"hljs-keyword\">var</span> callback = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">frame</span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(frame);\n};\n\nclient.<span class=\"hljs-title function_\">connect</span>({}, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-keyword\">var</span> subscription = client.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-string\">&quot;foo&quot;</span>, callback);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_registering_received_and_writing_frame_handlers\"><a class=\"anchor\" href=\"#_registering_received_and_writing_frame_handlers\"></a>注册接收消息处理器和写入消息处理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>STOMP 客户端， 客户端连接和服务端都支持注册一个接收\n<code><a href=\"../../apidocs/io/vertx/ext/stomp/Frame.html\">Frame</a></code> 的处理器，该处理器会在每次接收到消息时被调用。 您可以通过\n它去打印数据包的日志或实现其他自定义的行为。 该处理器也会在接收 <code>PING</code>\n消息, 和其他 <em>非法 / 未知</em> 类型消息时被调用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx).receivedFrameHandler(sf -&gt; {\n      System.out.println(sf.frame());\n    }))\n    .listen();\n\n<span class=\"hljs-type\">StompClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> StompClient.create(vertx).receivedFrameHandler(frame -&gt; System.out.println(frame));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>该处理器是在消息体被处理前调用的，因此可以使用它来 <em>修改</em> 消息体内容</p>\n</div>\n<div class=\"paragraph\">\n<p>使用了不合法的指令的消息会被当做 <code>UNKNOWN</code> 指令类型来处理。 原本的指令值会被写入\n首部，其字段为 <code><a href=\"../../apidocs/io/vertx/ext/stomp/Frame.html#STOMP_FRAME_COMMAND\">Frame.STOMP_FRAME_COMMAND</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>您也可以设置一个处理器，该处理器会在数据包被发送前调用 (写入到网络前):</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;StompServer&gt; server = StompServer.create(vertx)\n    .handler(StompServerHandler.create(vertx))\n    .writingFrameHandler(sf -&gt; {\n      System.out.println(sf.frame());\n    })\n    .listen();\n\n<span class=\"hljs-type\">StompClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> StompClient.create(vertx).writingFrameHandler(frame -&gt; {\n  System.out.println(frame);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.2.2"},"__N_SSG":true}