{"pageProps":{"slug":"4.0.3/vertx-mail-client/java","title":"Vert.x Mail client (SMTP client implementation)","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_creating_a_client\">创建客户端</a></li>\n<li><a href=\"#_sending_mails\">发送邮件</a></li>\n<li><a href=\"#_dkim_signature_signing_emails\">DKIM 邮件电子签名</a></li>\n<li><a href=\"#_caching_the_attachment_streams_used_in_dkim\">在DKIM中缓存附件数据流</a></li>\n<li><a href=\"#_mail_client_data_objects\">Mail-client 数据对象</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_mailmessage_properties\">MailMessage 属性</a></li>\n<li><a href=\"#_mailattachment_properties\">邮件附件属性</a></li>\n<li><a href=\"#_mailconfig_options\">MailConfig 选项</a></li>\n<li><a href=\"#_mailresult_object\">MailResult对象</a></li>\n<li><a href=\"#_dkimsignoptions_object\">DKIMSignOptions对象</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Mail client (SMTP client implementation)</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x邮件客户端通过本地邮件服务器（例如： postfix）或者外部邮件服务器\n（例如： googlemail或aol）发送邮件。</p>\n</div>\n<div class=\"paragraph\">\n<p>该客户端支持一些额外的验证方法，例如DIGEST-MD5。\n该客户端完全支持TLS和SSL。该客户端是全异步的。\n该客户端支持使用连接池复用连接。</p>\n</div>\n<div class=\"paragraph\">\n<p>要使用这个项目，请加入以下依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mail-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-mail-client:4.0.3&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_client\"><a class=\"anchor\" href=\"#_creating_a_client\"></a>创建客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可在本地JVM上创建一个客户端来打开SMTP连接发送邮件。</p>\n</div>\n<div class=\"paragraph\">\n<p>该客户端使用配置对象，默认会创建空的配置对象，\n这种情况下客户端将会连接到localhost的25端口。\n在运行着Postfix或类似的邮件服务器的标准Linux环境下，本机的25端口是可用的。\n有关配置对象的全部可选属性，请参见下文。</p>\n</div>\n<div class=\"paragraph\">\n<p>该客户端可以使用SMTP连接池来避免因TLS协商、\n登陆产生的时间开销（这个功能可以通过设置keepAlive = false来关闭）。\n客户端可以被设置成共享或非共享的，\n如果设置为共享，则所有标识符相同的客户端都会使用同一个连接池。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MailConfig</span> <span class=\"hljs-variable\">config</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MailConfig</span>();\n<span class=\"hljs-type\">MailClient</span> <span class=\"hljs-variable\">mailClient</span> <span class=\"hljs-operator\">=</span> MailClient\n  .createShared(vertx, config, <span class=\"hljs-string\">&quot;exampleclient&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>MailClient.createShared的第一次调用将会实际创建一个指定配置的连接池。\n后续调用将返回一个使用相同连接池的新客户端实例，因此后指定的配置将不会被使用。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果省略连接池标识符，将会创建默认标识符的连接池。\n注意，客户端仅共享在vertx实例作用域内（因此，\n两个不同的vertx实例将会有相同标识名但实例对象不相同的连接池）。</p>\n</div>\n<div class=\"paragraph\">\n<p>创建非共享客户端的方法相同，不需要指定连接池标识符。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MailConfig</span> <span class=\"hljs-variable\">config</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MailConfig</span>();\n<span class=\"hljs-type\">MailClient</span> <span class=\"hljs-variable\">mailClient</span> <span class=\"hljs-operator\">=</span> MailClient.create(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过TLS登陆的邮件服务器示例</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MailConfig</span> <span class=\"hljs-variable\">config</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MailConfig</span>();\nconfig.setHostname(<span class=\"hljs-string\">&quot;mail.example.com&quot;</span>);\nconfig.setPort(<span class=\"hljs-number\">587</span>);\nconfig.setStarttls(StartTLSOptions.REQUIRED);\nconfig.setUsername(<span class=\"hljs-string\">&quot;user&quot;</span>);\nconfig.setPassword(<span class=\"hljs-string\">&quot;password&quot;</span>);\n<span class=\"hljs-type\">MailClient</span> <span class=\"hljs-variable\">mailClient</span> <span class=\"hljs-operator\">=</span> MailClient.create(vertx, config);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sending_mails\"><a class=\"anchor\" href=\"#_sending_mails\"></a>发送邮件</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>一旦客户端创建好了，就可以用它来发送邮件。\n因为在vert.x中邮件发送是异步的，\n所以当邮件发送操作完成后才会调用结果处理程序。\n多个邮件发送操作可以并发，连接池将会限制并发数，\n如果没有可用连接那么新的操作将会在队列中等待。</p>\n</div>\n<div class=\"paragraph\">\n<p>邮件消息被构建成JSON。 MailMessage对象有\nfrom、to、cc、bcc、subject、text、html等属性。\n依据具体的值，生成的MIME消息将会有所不同。\n收件人地址可以是单个地址或地址列表。</p>\n</div>\n<div class=\"paragraph\">\n<p>MIME编码器支持 us-ascii (7bit) headers/messages 和\nutf8 (usually quoted-printable) headers/messages</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MailMessage</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MailMessage</span>();\nmessage.setFrom(<span class=\"hljs-string\">&quot;user@example.com (Example User)&quot;</span>);\nmessage.setTo(<span class=\"hljs-string\">&quot;recipient@example.org&quot;</span>);\nmessage.setCc(<span class=\"hljs-string\">&quot;Another User &lt;another@example.net&gt;&quot;</span>);\nmessage.setText(<span class=\"hljs-string\">&quot;this is the plain message text&quot;</span>);\nmessage.setHtml(<span class=\"hljs-string\">&quot;this is html text &lt;a href=\\&quot;http://vertx.io\\&quot;&gt;vertx.io&lt;/a&gt;&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>MailAttachment对象可以使用数据存储缓冲区来创建附件，\n支持base64附件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MailAttachment</span> <span class=\"hljs-variable\">attachment</span> <span class=\"hljs-operator\">=</span> MailAttachment.create();\nattachment.setContentType(<span class=\"hljs-string\">&quot;text/plain&quot;</span>);\nattachment.setData(Buffer.buffer(<span class=\"hljs-string\">&quot;attachment file&quot;</span>));\n\nmessage.setAttachment(attachment);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当使用到内联附件（通常是图像），\nhtml消息中可以引用邮件中包含的图像来展示html。\nhtml文本中图像可以被引用为&lt;img src=\"cid:contentid@domain\"&gt;，相应的图像具有特征：\n内联并且Message-ID头是\"&lt;contentid@domain&gt;\"。\n请注意，RFC 2392需要Content-ID值的结构是Message-ID带有尖括号并且local和domain部分已经使用URL兼容编码编码过。\n这些都不是强制的，大多数邮件客户端支持没有尖括号或者没有domain部分，最好是使用严格的格式标准。\n正确的Content-ID值示例是\"&lt;<a href=\"mailto:filename%201.jpg@example.org\">filename%201.jpg@example.org</a>&gt;\"</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">MailAttachment</span> <span class=\"hljs-variable\">attachment</span> <span class=\"hljs-operator\">=</span> MailAttachment.create();\nattachment.setContentType(<span class=\"hljs-string\">&quot;image/jpeg&quot;</span>);\nattachment.setData(Buffer.buffer(<span class=\"hljs-string\">&quot;image data&quot;</span>));\nattachment.setDisposition(<span class=\"hljs-string\">&quot;inline&quot;</span>);\nattachment.setContentId(<span class=\"hljs-string\">&quot;&lt;image1@example.com&gt;&quot;</span>);\n\nmessage.setInlineAttachment(attachment);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>发送邮件时，您可提供 AsyncResult&lt;MailResult&gt; 回调函数，\n它会在发送操作完成或者失败时被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p>按如下方式发送邮件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mailClient.sendMail(message)\n  .onSuccess(System.out::println)\n  .onFailure(Throwable::printStackTrace);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_dkim_signature_signing_emails\"><a class=\"anchor\" href=\"#_dkim_signature_signing_emails\"></a>DKIM 邮件电子签名</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>支持 <a href=\"http://dkim.org\">DomainKeys Identified Mail (DKIM)</a> 电子签名保护您的邮件。\n您需要做的就是指定所需配置来签名您的邮件。</p>\n</div>\n<div class=\"paragraph\">\n<p>邮件客户端启用DKIM功能可以按如下方式创建：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">DKIMSignOptions</span> <span class=\"hljs-variable\">dkimSignOptions</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DKIMSignOptions</span>();\ndkimSignOptions.setPrivateKey(<span class=\"hljs-string\">&quot;PKCS8 Private Key Base64 String&quot;</span>);\ndkimSignOptions.setAuid(<span class=\"hljs-string\">&quot;identifier@example.com&quot;</span>);\ndkimSignOptions.setSelector(<span class=\"hljs-string\">&quot;selector&quot;</span>);\ndkimSignOptions.setSdid(<span class=\"hljs-string\">&quot;example.com&quot;</span>);\n<span class=\"hljs-type\">MailConfig</span> <span class=\"hljs-variable\">config</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MailConfig</span>()\n  .setDKIMSignOption(dkimSignOptions)\n  .setEnableDKIM(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-type\">MailClient</span> <span class=\"hljs-variable\">mailClient</span> <span class=\"hljs-operator\">=</span> MailClient.createShared(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦邮件客户端被创建，每次调用 <code>mailClient.sendMail</code> 都会添加额外的\n<code>DKIM-Signature</code> 头对电子邮件进行签名。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_caching_the_attachment_streams_used_in_dkim\"><a class=\"anchor\" href=\"#_caching_the_attachment_streams_used_in_dkim\"></a>在DKIM中缓存附件数据流</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了能够进行DKIM签名，需要计算电子邮件包含附件在内的正文hash。\n如果附件来自读流，它将无法被二次读取。所以我们需要缓存数据。\n该客户端提供了两种缓存策略。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>缓存在内存中</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，数据流被缓存在内存中以便随后发送。</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>缓存在临时文件中</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>您可通过设置系统变量将附件数据流中的数据缓存到临时文件中：\n<code>vertx.mail.attachment.cache.file</code> 设为 <code>true</code> 用于处理大体积附件。\n附件被发送之后将会删除临时文件。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_mail_client_data_objects\"><a class=\"anchor\" href=\"#_mail_client_data_objects\"></a>Mail-client 数据对象</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_mailmessage_properties\"><a class=\"anchor\" href=\"#_mailmessage_properties\"></a>MailMessage 属性</h3>\n<div class=\"paragraph\">\n<p>Email\n字段是带真实名称或不带真实名称的通用电子邮件地址格式</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>username@example.com</code></p>\n</li>\n<li>\n<p><code>username@example.com (Firstname Lastname)</code></p>\n</li>\n<li>\n<p><code>Firstname Lastname &lt;<a href=\"mailto:username@example.com\">username@example.com</a>&gt;</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>MailMessage对象有如下属性</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>from</code> String 类型，表示发件人地址和MAIL FROM字段</p>\n</li>\n<li>\n<p><code>to</code> String 或 String 列表类型，表示单个收件人地址和RCPT TO字段</p>\n</li>\n<li>\n<p><code>cc</code> 同to</p>\n</li>\n<li>\n<p><code>bcc</code> 同to</p>\n</li>\n<li>\n<p><code>bounceAddress</code> String类型，表示错误地址（MAIL FROM），如果未设置则使用from字段值</p>\n</li>\n<li>\n<p><code>text</code> String类型，表示邮件的text/plain部分</p>\n</li>\n<li>\n<p><code>html</code> String类型，表示邮件的text/html部分</p>\n</li>\n<li>\n<p><code>attachment</code> 表示消息的单个或多个附件</p>\n</li>\n<li>\n<p><code>inlineAttachment</code> 表示单个或多个内联附件（通常是图像）</p>\n</li>\n<li>\n<p><code>headers</code> MultiMap类型，表示除MIME消息所必要的消息头之外需额外添加的消息头</p>\n</li>\n<li>\n<p><code>fixedHeaders</code> boolean类型，如果值为true，则只有headers字段的值才会作为消息的消息头</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>最后两个属性允许操作自定义的消息头，\n例如。提供调用程序选择的消息id或者设置不同于默认情况下生成的头。除非您知道自己在做什么，\n否则可能会生成无效消息。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mailattachment_properties\"><a class=\"anchor\" href=\"#_mailattachment_properties\"></a>邮件附件属性</h3>\n<div class=\"paragraph\">\n<p>邮件附件对象由如下属性</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>data</code> 缓冲区，包含附件的二进制数据</p>\n</li>\n<li>\n<p><code>stream</code> ReadStream，表示附件二进制数据的源</p>\n</li>\n<li>\n<p><code>size</code> int类型，当 <code>stream</code> 作为二进制数据的源时，描述附件大小</p>\n</li>\n<li>\n<p><code>contentType</code> String类型，表示附件的内容类型（例如：text/plain或text/plain;charset=\"UTF8\"，默认为application/octet-stream）</p>\n</li>\n<li>\n<p><code>description</code> String类型，表示附件的描述信息（放置在附件的描述头部分），可选</p>\n</li>\n<li>\n<p><code>disposition</code> String类型，表示附件的部署类型（可以是“inline”或“attachment”，默认为attachment）</p>\n</li>\n<li>\n<p><code>name</code> String类型，表示附件的文件名（它被放入附件的disposition和Content-Type头中），可选</p>\n</li>\n<li>\n<p><code>contentId</code> String类型，表示附件的Content-Id（用于标识内联图像），可选</p>\n</li>\n<li>\n<p><code>headers</code> MultiMap类型，除了默认头之外的附加头，可选</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mailconfig_options\"><a class=\"anchor\" href=\"#_mailconfig_options\"></a>MailConfig 选项</h3>\n<div class=\"paragraph\">\n<p>该配置具有如下属性</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>hostname</code> 连接smtp服务器的主机名（默认是localhost）</p>\n</li>\n<li>\n<p><code>port</code> 连接smtp服务器的端口（默认是25）</p>\n</li>\n<li>\n<p><code>startTLS</code> StartTLSOptions可选DISABLED，OPTIONAL或者REQUIRED，默认是OPTIONAL</p>\n</li>\n<li>\n<p><code>login</code> LoginOption可选DISABLED，NONE或者REQUIRED，默认是NONE</p>\n</li>\n<li>\n<p><code>username</code> 用于登陆的用户名（当LoginOption是REQUIRED时为必须）</p>\n</li>\n<li>\n<p><code>password</code> 用于登陆的密码（当LoginOption是REQUIRED时为必须）</p>\n</li>\n<li>\n<p><code>ssl</code> 连接邮件服务器是否使用ssl（默认是false），设置为true则使用465端口建立ssl连接（默认是false）</p>\n</li>\n<li>\n<p><code>ehloHostname</code> 在EHLO中使用，用于创建message-id，如果未设置，将使用自己的主机名，如果主机名不是FQDN或者主机名是localhost则不推荐使用（可选的）</p>\n</li>\n<li>\n<p><code>authMethods</code> 用空格分割的允许认证方法列表，可以用来禁止一些认证方法或定义一个必需的认证方法（可选的）</p>\n</li>\n<li>\n<p><code>keepAlive</code> 是否启用连接池（默认是true）</p>\n</li>\n<li>\n<p><code>maxPoolSize</code> 连接池中能保留的连接数的最大值（启用连接池）或者可以同时打开的最大连接数（不启用连接池），默认是10</p>\n</li>\n<li>\n<p><code>trustAll</code> 是否接受服务端的所有证书（默认是false）</p>\n</li>\n<li>\n<p><code>keyStore</code> 密钥文件的文件名，可用于信任自定义生成的服务器证书（可选的）</p>\n</li>\n<li>\n<p><code>keyStorePassword</code> 用于解密密钥库（可选的）</p>\n</li>\n<li>\n<p><code>allowRcptErrors</code> 如果为true，允许收件人列表中的地址发送撕逼爱，但至少有一个发送成功（默认是false）</p>\n</li>\n<li>\n<p><code>disableEsmtp</code> 如果为true，ESMTP-related命令将不会被调用（如果您的smtp服务器甚至没有为EHLO命令提供正确的错误响应代码，则设置此选项）（默认是false）</p>\n</li>\n<li>\n<p><code>userAgent</code> 表示邮件用户代理（MUA）名称用来生成multipart邮件和message-id的边界，默认是 <code>vertxmail</code></p>\n</li>\n<li>\n<p><code>enableDKIM</code> 如果为true，则在DKIM配置设置好了的情况下DKIM签名将会启用，默认是 <code>false</code></p>\n</li>\n<li>\n<p><code>dkimSignOptions</code> <code>DKIMSignOptions</code> 列表用于执行DKIM签名</p>\n</li>\n<li>\n<p><code>pipelining</code> 如果邮件服务端允许，则开启管道。默认是 <code>true</code></p>\n</li>\n<li>\n<p><code>multiPartOnly</code> 布尔类型，指代该编码的邮件消息是否是仅由多部分（multipart）消息组成。默认为 <code>false</code></p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mailresult_object\"><a class=\"anchor\" href=\"#_mailresult_object\"></a>MailResult对象</h3>\n<div class=\"paragraph\">\n<p>MailResult对象有下列成员变量</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>messageID</code> 这封邮件的Message-ID</p>\n</li>\n<li>\n<p><code>recipients</code> 成功投递的收件人列表 （如果allowRcptErrors值为true，数量可能比预期收件人少）</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_dkimsignoptions_object\"><a class=\"anchor\" href=\"#_dkimsignoptions_object\"></a>DKIMSignOptions对象</h3>\n<div class=\"paragraph\">\n<p>DKIMSignOptions有下列属性</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>privateKey</code> 按照RSA <a href=\"https://www.ietf.org/rfc/rfc5208.txt\">PKCS#8</a> 格式来格式化的用于签名的私钥。</p>\n</li>\n<li>\n<p><code>privateKeyPath</code> 按照RSA <a href=\"https://www.ietf.org/rfc/rfc5208.txt\">PKCS#8</a> 格式来格式化的私钥文件地址。<code>privateKey</code> 或者 <code>privateKeyPath</code> 二选一。</p>\n</li>\n<li>\n<p><code>signAlgo</code> <code>DKIMSignAlgorithm.RSA_SHA256</code>（default）或者 <code>DKIMSignAlgorithm.RSA_SHA1</code> 二选一。该算法用来做正文哈希或签名。</p>\n</li>\n<li>\n<p><code>signedHeaders</code> 指定将用于执行签名的电子邮件头的字符串列表。默认是： <code>From</code>、 <code>Reply-to</code>、 <code>Subject</code>、 <code>Date</code>、 <code>To</code>、 <code>Cc</code> 。 注意：顺序很重要。</p>\n</li>\n<li>\n<p><code>sdid</code> <strong>必须的</strong>，字符串，域标识符（SDID），通常是SMTP服务端的域。</p>\n</li>\n<li>\n<p><code>auid</code> 可选，字符串，代理或用户标识符（AUID），默认是 <code>@</code> 加上 <code>sdid</code> 。</p>\n</li>\n<li>\n<p><code>selector</code> <strong>必须的</strong>，字符串，用于查询公钥的选择器。</p>\n</li>\n<li>\n<p><code>headerCanonAlgo</code> 用于邮件头的规范化算法， <code>simple</code>（默认） 和 <code>relaxed</code> 其中之一。</p>\n</li>\n<li>\n<p><code>bodyCanonAlgo</code> 用于邮件正文的规范化算法， <code>simple</code>（默认） and <code>relaxed</code> 其中之一。</p>\n</li>\n<li>\n<p><code>bodyLimit</code> 可选的，整型，用于计算正文hash的正文长度上限。</p>\n</li>\n<li>\n<p><code>signatureTimestamp</code> 可选的，布尔类型，如果为true则在 <code>DKIM-SIgnature</code> 标签列表里包含时间戳。默认是false。</p>\n</li>\n<li>\n<p><code>expireTime</code> 可选的，长整型，签名在当前时间的多少秒内有效。</p>\n</li>\n<li>\n<p><code>copiedHeaders</code> 可选的，字符串列表，DKIM中使用的复制头。根据DKIM规范，它们通常用于调试。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>","version":"4.0.3"},"__N_SSG":true}