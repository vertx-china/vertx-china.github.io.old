{"pageProps":{"slug":"4.1.3/vertx-cassandra-client/java","title":"Vert.x Cassandra 客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">开始</a></li>\n<li><a href=\"#_creating_a_client\">创建客户端</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_client_options\">客户端选项</a></li>\n<li><a href=\"#_shared_clients\">共享客户端</a></li>\n<li><a href=\"#_client_lifecycle\">客户端生命周期</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_api\">使用API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_querying\">查询</a></li>\n<li><a href=\"#_collector_queries\">Collector 查询</a></li>\n<li><a href=\"#_prepared_queries\">Prepared queries</a></li>\n<li><a href=\"#_batching\">批处理</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxjava_3_api\">RxJava 3 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_an_rxfied_client\">创建Rx版客户端</a></li>\n<li><a href=\"#_querying\">查询</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Cassandra 客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 客户端可以访问 <a href=\"http://cassandra.apache.org/\">Apache Cassandra</a> 服务。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>开始</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用本模块，请在Maven的pom文件中添加如下 <em>依赖</em> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-cassandra-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>或者，如果您使用gradle：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-cassandra-client:4.1.3&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_client\"><a class=\"anchor\" href=\"#_creating_a_client\"></a>创建客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_client_options\"><a class=\"anchor\" href=\"#_client_options\"></a>客户端选项</h3>\n<div class=\"paragraph\">\n<p>Cassandra是一个分布式的系统，它可以有很多节点。\n要连接Cassandra，在创建 <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClientOptions.html\">CassandraClientOptions</a></code> 对象时， 您需要指定集群当中的一些结点的地址</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;node1.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node2.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node3.address&quot;</span>, <span class=\"hljs-number\">9142</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> CassandraClient.create(vertx, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，Vert.x Cassandra客户端连接的是本地机器的 <code>9042</code> 端口，并且不绑定任何 keyspace。但是您可以用以下选项来同时设置 ContactPoint 和 keyspace，\n也可以设置二者之一：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .setKeyspace(<span class=\"hljs-string\">&quot;my_keyspace&quot;</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> CassandraClient.create(vertx, options);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClientOptions.html\">CassandraClientOptions</a></code> 提供了一个 <code>com.datastax.driver.core.Cluster.Builder</code> 对象用来达到调优的目的。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_shared_clients\"><a class=\"anchor\" href=\"#_shared_clients\"></a>共享客户端</h3>\n<div class=\"paragraph\">\n<p>如果您部署了多个Verticle实例，或者有多个同时和同一数据库交互的Verticle，我们建议创建一个共享的客户端：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;node1.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node2.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node3.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .setKeyspace(<span class=\"hljs-string\">&quot;my_keyspace&quot;</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> CassandraClient.createShared(vertx, <span class=\"hljs-string\">&quot;sharedClientName&quot;</span>, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>相同名称的共享客户端在底层使用的是同一个 <code>com.datastax.driver.core.Session</code> 。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_client_lifecycle\"><a class=\"anchor\" href=\"#_client_lifecycle\"></a>客户端生命周期</h3>\n<div class=\"paragraph\">\n<p>客户端创建之后，直到执行第一个查询前，该客户端不会被连接。</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n如果相同名称的客户端已经存在并已经执行了一次查询，那么新的共享客户端在被创建之后则可以连接。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>在verticle内创建的客户端会在verticle被取消部署的时候停止。\n换句话说，您不需要在vertical的 <code>stop</code> 方法中调用 <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClient.html#close--\">close</a></code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>在其他情况下，您必须手动关闭客户端。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n当一个共享客户端被关闭，如果存在同名客户端仍旧在运行，那么数据库的会话不会被关闭。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_api\"><a class=\"anchor\" href=\"#_using_the_api\"></a>使用API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>客户端API由 <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClient.html\">CassandraClient</a></code> 提供。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_querying\"><a class=\"anchor\" href=\"#_querying\"></a>查询</h3>\n<div class=\"paragraph\">\n<p>您有3种不同的方式来获取查询结果。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming\"><a class=\"anchor\" href=\"#_streaming\"></a>Streaming</h4>\n<div class=\"paragraph\">\n<p>当您需要以迭代的方式来处理查询结果（例如，您想处理结果集重的每一个元素），那么Streaming API是再合适不过了。\n特别是处理大量数据记录时，这样是非常高效的。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了给您一些使用这些API的灵感和思路，我们建议您参考如下示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.queryStream(<span class=\"hljs-string\">&quot;SELECT my_string_col FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>, queryStream -&gt; {\n  <span class=\"hljs-keyword\">if</span> (queryStream.succeeded()) {\n    <span class=\"hljs-type\">CassandraRowStream</span> <span class=\"hljs-variable\">stream</span> <span class=\"hljs-operator\">=</span> queryStream.result();\n\n    <span class=\"hljs-comment\">// 当队列准备好接收buffer的时候恢复stream</span>\n    response.drainHandler(v -&gt; stream.resume());\n\n    stream.handler(row -&gt; {\n      <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> row.getString(<span class=\"hljs-string\">&quot;my_string_col&quot;</span>);\n      response.write(value);\n\n      <span class=\"hljs-comment\">// 当buffer队列满时，暂停stream</span>\n      <span class=\"hljs-keyword\">if</span> (response.writeQueueFull()) {\n        stream.pause();\n      }\n    });\n\n    <span class=\"hljs-comment\">// 在stream末尾结束请求。</span>\n    stream.endHandler(end -&gt; response.end());\n\n  } <span class=\"hljs-keyword\">else</span> {\n    queryStream.cause().printStackTrace();\n    <span class=\"hljs-comment\">// 如果无法执行该查询，则响应服务器内部错误。</span>\n    response\n      .setStatusCode(<span class=\"hljs-number\">500</span>)\n      .end(<span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这个示例当中，我们执行查询，并通过HTTP来流式地处理查询结果。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_bulk_fetching\"><a class=\"anchor\" href=\"#_bulk_fetching\"></a>获取 Bulk</h4>\n<div class=\"paragraph\">\n<p>这个API应该在您需要同时处理所有结果行的时候来使用。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.executeWithFullFetch(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>, executeWithFullFetch -&gt; {\n  <span class=\"hljs-keyword\">if</span> (executeWithFullFetch.succeeded()) {\n    List&lt;Row&gt; rows = executeWithFullFetch.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      <span class=\"hljs-comment\">// 在此处处理每一行</span>\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>);\n    executeWithFullFetch.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n只能在内存足以容纳整个数据块时获取 bulk 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector 查询</h3>\n<div class=\"paragraph\">\n<p>您可以结合查询API来使用java Collector：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.execute(<span class=\"hljs-string\">&quot;SELECT * FROM users&quot;</span>, listCollector, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 获取collector创建的字符串。</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + list);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_low_level_fetch\"><a class=\"anchor\" href=\"#_low_level_fetch\"></a>低级别获取</h4>\n<div class=\"paragraph\">\n<p>相比于stream 和bulk fetch，这个API更加底层，并对负载提供了更强大控制。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.execute(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>, execute -&gt; {\n  <span class=\"hljs-keyword\">if</span> (execute.succeeded()) {\n    <span class=\"hljs-type\">ResultSet</span> <span class=\"hljs-variable\">resultSet</span> <span class=\"hljs-operator\">=</span> execute.result();\n\n    <span class=\"hljs-keyword\">if</span> (resultSet.remaining() != <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-type\">Row</span> <span class=\"hljs-variable\">row</span> <span class=\"hljs-operator\">=</span> resultSet.one();\n      System.out.println(<span class=\"hljs-string\">&quot;One row successfully fetched&quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!resultSet.hasMorePages()) {\n      System.out.println(<span class=\"hljs-string\">&quot;No pages to fetch&quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      resultSet.fetchNextPage().onComplete(fetchMoreResults -&gt; {\n        <span class=\"hljs-keyword\">if</span> (fetchMoreResults.succeeded()) {\n          <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">availableWithoutFetching</span> <span class=\"hljs-operator\">=</span> resultSet.remaining();\n          System.out.println(<span class=\"hljs-string\">&quot;Now we have &quot;</span> + availableWithoutFetching + <span class=\"hljs-string\">&quot; rows fetched, but not consumed!&quot;</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          System.out.println(<span class=\"hljs-string\">&quot;Unable to fetch more results&quot;</span>);\n          fetchMoreResults.cause().printStackTrace();\n        }\n      });\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>);\n    execute.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>Prepared queries</h3>\n<div class=\"paragraph\">\n<p>为了安全和高效，对于将被多次使用的查询来讲，使用prepared statement是一个比较好的做法。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以预备一个查询：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.prepare(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = ? &quot;</span>, preparedStatementResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (preparedStatementResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;The query has successfully been prepared&quot;</span>);\n    <span class=\"hljs-type\">PreparedStatement</span> <span class=\"hljs-variable\">preparedStatement</span> <span class=\"hljs-operator\">=</span> preparedStatementResult.result();\n    <span class=\"hljs-comment\">// 现在您可以用这个 PreparedStatement 来执行下一次查询。</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to prepare the query&quot;</span>);\n    preparedStatementResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后，在接下来所有的查询中使用 <a href=\"https://docs.datastax.com/en/drivers/java/${datastax.driver.minor.version}/com/datastax/driver/core/PreparedStatement.html\"><code>PreparedStatement</code></a> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.execute(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>), done -&gt; {\n  <span class=\"hljs-type\">ResultSet</span> <span class=\"hljs-variable\">results</span> <span class=\"hljs-operator\">=</span> done.result();\n  <span class=\"hljs-comment\">// 处理查询结果</span>\n});\n\n<span class=\"hljs-comment\">// Bulk fetching API</span>\ncassandraClient.executeWithFullFetch(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>), done -&gt; {\n  List&lt;Row&gt; results = done.result();\n  <span class=\"hljs-comment\">// 处理查询结果</span>\n});\n\n<span class=\"hljs-comment\">// Streaming API</span>\ncassandraClient.queryStream(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>), done -&gt; {\n  <span class=\"hljs-type\">CassandraRowStream</span> <span class=\"hljs-variable\">results</span> <span class=\"hljs-operator\">=</span> done.result();\n  <span class=\"hljs-comment\">// 处理查询结果</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batching\"><a class=\"anchor\" href=\"#_batching\"></a>批处理</h3>\n<div class=\"paragraph\">\n<p>考虑到您可能一次执行多个查询，您可以用 <a href=\"https://docs.datastax.com/en/drivers/java/${datastax.driver.minor.version}/com/datastax/driver/core/BatchStatement.html\"><code>BatchStatement</code></a> 达到批处理效果：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">BatchStatement</span> <span class=\"hljs-variable\">batchStatement</span> <span class=\"hljs-operator\">=</span> BatchStatement.newInstance(BatchType.LOGGED)\n  .add(SimpleStatement.newInstance(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Pavel&#x27;)&quot;</span>))\n  .add(SimpleStatement.newInstance(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Thomas&#x27;)&quot;</span>))\n  .add(SimpleStatement.newInstance(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Julien&#x27;)&quot;</span>));\n\ncassandraClient.execute(batchStatement, result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;The given batch executed successfully&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to execute the batch&quot;</span>);\n    result.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_3_api\"><a class=\"anchor\" href=\"#_rxjava_3_api\"></a>RxJava 3 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Cassandra 客户端为原来的API提供了一个Rx版本。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_an_rxfied_client\"><a class=\"anchor\" href=\"#_creating_an_rxfied_client\"></a>创建Rx版客户端</h3>\n<div class=\"paragraph\">\n<p>想要创建Rx版 Cassandra 客户端，您需要引入 <code><a href=\"../../apidocs/io/vertx/rxjava3/cassandra/CassandraClient.html\">CassandraClient</a></code> 类。\n然后用 <code>create</code> 方法获取一个实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;node1.corp.int&quot;</span>, <span class=\"hljs-number\">7000</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node2.corp.int&quot;</span>, <span class=\"hljs-number\">7000</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node3.corp.int&quot;</span>, <span class=\"hljs-number\">7000</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">cassandraClient</span> <span class=\"hljs-operator\">=</span> CassandraClient.createShared(vertx, options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_querying\"><a class=\"anchor\" href=\"#_querying\"></a>查询</h3>\n<div class=\"paragraph\">\n<p>在本节，我们会回顾之前的一些 Rx-API 用例。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_2\"><a class=\"anchor\" href=\"#_streaming_2\"></a>Streaming</h4>\n<div class=\"paragraph\">\n<p>一个 <code><a href=\"../../apidocs/io/vertx/rxjava3/cassandra/CassandraRowStream.html\">CassandraRowStream</a></code> 可以转换成 <code><a href=\"../../apidocs/io/reactivex/rxjava3/core/Flowable.html\">Flowable</a></code> ，这样会方便您处理大容量数据集合:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.rxQueryStream(<span class=\"hljs-string\">&quot;SELECT my_key FROM my_keyspace.my_table where my_key = my_value&quot;</span>)\n  <span class=\"hljs-comment\">// 将stream转换成Flowable</span>\n  .flatMapPublisher(CassandraRowStream::toFlowable)\n  .subscribe(row -&gt; {\n    <span class=\"hljs-comment\">// 处理单行</span>\n  }, t -&gt; {\n    <span class=\"hljs-comment\">// 处理失败</span>\n  }, () -&gt; {\n    <span class=\"hljs-comment\">// stream 末尾</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_bulk_fetching\"><a class=\"anchor\" href=\"#_bulk_fetching\"></a>获取 Bulk</h4>\n<div class=\"paragraph\">\n<p>当您的结果集数据量很少，您可以一次性获取所有结果；</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.rxExecuteWithFullFetch(<span class=\"hljs-string\">&quot;SELECT my_key FROM my_keyspace.my_table where my_key = my_value&quot;</span>)\n  .subscribe(rows -&gt; {\n    <span class=\"hljs-comment\">// 处理结果集</span>\n  }, throwable -&gt; {\n    <span class=\"hljs-comment\">// 处理失败</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.1.3"},"__N_SSG":true}