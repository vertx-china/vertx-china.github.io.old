{"pageProps":{"categories":["releases","guides","security","news"],"post":{"meta":{"title":"Scala is here","category":"guides","authors":[{"name":"Jochen Mader","github_id":"codepitbull"}],"summary":"The rise of Scala as one of the most important languages on the JVM caught many (me included) by surprise. This hybrid of functional and imperative paradigms struck a chord with many developers."},"date":"2017-03-20","slug":"scala-is-here","readingTime":{"text":"8 min read","minutes":7.065,"time":423900,"words":1413},"content":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      strong: \"strong\",\n      ul: \"ul\",\n      li: \"li\",\n      a: \"a\",\n      h2: \"h2\",\n      em: \"em\",\n      pre: \"pre\",\n      code: \"code\",\n      span: \"span\",\n      ol: \"ol\"\n    }, props.components), {Alert, Link} = _components;\n    if (!Alert) _missingMdxReference(\"Alert\", true);\n    if (!Link) _missingMdxReference(\"Link\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"TL;DR:\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Scala sup­port for Vert.x is here!\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"It is based on Scala 2.12, no sup­port for 2.11 planned\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"all Vert.x-​modules are avail­able in a Scala fla­vor\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"It’s awe­some\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Get started \", _jsx(_components.a, {\n            href: \"https://github.com/vert-x3/vertx-sbt-starter\",\n            children: \"here\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"intro\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#intro\"\n        }), \"Intro\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The rise of \", _jsx(_components.a, {\n          href: \"http://scala-lang.org/\",\n          children: \"Scala\"\n        }), \" as one of the most im­por­tant lan­guages on the JVM caught many (me in­cluded) by sur­prise. This hy­brid of func­tional and im­per­a­tive par­a­digms struck a chord with many de­vel­op­ers. Thanks to Scala a lot of peo­ple who’d never have touched a lan­guage like Haskell got ex­posed to func­tional pro­gram­ming. This ex­po­sure was one of the dri­ving forces to get streams and lambda into the JVM.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"With the re­lease of Vert.x 3.4.0 we fi­nally in­tro­duced Scala to the fam­ily of sup­ported lan­guages: \", _jsx(_components.a, {\n          href: \"https://github.com/vert-x3/vertx-lang-scala\",\n          children: \"vertx-​lang-scala\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In this post I will in­tro­duce the new stack and how the power of Scala can be used in your fa­vorite re­ac­tive toolkit.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"basics\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#basics\"\n        }), \"Basics\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"vertx-​lang-scala is based on Scala 2.12. There are no plans to sup­port 2.11.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"All mod­ules avail­able for Vert.x are sup­ported (you can check  \", _jsx(_components.a, {\n          href: \"https://github.com/vert-x3/vertx-lang-scala/tree/master/vertx-lang-scala-stack\",\n          children: \"here\"\n        }), \" ).\"]\n      }), \"\\n\", _jsx(Alert, {\n        info: true,\n        title: \"Future and Promise both need a ExecutionContext\",\n        children: _jsxs(_components.p, {\n          children: [\"Mod­ules use the fol­low­ing naming-​scheme: \", _jsx(_components.em, {\n            children: \"io.vertx:<name-​of-vertx-module>-​scala_2.12:<vertx-​major-version>\"\n          }), \". The Scala ver­sion of \", _jsx(_components.em, {\n            children: \"io.vertx:vert-​web:3.4.0\"\n          }), \" would be \", _jsx(_components.em, {\n            children: \"io.vertx:vertx-​web-scala_2.12:3.4.0\"\n          }), \".\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"There is an sbt-​based \", _jsx(_components.a, {\n          href: \"https://github.com/vert-x3/vertx-sbt-starter\",\n          children: \"quickstart-​project\"\n        }), \" avail­able that will be up­dated for each Vert.x-​release.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Please note: Al­though \", _jsx(_components.a, {\n          href: \"http://www.scala-sbt.org/\",\n          children: \"sbt\"\n        }), \" is used in this quick­start it is by no means re­quired. There are no spe­cial plu­g­ins in­volved so vertx-​lang-scala can eas­ily be used with \", _jsx(_components.a, {\n          href: \"https://docs.gradle.org/current/userguide/scala_plugin.html\",\n          children: \"Gra­dle\"\n        }), \" or \", _jsx(_components.a, {\n          href: \"https://github.com/davidB/scala-maven-plugin\",\n          children: \"Maven\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I use sbt as it is the de­fault build sys­tem used for Scala projects.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"quickstart\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#quickstart\"\n        }), \"Quickstart\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Let’s get started by cloning the quick­start:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-bash\",\n          children: [\"git \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"clone\"\n          }), \" git@github.com:vert-x3/vertx-sbt-starter.git\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"You just got the fol­low­ing things:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"An sbt project con­tain­ing de­pen­den­cies to Vert.x-​core and Vert.x-web\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The abil­ity to cre­ate a fat-​jat via \", _jsx(_components.code, {\n            children: \"sbt assembly\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The abil­ity to cre­ate a docker con­tainer via \", _jsx(_components.code, {\n            children: \"sbt docker\"\n          })]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"A few ex­am­ple ver­ti­cles\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Unit test ex­am­ples\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"a pre-​configured Scala-​shell in­side sbt\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We will now run the ap­pli­ca­tion to get some quick sat­is­fac­tion. Use \", _jsx(_components.code, {\n          children: \"sbt assembly\"\n        }), \" to pro­duce the fat-​jar fol­lowed by \", _jsx(_components.code, {\n          children: \"java -jar target/scala-2.12/vertx-scala-sbt-assembly-0.1-SNAPSHOT.jar\"\n        }), \". Now point your browser to \", _jsx(_components.a, {\n          href: \"http://localhost:8666/hello\",\n          children: \"http://lo­cal­host:8666/hello\"\n        }), \" for a clas­sic wel­come mes­sage.\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"the-details\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#the-details\"\n        }), \"The details\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Open your IDE so we can take a look at what’s going on under the hood. We start with the \", _jsx(_components.em, {\n          children: \"HttpVer­ti­cle\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-scala\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"package\"\n          }), \" io.vertx.scala.sbt\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"import\"\n          }), \" io.vertx.lang.scala.\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"ScalaVerticle\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"import\"\n          }), \" io.vertx.scala.ext.web.\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Router\"\n          }), \"\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"import\"\n          }), \" scala.concurrent.\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Future\"\n          }), \"\\n\\n\", _jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"class\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"HttpVerticle\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"extends\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"ScalaVerticle\"\n            }), \" \"]\n          }), \"{ \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <1>\"\n          }), \"\\n\\n\\n  \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"override\"\n          }), \" \", _jsxs(_components.span, {\n            className: \"hljs-function\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"def\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"startFuture\"\n            })]\n          }), \"(): \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Future\"\n          }), \"[\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Unit\"\n          }), \"] = { \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <2>\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"val\"\n          }), \" router = \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Router\"\n          }), \".router(vertx) \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <3>\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"val\"\n          }), \" route = router\\n      .get(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/hello\\\"\"\n          }), \")\\n        .handler(_.response().end(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"world\\\"\"\n          }), \"))\\n\\n    vertx \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"//<4>\"\n          }), \"\\n      .createHttpServer()\\n      .requestHandler(router.accept)\\n      .listenFuture(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"8666\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"0.0.0.0\\\"\"\n          }), \")  \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <5>\"\n          }), \"\\n        .map(_ => ()) \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <6>\"\n          }), \"\\n  }\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.em, {\n            children: \"ScalaVer­ti­cle\"\n          }), \" is the base class for all Scala-​Verticles. It pro­vides all re­quired meth­ods to in­te­grate with the Vert.x-​runtime.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"There are two ways to start a Ver­ti­cle. Over­rid­ing \", _jsx(_components.em, {\n            children: \"start­Fu­ture\"\n          }), \", like in this ex­am­ple, tells Vert.x to only con­sider the Ver­ti­cle fully started after the re­turned \", _jsx(_components.em, {\n            children: \"Fu­ture[Unit]\"\n          }), \" has been suc­cess­fully com­pleted. Al­ter­na­tively one can over­ride \", _jsx(_components.em, {\n            children: \"start\"\n          }), \" and by that sig­nal to Vert.x the in­stant avail­abil­ity of the Ver­ti­cle.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"This block cre­ates a \", _jsx(_components.em, {\n            children: \"Router\"\n          }), \" for in­com­ing HTTP-​requests. It reg­is­ters a han­dler to an­swer with “world” if a re­quest to the URL “/hello” ar­rives. The class is com­ing from the \", _jsx(Link, {\n            href: \"/docs/vertx-web/scala/\",\n            passHref: true,\n            children: _jsx(_components.a, {\n              href: \"\",\n              children: \"Vert.x-​web-module\"\n            })\n          }), \".\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Every Ver­ti­cle has ac­cess to the Vert.x-​instance. Here we use it to cre­ate a web­server and reg­is­ter our router to han­dle in­com­ing re­quests.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"We fi­nally reached the rea­son why I use \", _jsx(_components.em, {\n            children: \"start­Fu­ture\"\n          }), \" in the first place. All op­er­a­tions in Vert.x are asyn­chro­nous. So start­ing the web­server most def­i­nitely means it takes some more time until it bound to the given port (8666 in this case). That’s why \", _jsx(_components.em, {\n            children: \"lis­ten­Fu­ture\"\n          }), \" is used, which re­turns a \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" which in turn con­tains the ac­tual in­stance of the web­server that just got started. So our Ver­ti­cle will be ready to re­ceive re­quests \", _jsx(_components.em, {\n            children: \"after\"\n          }), \" the re­turned \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" has been com­pleted.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"In most cases we can re­turn the \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" di­rectly. In this case the \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" re­turned by \", _jsx(_components.em, {\n            children: \"lis­ten­Fu­ture\"\n          }), \" has the wrong type. We get a \", _jsx(_components.em, {\n            children: \"Fu­ture[HttpServer]\"\n          }), \" but we need a \", _jsx(_components.em, {\n            children: \"Fu­ture[Unit]\"\n          }), \" as you can see in the sig­na­ture of \", _jsx(_components.em, {\n            children: \"start­Fu­ture\"\n          }), \". This call takes care of map­ping the given \", _jsx(_components.em, {\n            children: \"Fu­ture[HttpServer]\"\n          }), \" to the re­quired re­turn type.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"testing\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#testing\"\n        }), \"Testing\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I use \", _jsx(_components.a, {\n          href: \"http://www.scalatest.org/\",\n          children: \"Sca­laT­est\"\n        }), \" for all my test­ing needs. It comes with stel­lar sup­port for asyn­chro­nous op­er­a­tions and is a per­fect fit for test­ing Vert.x-​applications.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The fol­low­ing \", _jsx(_components.em, {\n          children: \"HttpVer­ti­cle­Spec\"\n        }), \" shows how to test an HTTP-​API using only Vert.x-​classes. Per­son­ally I pre­fer \", _jsx(_components.a, {\n          href: \"http://rest-assured.io/\",\n          children: \"REST-​assured\"\n        }), \" with its rich DSL. For this post I wanted to stick with Vert.x-API, so here we go.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-scala\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"package\"\n          }), \" io.vertx.scala.sbt\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"import\"\n          }), \" org.scalatest.\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Matchers\"\n          }), \"\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"import\"\n          }), \" scala.concurrent.\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Promise\"\n          }), \"\\n\\n\", _jsxs(_components.span, {\n            className: \"hljs-class\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"class\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"HttpVerticleSpec\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"extends\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"VerticleTesting\"\n            }), \"[\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"HttpVerticle\"\n            }), \"] \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"with\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-title\",\n              children: \"Matchers\"\n            }), \" \"]\n          }), \"{ \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <1>\"\n          }), \"\\n\\n  \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"HttpVerticle\\\"\"\n          }), \" should \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"bind to 8666 and answer with 'world'\\\"\"\n          }), \" in { \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <2>\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"val\"\n          }), \" promise = \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Promise\"\n          }), \"[\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"String\"\n          }), \"] \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <3>\"\n          }), \"\\n\\n    vertx.createHttpClient()  \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <4>\"\n          }), \"\\n      .getNow(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"8666\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"127.0.0.1\\\"\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"/hello\\\"\"\n          }), \",\\n        r => {\\n          r.exceptionHandler(promise.failure)\\n          r.bodyHandler(b => promise.success(b.toString))\\n        })\\n\\n    promise.future.map(res => res should equal(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"world\\\"\"\n          }), \")) \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <5>\"\n          }), \"\\n  }\\n\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.em, {\n            children: \"Ver­ti­cleTest­ing\"\n          }), \" is a base class for your tests in­cluded with the quickstart-​project. It’s a small helper that takes care of de­ploy­ing/un-​deploying the Ver­ti­cle to be tested and man­ages a Vert.x-​instance. It ad­di­tion­ally ex­tends \", _jsx(_components.a, {\n            href: \"http://www.scalatest.org/user_guide/async_testing\",\n            children: \"AsyncFlat­Spec\"\n          }), \" so we can use Fu­tures as test-​return-types.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Isn’t it nice and read­able?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"The promise is re­quired as the whole test will run async\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"We use the vertx-​instance pro­vided by \", _jsx(_components.em, {\n            children: \"Ver­ti­cleTest­ing\"\n          }), \" to cre­ate a Netty-​based Http­Client. We in­struct the client to call the spec­i­fied URL and to suc­ceed the \", _jsx(_components.em, {\n            children: \"Promise\"\n          }), \" with the re­turned body.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"This cre­ates the ac­tual as­ser­tion. After get­ting the \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" from the \", _jsx(_components.em, {\n            children: \"Promise\"\n          }), \" an as­ser­tion is cre­ated: \", _jsx(_components.em, {\n            children: \"The Re­sult should be equal to the String “world”\"\n          }), \". Sca­laT­est takes care of eval­u­at­ing the re­turned \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"That’s all you need to get started!\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"futures-in-vertx-lang-scala\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#futures-in-vertx-lang-scala\"\n        }), \"Futures in vertx-lang-scala\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now for a more in depth topic I think is worth men­tion­ing. vertx-​lang-scala treats async op­er­a­tions the Scala-​way which is a lit­tle dif­fer­ent from what you might be used from Vert.x. For async op­er­a­tions like sub­scrib­ing to the event­bus or de­ploy­ing a Ver­ti­cle you would call a method like this:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-scala\",\n          children: [\"vertx.deployVerticle(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"com.foo.OtherVerticle\\\"\"\n          }), \", res -> {\\n  \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (res.succeeded()) {\\n    startFuture.complete();\\n  } \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"else\"\n          }), \" {\\n    startFuture.fail(res.cause());\\n  }\\n});\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.em, {\n          children: \"de­ployVer­ti­cle\"\n        }), \" method takes the Verticle-​name and a \", _jsx(_components.em, {\n          children: \"Han­dler[Asyn­cRe­sult]\"\n        }), \" as its ar­gu­ments. The \", _jsx(_components.em, {\n          children: \"Han­dler[Asyn­cRe­sult]\"\n        }), \" is called after Vert.x tried de­ploy­ing the Ver­ti­cle. This style can also be used for Scala (which might ease the tran­si­tion when com­ing from the Java-​world) but their is a way more \", _jsx(_components.em, {\n          children: \"scalaish\"\n        }), \" way of doing this.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"For every method tak­ing a \", _jsx(_components.em, {\n          children: \"Han­dler[Asyn­cRe­sult]\"\n        }), \" as its ar­gu­ment I cre­ate an al­ter­na­tive method using \", _jsx(_components.a, {\n          href: \"http://docs.scala-lang.org/overviews/core/futures.html\",\n          children: \"Scala-​Futures\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-scala\",\n          children: [\"vertx.deployVerticleFuture(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"com.foo.OtherVerticle\\\"\"\n          }), \") \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <1>\"\n          }), \"\\n  .onComplete{  \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <2>\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"case\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Success\"\n          }), \"(s) => println(\", _jsxs(_components.span, {\n            className: \"hljs-string\",\n            children: [\"s\\\"Verticle id is: \", _jsx(_components.span, {\n              className: \"hljs-subst\",\n              children: \"$s\"\n            }), \"\\\"\"]\n          }), \") \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// <3>\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"case\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Failure\"\n          }), \"(t) => t.printStackTrace()\\n  }\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"A method pro­vid­ing a \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" based al­ter­na­tive gets \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" ap­pended to its name and re­turns a \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" in­stead of tak­ing a \", _jsx(_components.em, {\n            children: \"Han­dler\"\n          }), \" as its ar­gu­ment.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"We are now free to use \", _jsx(_components.em, {\n            children: \"Fu­ture\"\n          }), \" the way we want. In this case on­Com­plete is used to react on the com­ple­tion.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Pat­tern match­ing on the re­sult \", _jsx(_components.em, {\n            children: \"<3\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I strongly rec­om­mend using this ap­proach over using \", _jsx(_components.em, {\n          children: \"Han­dlers\"\n        }), \" as you won’t run into Callback-​hell and you get all the good­ies Scala pro­vides for async op­er­a­tions.\"]\n      }), \"\\n\", _jsx(Alert, {\n        info: true,\n        title: \"Future and Promise both need a ExecutionContext\",\n        children: _jsxs(_components.p, {\n          children: [\"The \", _jsx(_components.a, {\n            href: \"https://github.com/vert-x3/vertx-lang-scala/blob/master/vertx-lang-scala/src/main/scala/io/vertx/lang/scala/VertxExecutionContext.scala\",\n            children: \"Vertx­Ex­e­cu­tion­Con­text\"\n          }), \" is made im­plic­itly avail­able in­side the \", _jsx(_components.a, {\n            href: \"https://github.com/vert-x3/vertx-lang-scala/blob/master/vertx-lang-scala/src/main/scala/io/vertx/lang/scala/ScalaVerticle.scala\",\n            children: \"ScalaVer­ti­cle\"\n          }), \". It makes sure all  op­er­a­tions are ex­e­cuted on the cor­rect Event Loop. If you are using Vert.x with­out Ver­ti­cles you have to pro­vide it on your own.\"]\n        })\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"using-the-console\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#using-the-console\"\n        }), \"Using the console\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"A great fea­ture of sbt is the em­bed­ded, con­fig­urable Scala-​console. The con­sole avail­able in the quickstart-​project is pre-​configured to pro­vide a fresh Vert.x-​instance and all re­quired im­ports so you can start play­ing around with Vert.x in an in­stant.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Ex­e­cute the fol­low­ing com­mands in the project-​folder to de­ploy the \", _jsx(_components.em, {\n          children: \"HttpVer­ti­cle\"\n        }), \":\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-bash\",\n          children: \"sbt\\n> console\\nscala> vertx.deployVerticle(nameForVerticle[HttpVerticle])\\nscala> vertx.deploymentIDs\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"After  ex­e­cut­ing this se­quence you can now point your browser \", _jsx(_components.a, {\n          href: \"http://localhost:8666/hello\",\n          children: \"http://lo­cal­host:8666/hello\"\n        }), \" to see our mes­sage. The last com­mand is­sued shows the Ids under which Ver­ti­cles have been de­ployed.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"To get rid of the de­ploy­ment you can now type \", _jsx(_components.code, {\n          children: \"vertx.undeploy(vertx.deploymentIDs.head)\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"thats-it\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#thats-it\"\n        }), \"That’s it!\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This was a very quick in­tro­duc­tion to our new Scala-​stack. I hope to have given you a lit­tle taste of the Scala good­ness now avail­able with Vert.x. I rec­om­mend dig­ging a lit­tle more through the quick­start to get a feel­ing for what’s there.\\nIn my next blog post I will ex­plain some of the de­ci­sions I made and the ob­sta­cles I faced with the dif­fer­ences be­tween Java and Scala /Hint: They are way big­ger than I was aware of).\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Enjoy!\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},"prevPost":{"meta":{"title":"Dynamic Routing in Serverless Microservice with Vert.x Event Bus","category":"guides","authors":[{"name":"Rowell Belen","github_id":"bytekast"}],"summary":"The Serverless Framework has become the de facto toolkit for building and deploying serverless functions or applications."},"date":"2017-04-14","slug":"dynamic-routing-in-serverless-microservice-with-vert-x-event-bus"},"nextPost":{"meta":{"title":"Data-driven Apps made easy with Vert.x 3.4.0 and headless CMS Gentics Mesh","category":"guides","authors":[{"name":"Johannes Schüth","github_id":"jotschi"}],"summary":"I would like to share why Vert.x is not only a robust foundation for the headless Content Management System Gentics Mesh but also how it can be used to build a template-based web server."},"date":"2017-03-13","slug":"data-driven-apps-made-easy-with-vert-x-3-4-0-and-headless-cms-gentics-mesh"},"relatedPosts":[{"meta":{"title":"Unit and Integration Tests","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"Let’s refresh our mind about what we developed so far in the introduction to vert.x series. We forgot an important task. We didn’t test the API."},"date":"2015-08-03","slug":"unit-and-integration-tests"},{"meta":{"title":"My first Vert.x 3 Application","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"Let's say, you heard someone saying that Vert.x is awesome. Ok great, but you may want to try it by yourself. Well, the next natural question is “where do I start ?”"},"date":"2015-07-14","slug":"my-first-vert-x-3-application"},{"meta":{"title":"Eclipse Vert.x for Scala next steps","category":"news","authors":[{"name":"Jochen Mader","github_id":"codepitbull"}],"summary":"This blog post gives an overview of the current plans for the vertx-lang-scala module, in particular with respect to the upcoming Vert.x 4."},"date":"2019-08-30","slug":"eclipse-vert-x-for-scala-next-steps"}]},"__N_SSG":true}