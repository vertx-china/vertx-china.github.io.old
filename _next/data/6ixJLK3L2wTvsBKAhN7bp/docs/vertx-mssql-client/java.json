{"pageProps":{"slug":"vertx-mssql-client/java","title":"Reactive MSSQL Client","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_usage\">Usage</a></li>\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_connecting_to_sql_server\">Connecting to SQL Server</a></li>\n<li><a href=\"#_configuration\">Configuration</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_object\">Data Object</a></li>\n<li><a href=\"#_connection_uri\">Connection URI</a></li>\n</ul>\n</li>\n<li><a href=\"#_connect_retries\">Connect retries</a></li>\n<li><a href=\"#_running_queries\">Running queries</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_queries\">Prepared queries</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_connections\">Using connections</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_getting_a_connection\">Getting a connection</a></li>\n<li><a href=\"#_simplified_connection_api\">Simplified connection API</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_transactions\">Using transactions</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_transactions_with_connections\">Transactions with connections</a></li>\n<li><a href=\"#_simplified_transaction_api\">Simplified transaction API</a></li>\n</ul>\n</li>\n<li><a href=\"#_tracing_queries\">Tracing queries</a></li>\n<li><a href=\"#_data_types_supported\">Data types supported</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_java_enum_types\">Using Java <code>enum</code> types</a></li>\n<li><a href=\"#_handling_null\">Handling <code>NULL</code></a></li>\n</ul>\n</li>\n<li><a href=\"#_collector_queries\">Collector queries</a></li>\n</ul>\n</div>","contents":"<h1>Reactive MSSQL Client</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Reactive MSSQL Client is a client for Microsoft SQL Server with a straightforward API focusing on\nscalability and low overhead.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Features</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Event driven</p>\n</li>\n<li>\n<p>Lightweight</p>\n</li>\n<li>\n<p>Built-in connection pooling</p>\n</li>\n<li>\n<p>Direct memory to object without unnecessary copies</p>\n</li>\n<li>\n<p>Java 8 Date and Time</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><strong>Not supported yet</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Prepared queries caching</p>\n</li>\n<li>\n<p>Batch and cursor</p>\n</li>\n<li>\n<p>Row streaming</p>\n</li>\n<li>\n<p>Some <a href=\"https://github.com/eclipse-vertx/vertx-sql-client/issues/608#issuecomment-629390027\">data types</a> are not supported</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_usage\"><a class=\"anchor\" href=\"#_usage\"></a>Usage</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use the Reactive MSSQL Client add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mssql-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-mssql-client:4.1.0'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Here is the simplest way to connect, query and disconnect</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the client pool</span>\nMSSQLPool client = MSSQLPool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// A simple query</span>\nclient\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n\n  <span class=\"hljs-comment\">// Now close the pool</span>\n  client.close();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_sql_server\"><a class=\"anchor\" href=\"#_connecting_to_sql_server\"></a>Connecting to SQL Server</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Most of the time you will use a pool to connect to MSSQL:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nMSSQLPool client = MSSQLPool.pool(connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The pooled client uses a connection pool and any operation will borrow a connection from the pool\nto execute the operation and release it to the pool.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are running with Vert.x you can pass it your Vertx instance:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-comment\">// Create the pooled client</span>\nMSSQLPool client = MSSQLPool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You need to release the pool when you don&#8217;t need it anymore:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you need to execute several operations on the same connection, you need to use a client\n<code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnection.html\">connection</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can easily get one from the pool:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nMSSQLPool client = MSSQLPool.pool(vertx, connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// Get a connection from the pool</span>\nclient.getConnection().compose(conn -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Got a connection from the pool\"</span>);\n\n  <span class=\"hljs-comment\">// All operations execute on the same connection</span>\n  <span class=\"hljs-keyword\">return</span> conn\n    .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n    .execute()\n    .compose(res -&gt; conn\n      .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='emad'\"</span>)\n      .execute())\n    .onComplete(ar -&gt; {\n      <span class=\"hljs-comment\">// Release the connection to the pool</span>\n      conn.close();\n    });\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    System.out.println(<span class=\"hljs-string\">\"Done\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Once you are done with the connection you must close it to release it to the pool, so it can be reused.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>Configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_data_object\"><a class=\"anchor\" href=\"#_data_object\"></a>Data Object</h3>\n<div class=\"paragraph\">\n<p>A simple way to configure the client is to specify a <code>MSSQLConnectOptions</code> data object.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool Options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pool from the data object</span>\nMSSQLPool pool = MSSQLPool.pool(vertx, connectOptions, poolOptions);\n\npool.getConnection(ar -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection_uri\"><a class=\"anchor\" href=\"#_connection_uri\"></a>Connection URI</h3>\n<div class=\"paragraph\">\n<p>As an alternative to configuring the client with a <code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnectOptions.html\">MSSQLConnectOptions</a></code> data object, you can use a connection URI:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String connectionUri = <span class=\"hljs-string\">\"sqlserver://dbuser:secretpassword@database.server.com:3211/mydb\"</span>;\n\n<span class=\"hljs-comment\">// Create the pool from the connection URI</span>\nMSSQLPool pool = MSSQLPool.pool(connectionUri);\n\n<span class=\"hljs-comment\">// Create the connection from the connection URI</span>\nMSSQLConnection.connect(vertx, connectionUri, res -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The connection URI format is defined by the client in an idiomatic way: <code>sqlserver://[user[:[password]]@]host[:port][/database][?attribute1=value1&amp;attribute2=value2&#8230;&#8203;]</code></p>\n</div>\n<div class=\"paragraph\">\n<p>Currently, the client supports the following parameter keywords in connection uri (keys are case-insensitive):</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>host</p>\n</li>\n<li>\n<p>port</p>\n</li>\n<li>\n<p>user</p>\n</li>\n<li>\n<p>password</p>\n</li>\n<li>\n<p>database</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connect_retries\"><a class=\"anchor\" href=\"#_connect_retries\"></a>Connect retries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can configure the client to retry when a connection fails to be established.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options\n  .setReconnectAttempts(<span class=\"hljs-number\">2</span>)\n  .setReconnectInterval(<span class=\"hljs-number\">1000</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_queries\"><a class=\"anchor\" href=\"#_running_queries\"></a>Running queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When you don&#8217;t need a transaction or run single queries, you can run queries directly on the pool; the pool\nwill use one of its connection to run the query and return the result to you.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is how to run simple queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>Prepared queries</h3>\n<div class=\"paragraph\">\n<p>You can do the same with prepared queries.</p>\n</div>\n<div class=\"paragraph\">\n<p>The SQL string can refer to parameters by position, using the database syntax `@1`, `@2`, etc…​</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id=@p1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Query methods provides an asynchronous <code><a href=\"../../apidocs/io/vertx/sqlclient/RowSet.html\">RowSet</a></code> instance that works for <em>SELECT</em> queries</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT first_name, last_name FROM users\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>or <em>UPDATE</em>/<em>INSERT</em> queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO users (first_name, last_name) VALUES (@p1, @p2)\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> gives you access to your data by index</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>or by name</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-string\">\"first_name\"</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The client will not do any magic here and the column name is identified with the name in the table regardless of how your SQL text is.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can access a wide variety of of types</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String firstName = row.getString(<span class=\"hljs-string\">\"first_name\"</span>);\nBoolean male = row.getBoolean(<span class=\"hljs-string\">\"male\"</span>);\nInteger age = row.getInteger(<span class=\"hljs-string\">\"age\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can use cached prepared statements to execute one-shot prepared queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connectOptions.setCachePreparedStatements(<span class=\"hljs-keyword\">true</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = @p1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can create a <code>PreparedStatement</code> and manage the lifecycle by yourself.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sqlConnection\n  .prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = @p1\"</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      PreparedStatement preparedStatement = ar.result();\n      preparedStatement.query()\n        .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n            System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n            preparedStatement.close();\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar2.cause().getMessage());\n          }\n        });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_connections\"><a class=\"anchor\" href=\"#_using_connections\"></a>Using connections</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>Getting a connection</h3>\n<div class=\"paragraph\">\n<p>When you need to execute sequential queries (without a transaction), you can create a new connection\nor borrow one from the pool. Remember that between acquiring the connection from the pool and returning it to the pool, you should take care of the connection because it might be closed by the server for some reason such as an idle time out.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool\n  .getConnection()\n  .compose(connection -&gt;\n    connection\n      .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES (@p1, @p2)\"</span>)\n      .executeBatch(Arrays.asList(\n        Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>),\n        Tuple.of(<span class=\"hljs-string\">\"Emad\"</span>, <span class=\"hljs-string\">\"Alblueshi\"</span>)\n      ))\n      .compose(res -&gt; connection\n        <span class=\"hljs-comment\">// Do something with rows</span>\n        .query(<span class=\"hljs-string\">\"SELECT COUNT(*) FROM Users\"</span>)\n        .execute()\n        .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n      .eventually(v -&gt; connection.close())\n  ).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Insert users, now the number of users is \"</span> + count);\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Prepared queries can be created:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection\n  .prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE first_name LIKE @p1\"</span>)\n  .compose(pq -&gt;\n    pq.query()\n      .execute(Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>))\n      .eventually(v -&gt; pq.close())\n  ).onSuccess(rows -&gt; {\n  <span class=\"hljs-comment\">// All rows</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_connection_api\"><a class=\"anchor\" href=\"#_simplified_connection_api\"></a>Simplified connection API</h3>\n<div class=\"paragraph\">\n<p>When you use a pool, you can call <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withConnection-java.util.function.Function-io.vertx.core.Handler-\">withConnection</a></code> to pass it a function executed\nwithin a connection.</p>\n</div>\n<div class=\"paragraph\">\n<p>It borrows a connection from the pool and calls the function with this connection.</p>\n</div>\n<div class=\"paragraph\">\n<p>The function must return a future of an arbitrary result.</p>\n</div>\n<div class=\"paragraph\">\n<p>After the future completes, the connection is returned to the pool and the overall result is provided.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withConnection(connection -&gt;\n  connection\n    .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES (@p1, @p2)\"</span>)\n    .executeBatch(Arrays.asList(\n      Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>),\n      Tuple.of(<span class=\"hljs-string\">\"Emad\"</span>, <span class=\"hljs-string\">\"Alblueshi\"</span>)\n    ))\n    .compose(res -&gt; connection\n      <span class=\"hljs-comment\">// Do something with rows</span>\n      .query(<span class=\"hljs-string\">\"SELECT COUNT(*) FROM Users\"</span>)\n      .execute()\n      .map(rows -&gt; rows.iterator().next().getInteger(<span class=\"hljs-number\">0</span>)))\n).onSuccess(count -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Insert users, now the number of users is \"</span> + count);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_transactions\"><a class=\"anchor\" href=\"#_using_transactions\"></a>Using transactions</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_transactions_with_connections\"><a class=\"anchor\" href=\"#_transactions_with_connections\"></a>Transactions with connections</h3>\n<div class=\"paragraph\">\n<p>You can execute transaction using SQL <code>BEGIN</code>/<code>COMMIT</code>/<code>ROLLBACK</code>, if you do so you must use\na <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code> and manage it yourself.</p>\n</div>\n<div class=\"paragraph\">\n<p>Or you can use the transaction API of <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnection.html\">SqlConnection</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.getConnection()\n  <span class=\"hljs-comment\">// Transaction must use a connection</span>\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// Begin the transaction</span>\n    conn.begin()\n      .compose(tx -&gt; conn\n        <span class=\"hljs-comment\">// Various statements</span>\n        .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n        .execute()\n        .compose(res2 -&gt; conn\n          .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\"</span>)\n          .execute())\n        <span class=\"hljs-comment\">// Commit the transaction</span>\n        .compose(res3 -&gt; tx.commit()))\n      <span class=\"hljs-comment\">// Return the connection to the pool</span>\n      .eventually(v -&gt; conn.close())\n      .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction succeeded\"</span>))\n      .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction failed: \"</span> + err.getMessage()));\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When the database server reports the current transaction is failed (e.g the infamous <em>current transaction is aborted, commands ignored until\nend of transaction block</em>), the transaction is rollbacked and the <code><a href=\"../../apidocs/io/vertx/sqlclient/Transaction.html#completion--\">completion</a></code> future\nis failed with a <code><a href=\"../../apidocs/io/vertx/sqlclient/TransactionRollbackException.html\">TransactionRollbackException</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">tx.completion()\n  .onFailure(err -&gt; {\n    System.out.println(<span class=\"hljs-string\">\"Transaction failed =&gt; rolled back\"</span>);\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_simplified_transaction_api\"><a class=\"anchor\" href=\"#_simplified_transaction_api\"></a>Simplified transaction API</h3>\n<div class=\"paragraph\">\n<p>When you use a pool, you can call <code><a href=\"../../apidocs/io/vertx/sqlclient/Pool.html#withTransaction-java.util.function.Function-io.vertx.core.Handler-\">withTransaction</a></code> to pass it a function executed\nwithin a transaction.</p>\n</div>\n<div class=\"paragraph\">\n<p>It borrows a connection from the pool, begins the transaction and calls the function with a client executing all\noperations in the scope of this transaction.</p>\n</div>\n<div class=\"paragraph\">\n<p>The function must return a future of an arbitrary result:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>when the future succeeds the client will commit the transaction</p>\n</li>\n<li>\n<p>when the future fails the client will rollback the transaction</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>After the transaction completes, the connection is returned to the pool and the overall result is provided.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.withTransaction(client -&gt; client\n  .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n  .execute()\n  .flatMap(res -&gt; client\n    .query(<span class=\"hljs-string\">\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\"</span>)\n    .execute()\n    <span class=\"hljs-comment\">// Map to a message result</span>\n    .map(<span class=\"hljs-string\">\"Users inserted\"</span>)))\n  .onSuccess(v -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction succeeded\"</span>))\n  .onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">\"Transaction failed: \"</span> + err.getMessage()));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>Tracing queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The SQL client can trace query execution when Vert.x has tracing enabled.</p>\n</div>\n<div class=\"paragraph\">\n<p>The client reports the following <em>client</em> spans:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> operation name</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>db.user</code>: the database username</p>\n</li>\n<li>\n<p><code>db.instance</code>: the database instance</p>\n</li>\n<li>\n<p><code>db.statement</code>: the SQL query</p>\n</li>\n<li>\n<p><code>db.type</code>: <em>sql</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The default tracing policy is <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>, the client\nwill only create a span when involved in an active trace.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can change the client policy with <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnectOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code>,\ne.g you can set <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code> to always report\na span:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_data_types_supported\"><a class=\"anchor\" href=\"#_data_types_supported\"></a>Data types supported</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Currently, the client supports the following SQL Server types:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>TINYINT(<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>SMALLINT(<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>INT(<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>BIGINT(<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>BIT(<code>java.lang.Boolean</code>)</p>\n</li>\n<li>\n<p>REAL(<code>java.lang.Float</code>)</p>\n</li>\n<li>\n<p>DOUBLE(<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>NUMERIC/DECIMAL(<code><a href=\"../../apidocs/java/math/BigDecimal.html\">BigDecimal</a></code>)</p>\n</li>\n<li>\n<p>CHAR/VARCHAR(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>NCHAR/NVARCHAR(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>DATE(<code>java.time.LocalDate</code>)</p>\n</li>\n<li>\n<p>TIME(<code>java.time.LocalTime</code>)</p>\n</li>\n<li>\n<p>DATETIME2(<code>java.time.LocalDateTime</code>)</p>\n</li>\n<li>\n<p>DATETIMEOFFSET(<code>java.time.OffsetDateTime</code>)</p>\n</li>\n<li>\n<p>BINARY/VARBINARY(<code>io.vertx.core.buffer.Buffer</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Tuple decoding uses the above types when storing values.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_java_enum_types\"><a class=\"anchor\" href=\"#_using_java_enum_types\"></a>Using Java <code>enum</code> types</h3>\n<div class=\"paragraph\">\n<p>SQL Server does not have <code>ENUM</code> data type, but the client can map the retrieved string/numeric data type to enum.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can encode Java enums like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO colors VALUES (@p1)\"</span>)\n  .execute(Tuple.of(Color.red),  res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can decode a Java enum like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT color FROM colors\"</span>)\n  .execute()\n  .onComplete(res -&gt; {\n    <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n      RowSet&lt;Row&gt; rows = res.result();\n      <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n        System.out.println(row.get(Color<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, \"<span class=\"hljs-title\">color</span>\"))</span>;\n      }\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_null\"><a class=\"anchor\" href=\"#_handling_null\"></a>Handling <code>NULL</code></h3>\n<div class=\"paragraph\">\n<p>If you modify a <code>Tuple</code> with one of the <code>addXXX</code> methods, <code>null</code> values are handled transparently.</p>\n</div>\n<div class=\"paragraph\">\n<p>The client can infer the right SQL type when executing a prepared query:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Tuple tuple = Tuple.tuple()\n  .addInteger(<span class=\"hljs-number\">17</span>)\n  .addString(<span class=\"hljs-string\">\"The Man Who Knew Too Much\"</span>)\n  .addString(<span class=\"hljs-keyword\">null</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO movies (id, title, plot) VALUES (@p1, @p2, @p3)\"</span>)\n  .execute(tuple, res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Otherwise, you should declare the type explicitely using one of the <code><a href=\"../../apidocs/io/vertx/sqlclient/data/NullValue.html\">NullValue</a></code> constants or the <code><a href=\"../../apidocs/io/vertx/sqlclient/data/NullValue.html#of-java.lang.Class-\">NullValue.of</a></code> method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Tuple tuple = Tuple.of(<span class=\"hljs-number\">17</span>, <span class=\"hljs-string\">\"The Man Who Knew Too Much\"</span>, NullValue.String);\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO movies (id, title, plot) VALUES (@p1, @p2, @p3)\"</span>)\n  .execute(tuple, res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can use Java collectors with the query API:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, Map&lt;Long, String&gt;&gt; collector = Collectors.toMap(\n  row -&gt; row.getLong(<span class=\"hljs-string\">\"id\"</span>),\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;Map&lt;Long, String&gt;&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the map created by the collector</span>\n      Map&lt;Long, String&gt; map = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + map);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The collector processing must not keep a reference on the <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> as\nthere is a single row used for processing the entire set.</p>\n</div>\n<div class=\"paragraph\">\n<p>The Java <code>Collectors</code> provides many interesting predefined collectors, for example you can\ncreate easily create a string directly from the row set:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, String&gt; collector = Collectors.mapping(\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>),\n  Collectors.joining(<span class=\"hljs-string\">\",\"</span>, <span class=\"hljs-string\">\"(\"</span>, <span class=\"hljs-string\">\")\"</span>)\n);\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;String&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the string created by the collector</span>\n      String list = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + list);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}