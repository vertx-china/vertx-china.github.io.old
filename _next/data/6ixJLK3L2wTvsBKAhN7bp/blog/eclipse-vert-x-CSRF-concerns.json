{"pageProps":{"categories":["releases","guides","news"],"post":{"meta":{"title":"Things to keep in mind concerning CSRF attacks","category":"guides","authors":[{"name":"Xhelal Likaj","github_id":"xhlika"}],"summary":"Eclipse Vert.x like most frameworks provides an anti-CSRF defense. However, no framework can prevent all attack vectors that exist in the web. Therefore, developers need to be aware of some dangers and common attack vectors concerning CSRF defenses."},"date":"2021-01-23","slug":"eclipse-vert-x-CSRF-concerns","readingTime":{"text":"22 min read","minutes":21.545,"time":1292700,"words":4309},"content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The first mile\\xADstone re\\xADleases of Vert.x 4.0.0 suf\\xADfered from \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://nvd.nist.gov/vuln/detail/CVE-2020-35217\"\n  }), \"CVE-2020-35217\"), \". Thanks to Xhe\\xADlal, we were able to ad\\xADdress the\\nse\\xADcu\\xADrity bugs and fix it on the first beta. This blog post is a ex\\xADpla\\xADna\\xADtion why CSRF should be used in your web\\nap\\xADpli\\xADca\\xADtions.\"), mdx(\"h3\", {\n    \"id\": \"be-aware-of-the-danger-cross-site-request-forgery-csrf\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#be-aware-of-the-danger-cross-site-request-forgery-csrf\"\n  })), \"Be aware of the danger: Cross-Site Request Forgery (CSRF)\"), mdx(\"p\", null, \"A pop\\xADu\\xADlar web vul\\xADner\\xADa\\xADbil\\xADity that has at\\xADtracted a lot of at\\xADten\\xADtion in the re\\xADsearch com\\xADmu\\xADnity is Cross-\\u200BSite Script\\xADing\\n(XSS). This vul\\xADner\\xADa\\xADbil\\xADity al\\xADlows the at\\xADtacker to in\\xADject ar\\xADbi\\xADtrary JavaScript (JS) code on a web\\xADsite that will run in the\\nsame ori\\xADgin as the web\\xADsite. Ac\\xADcord\\xADing to the Open Web Ap\\xADpli\\xADca\\xADtion Se\\xADcu\\xADrity Project (OWASP), XSS is the sec\\xADond most\\npreva\\xADlent issue in the 2017\\u2019s OWASP Top \", \"[1]\", \", and it is found in around two-\\u200Bthirds of all web ap\\xADpli\\xADca\\xADtions. How\\xADever,\\nwhile XSS gets all the at\\xADten\\xADtion, few de\\xADvel\\xADop\\xADers pay at\\xADten\\xADtion to an\\xADother at\\xADtack that can be equally de\\xADstruc\\xADtive and far\\neas\\xADier to ex\\xADploit. This at\\xADtack is called Cross-\\u200BSite Re\\xADquest Forgery (CSRF). It was ranked by OWASP as the fifth most\\ndan\\xADger\\xADous web vul\\xADner\\xADa\\xADbil\\xADity twice (2007, 2010) and eighth in 2013. For\\xADtu\\xADnately, the de\\xADvel\\xADop\\xADers\\u2019 aware\\xADness has in\\xADcreased\\nin re\\xADcent years and most web frame\\xADworks pro\\xADvide at least one de\\xADfen\\xADsive mech\\xADa\\xADnism against CSRF. As a re\\xADsult, CSRF was not\\nlisted in the 2017\\u2019s OWASP Top 10 list. Un\\xADfor\\xADtu\\xADnately, this at\\xADtack is far from ex\\xADtinct.\"), mdx(\"h3\", {\n    \"id\": \"csrf-origins\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#csrf-origins\"\n  })), \"CSRF Origins\"), mdx(\"p\", null, \"In 1988 Norm Hardy pub\\xADlished a paper where he ex\\xADplained a the\\xADo\\xADret\\xADi\\xADcal se\\xADcu\\xADrity issue that he called \\u201Ccon\\xADfused\\ndeputy\\u201D \", \"[2]\", \". This se\\xADcu\\xADrity issue was first re\\xADported in 2000 in Bug\\xADTraq (nowa\\xADdays Se\\xADcu\\xADri\\xADty\\xADFo\\xADcus \", \"[3]\", \"). The post\", \"[4]\", \" in\\nBug\\xADTraq showed how ZOPE, a Python web frame\\xADwork, was vul\\xADner\\xADa\\xADble to this web \\u201Ccon\\xADfused deputy\\u201D that we today know as\\nCSRF. This term (\\u201CCSRF\\u201D) was first used in June 2001 by Peter Watkins, fol\\xADlowed by a de\\xADtailed de\\xADscrip\\xADtion in 2004 by\\nThomas Schreiber \", \"[5]\", \". The au\\xADthor de\\xADscribed a va\\xADri\\xADety of at\\xADtack sce\\xADnar\\xADios where CSRF could be ex\\xADploited, pro\\xADvid\\xADing the\\nmost de\\xADtailed de\\xADscrip\\xADtion of the prob\\xADlem at the time. Since then CSRF has had many names such as XSRF, one-\\u200Bclick at\\xADtack,\\nCross-\\u200BSite Ref\\xADer\\xADence Forgery, ses\\xADsion rid\\xADing, sea surf, hos\\xADtile link\\xADing, \\u201Csleep\\xADing giant\\u201D etc. For the rest of this\\nblog, we will refer to this vul\\xADner\\xADa\\xADbil\\xADity as CSRF.\"), mdx(\"h3\", {\n    \"id\": \"how-does-csrf-exactly-work\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#how-does-csrf-exactly-work\"\n  })), \"How does CSRF exactly work?\"), mdx(\"p\", null, \"There are many de\\xADf\\xADi\\xADn\\xADi\\xADtions for it in the lit\\xADer\\xADa\\xADture, but the core idea re\\xADmains the same; in a CSRF at\\xADtack the vic\\xADtim\\u2019s\\nbrowser is tricked by an at\\xADtacker into send\\xADing a state-\\u200Bchanging HTTP re\\xADquest with au\\xADthen\\xADti\\xADca\\xADtion cook\\xADies, which the\\nvic\\xADtim did not in\\xADtend. This ex\\xADploits the fact that cook\\xADies are widely used on the in\\xADter\\xADnet and browsers au\\xADto\\xADmat\\xADi\\xADcally\\nat\\xADtach them to re\\xADquests \", \"[6]\", \". For in\\xADstance, on\\xADline shops, so\\xADcial net\\xADworks, web\\xADmail ap\\xADpli\\xADca\\xADtions, etc. use cook\\xADies to\\nmain\\xADtain state and track/re-\\u200Bidentify users with\\xADout need\\xADing to reau\\xADthen\\xADti\\xADcate. The rea\\xADson cook\\xADies are used is be\\xADcause\\nHTTP is a state\\xADless pro\\xADto\\xADcol. The server re\\xADsponds to a re\\xADceived re\\xADquest and then \\u201Cfor\\xADgets\\u201D about the con\\xADnec\\xADtion. To\\npre\\xADvent this state\\xADless\\xADness of HTTP, the au\\xADthen\\xADti\\xADca\\xADtion in\\xADfor\\xADma\\xADtion is stored some\\xADwhere in the server-\\u200Bside (e.g. ses\\xADsion\\nstore, data\\xADbase, etc.) and the browser re\\xADceives only an iden\\xADti\\xADfier (ID) from the server for that ses\\xADsion, often via a\\ncookie. The browser stores this cookie and when a user sends a re\\xADquest to the server, the browser will also\\nau\\xADto\\xADmat\\xADi\\xADcally at\\xADtach the cookie(s) for this web ap\\xADpli\\xADca\\xADtion. The server re\\xADtrieves the Ses\\xADsion ID from the cookie and\\nlooks up in its ses\\xADsion stor\\xADage or data\\xADbase to re\\xADtrieve the user\\u2019s data, iden\\xADti\\xADfied by the Ses\\xADsion ID.\"), mdx(\"p\", null, \"Many al\\xADter\\xADna\\xADtives exist when it comes to forg\\xADing a CSRF re\\xADquest. If a state-\\u200Bchanging re\\xADquest can be ex\\xADe\\xADcuted through\\nHTTP GET, then an at\\xADtacker can ex\\xADploit this in (mainly) two ways. One op\\xADtion would be for the at\\xADtacker to send an email\\nthat con\\xADtains a HTML tag with the CSRF pay\\xADload (e.g. \", mdx(\"code\", null, \"<\", \"img src=\\u201D\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://bank.com/transfer?amount=x&dest=y%22/\"\n  }), \"http://bank.com/trans\\xADfer?amount=x\", \"&\", \"dest=y\\u201D/\"), \">\"), \"). If the\\nweb\\xADmail ap\\xADpli\\xADca\\xADtion loads HTML im\\xADages au\\xADto\\xADmat\\xADi\\xADcally, then the browser will send the HTTP GET re\\xADquest and the CSRF at\\xADtack\\nsuc\\xADceeds. The sec\\xADond op\\xADtion is for the at\\xADtacker to trick the user into vis\\xADit\\xADing his ma\\xADli\\xADcious web\\xADsite, which con\\xADtains\\nthe above HTML image tag. Note that the at\\xADtacker is not lim\\xADited to only the \", mdx(\"code\", null, \"<\", \"img\", \">\"), \" tag. The at\\xADtack can be trig\\xADgered\\nby using dif\\xADfer\\xADent HTML tags, which usu\\xADally pro\\xADvide a src at\\xADtribute. How\\xADever, in most cases, ap\\xADpli\\xADca\\xADtions per\\xADform\\nstate-\\u200Bchanging re\\xADquest through HTTP POST re\\xADquests. In this case, the at\\xADtacker has to cre\\xADate a hid\\xADden JS form in his\\nma\\xADli\\xADcious web\\xADsite with the exact form fields that the server is ex\\xADpect\\xADing. Then, the at\\xADtacker can use JS\\u2019s events (e.g.\\non\\xADload()) to au\\xADto\\xADmat\\xADi\\xADcally post the hid\\xADden form when the vic\\xADtim loads/vis\\xADits the page.\"), mdx(\"p\", null, \"CSRF can be con\\xADsid\\xADered a type of the con\\xADfused deputy at\\xADtack where the web browser (con\\xADfused deputy) is tricked into\\nsend\\xADing a forged re\\xADquest (for a less priv\\xADi\\xADleged at\\xADtacker) to a web ap\\xADpli\\xADca\\xADtion. A CSRF at\\xADtack works be\\xADcause, by de\\xADsign,\\na web browser au\\xADto\\xADmat\\xADi\\xADcally at\\xADtaches all cook\\xADies that it has for the tar\\xADget web ap\\xADpli\\xADca\\xADtion when a re\\xADquest is sent. A\\nserver that does not pro\\xADtect against CSRF would ac\\xADcept and ex\\xADe\\xADcute the re\\xADquest as com\\xADing from the vic\\xADtim since the\\nses\\xADsion cookie was part of the re\\xADquest. What is worse, the vic\\xADtim is not aware of the at\\xADtack until when it is too late.\\nThe fig\\xADure below shows the steps of a com\\xADmon CSRF at\\xADtack. How\\xADever, some con\\xADdi\\xADtions have to be ful\\xADfilled for the at\\xADtack\\nto work:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The at\\xADtacker must find an un\\xADpro\\xADtected state-\\u200Bchanging op\\xADer\\xADa\\xADtion in the tar\\xADget web ap\\xADpli\\xADca\\xADtion.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The vic\\xADtim must be al\\xADready au\\xADthen\\xADti\\xADcated to the tar\\xADget web ap\\xADpli\\xADca\\xADtion (i.e. a ses\\xADsion cookie is al\\xADready stored in his/her browser).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The at\\xADtacker must forge the state-\\u200Bchanging re\\xADquest cor\\xADrectly. This means that the at\\xADtacker must in\\xADclude all HTML form fields or re\\xADquest pa\\xADra\\xADme\\xADters that the server-\\u200Bside ex\\xADpects.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The at\\xADtacker has to trick the au\\xADthen\\xADti\\xADcated vic\\xADtim into vis\\xADit\\xADing the at\\xADtacker\\u2019s web\\xADsite (where the CSRF at\\xADtack will take place) or trick the vic\\xADtim into click\\xADing a link.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The means for au\\xADthen\\xADti\\xADca\\xADtion must be au\\xADto\\xADmat\\xADi\\xADcally at\\xADtached to the re\\xADquest by the browser (e.g. Basic Au\\xADthen\\xADti\\xADca\\xADtion re\\xADquest header \", \"[7]\", \" or cook\\xADies). Note that, dif\\xADfer\\xADent from XSS, CSRF aims to reuse the ses\\xADsion cookie, not steal it.\")), mdx(\"h3\", {\n    \"id\": \"impact-of-csrf-attacks\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#impact-of-csrf-attacks\"\n  })), \"Impact of CSRF attacks\"), mdx(\"p\", null, \"The im\\xADpact of the at\\xADtack de\\xADpends on the spe\\xADcific op\\xADer\\xADa\\xADtion that is vul\\xADner\\xADa\\xADble to CSRF, but also on the priv\\xADi\\xADleges that\\nthe vic\\xADtim has. This can re\\xADsult in a money trans\\xADfer, change of pass\\xADword, a pur\\xADchase in a shop\\xADping web\\xADsite, ac\\xADcount\\ncom\\xADpro\\xADmise, cre\\xADated admin user, etc. Some\\xADtimes CSRF can be even more dan\\xADger\\xADous than ses\\xADsion hi\\xADjack\\xADing. For in\\xADstance, in\\na court case, the vic\\xADtim can\\xADnot argue that he did not per\\xADform a trans\\xADac\\xADtion be\\xADcause the IP of the re\\xADquest (al\\xADthough\\nun\\xADin\\xADtended) was that of the vic\\xADtim. To makes things even worse, the vic\\xADtim doesn\\u2019t even know which ma\\xADli\\xADcious web\\xADsite he\\nvis\\xADited that trig\\xADgered the CSRF at\\xADtack. In the case of ses\\xADsion hi\\xADjack\\xADing, the ma\\xADli\\xADcious at\\xADtacker logs in with stolen\\ncre\\xADden\\xADtials (usu\\xADally) from an IP ad\\xADdress dif\\xADfer\\xADent from that of the vic\\xADtim\\u2019s. There\\xADfore, in this case, the vic\\xADtim can\\nargue that he was the vic\\xADtim of an at\\xADtack. There have also been other ex\\xADam\\xADples of CSRF at\\xADtacks that lead to re\\xADmote code\\nex\\xADe\\xADcu\\xADtion with root priv\\xADi\\xADleges \", \"[8]\", \" or com\\xADpro\\xADmise of a root cer\\xADtifi\\xADcate \", \"[9]\", \".\"), mdx(\"p\", null, \"Some\\xADtimes CSRF is mis\\xADtak\\xADenly con\\xADfused with XSS, but they are two dif\\xADfer\\xADent at\\xADtacks. XSS aims to ex\\xADe\\xADcute ar\\xADbi\\xADtrary JS\\ncode on a vul\\xADner\\xADa\\xADble web\\xADsite. It abuses the trust that a client has in a cer\\xADtain web ap\\xADpli\\xADca\\xADtion, thus click\\xADing the\\nlink. On the other hand, CSRF tricks the user\\u2019s browser to send un\\xADin\\xADtended HTTP re\\xADquests to a vul\\xADner\\xADa\\xADble web\\nap\\xADpli\\xADca\\xADtion. It ex\\xADploits the trust that a web ap\\xADpli\\xADca\\xADtion has in the user. The web ap\\xADpli\\xADca\\xADtion as\\xADsumes that if a re\\xADquest\\nwas re\\xADceived, then it orig\\xADi\\xADnated from the user (be\\xADcause of the ses\\xADsion cookie) and ex\\xADe\\xADcutes it. Ad\\xADdi\\xADtion\\xADally, in a CSRF\\nex\\xADploit the at\\xADtacker can trick the vic\\xADtim\\u2019s browser to send an HTTP re\\xADquest, but he can\\xADnot read the re\\xADsponse of that\\nre\\xADquest while XSS can issue re\\xADquests and also read the re\\xADsponse. XSS at\\xADtacks are based on JS, while CSRF at\\xADtacks can\\nalso be car\\xADried out just by using a crafted HTML form. Fi\\xADnally, if a web ap\\xADpli\\xADca\\xADtion is vul\\xADner\\xADa\\xADble to XSS, then it is\\nalso vul\\xADner\\xADa\\xADble to CSRF. How\\xADever, if a web ap\\xADpli\\xADca\\xADtion is safe from XSS, it might still be vul\\xADner\\xADa\\xADble to CSRF.\"), mdx(\"p\", null, \"Since its dis\\xADcov\\xADery in 2001, there have been many re\\xADported CSRF at\\xADtacks. Major web\\xADsites such as Net\\xADflix, Google, Yahoo,\\nfi\\xADnan\\xADcial in\\xADsti\\xADtutes, Face\\xADbook, etc. have been vul\\xADner\\xADa\\xADble to CSRF and in some cases even more than once. Some of the\\nmost fa\\xADmous cases are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Net\\xADflix web\\xADsite (2006): an at\\xADtacker could add a DVD to the vic\\xADtim\\u2019s shop\\xADping cart, change the ship\\xADping ad\\xADdress of the vic\\xADtim, or even com\\xADpro\\xADmise his/her ac\\xADcount.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"New York Time\\u2019s web\\xADsite \", \"[10]\", \": CSRF that leaks the email ad\\xADdress of the user. It was used for spam\\xADming the vic\\xADtims. The web\\xADsite kept users logged in for over a year.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ING Di\\xADrect web ap\\xADpli\\xADca\\xADtion \", \"[10]\", \": vul\\xADner\\xADa\\xADble to a CSRF at\\xADtack that al\\xADlowed unau\\xADtho\\xADrized money trans\\xADfers from vic\\xADtim\\u2019s ac\\xADcount to the at\\xADtacker\\u2019s ac\\xADcount.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"YouTube \", \"[10]\", \": The vul\\xADner\\xADa\\xADbil\\xADity al\\xADlowed the at\\xADtacker to per\\xADform al\\xADmost all ac\\xADtions that a user can nor\\xADmally do.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Google, Yahoo, Pay\\xADPal (2008) \", \"[11]\", \" were vul\\xADner\\xADa\\xADble to Login CSRF.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Face\\xADbook (2009) was vul\\xADner\\xADa\\xADble to CSRF. The at\\xADtacker could use an HTML \", mdx(\"code\", null, \"<\", \"img\", \">\"), \" tag to steal the user\\u2019s ac\\xADcount in\\xADfor\\xADma\\xADtion.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"MetaFil\\xADter \", \"[10]\", \": the vul\\xADner\\xADa\\xADbil\\xADity al\\xADlowed an at\\xADtacker to take con\\xADtrol of a user\\u2019s ac\\xADcount.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Twit\\xADter \", \"[12]\", \" was also vul\\xADner\\xADa\\xADble to CSRF in 2010. When au\\xADthen\\xADti\\xADcated users vis\\xADited the ma\\xADli\\xADcious web\\xADsite, they un\\xADin\\xADten\\xADtion\\xADally posted two tweets \\u2013 one with a link lead\\xADing to this ma\\xADli\\xADcious web\\xADsite and an\\xADother with a tweet about goats. Every user who clicked on the link pro\\xADvided in the first tweet also posted those two tweets, hence the worm was spread.\")), mdx(\"h3\", {\n    \"id\": \"most-popular-anti-csrf-defenses\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#most-popular-anti-csrf-defenses\"\n  })), \"Most popular anti-CSRF defenses\"), mdx(\"p\", null, \"Syn\\xADchro\\xADnizer Token Pat\\xADtern (STP) \", \"[13]\", \" is one of the most pop\\xADu\\xADlar coun\\xADter\\xADmea\\xADsures. A se\\xADcret, unguess\\xADable, ran\\xADdom value\\n(known as CSRF token) is gen\\xADer\\xADated on the server-\\u200Bside using a cryptographically-\\u200Bsecure pseudo\\xADran\\xADdom gen\\xADer\\xADa\\xADtor (CSPRNG)\\nwith a ran\\xADdom input/seed. The gen\\xADer\\xADated token is stored in server-\\u200Bside stor\\xADage and must be tied to a spe\\xADcific user\\n(usu\\xADally linked to the Ses\\xADsion ID). This stor\\xADage can be a ses\\xADsion data\\xADs\\xADtore (e.g. Redis), a data\\xADbase, a filesys\\xADtem (e.g.\\nin PHP), server\\u2019s mem\\xADory, etc. The CSRF token is sent as part of the server\\u2019s re\\xADsponse and is usu\\xADally placed in a hid\\xADden\\nHTML form field. Once a re\\xADquest ar\\xADrives in server-\\u200Bside, the server will use the Ses\\xADsion ID from the ses\\xADsion cookie\\n(found in the in\\xADcom\\xADing re\\xADquest) to ex\\xADtract the CSRF token from the stor\\xADage. It will then com\\xADpare it against the CSRF\\ntoken that came as part of the re\\xADquest\\u2019s body (or in a cus\\xADtom header).\"), mdx(\"p\", null, \"Dou\\xADble Sub\\xADmit Cookie \", \"[14]\", \" is an\\xADother pop\\xADu\\xADlar coun\\xADter\\xADmea\\xADsure that makes use of cook\\xADies in\\xADstead of ses\\xADsion stor\\xADage to\\nstore a CSRF token. The se\\xADcu\\xADrity of this coun\\xADter\\xADmea\\xADsure re\\xADlies on the SOP. Only JS run\\xADning within the same ori\\xADgin is\\nal\\xADlowed to read or mod\\xADify the cookie\\u2019s value. The server-\\u200Bside gen\\xADer\\xADates a CSRF token same as in the STP coun\\xADter\\xADmea\\xADsure.\\nThe server cre\\xADates a cookie with the CSRF token in it and sends both this cookie and the CSRF token (usu\\xADally in an HTML\\nform) to the client-\\u200Bside. When a re\\xADquest is sent to the server-\\u200Bside, this cookie that holds the CSRF token will be\\nau\\xADto\\xADmat\\xADi\\xADcally sent by the browser in ad\\xADdi\\xADtion to the CSRF token in the re\\xADquest body/cus\\xADtom header, hence the name\\n\\u201CDou\\xADble Sub\\xADmit\\u201D. The server-\\u200Bside will re\\xADtrieve the CSRF token from the cookie and com\\xADpare against the CSRF token in the\\nre\\xADquest body/cus\\xADtom HTTP re\\xADquest header.\"), mdx(\"h3\", {\n    \"id\": \"great-does-not-mean-perfect\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#great-does-not-mean-perfect\"\n  })), \"Great does not mean perfect!\"), mdx(\"p\", null, \"Al\\xADthough anti-\\u200BCSRF de\\xADfenses mit\\xADi\\xADgate CSRF at\\xADtacks to a great ex\\xADtent, they are not per\\xADfect and may be sus\\xADcep\\xADti\\xADble to\\ndif\\xADfer\\xADent at\\xADtacks vec\\xADtors:\"), mdx(\"h4\", {\n    \"id\": \"cryptography-concerns\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#cryptography-concerns\"\n  })), \"Cryptography concerns\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use of un\\xADsafe func\\xADtions for ran\\xADdom\\xADness: the func\\xADtion that is used to gen\\xADer\\xADate CSRF to\\xADkens/se\\xADcrets is cru\\xADcial for se\\xADcu\\xADrity. Pseudo-\\u200BRandom Num\\xADber Gen\\xADer\\xADa\\xADtors (PRNG) are fast func\\xADtions that out\\xADput low-\\u200Bquality ran\\xADdom\\xADness and should not be used to gen\\xADer\\xADate strings for crit\\xADi\\xADcal se\\xADcu\\xADrity op\\xADer\\xADa\\xADtions. It is ad\\xADvised to use cryptographically-\\u200Bsecure PRNG (CSPRNG) in\\xADstead. They pro\\xADvide enough ran\\xADdom\\xADness/en\\xADtropy in ex\\xADchange for longer gen\\xADer\\xADa\\xADtion time. Most lan\\xADguages pro\\xADvide a CSPRNG \", \"[15]\", \" so make sure to check be\\xADfore you end up using func\\xADtions like Math.Ran\\xADdom().\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In\\xADsuf\\xADfi\\xADcient ran\\xADdom\\xADness of the (CSRF) token: to\\xADkens need to be ran\\xADdomly gen\\xADer\\xADated (i.e. high en\\xADtropy) so that it can\\xADnot be guessed or brute-\\u200Bforced in a rea\\xADson\\xADable amount of time. In order to with\\xADstand the com\\xADpu\\xADta\\xADtion power of today\\u2019s com\\xADput\\xADers, to\\xADkens needs to have an en\\xADtropy of at least 128-bit to be con\\xADsid\\xADered se\\xADcure.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In\\xADsuf\\xADfi\\xADcient ran\\xADdom\\xADness of the cryp\\xADto\\xADgraphic key: in those cases when the CSRF token/cookie is signed and/or en\\xADcrypted (for ad\\xADdi\\xADtional se\\xADcu\\xADrity or to pre\\xADvent tam\\xADper\\xADing), the se\\xADcret key that is used for en\\xADcrypt\\xADing or sign\\xADing dur\\xADing token gen\\xADer\\xADa\\xADtion might not be se\\xADcure enough. The se\\xADcret key should be ran\\xADdom enough so that the at\\xADtacker can\\xADnot eas\\xADily brute-\\u200Bforce it. De\\xADvel\\xADop\\xADers often copy and paste it from the doc\\xADu\\xADmen\\xADta\\xADtion code snip\\xADpet or Stack Over\\xADflow posts with\\xADout re\\xADal\\xADiz\\xADing the risks.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lack of key ro\\xADta\\xADtion: se\\xADcret keys should often be ro\\xADtated. The life\\xADtime of the cryp\\xADto\\xADgraphic key is im\\xADpor\\xADtant and de\\xADpends on many fac\\xADtors as al\\xADready cov\\xADered in de\\xADtail by OWASP \", \"[16]\", \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use of in\\xADse\\xADcure cryp\\xADto\\xADgraphic al\\xADgo\\xADrithms: a web frame\\xADwork might still be using an in\\xADse\\xADcure cryp\\xADto\\xADgraphic al\\xADgo\\xADrithm such as DES, MD-5, SHA-1, or use un\\xADsafe block ci\\xADpher such as Elec\\xADtronic Code Book (ECB). OWASP pro\\xADvides de\\xADtailed doc\\xADu\\xADmen\\xADta\\xADtion con\\xADcern\\xADing cryp\\xADto\\xADgraphic op\\xADer\\xADa\\xADtions (as men\\xADtioned above).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use of dep\\xADre\\xADcated/un\\xADpatched cryp\\xADto\\xADgraphic li\\xADbraries: the cryp\\xADto\\xADgraphic al\\xADgo\\xADrithms are often pro\\xADvided by li\\xADbraries. An un\\xADpatched or dep\\xADre\\xADcated li\\xADbrary might be prob\\xADlem\\xADatic and de\\xADvel\\xADop\\xADers should al\\xADways be using the lat\\xADest (patched) ver\\xADsion.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In\\xADse\\xADcure stor\\xADage of the ap\\xADpli\\xADca\\xADtion\\u2019s cryp\\xADto\\xADgraphic key: aside from ran\\xADdom\\xADness and key ro\\xADta\\xADtion, its stor\\xADage is also im\\xADpor\\xADtant. Stor\\xADing a se\\xADcret key hard\\xADcoded in the source code (or in some other in\\xADse\\xADcure lo\\xADca\\xADtion) would com\\xADpro\\xADmise the key if the code is leaked or a (ma\\xADli\\xADcious) em\\xADployee has ac\\xADcess to it.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Server-\\u200Bside token stor\\xADage: A pos\\xADsi\\xADble im\\xADple\\xADmen\\xADta\\xADtion mis\\xADtake (for STP de\\xADfense for ex\\xADam\\xADple) would be the in\\xADcor\\xADrect map\\xADping user-\\u200Btoken be\\xADtween the user and the CSRF se\\xADcret that is stored on the server-\\u200Bside. An in\\xADcor\\xADrect map\\xADping might lead to many users hav\\xADing the same token. If the at\\xADtacker and vic\\xADtim share the same token, the at\\xADtacker can eas\\xADily forge a suc\\xADcess\\xADful CSRF at\\xADtack. Al\\xADthough this might sound as im\\xADprob\\xADa\\xADble, it has even hap\\xADpened re\\xADcently \", \"[17]\", \".\")), mdx(\"h4\", {\n    \"id\": \"token-transmission-from-server-side-to-client-side\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#token-transmission-from-server-side-to-client-side\"\n  })), \"Token transmission from server-side to client-side\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"MITM at\\xADtacks: Trans\\xADmis\\xADsion of the se\\xADcret val\\xADues over HTTP is in\\xADse\\xADcure since a net\\xADwork at\\xADtacker can per\\xADform a tra\\xADdi\\xADtional MITM at\\xADtack by in\\xADter\\xADcept\\xADing the re\\xADquest and leak the CSRF token. Ad\\xADdi\\xADtion\\xADally, SSL strip\\xADping at\\xADtack or a more ad\\xADvanced MITM \", \"[18]\", \" might be ex\\xADploited.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BREACH \", \"[19]\", \": is an\\xADother at\\xADtack vec\\xADtor that can leak the CSRF token using a compression-\\u200Bbased side-\\u200Bchannel if the HTTP re\\xADsponse is com\\xADpressed. This at\\xADtack is pos\\xADsi\\xADble if the CSRF token is in the HTTP re\\xADsponse body (which nor\\xADmally is), along with some user-\\u200Bspecified input. The au\\xADthors that dis\\xADcov\\xADered BREACH showed how they leaked a CSRF token in 30 sec\\xADonds in Mi\\xADcrosoft\\u2019s Out\\xADlook Web Ac\\xADcess web\\xADsite.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Plac\\xADing the token in the URL: is a com\\xADmon mis\\xADtake that might lead to CSRF token leak\\xADage through log files, browser his\\xADtory and Refer(r)er header. An\\xADother trick is to re\\xADtrieve the CSRF token by using the so-\\u200Bcalled \\u201CCSS His\\xADtory Hack\\u201D \", \"[20]\", \".\")), mdx(\"h4\", {\n    \"id\": \"https-request-with-the-csrf-token-from-client-side\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#https-request-with-the-csrf-token-from-client-side\"\n  })), \"HTTP(S) request with the CSRF token from client-side\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Code in\\xADjec\\xADtion (XSS, Dan\\xADgling Markup, CSS tricks): this cat\\xADe\\xADgory of at\\xADtacks aims to leak the se\\xADcret token by using JS (XSS), HTML (Dan\\xADgling markup), or CSS. Any XSS vec\\xADtor can be used to leak the CSRF token that is placed in the hid\\xADden HTML form. One might think that CSRF is point\\xADless when the at\\xADtacker can al\\xADready per\\xADform XSS, a larger threat than CSRF. How\\xADever, there are cases when the at\\xADtacker can be de\\xADtected, e.g. in server-\\u200Bside XSS cases. Al\\xADter\\xADna\\xADtively, an XSS vec\\xADtor in a sub\\xADdo\\xADmain might be ex\\xADploited to at\\xADtack an XSS-\\u200Bsecure tar\\xADget par\\xADent do\\xADmain. For in\\xADstance, the at\\xADtacker can use the XSS in the sub\\xADdo\\xADmain to set cook\\xADies for the par\\xADent do\\xADmain and per\\xADform a cookie toss\\xADing at\\xADtack (to be dis\\xADcussed soon). Dan\\xADgling Markup is an\\xADother kind of at\\xADtack that uses HTML to ex\\xADtract the CSRF token when attacker-\\u200Bcontrolled input is re\\xADflected in the HTML. A de\\xADtailed ex\\xADam\\xADple of this at\\xADtack can be found in this blog by Gareth Heyes\\\\cite{dan\\xADgling}.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Click\\xADjack\\xADing \", \"[21]\", \": is an\\xADother at\\xADtack that can leak CSRF token or ren\\xADder the CSRF de\\xADfense use\\xADless. The de\\xADfense can be by\\xADpassed by fram\\xADing the tar\\xADget web ap\\xADpli\\xADca\\xADtion on the at\\xADtacker\\u2019s web\\xADsite. The vic\\xADtim is then tricked into sub\\xADmit\\xADting an HTML form on the tar\\xADget web ap\\xADpli\\xADca\\xADtion (same ori\\xADgin) which is loaded in\\xADside the at\\xADtacker\\u2019s web\\xADsite with the CSRF token in it. Since the CSRF token is part of the re\\xADquest, the de\\xADfense be\\xADcomes point\\xADless. How\\xADever, tra\\xADdi\\xADtional Click\\xADjack\\xADing is lim\\xADited to click\\xADing but\\xADtons while in re\\xADal\\xADity, an HTML form has to be filled in order to per\\xADform a sen\\xADsi\\xADtive op\\xADer\\xADa\\xADtion. Stone \", \"[22]\", \" showed how Click\\xADjack\\xADing could be used to achieve this. He sug\\xADgests the use of drag-\\u200Band-drop API to leak the CSRF token and/or fill HTML forms.\")), mdx(\"h4\", {\n    \"id\": \"cookie-injection-for-cookie-based-mechanisms-like-double-submit-cookie\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#cookie-injection-for-cookie-based-mechanisms-like-double-submit-cookie\"\n  })), \"Cookie injection (for cookie-based mechanisms like Double Submit Cookie)**\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cookie toss\\xADing \", \"[23]\", \": this at\\xADtack vec\\xADtor is the nat\\xADural enemy of Dou\\xADble Sub\\xADmit coun\\xADter\\xADmea\\xADsure and ex\\xADploits the fact that an attacker-\\u200Bcontrolled sub\\xADdo\\xADmain can set a cookie for the tar\\xADget par\\xADent do\\xADmain. It also ex\\xADploits the com\\xADplex na\\xADture of cook\\xADies. A cookie is stored as a unique com\\xADbi\\xADna\\xADtion of name/do\\xADmain/path in the browser. Be\\xADcause name/do\\xADmain/path de\\xADter\\xADmine the unique\\xADness of a cookie, an at\\xADtacker can cre\\xADate a cookie from a sub\\xADdo\\xADmain that he con\\xADtrols with the same name and do\\xADmain but with a dif\\xADfer\\xADent path. This will cre\\xADate a whole new cookie and the browser will store it even if it has the same name. When the re\\xADquest is sent, the browser will at\\xADtach this header: \\u201CCookie: Xname=good; Xname=bad\\u201D (and no other cookie at\\xADtrib\\xADutes). As a re\\xADsult, the server that hosts the tar\\xADget par\\xADent do\\xADmain now sees two cook\\xADies with the same name but can\\xADnot dis\\xADtin\\xADguish which one be\\xADlongs to the par\\xADent do\\xADmain. The suc\\xADcess of the at\\xADtack re\\xADlies on the fact that the at\\xADtacker\\u2019s cookie (i.e. \\u201CXname=bad\\u201D cookie) is the one that is con\\xADsid\\xADered by the server. To in\\xADcrease the suc\\xADcess chance, the at\\xADtacker can also in\\xADclude a spe\\xADcific path in the forged cookie, e.g. path=trans\\xADfer. This ex\\xADploits the fact that (most) browsers will con\\xADsider a cookie with a path to be the \\u201Cmore specifically-\\u200Bscoped\\u201D and will send it first. Some pro\\xADgram\\xADming lan\\xADguages (e.g. PHP) cre\\xADate an array from the Cookie header and only con\\xADsider the first cookie of the array. Other lan\\xADguages like Python con\\xADsider the last cookie in the array. Egor Homakov \", \"[24]\", \" showed a de\\xADtailed ex\\xADam\\xADple of a real-\\u200Blife ap\\xADpli\\xADca\\xADtion of cookie toss\\xADing on GitHub.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cookie jar over\\xADflow \", \"[25]\", \": is an at\\xADtack vec\\xADtor that tar\\xADgets the web browser\\u2019s cookie jar. When a web\\xADsite sets a cookie, the browser adds it to the cookie jar which can be thought of as a data\\xADbase in the browser that stores cook\\xADies. Just like a real jar, there is a limit to how many cook\\xADies it can store. Fire\\xADfox al\\xADlows up to 150 cook\\xADies while Chrome al\\xADlows 180. If the limit is reached, the browser will start re\\xADplac\\xADing old cook\\xADies with new ones. There\\xADfore, an at\\xADtacker can do a cookie jar over\\xADflow to \\u201Ckick out\\u201D every sin\\xADgle cookie of the par\\xADent do\\xADmain and re\\xADplace them with attacker-\\u200Bspecified cook\\xADies (and CSRF token) just by run\\xADning a JS snip\\xADpet code on a sub\\xADdo\\xADmain. Even if the at\\xADtacker can\\xADnot mod\\xADify a cookie (e.g. HttpOnly or Same\\xADSite), he can use this over\\xADflow to con\\xADtrol what cook\\xADies the browser stores.\")), mdx(\"h4\", {\n    \"id\": \"server-side-csrf-verification\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#server-side-csrf-verification\"\n  })), \"Server-side CSRF verification**\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In\\xADse\\xADcure token com\\xADpar\\xADi\\xADson (tim\\xADing at\\xADtacks) \", \"[26]\", \": tim\\xADing at\\xADtacks on token com\\xADpar\\xADi\\xADson can hap\\xADpen if a token com\\xADpar\\xADi\\xADson is done using the \\u201D==\\u201D op\\xADer\\xADa\\xADtor or a func\\xADtion that is based on this op\\xADer\\xADa\\xADtor. The du\\xADra\\xADtion of the com\\xADpar\\xADi\\xADson is longer for strings with many char\\xADac\\xADters in com\\xADmon (e.g. \\u201Cuni\\xADver\\xADsity\\u201D and \\u201Cuni\\xADverse\\u201D) and shorter oth\\xADer\\xADwise (e.g., \\u201Cuni\\xADver\\xADsity\\u201D and \\u201Ctest\\u201D). This time dif\\xADfer\\xADence in the com\\xADpar\\xADi\\xADson can be used as a side-\\u200Bchannel to guess the CSRF token.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Miss\\xADing checks for \\u201Csafe\\u201D HTTP meth\\xADods: a com\\xADmon mis\\xADtake is to per\\xADform CSRF ver\\xADi\\xADfi\\xADca\\xADtion only for un\\xADsafe HTTP meth\\xADods such as POST, PUT, DELETE, PATCH. In\\xADdeed, ac\\xADcord\\xADing to RFC 2616 \", \"[27]\", \", \\u201Csafe\\u201D meth\\xADods should be idem\\xADpo\\xADtent. How\\xADever, de\\xADvel\\xADop\\xADers use GET-\\u200Bbased re\\xADquests for state-\\u200Bchanging op\\xADer\\xADa\\xADtions quite often in prac\\xADtice (e.g. for log out). This al\\xADlows for GET-\\u200Bbased CSRF at\\xADtacks to hap\\xADpen.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Miss\\xADing check for non-\\u200BPOST un\\xADsafe HTTP meth\\xADods: is an even more dan\\xADger\\xADous prac\\xADtice. There are few frame\\xADwork de\\xADvel\\xADop\\xADers that only per\\xADform CSRF ver\\xADi\\xADfi\\xADca\\xADtion only for POST re\\xADquests and ig\\xADnore other un\\xADsafe meth\\xADods such as DELETE or PUT. In some cases, the de\\xADvel\\xADoper doesn\\u2019t un\\xADder\\xADstand the risk of such be\\xADhav\\xADior \", \"[28]\", \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"HTTP Method Over\\xADride is also a \\u201Cfea\\xADture\\u201D that can by\\xADpass the CSRF ver\\xADi\\xADfi\\xADca\\xADtion that is per\\xADformed only for spe\\xADcific HTTP head\\xADers. The at\\xADtacker can forge his re\\xADquest as a GET re\\xADquest and also add a cus\\xADtom re\\xADquest header (X-\\u200BHTTP-Method-Override) to over\\xADride the re\\xADquest method to PUT, POST, or DELETE. Usu\\xADally, this is pro\\xADvided as a mid\\xADdle\\xADware. If this mid\\xADdle\\xADware is spec\\xADi\\xADfied after the CSRF mid\\xADdle\\xADware, then the CSRF ver\\xADi\\xADfi\\xADca\\xADtion will be by\\xADpassed be\\xADcause it con\\xADsid\\xADers the re\\xADquest as GET. Next, when method over\\xADride mid\\xADdle\\xADware is ex\\xADe\\xADcuted, it will change the re\\xADquest method to POST and will ex\\xADe\\xADcute the CSRF re\\xADquest \", \"[29]\", \". An\\xADother at\\xADtack vec\\xADtor using HTTP Method Over\\xADride hap\\xADpens when the at\\xADtacker spec\\xADi\\xADfies an ar\\xADbi\\xADtrary name as a mod\\xADi\\xADfied re\\xADquest method and the coun\\xADter\\xADmea\\xADsure will trig\\xADger the CSRF ver\\xADi\\xADfi\\xADca\\xADtion only for a list of spec\\xADi\\xADfied meth\\xADods (e.g. only for POST, DELETE, etc.). In this case, the ver\\xADi\\xADfi\\xADca\\xADtion will not be called at all, lead\\xADing to CSRF.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Log\\xADi\\xADcal er\\xADrors: are all er\\xADrors that don\\u2019t throw an ex\\xADcep\\xADtion but have a flaw in the code\\u2019s logic or pro\\xADgram\\xADming mis\\xADtakes (e.g. in\\xADcor\\xADrect \\u201Cif-\\u200Belse\\u201D clauses). As we will see dur\\xADing the field study, there are few frame\\xADworks that have ac\\xADtu\\xADally fallen vic\\xADtim to this prob\\xADlem.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Re\\xADplay at\\xADtack \", \"[30]\", \": is one of the old\\xADest tricks that is usu\\xADally ex\\xADploited in cryp\\xADto\\xADgraphic pro\\xADto\\xADcols. The at\\xADtacker in\\xADter\\xADcepts a mes\\xADsage that is sent from A to B, say a re\\xADquest for money trans\\xADfer, and then re\\xADplay this at\\xADtack by send\\xADing the in\\xADter\\xADcepted mes\\xADsage to B mul\\xADti\\xADple times. B has no way of check\\xADing the fresh\\xADness of the mes\\xADsage and will do the trans\\xADac\\xADtion every time. This can hap\\xADpen with CSRF to\\xADkens as well. An at\\xADtacker that leaks a sin\\xADgle CSRF token can use it mul\\xADti\\xADple times until token ex\\xADpi\\xADra\\xADtion. This at\\xADtack is also aided by the way ses\\xADsions are usu\\xADally han\\xADdled in prac\\xADtice. Some ses\\xADsions can last for days or months and if time is not spec\\xADi\\xADfied in the cookie, the end of the ses\\xADsion is con\\xADsid\\xADered when the browser is closed. How\\xADever, some browsers like Chrome have \\u201CClear cook\\xADies and site data when you quit Chrome\\u201D fea\\xADture, which is by de\\xADfault dis\\xADabled. As a re\\xADsult, the ses\\xADsion does not re\\xADally end even when the browser is closed.\")), mdx(\"p\", null, \"\\u2022    \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cross-\\u200BSite Web\\xADSocket Hi\\xADjack\\xADing \", \"[31]\"), \": (WS) con\\xADnec\\xADtions are an\\xADother pos\\xADsi\\xADble at\\xADtack vec\\xADtor. An at\\xADtacker can write some code in his ma\\xADli\\xADcious web\\xADsite that ini\\xADti\\xADates a WS hand\\xADshake with the tar\\xADget server. Once the vic\\xADtim vis\\xADits the page, the browser will send an UP\\xADGRADE re\\xADquest header to\\xADgether with the ses\\xADsion cookie. In a nor\\xADmal sce\\xADnario, the server re\\xADsponds with CORS re\\xADsponse head\\xADers that would pre\\xADvent the cross-\\u200Borigin con\\xADnec\\xADtion. How\\xADever, the in\\xADter\\xADest\\xADing fact is that WS does not re\\xADspect SOP or CORS pol\\xADicy and the con\\xADnec\\xADtion will ac\\xADtu\\xADally be es\\xADtab\\xADlished. As a re\\xADsult, the at\\xADtacker can now leak the CSRF token and forge suc\\xADcess\\xADful CSRF at\\xADtacks.\"), mdx(\"p\", null, \"\\u2022    \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"In\\xADcor\\xADrect SOP re\\xADlax\\xADation (e.g. faulty CORS)\"), \": is also a pos\\xADsi\\xADble at\\xADtack vec\\xADtor that can lead to CSRF token leak\\xADage. An over-\\u200Bpermissive CORS that sets the re\\xADsponse head\\xADers Access-\\u200BControl-Allow-Origin: true and Access-\\u200BControl-Allow-Credentials:true would leak the CSRF token of the vic\\xADtim. The at\\xADtacker can sim\\xADply per\\xADform a GET re\\xADquest to re\\xADtrieve the CSRF-\\u200Bprotected HTML form, read the re\\xADsponse and steal the CSRF token. Then, he can con\\xADtinue per\\xADform\\xADing a CSRF at\\xADtack by pro\\xADvid\\xADing the valid CSRF token.\"), mdx(\"p\", null, \"Note: Same\\xADSite cook\\xADies ap\\xADpear to be the next at\\xADtempt to pre\\xADvent CSRF at\\xADtacks. Al\\xADthough Same\\xADSite raises the bar for at\\xADtack\\xADers, it is not per\\xADfect as well. For ex\\xADam\\xADple, Same\\xADSite: Lax does not com\\xADpletely pre\\xADvent CSRF. Three pos\\xADsi\\xADble at\\xADtacks can be ex\\xADploited: 1) at\\xADtacker can use top-\\u200Blevel nav\\xADi\\xADga\\xADtion (\", mdx(\"code\", null, \"<\", \"a\", \">\"), \") to trig\\xADger GET-\\u200Bbased CSRF. 2) \\u201CClient-\\u200Bside\\u201D CSRF can cir\\xADcum\\xADvent this mech\\xADa\\xADnism and even send POST-\\u200Bbased CSRF re\\xADquests with cook\\xADies at\\xADtached. 3) \", mdx(\"code\", null, \"<\", \"por\\xADtal\", \">\"), \", a new HTML tag that was in\\xADtro\\xADduced by Google in the end of 2019 for per\\xADfor\\xADmant web\\xADsite fram\\xADing. Until now, it is still a draft and only avail\\xADable on Google Ca\\xADnary. How\\xADever, de\\xADvel\\xADop\\xADers should be aware of the se\\xADcu\\xADrity risks. If the tar\\xADget web ap\\xADpli\\xADca\\xADtion is em\\xADbed\\xADded into at\\xADtacker\\u2019s site using \", mdx(\"code\", null, \"<\", \"por\\xADtal\", \">\"), \", then the browser will send the Same\\xADSite=Lax cookie even if it is a cross-\\u200Borigin re\\xADquest \", \"[32]\", \". Re\\xADcent at\\xADtacks show that Same\\xADSite can also be cir\\xADcum\\xADvented with other means \", \"[33]\", \".\"), mdx(\"p\", null, \"I hope that de\\xADvel\\xADop\\xADers be\\xADcome aware of these at\\xADtack vec\\xADtors and read the doc\\xADu\\xADmen\\xADta\\xADtion of the frame\\xADwork they use care\\xADfully. There is cur\\xADrently no frame\\xADwork that pre\\xADvents all these at\\xADtack vec\\xADtors and if se\\xADcu\\xADrity is your pri\\xADor\\xADity, make sure to check that you are safe from the above-\\u200Bmentioned at\\xADtack vec\\xADtors.\"), mdx(\"h3\", {\n    \"id\": \"references\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#references\"\n  })), \"References\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\"\n  }), \"https://owasp.org/www-\\u200Bproject-top-ten/2017/A7_2017-\\u200BCross-Site_Script\\xADing_(XSS)\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://doi.org/10.1145/54289.871709\"\n  }), \"https://doi.org/10.1145/54289.871709\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.securityfocus.com\"\n  }), \"https://www.se\\xADcu\\xADri\\xADty\\xADfo\\xADcus.com\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://web.archive.org/web/20000622042229/http://www.zope.org/Members/jim/ZopeSecurity/ClientSideTrojan\"\n  }), \"https://web.archive.org/web/20000622042229/http://www.zope.org/Mem\\xADbers/jim/ZopeSe\\xADcu\\xADrity/ClientSide\\xADTro\\xADjan\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://crypto.stanford.edu/cs155old/cs155-spring08/papers/Session_Riding.pdf\"\n  }), \"https://crypto.stan\\xADford.edu/cs155old/cs155-\\u200Bspring08/pa\\xADpers/Ses\\xADsion_Rid\\xADing.pdf\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://homes.cs.washington.edu/~yoshi/papers/czeskis-arls.pdf\"\n  }), \"https://homes.cs.wash\\xADing\\xADton.edu/~yoshi/pa\\xADpers/czeskis-\\u200Barls.pdf\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://tools.ietf.org/html/rfc7617\"\n  }), \"https://tools.ietf.org/html/rfc7617\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.kb.cert.org/vuls/id/584089/\"\n  }), \"https://www.kb.cert.org/vuls/id/584089/\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.kb.cert.org/vuls/id/264385/\"\n  }), \"https://www.kb.cert.org/vuls/id/264385/\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://people.eecs.berkeley.edu/~daw/teaching/cs261-f11/reading/csrf.pdf\"\n  }), \"https://peo\\xADple.eecs.berke\\xADley.edu/~daw/teach\\xADing/cs261-f11/read\\xADing/csrf.pdf\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://dl.acm.org/doi/10.1145/1455770.1455782\"\n  }), \"https://dl.acm.org/doi/10.1145/1455770.1455782\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://twitter.com/TwitterSupport/status/25614603915\"\n  }), \"https://twit\\xADter.com/Twit\\xADter\\xADSup\\xADport/sta\\xADtus/25614603915\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern\"\n  }), \"https://cheat\\xADsheet\\xADseries.owasp.org/cheat\\xADsheets/Cross-\\u200BSite_Re\\xADquest_Forgery_Pre\\xADven\\xADtion_Cheat_Sheet.html#synchronizer-\\u200Btoken-pattern\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie\"\n  }), \"https://cheat\\xADsheet\\xADseries.owasp.org/cheat\\xADsheets/Cross-\\u200BSite_Re\\xADquest_Forgery_Pre\\xADven\\xADtion_Cheat_Sheet.html#double-\\u200Bsubmit-cookie\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html\"\n  }), \"https://cheat\\xADsheet\\xADseries.owasp.org/cheat\\xADsheets/Cryp\\xADto\\xADgraphic_Stor\\xADage_Cheat_Sheet.html\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://cheatsheetseries.owasp.org/cheatsheets/Key%5C_Management%5C_Cheat%5C_Sheet.html%5C#key-management-lifecycle-best-practices\"\n  }), \"https://cheat\\xADsheet\\xADseries.owasp.org/cheat\\xADsheets/Key\\\\_Man\\xADage\\xADment\\\\_Cheat\\\\_Sheet.html\\\\#key-\\u200Bmanagement-lifecycle-best-practices\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://nvd.nist.gov/vuln/detail/CVE-2020-11825\"\n  }), \"https://nvd.nist.gov/vuln/de\\xADtail/CVE-2020-11825\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://owasp.org/www-chapter-london/assets/slides/David_Johansson-Double_Defeat_of_Double-Submit_Cookie.pdf\"\n  }), \"https://owasp.org/www-\\u200Bchapter-london/as\\xADsets/slides/David_Johansson-\\u200BDouble_De\\xADfeat_of_Double-\\u200BSubmit_Cookie.pdf\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://www.breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf\"\n  }), \"http://www.breachat\\xADtack.com/re\\xADsources/BREACH%20-%20SSL,%20gone%20in%2030%20sec\\xADonds.pdf\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://blog.jeremiahgrossman.com/2006/08/i-know-where-youve-been.html\"\n  }), \"https://blog.je\\xADre\\xADmi\\xADah\\xADgross\\xADman.com/2006/08/i-\\u200Bknow-where-youve-been.html\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Clickjacking\"\n  }), \"https://en.wikipedia.org/wiki/Click\\xADjack\\xADing\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.contextis.com/media/downloads/Next_Generation_Clickjacking.pdf\"\n  }), \"https://www.con\\xADtex\\xADtis.com/media/down\\xADloads/Next_Gen\\xADer\\xADa\\xADtion_Click\\xADjack\\xADing.pdf\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://media.blackhat.com/bh-ad-11/Lundeen/bh-ad-11-Lundeen-New_Ways_Hack_WebApp-WP.pdf\"\n  }), \"https://media.black\\xADhat.com/bh-\\u200Bad-11/Lun\\xADdeen/bh-\\u200Bad-11-\\u200BLundeen-New_Ways_Hack_WebApp-\\u200BWP.pdf\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://homakov.blogspot.com/2013/03/hacking-github-with-webkit.html\"\n  }), \"http://homakov.blogspot.com/2013/03/hacking-\\u200Bgithub-with-webkit.html\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.sjoerdlangkemper.nl/2020/05/27/overwriting-httponly-cookies-from-javascript-using-cookie-jar-overflow/\"\n  }), \"https://www.sjo\\xADerd\\xADlangkem\\xADper.nl/2020/05/27/overwriting-\\u200Bhttponly-cookies-from-javascript-using-cookie-jar-overflow/\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://cwe.mitre.org/data/definitions/208.html\"\n  }), \"https://cwe.mitre.org/data/de\\xADf\\xADi\\xADn\\xADi\\xADtions/208.html\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.ietf.org/rfc/rfc2616.txt\"\n  }), \"https://www.ietf.org/rfc/rfc2616.txt\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/hapijs/crumb/issues/4\"\n  }), \"https://github.com/hapijs/crumb/is\\xADsues/4\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://blog.nibblesec.org/2014/05/nodejs-connect-csrf-bypass-abusing.html\"\n  }), \"http://blog.nib\\xADblesec.org/2014/05/nodejs-\\u200Bconnect-csrf-bypass-abusing.html\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Replay_attack\"\n  }), \"https://en.wikipedia.org/wiki/Re\\xADplay_at\\xADtack\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://christian-schneider.net/CrossSiteWebSocketHijacking.html\"\n  }), \"https://christian-\\u200Bschneider.net/Cross\\xADSiteWeb\\xADSock\\xADetHi\\xADjack\\xADing.html\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://research.securitum.com/security-analysis-of-portal-element/\"\n  }), \"https://re\\xADsearch.se\\xADcu\\xADri\\xADtum.com/security-\\u200Banalysis-of-portal-element/\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.facebook.com/notes/facebook-bug-bounty/client-side-csrf/2056804174333798/?fref=mentions\"\n  }), \"https://www.face\\xADbook.com/notes/facebook-\\u200Bbug-bounty/client-\\u200Bside-csrf/2056804174333798/?fref=men\\xADtions\"))));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>The first mile­stone re­leases of Vert.x 4.0.0 suf­fered from <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35217\">CVE-2020-35217</a>. Thanks to Xhe­lal, we were able to ad­dress the\nse­cu­rity bugs and fix it on the first beta. This blog post is a ex­pla­na­tion why CSRF should be used in your web\nap­pli­ca­tions.</p><h3 id=\"be-aware-of-the-danger-cross-site-request-forgery-csrf\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#be-aware-of-the-danger-cross-site-request-forgery-csrf\"></a>Be aware of the danger: Cross-Site Request Forgery (CSRF)</h3><p>A pop­u­lar web vul­ner­a­bil­ity that has at­tracted a lot of at­ten­tion in the re­search com­mu­nity is Cross-​Site Script­ing\n(XSS). This vul­ner­a­bil­ity al­lows the at­tacker to in­ject ar­bi­trary JavaScript (JS) code on a web­site that will run in the\nsame ori­gin as the web­site. Ac­cord­ing to the Open Web Ap­pli­ca­tion Se­cu­rity Project (OWASP), XSS is the sec­ond most\npreva­lent issue in the 2017’s OWASP Top <!-- -->[1]<!-- -->, and it is found in around two-​thirds of all web ap­pli­ca­tions. How­ever,\nwhile XSS gets all the at­ten­tion, few de­vel­op­ers pay at­ten­tion to an­other at­tack that can be equally de­struc­tive and far\neas­ier to ex­ploit. This at­tack is called Cross-​Site Re­quest Forgery (CSRF). It was ranked by OWASP as the fifth most\ndan­ger­ous web vul­ner­a­bil­ity twice (2007, 2010) and eighth in 2013. For­tu­nately, the de­vel­op­ers’ aware­ness has in­creased\nin re­cent years and most web frame­works pro­vide at least one de­fen­sive mech­a­nism against CSRF. As a re­sult, CSRF was not\nlisted in the 2017’s OWASP Top 10 list. Un­for­tu­nately, this at­tack is far from ex­tinct.</p><h3 id=\"csrf-origins\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#csrf-origins\"></a>CSRF Origins</h3><p>In 1988 Norm Hardy pub­lished a paper where he ex­plained a the­o­ret­i­cal se­cu­rity issue that he called “con­fused\ndeputy” <!-- -->[2]<!-- -->. This se­cu­rity issue was first re­ported in 2000 in Bug­Traq (nowa­days Se­cu­ri­ty­Fo­cus <!-- -->[3]<!-- -->). The post<!-- -->[4]<!-- --> in\nBug­Traq showed how ZOPE, a Python web frame­work, was vul­ner­a­ble to this web “con­fused deputy” that we today know as\nCSRF. This term (“CSRF”) was first used in June 2001 by Peter Watkins, fol­lowed by a de­tailed de­scrip­tion in 2004 by\nThomas Schreiber <!-- -->[5]<!-- -->. The au­thor de­scribed a va­ri­ety of at­tack sce­nar­ios where CSRF could be ex­ploited, pro­vid­ing the\nmost de­tailed de­scrip­tion of the prob­lem at the time. Since then CSRF has had many names such as XSRF, one-​click at­tack,\nCross-​Site Ref­er­ence Forgery, ses­sion rid­ing, sea surf, hos­tile link­ing, “sleep­ing giant” etc. For the rest of this\nblog, we will refer to this vul­ner­a­bil­ity as CSRF.</p><h3 id=\"how-does-csrf-exactly-work\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#how-does-csrf-exactly-work\"></a>How does CSRF exactly work?</h3><p>There are many de­f­i­n­i­tions for it in the lit­er­a­ture, but the core idea re­mains the same; in a CSRF at­tack the vic­tim’s\nbrowser is tricked by an at­tacker into send­ing a state-​changing HTTP re­quest with au­then­ti­ca­tion cook­ies, which the\nvic­tim did not in­tend. This ex­ploits the fact that cook­ies are widely used on the in­ter­net and browsers au­to­mat­i­cally\nat­tach them to re­quests <!-- -->[6]<!-- -->. For in­stance, on­line shops, so­cial net­works, web­mail ap­pli­ca­tions, etc. use cook­ies to\nmain­tain state and track/re-​identify users with­out need­ing to reau­then­ti­cate. The rea­son cook­ies are used is be­cause\nHTTP is a state­less pro­to­col. The server re­sponds to a re­ceived re­quest and then “for­gets” about the con­nec­tion. To\npre­vent this state­less­ness of HTTP, the au­then­ti­ca­tion in­for­ma­tion is stored some­where in the server-​side (e.g. ses­sion\nstore, data­base, etc.) and the browser re­ceives only an iden­ti­fier (ID) from the server for that ses­sion, often via a\ncookie. The browser stores this cookie and when a user sends a re­quest to the server, the browser will also\nau­to­mat­i­cally at­tach the cookie(s) for this web ap­pli­ca­tion. The server re­trieves the Ses­sion ID from the cookie and\nlooks up in its ses­sion stor­age or data­base to re­trieve the user’s data, iden­ti­fied by the Ses­sion ID.</p><p>Many al­ter­na­tives exist when it comes to forg­ing a CSRF re­quest. If a state-​changing re­quest can be ex­e­cuted through\nHTTP GET, then an at­tacker can ex­ploit this in (mainly) two ways. One op­tion would be for the at­tacker to send an email\nthat con­tains a HTML tag with the CSRF pay­load (e.g. <code>&lt;<!-- -->img src=”<a href=\"http://bank.com/transfer?amount=x&amp;dest=y%22/\">http://bank.com/trans­fer?amount=x<!-- -->&amp;<!-- -->dest=y”/</a>&gt;</code>). If the\nweb­mail ap­pli­ca­tion loads HTML im­ages au­to­mat­i­cally, then the browser will send the HTTP GET re­quest and the CSRF at­tack\nsuc­ceeds. The sec­ond op­tion is for the at­tacker to trick the user into vis­it­ing his ma­li­cious web­site, which con­tains\nthe above HTML image tag. Note that the at­tacker is not lim­ited to only the <code>&lt;<!-- -->img<!-- -->&gt;</code> tag. The at­tack can be trig­gered\nby using dif­fer­ent HTML tags, which usu­ally pro­vide a src at­tribute. How­ever, in most cases, ap­pli­ca­tions per­form\nstate-​changing re­quest through HTTP POST re­quests. In this case, the at­tacker has to cre­ate a hid­den JS form in his\nma­li­cious web­site with the exact form fields that the server is ex­pect­ing. Then, the at­tacker can use JS’s events (e.g.\non­load()) to au­to­mat­i­cally post the hid­den form when the vic­tim loads/vis­its the page.</p><p>CSRF can be con­sid­ered a type of the con­fused deputy at­tack where the web browser (con­fused deputy) is tricked into\nsend­ing a forged re­quest (for a less priv­i­leged at­tacker) to a web ap­pli­ca­tion. A CSRF at­tack works be­cause, by de­sign,\na web browser au­to­mat­i­cally at­taches all cook­ies that it has for the tar­get web ap­pli­ca­tion when a re­quest is sent. A\nserver that does not pro­tect against CSRF would ac­cept and ex­e­cute the re­quest as com­ing from the vic­tim since the\nses­sion cookie was part of the re­quest. What is worse, the vic­tim is not aware of the at­tack until when it is too late.\nThe fig­ure below shows the steps of a com­mon CSRF at­tack. How­ever, some con­di­tions have to be ful­filled for the at­tack\nto work:</p><ul><li>The at­tacker must find an un­pro­tected state-​changing op­er­a­tion in the tar­get web ap­pli­ca­tion.</li><li>The vic­tim must be al­ready au­then­ti­cated to the tar­get web ap­pli­ca­tion (i.e. a ses­sion cookie is al­ready stored in his/her browser).</li><li>The at­tacker must forge the state-​changing re­quest cor­rectly. This means that the at­tacker must in­clude all HTML form fields or re­quest pa­ra­me­ters that the server-​side ex­pects.</li><li>The at­tacker has to trick the au­then­ti­cated vic­tim into vis­it­ing the at­tacker’s web­site (where the CSRF at­tack will take place) or trick the vic­tim into click­ing a link.</li><li>The means for au­then­ti­ca­tion must be au­to­mat­i­cally at­tached to the re­quest by the browser (e.g. Basic Au­then­ti­ca­tion re­quest header <!-- -->[7]<!-- --> or cook­ies). Note that, dif­fer­ent from XSS, CSRF aims to reuse the ses­sion cookie, not steal it.</li></ul><h3 id=\"impact-of-csrf-attacks\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#impact-of-csrf-attacks\"></a>Impact of CSRF attacks</h3><p>The im­pact of the at­tack de­pends on the spe­cific op­er­a­tion that is vul­ner­a­ble to CSRF, but also on the priv­i­leges that\nthe vic­tim has. This can re­sult in a money trans­fer, change of pass­word, a pur­chase in a shop­ping web­site, ac­count\ncom­pro­mise, cre­ated admin user, etc. Some­times CSRF can be even more dan­ger­ous than ses­sion hi­jack­ing. For in­stance, in\na court case, the vic­tim can­not argue that he did not per­form a trans­ac­tion be­cause the IP of the re­quest (al­though\nun­in­tended) was that of the vic­tim. To makes things even worse, the vic­tim doesn’t even know which ma­li­cious web­site he\nvis­ited that trig­gered the CSRF at­tack. In the case of ses­sion hi­jack­ing, the ma­li­cious at­tacker logs in with stolen\ncre­den­tials (usu­ally) from an IP ad­dress dif­fer­ent from that of the vic­tim’s. There­fore, in this case, the vic­tim can\nargue that he was the vic­tim of an at­tack. There have also been other ex­am­ples of CSRF at­tacks that lead to re­mote code\nex­e­cu­tion with root priv­i­leges <!-- -->[8]<!-- --> or com­pro­mise of a root cer­tifi­cate <!-- -->[9]<!-- -->.</p><p>Some­times CSRF is mis­tak­enly con­fused with XSS, but they are two dif­fer­ent at­tacks. XSS aims to ex­e­cute ar­bi­trary JS\ncode on a vul­ner­a­ble web­site. It abuses the trust that a client has in a cer­tain web ap­pli­ca­tion, thus click­ing the\nlink. On the other hand, CSRF tricks the user’s browser to send un­in­tended HTTP re­quests to a vul­ner­a­ble web\nap­pli­ca­tion. It ex­ploits the trust that a web ap­pli­ca­tion has in the user. The web ap­pli­ca­tion as­sumes that if a re­quest\nwas re­ceived, then it orig­i­nated from the user (be­cause of the ses­sion cookie) and ex­e­cutes it. Ad­di­tion­ally, in a CSRF\nex­ploit the at­tacker can trick the vic­tim’s browser to send an HTTP re­quest, but he can­not read the re­sponse of that\nre­quest while XSS can issue re­quests and also read the re­sponse. XSS at­tacks are based on JS, while CSRF at­tacks can\nalso be car­ried out just by using a crafted HTML form. Fi­nally, if a web ap­pli­ca­tion is vul­ner­a­ble to XSS, then it is\nalso vul­ner­a­ble to CSRF. How­ever, if a web ap­pli­ca­tion is safe from XSS, it might still be vul­ner­a­ble to CSRF.</p><p>Since its dis­cov­ery in 2001, there have been many re­ported CSRF at­tacks. Major web­sites such as Net­flix, Google, Yahoo,\nfi­nan­cial in­sti­tutes, Face­book, etc. have been vul­ner­a­ble to CSRF and in some cases even more than once. Some of the\nmost fa­mous cases are:</p><ul><li>The Net­flix web­site (2006): an at­tacker could add a DVD to the vic­tim’s shop­ping cart, change the ship­ping ad­dress of the vic­tim, or even com­pro­mise his/her ac­count.</li><li>New York Time’s web­site <!-- -->[10]<!-- -->: CSRF that leaks the email ad­dress of the user. It was used for spam­ming the vic­tims. The web­site kept users logged in for over a year.</li><li>ING Di­rect web ap­pli­ca­tion <!-- -->[10]<!-- -->: vul­ner­a­ble to a CSRF at­tack that al­lowed unau­tho­rized money trans­fers from vic­tim’s ac­count to the at­tacker’s ac­count.</li><li>YouTube <!-- -->[10]<!-- -->: The vul­ner­a­bil­ity al­lowed the at­tacker to per­form al­most all ac­tions that a user can nor­mally do.</li><li>Google, Yahoo, Pay­Pal (2008) <!-- -->[11]<!-- --> were vul­ner­a­ble to Login CSRF.</li><li>Face­book (2009) was vul­ner­a­ble to CSRF. The at­tacker could use an HTML <code>&lt;<!-- -->img<!-- -->&gt;</code> tag to steal the user’s ac­count in­for­ma­tion.</li><li>MetaFil­ter <!-- -->[10]<!-- -->: the vul­ner­a­bil­ity al­lowed an at­tacker to take con­trol of a user’s ac­count.</li><li>Twit­ter <!-- -->[12]<!-- --> was also vul­ner­a­ble to CSRF in 2010. When au­then­ti­cated users vis­ited the ma­li­cious web­site, they un­in­ten­tion­ally posted two tweets – one with a link lead­ing to this ma­li­cious web­site and an­other with a tweet about goats. Every user who clicked on the link pro­vided in the first tweet also posted those two tweets, hence the worm was spread.</li></ul><h3 id=\"most-popular-anti-csrf-defenses\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#most-popular-anti-csrf-defenses\"></a>Most popular anti-CSRF defenses</h3><p>Syn­chro­nizer Token Pat­tern (STP) <!-- -->[13]<!-- --> is one of the most pop­u­lar coun­ter­mea­sures. A se­cret, unguess­able, ran­dom value\n(known as CSRF token) is gen­er­ated on the server-​side using a cryptographically-​secure pseudo­ran­dom gen­er­a­tor (CSPRNG)\nwith a ran­dom input/seed. The gen­er­ated token is stored in server-​side stor­age and must be tied to a spe­cific user\n(usu­ally linked to the Ses­sion ID). This stor­age can be a ses­sion data­s­tore (e.g. Redis), a data­base, a filesys­tem (e.g.\nin PHP), server’s mem­ory, etc. The CSRF token is sent as part of the server’s re­sponse and is usu­ally placed in a hid­den\nHTML form field. Once a re­quest ar­rives in server-​side, the server will use the Ses­sion ID from the ses­sion cookie\n(found in the in­com­ing re­quest) to ex­tract the CSRF token from the stor­age. It will then com­pare it against the CSRF\ntoken that came as part of the re­quest’s body (or in a cus­tom header).</p><p>Dou­ble Sub­mit Cookie <!-- -->[14]<!-- --> is an­other pop­u­lar coun­ter­mea­sure that makes use of cook­ies in­stead of ses­sion stor­age to\nstore a CSRF token. The se­cu­rity of this coun­ter­mea­sure re­lies on the SOP. Only JS run­ning within the same ori­gin is\nal­lowed to read or mod­ify the cookie’s value. The server-​side gen­er­ates a CSRF token same as in the STP coun­ter­mea­sure.\nThe server cre­ates a cookie with the CSRF token in it and sends both this cookie and the CSRF token (usu­ally in an HTML\nform) to the client-​side. When a re­quest is sent to the server-​side, this cookie that holds the CSRF token will be\nau­to­mat­i­cally sent by the browser in ad­di­tion to the CSRF token in the re­quest body/cus­tom header, hence the name\n“Dou­ble Sub­mit”. The server-​side will re­trieve the CSRF token from the cookie and com­pare against the CSRF token in the\nre­quest body/cus­tom HTTP re­quest header.</p><h3 id=\"great-does-not-mean-perfect\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#great-does-not-mean-perfect\"></a>Great does not mean perfect!</h3><p>Al­though anti-​CSRF de­fenses mit­i­gate CSRF at­tacks to a great ex­tent, they are not per­fect and may be sus­cep­ti­ble to\ndif­fer­ent at­tacks vec­tors:</p><h4 id=\"cryptography-concerns\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#cryptography-concerns\"></a>Cryptography concerns</h4><ul><li>Use of un­safe func­tions for ran­dom­ness: the func­tion that is used to gen­er­ate CSRF to­kens/se­crets is cru­cial for se­cu­rity. Pseudo-​Random Num­ber Gen­er­a­tors (PRNG) are fast func­tions that out­put low-​quality ran­dom­ness and should not be used to gen­er­ate strings for crit­i­cal se­cu­rity op­er­a­tions. It is ad­vised to use cryptographically-​secure PRNG (CSPRNG) in­stead. They pro­vide enough ran­dom­ness/en­tropy in ex­change for longer gen­er­a­tion time. Most lan­guages pro­vide a CSPRNG <!-- -->[15]<!-- --> so make sure to check be­fore you end up using func­tions like Math.Ran­dom().</li><li>In­suf­fi­cient ran­dom­ness of the (CSRF) token: to­kens need to be ran­domly gen­er­ated (i.e. high en­tropy) so that it can­not be guessed or brute-​forced in a rea­son­able amount of time. In order to with­stand the com­pu­ta­tion power of today’s com­put­ers, to­kens needs to have an en­tropy of at least 128-bit to be con­sid­ered se­cure.</li><li>In­suf­fi­cient ran­dom­ness of the cryp­to­graphic key: in those cases when the CSRF token/cookie is signed and/or en­crypted (for ad­di­tional se­cu­rity or to pre­vent tam­per­ing), the se­cret key that is used for en­crypt­ing or sign­ing dur­ing token gen­er­a­tion might not be se­cure enough. The se­cret key should be ran­dom enough so that the at­tacker can­not eas­ily brute-​force it. De­vel­op­ers often copy and paste it from the doc­u­men­ta­tion code snip­pet or Stack Over­flow posts with­out re­al­iz­ing the risks.</li><li>Lack of key ro­ta­tion: se­cret keys should often be ro­tated. The life­time of the cryp­to­graphic key is im­por­tant and de­pends on many fac­tors as al­ready cov­ered in de­tail by OWASP <!-- -->[16]<!-- -->.</li><li>Use of in­se­cure cryp­to­graphic al­go­rithms: a web frame­work might still be using an in­se­cure cryp­to­graphic al­go­rithm such as DES, MD-5, SHA-1, or use un­safe block ci­pher such as Elec­tronic Code Book (ECB). OWASP pro­vides de­tailed doc­u­men­ta­tion con­cern­ing cryp­to­graphic op­er­a­tions (as men­tioned above).</li><li>Use of dep­re­cated/un­patched cryp­to­graphic li­braries: the cryp­to­graphic al­go­rithms are often pro­vided by li­braries. An un­patched or dep­re­cated li­brary might be prob­lem­atic and de­vel­op­ers should al­ways be using the lat­est (patched) ver­sion.</li><li>In­se­cure stor­age of the ap­pli­ca­tion’s cryp­to­graphic key: aside from ran­dom­ness and key ro­ta­tion, its stor­age is also im­por­tant. Stor­ing a se­cret key hard­coded in the source code (or in some other in­se­cure lo­ca­tion) would com­pro­mise the key if the code is leaked or a (ma­li­cious) em­ployee has ac­cess to it.</li><li>Server-​side token stor­age: A pos­si­ble im­ple­men­ta­tion mis­take (for STP de­fense for ex­am­ple) would be the in­cor­rect map­ping user-​token be­tween the user and the CSRF se­cret that is stored on the server-​side. An in­cor­rect map­ping might lead to many users hav­ing the same token. If the at­tacker and vic­tim share the same token, the at­tacker can eas­ily forge a suc­cess­ful CSRF at­tack. Al­though this might sound as im­prob­a­ble, it has even hap­pened re­cently <!-- -->[17]<!-- -->.</li></ul><h4 id=\"token-transmission-from-server-side-to-client-side\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#token-transmission-from-server-side-to-client-side\"></a>Token transmission from server-side to client-side</h4><ul><li>MITM at­tacks: Trans­mis­sion of the se­cret val­ues over HTTP is in­se­cure since a net­work at­tacker can per­form a tra­di­tional MITM at­tack by in­ter­cept­ing the re­quest and leak the CSRF token. Ad­di­tion­ally, SSL strip­ping at­tack or a more ad­vanced MITM <!-- -->[18]<!-- --> might be ex­ploited.</li><li>BREACH <!-- -->[19]<!-- -->: is an­other at­tack vec­tor that can leak the CSRF token using a compression-​based side-​channel if the HTTP re­sponse is com­pressed. This at­tack is pos­si­ble if the CSRF token is in the HTTP re­sponse body (which nor­mally is), along with some user-​specified input. The au­thors that dis­cov­ered BREACH showed how they leaked a CSRF token in 30 sec­onds in Mi­crosoft’s Out­look Web Ac­cess web­site.</li><li>Plac­ing the token in the URL: is a com­mon mis­take that might lead to CSRF token leak­age through log files, browser his­tory and Refer(r)er header. An­other trick is to re­trieve the CSRF token by using the so-​called “CSS His­tory Hack” <!-- -->[20]<!-- -->.</li></ul><h4 id=\"https-request-with-the-csrf-token-from-client-side\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#https-request-with-the-csrf-token-from-client-side\"></a>HTTP(S) request with the CSRF token from client-side</h4><ul><li>Code in­jec­tion (XSS, Dan­gling Markup, CSS tricks): this cat­e­gory of at­tacks aims to leak the se­cret token by using JS (XSS), HTML (Dan­gling markup), or CSS. Any XSS vec­tor can be used to leak the CSRF token that is placed in the hid­den HTML form. One might think that CSRF is point­less when the at­tacker can al­ready per­form XSS, a larger threat than CSRF. How­ever, there are cases when the at­tacker can be de­tected, e.g. in server-​side XSS cases. Al­ter­na­tively, an XSS vec­tor in a sub­do­main might be ex­ploited to at­tack an XSS-​secure tar­get par­ent do­main. For in­stance, the at­tacker can use the XSS in the sub­do­main to set cook­ies for the par­ent do­main and per­form a cookie toss­ing at­tack (to be dis­cussed soon). Dan­gling Markup is an­other kind of at­tack that uses HTML to ex­tract the CSRF token when attacker-​controlled input is re­flected in the HTML. A de­tailed ex­am­ple of this at­tack can be found in this blog by Gareth Heyes\\cite{dan­gling}.</li><li>Click­jack­ing <!-- -->[21]<!-- -->: is an­other at­tack that can leak CSRF token or ren­der the CSRF de­fense use­less. The de­fense can be by­passed by fram­ing the tar­get web ap­pli­ca­tion on the at­tacker’s web­site. The vic­tim is then tricked into sub­mit­ting an HTML form on the tar­get web ap­pli­ca­tion (same ori­gin) which is loaded in­side the at­tacker’s web­site with the CSRF token in it. Since the CSRF token is part of the re­quest, the de­fense be­comes point­less. How­ever, tra­di­tional Click­jack­ing is lim­ited to click­ing but­tons while in re­al­ity, an HTML form has to be filled in order to per­form a sen­si­tive op­er­a­tion. Stone <!-- -->[22]<!-- --> showed how Click­jack­ing could be used to achieve this. He sug­gests the use of drag-​and-drop API to leak the CSRF token and/or fill HTML forms.</li></ul><h4 id=\"cookie-injection-for-cookie-based-mechanisms-like-double-submit-cookie\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#cookie-injection-for-cookie-based-mechanisms-like-double-submit-cookie\"></a>Cookie injection (for cookie-based mechanisms like Double Submit Cookie)**</h4><ul><li>Cookie toss­ing <!-- -->[23]<!-- -->: this at­tack vec­tor is the nat­ural enemy of Dou­ble Sub­mit coun­ter­mea­sure and ex­ploits the fact that an attacker-​controlled sub­do­main can set a cookie for the tar­get par­ent do­main. It also ex­ploits the com­plex na­ture of cook­ies. A cookie is stored as a unique com­bi­na­tion of name/do­main/path in the browser. Be­cause name/do­main/path de­ter­mine the unique­ness of a cookie, an at­tacker can cre­ate a cookie from a sub­do­main that he con­trols with the same name and do­main but with a dif­fer­ent path. This will cre­ate a whole new cookie and the browser will store it even if it has the same name. When the re­quest is sent, the browser will at­tach this header: “Cookie: Xname=good; Xname=bad” (and no other cookie at­trib­utes). As a re­sult, the server that hosts the tar­get par­ent do­main now sees two cook­ies with the same name but can­not dis­tin­guish which one be­longs to the par­ent do­main. The suc­cess of the at­tack re­lies on the fact that the at­tacker’s cookie (i.e. “Xname=bad” cookie) is the one that is con­sid­ered by the server. To in­crease the suc­cess chance, the at­tacker can also in­clude a spe­cific path in the forged cookie, e.g. path=trans­fer. This ex­ploits the fact that (most) browsers will con­sider a cookie with a path to be the “more specifically-​scoped” and will send it first. Some pro­gram­ming lan­guages (e.g. PHP) cre­ate an array from the Cookie header and only con­sider the first cookie of the array. Other lan­guages like Python con­sider the last cookie in the array. Egor Homakov <!-- -->[24]<!-- --> showed a de­tailed ex­am­ple of a real-​life ap­pli­ca­tion of cookie toss­ing on GitHub.</li><li>Cookie jar over­flow <!-- -->[25]<!-- -->: is an at­tack vec­tor that tar­gets the web browser’s cookie jar. When a web­site sets a cookie, the browser adds it to the cookie jar which can be thought of as a data­base in the browser that stores cook­ies. Just like a real jar, there is a limit to how many cook­ies it can store. Fire­fox al­lows up to 150 cook­ies while Chrome al­lows 180. If the limit is reached, the browser will start re­plac­ing old cook­ies with new ones. There­fore, an at­tacker can do a cookie jar over­flow to “kick out” every sin­gle cookie of the par­ent do­main and re­place them with attacker-​specified cook­ies (and CSRF token) just by run­ning a JS snip­pet code on a sub­do­main. Even if the at­tacker can­not mod­ify a cookie (e.g. HttpOnly or Same­Site), he can use this over­flow to con­trol what cook­ies the browser stores.</li></ul><h4 id=\"server-side-csrf-verification\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#server-side-csrf-verification\"></a>Server-side CSRF verification**</h4><ul><li>In­se­cure token com­par­i­son (tim­ing at­tacks) <!-- -->[26]<!-- -->: tim­ing at­tacks on token com­par­i­son can hap­pen if a token com­par­i­son is done using the ”==” op­er­a­tor or a func­tion that is based on this op­er­a­tor. The du­ra­tion of the com­par­i­son is longer for strings with many char­ac­ters in com­mon (e.g. “uni­ver­sity” and “uni­verse”) and shorter oth­er­wise (e.g., “uni­ver­sity” and “test”). This time dif­fer­ence in the com­par­i­son can be used as a side-​channel to guess the CSRF token.</li><li>Miss­ing checks for “safe” HTTP meth­ods: a com­mon mis­take is to per­form CSRF ver­i­fi­ca­tion only for un­safe HTTP meth­ods such as POST, PUT, DELETE, PATCH. In­deed, ac­cord­ing to RFC 2616 <!-- -->[27]<!-- -->, “safe” meth­ods should be idem­po­tent. How­ever, de­vel­op­ers use GET-​based re­quests for state-​changing op­er­a­tions quite often in prac­tice (e.g. for log out). This al­lows for GET-​based CSRF at­tacks to hap­pen.</li><li>Miss­ing check for non-​POST un­safe HTTP meth­ods: is an even more dan­ger­ous prac­tice. There are few frame­work de­vel­op­ers that only per­form CSRF ver­i­fi­ca­tion only for POST re­quests and ig­nore other un­safe meth­ods such as DELETE or PUT. In some cases, the de­vel­oper doesn’t un­der­stand the risk of such be­hav­ior <!-- -->[28]<!-- -->.</li><li>HTTP Method Over­ride is also a “fea­ture” that can by­pass the CSRF ver­i­fi­ca­tion that is per­formed only for spe­cific HTTP head­ers. The at­tacker can forge his re­quest as a GET re­quest and also add a cus­tom re­quest header (X-​HTTP-Method-Override) to over­ride the re­quest method to PUT, POST, or DELETE. Usu­ally, this is pro­vided as a mid­dle­ware. If this mid­dle­ware is spec­i­fied after the CSRF mid­dle­ware, then the CSRF ver­i­fi­ca­tion will be by­passed be­cause it con­sid­ers the re­quest as GET. Next, when method over­ride mid­dle­ware is ex­e­cuted, it will change the re­quest method to POST and will ex­e­cute the CSRF re­quest <!-- -->[29]<!-- -->. An­other at­tack vec­tor using HTTP Method Over­ride hap­pens when the at­tacker spec­i­fies an ar­bi­trary name as a mod­i­fied re­quest method and the coun­ter­mea­sure will trig­ger the CSRF ver­i­fi­ca­tion only for a list of spec­i­fied meth­ods (e.g. only for POST, DELETE, etc.). In this case, the ver­i­fi­ca­tion will not be called at all, lead­ing to CSRF.</li><li>Log­i­cal er­rors: are all er­rors that don’t throw an ex­cep­tion but have a flaw in the code’s logic or pro­gram­ming mis­takes (e.g. in­cor­rect “if-​else” clauses). As we will see dur­ing the field study, there are few frame­works that have ac­tu­ally fallen vic­tim to this prob­lem.</li><li>Re­play at­tack <!-- -->[30]<!-- -->: is one of the old­est tricks that is usu­ally ex­ploited in cryp­to­graphic pro­to­cols. The at­tacker in­ter­cepts a mes­sage that is sent from A to B, say a re­quest for money trans­fer, and then re­play this at­tack by send­ing the in­ter­cepted mes­sage to B mul­ti­ple times. B has no way of check­ing the fresh­ness of the mes­sage and will do the trans­ac­tion every time. This can hap­pen with CSRF to­kens as well. An at­tacker that leaks a sin­gle CSRF token can use it mul­ti­ple times until token ex­pi­ra­tion. This at­tack is also aided by the way ses­sions are usu­ally han­dled in prac­tice. Some ses­sions can last for days or months and if time is not spec­i­fied in the cookie, the end of the ses­sion is con­sid­ered when the browser is closed. How­ever, some browsers like Chrome have “Clear cook­ies and site data when you quit Chrome” fea­ture, which is by de­fault dis­abled. As a re­sult, the ses­sion does not re­ally end even when the browser is closed.</li></ul><p>•    <strong>Cross-​Site Web­Socket Hi­jack­ing <!-- -->[31]</strong>: (WS) con­nec­tions are an­other pos­si­ble at­tack vec­tor. An at­tacker can write some code in his ma­li­cious web­site that ini­ti­ates a WS hand­shake with the tar­get server. Once the vic­tim vis­its the page, the browser will send an UP­GRADE re­quest header to­gether with the ses­sion cookie. In a nor­mal sce­nario, the server re­sponds with CORS re­sponse head­ers that would pre­vent the cross-​origin con­nec­tion. How­ever, the in­ter­est­ing fact is that WS does not re­spect SOP or CORS pol­icy and the con­nec­tion will ac­tu­ally be es­tab­lished. As a re­sult, the at­tacker can now leak the CSRF token and forge suc­cess­ful CSRF at­tacks.</p><p>•    <strong>In­cor­rect SOP re­lax­ation (e.g. faulty CORS)</strong>: is also a pos­si­ble at­tack vec­tor that can lead to CSRF token leak­age. An over-​permissive CORS that sets the re­sponse head­ers Access-​Control-Allow-Origin: true and Access-​Control-Allow-Credentials:true would leak the CSRF token of the vic­tim. The at­tacker can sim­ply per­form a GET re­quest to re­trieve the CSRF-​protected HTML form, read the re­sponse and steal the CSRF token. Then, he can con­tinue per­form­ing a CSRF at­tack by pro­vid­ing the valid CSRF token.</p><p>Note: Same­Site cook­ies ap­pear to be the next at­tempt to pre­vent CSRF at­tacks. Al­though Same­Site raises the bar for at­tack­ers, it is not per­fect as well. For ex­am­ple, Same­Site: Lax does not com­pletely pre­vent CSRF. Three pos­si­ble at­tacks can be ex­ploited: 1) at­tacker can use top-​level nav­i­ga­tion (<code>&lt;<!-- -->a<!-- -->&gt;</code>) to trig­ger GET-​based CSRF. 2) “Client-​side” CSRF can cir­cum­vent this mech­a­nism and even send POST-​based CSRF re­quests with cook­ies at­tached. 3) <code>&lt;<!-- -->por­tal<!-- -->&gt;</code>, a new HTML tag that was in­tro­duced by Google in the end of 2019 for per­for­mant web­site fram­ing. Until now, it is still a draft and only avail­able on Google Ca­nary. How­ever, de­vel­op­ers should be aware of the se­cu­rity risks. If the tar­get web ap­pli­ca­tion is em­bed­ded into at­tacker’s site using <code>&lt;<!-- -->por­tal<!-- -->&gt;</code>, then the browser will send the Same­Site=Lax cookie even if it is a cross-​origin re­quest <!-- -->[32]<!-- -->. Re­cent at­tacks show that Same­Site can also be cir­cum­vented with other means <!-- -->[33]<!-- -->.</p><p>I hope that de­vel­op­ers be­come aware of these at­tack vec­tors and read the doc­u­men­ta­tion of the frame­work they use care­fully. There is cur­rently no frame­work that pre­vents all these at­tack vec­tors and if se­cu­rity is your pri­or­ity, make sure to check that you are safe from the above-​mentioned at­tack vec­tors.</p><h3 id=\"references\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#references\"></a>References</h3><ol><li><a href=\"https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)\">https://owasp.org/www-​project-top-ten/2017/A7_2017-​Cross-Site_Script­ing_(XSS)</a></li><li><a href=\"https://doi.org/10.1145/54289.871709\">https://doi.org/10.1145/54289.871709</a></li><li><a href=\"https://www.securityfocus.com\">https://www.se­cu­ri­ty­fo­cus.com</a></li><li><a href=\"https://web.archive.org/web/20000622042229/http://www.zope.org/Members/jim/ZopeSecurity/ClientSideTrojan\">https://web.archive.org/web/20000622042229/http://www.zope.org/Mem­bers/jim/ZopeSe­cu­rity/ClientSide­Tro­jan</a></li><li><a href=\"https://crypto.stanford.edu/cs155old/cs155-spring08/papers/Session_Riding.pdf\">https://crypto.stan­ford.edu/cs155old/cs155-​spring08/pa­pers/Ses­sion_Rid­ing.pdf</a></li><li><a href=\"https://homes.cs.washington.edu/~yoshi/papers/czeskis-arls.pdf\">https://homes.cs.wash­ing­ton.edu/~yoshi/pa­pers/czeskis-​arls.pdf</a></li><li><a href=\"https://tools.ietf.org/html/rfc7617\">https://tools.ietf.org/html/rfc7617</a></li><li><a href=\"https://www.kb.cert.org/vuls/id/584089/\">https://www.kb.cert.org/vuls/id/584089/</a></li><li><a href=\"https://www.kb.cert.org/vuls/id/264385/\">https://www.kb.cert.org/vuls/id/264385/</a></li><li><a href=\"https://people.eecs.berkeley.edu/~daw/teaching/cs261-f11/reading/csrf.pdf\">https://peo­ple.eecs.berke­ley.edu/~daw/teach­ing/cs261-f11/read­ing/csrf.pdf</a></li><li><a href=\"https://dl.acm.org/doi/10.1145/1455770.1455782\">https://dl.acm.org/doi/10.1145/1455770.1455782</a></li><li><a href=\"https://twitter.com/TwitterSupport/status/25614603915\">https://twit­ter.com/Twit­ter­Sup­port/sta­tus/25614603915</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern\">https://cheat­sheet­series.owasp.org/cheat­sheets/Cross-​Site_Re­quest_Forgery_Pre­ven­tion_Cheat_Sheet.html#synchronizer-​token-pattern</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie\">https://cheat­sheet­series.owasp.org/cheat­sheets/Cross-​Site_Re­quest_Forgery_Pre­ven­tion_Cheat_Sheet.html#double-​submit-cookie</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html\">https://cheat­sheet­series.owasp.org/cheat­sheets/Cryp­to­graphic_Stor­age_Cheat_Sheet.html</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Key%5C_Management%5C_Cheat%5C_Sheet.html%5C#key-management-lifecycle-best-practices\">https://cheat­sheet­series.owasp.org/cheat­sheets/Key\\_Man­age­ment\\_Cheat\\_Sheet.html\\#key-​management-lifecycle-best-practices</a></li><li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-11825\">https://nvd.nist.gov/vuln/de­tail/CVE-2020-11825</a></li><li><a href=\"https://owasp.org/www-chapter-london/assets/slides/David_Johansson-Double_Defeat_of_Double-Submit_Cookie.pdf\">https://owasp.org/www-​chapter-london/as­sets/slides/David_Johansson-​Double_De­feat_of_Double-​Submit_Cookie.pdf</a></li><li><a href=\"http://www.breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf\">http://www.breachat­tack.com/re­sources/BREACH%20-%20SSL,%20gone%20in%2030%20sec­onds.pdf</a></li><li><a href=\"https://blog.jeremiahgrossman.com/2006/08/i-know-where-youve-been.html\">https://blog.je­re­mi­ah­gross­man.com/2006/08/i-​know-where-youve-been.html</a></li><li><a href=\"https://en.wikipedia.org/wiki/Clickjacking\">https://en.wikipedia.org/wiki/Click­jack­ing</a></li><li><a href=\"https://www.contextis.com/media/downloads/Next_Generation_Clickjacking.pdf\">https://www.con­tex­tis.com/media/down­loads/Next_Gen­er­a­tion_Click­jack­ing.pdf</a></li><li><a href=\"https://media.blackhat.com/bh-ad-11/Lundeen/bh-ad-11-Lundeen-New_Ways_Hack_WebApp-WP.pdf\">https://media.black­hat.com/bh-​ad-11/Lun­deen/bh-​ad-11-​Lundeen-New_Ways_Hack_WebApp-​WP.pdf</a></li><li><a href=\"http://homakov.blogspot.com/2013/03/hacking-github-with-webkit.html\">http://homakov.blogspot.com/2013/03/hacking-​github-with-webkit.html</a></li><li><a href=\"https://www.sjoerdlangkemper.nl/2020/05/27/overwriting-httponly-cookies-from-javascript-using-cookie-jar-overflow/\">https://www.sjo­erd­langkem­per.nl/2020/05/27/overwriting-​httponly-cookies-from-javascript-using-cookie-jar-overflow/</a></li><li><a href=\"https://cwe.mitre.org/data/definitions/208.html\">https://cwe.mitre.org/data/de­f­i­n­i­tions/208.html</a></li><li><a href=\"https://www.ietf.org/rfc/rfc2616.txt\">https://www.ietf.org/rfc/rfc2616.txt</a></li><li><a href=\"https://github.com/hapijs/crumb/issues/4\">https://github.com/hapijs/crumb/is­sues/4</a></li><li><a href=\"http://blog.nibblesec.org/2014/05/nodejs-connect-csrf-bypass-abusing.html\">http://blog.nib­blesec.org/2014/05/nodejs-​connect-csrf-bypass-abusing.html</a></li><li><a href=\"https://en.wikipedia.org/wiki/Replay_attack\">https://en.wikipedia.org/wiki/Re­play_at­tack</a></li><li><a href=\"https://christian-schneider.net/CrossSiteWebSocketHijacking.html\">https://christian-​schneider.net/Cross­SiteWeb­Sock­etHi­jack­ing.html</a></li><li><a href=\"https://research.securitum.com/security-analysis-of-portal-element/\">https://re­search.se­cu­ri­tum.com/security-​analysis-of-portal-element/</a></li><li><a href=\"https://www.facebook.com/notes/facebook-bug-bounty/client-side-csrf/2056804174333798/?fref=mentions\">https://www.face­book.com/notes/facebook-​bug-bounty/client-​side-csrf/2056804174333798/?fref=men­tions</a></li></ol>","scope":{}}},"prevPost":{"meta":{"title":"Eclipse Vert.x 4.0.2 released!","category":"releases","authors":[{"name":"Julien Viet","github_id":"vietj"}],"summary":"Eclipse Vert.x version 4.0.2 has just been released. It fixes quite a few bugs that have been reported by the community."},"date":"2021-02-05","slug":"eclipse-vert-x-4-0-2"},"nextPost":{"meta":{"title":"Eclipse Vert.x 3.9.5 released!","category":"releases","authors":[{"name":"Julien Viet","github_id":"vietj"}],"summary":"Eclipse Vert.x version 3.9.5 has just been released. It fixes quite a few bugs that have been reported by the community."},"date":"2020-12-16","slug":"eclipse-vert-x-3-9-5"},"relatedPosts":[{"meta":{"title":"Some Rest with Vert.x","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"This post is part of the Introduction to Vert.x series. Let’s go a bit further this time and develop a CRUD-ish application"},"date":"2015-07-27","slug":"some-rest-with-vert-x"},{"meta":{"title":"Unit and Integration Tests","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"Let’s refresh our mind about what we developed so far in the introduction to vert.x series. We forgot an important task. We didn’t test the API."},"date":"2015-08-03","slug":"unit-and-integration-tests"},{"meta":{"title":"Real-time bidding with Websockets and Vert.x","category":"guides","authors":[{"name":"Marcin Warczyglowa","github_id":"mwarc"}],"summary":"The expectations of users for interactivity with web applications have changed over the past few years.\n    Users during bidding in auction no longer want to press the refresh button."},"date":"2016-01-15","slug":"real-time-bidding-with-websockets-and-vert-x"}]},"__N_SSG":true}