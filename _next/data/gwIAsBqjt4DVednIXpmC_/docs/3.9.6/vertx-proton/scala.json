{"pageProps":{"slug":"3.9.6/vertx-proton/scala","title":"Vert.x Proton","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_proton\">Using Vert.x Proton</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_a_connection\">Creating a connection</a></li>\n<li><a href=\"#_creating_a_sender\">Creating a sender</a></li>\n<li><a href=\"#_creating_a_receiver\">Creating a receiver</a></li>\n<li><a href=\"#_threading_considerations\">Threading Considerations</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Proton</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This component facilitates AMQP integrations for Vert.x by providing a thin wrapper around the\n<a href=\"http://qpid.apache.org/\">Apache Qpid</a> Proton-J AMQP 1.0 protocol engine.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nThis module exposes certain Proton-J classes directly, as it is an integration layer to integrate\nthe Proton-J engine with the Vert.x threading model and networking layers, rather than a high level\nclient or server abstraction.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_proton\"><a class=\"anchor\" href=\"#_using_vert_x_proton\"></a>Using Vert.x Proton</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use Vert.x Proton, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-proton<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${maven.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile io.<span class=\"hljs-string\">vertx:</span>vertx-<span class=\"hljs-string\">proton:</span>${maven.version}</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_connection\"><a class=\"anchor\" href=\"#_creating_a_connection\"></a>Creating a connection</h3>\n<div class=\"paragraph\">\n<p>Here is an example of connecting and then opening a connection, which can then be used to create senders and\nreceivers.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ProtonClient client = ProtonClient.create(vertx);\n\n<span class=\"hljs-comment\">// Connect, then use the event loop thread to process things thereafter</span>\nclient.connect(<span class=\"hljs-string\">\"hostname\"</span>, <span class=\"hljs-number\">5672</span>, <span class=\"hljs-string\">\"username\"</span>, <span class=\"hljs-string\">\"password\"</span>, connectResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (connectResult.succeeded()) {\n    connectResult.result().setContainer(<span class=\"hljs-string\">\"my-container/client-id\"</span>).openHandler(openResult -&gt; {\n      <span class=\"hljs-keyword\">if</span> (openResult.succeeded()) {\n        ProtonConnection conn = openResult.result();\n        <span class=\"hljs-comment\">// Create senders, receivers etc..</span>\n      }\n    }).open();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_sender\"><a class=\"anchor\" href=\"#_creating_a_sender\"></a>Creating a sender</h3>\n<div class=\"paragraph\">\n<p>Here is an example of creating a sender and sending a message with it. The onUpdated handler provided in the send\ncall is invoked when disposition updates are received for the delivery, with the example using this to print the\ndelivery state and whether the delivery was settled.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.createSender(<span class=\"hljs-string\">\"myQueue\"</span>).openHandler(openResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (openResult.succeeded()) {\n    ProtonSender sender = openResult.result();\n\n    Message message = message();\n    message.setBody(<span class=\"hljs-keyword\">new</span> AmqpValue(<span class=\"hljs-string\">\"Hello World\"</span>));\n\n    <span class=\"hljs-comment\">// Send message, providing an onUpdated delivery handler that prints updates</span>\n    sender.send(message, delivery -&gt; {\n      System.out.println(String.format(<span class=\"hljs-string\">\"Message received by server: remote state=%s, remotely settled=%s\"</span>,\n                                       delivery.getRemoteState(), delivery.remotelySettled()));\n    });\n  }\n}).open();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_receiver\"><a class=\"anchor\" href=\"#_creating_a_receiver\"></a>Creating a receiver</h3>\n<div class=\"paragraph\">\n<p>Here is an example of creating a receiver, and setting a message handler to process the incoming messages and their\nrelated delivery.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connection.createReceiver(<span class=\"hljs-string\">\"myQueue\"</span>).handler((delivery, msg) -&gt; {\n  Section body = msg.getBody();\n  <span class=\"hljs-keyword\">if</span> (body <span class=\"hljs-keyword\">instanceof</span> AmqpValue) {\n    System.out.println(<span class=\"hljs-string\">\"Received message with content: \"</span> + ((AmqpValue) body).getValue());\n  }\n  <span class=\"hljs-comment\">// By default, the receiver automatically accepts (and settles) the delivery</span>\n  <span class=\"hljs-comment\">// when the handler returns if no other disposition has already been applied.</span>\n}).open();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_threading_considerations\"><a class=\"anchor\" href=\"#_threading_considerations\"></a>Threading Considerations</h3>\n<div class=\"paragraph\">\n<p>The Proton protocol engine is inherently single threaded, so a given engine and any related connection etc objects\nmust only be used by a single thread at a time. To satisfy this, vertx-proton requires that a connection and related\nobjects are only used by a single Vert.x Context, the one associated with the underlying socket during creation of\nthe connection, with result that only a single thread uses the protocol engine.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the case of a ProtonClient connection, this is always the Context used (or created automatically if there wasn&#8217;t\none present) while calling the connect() methods. The connect handler, and any subsequent callbacks for the related\nconnection, will be fired using this context. The application must use the same context to interact with the\nconnection and related objects outwith any callbacks.</p>\n</div>\n<div class=\"paragraph\">\n<p>For example, consider the following code:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client.connect(<span class=\"hljs-string\">\"hostname\"</span>, <span class=\"hljs-number\">5672</span>, connectResult -&gt; {\n  <span class=\"hljs-comment\">// In this case the context will be either the one used to call connect</span>\n  <span class=\"hljs-comment\">// or one created during the process if there was none originally.</span>\n  Context connectionCtx = Vertx.currentContext();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If the above were to be run within a Verticle initialisation for example, then the verticle Context would be used by\nthe connection for I/O and any callbacks, as would calls by the verticle to interact with the connection outwith\nsuch callbacks.</p>\n</div>\n<div class=\"paragraph\">\n<p>If however the above snippet were run outwith a Verticle, e.g. embedded in a simple main() method, then no Context\nwould be present during the connect() call and a new one would have to be automatically created during the call. This\nContext would then be used for the connect callback and any subsequent callbacks. The application code would need to\nensure it also used this context to run any interactions with the connection outside of callbacks. One option would\nbe to capture the context in a callback as shown above and then later use it to run tasks. Another would be to\nexplicitly create a Context if needed before calling connect, and then run the connect() operation on it, thus\nensuring it becomes the Context associated with the connection. This can be seen in the example below:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Context myContext = vertx.getOrCreateContext();\n\nmyContext.runOnContext(x -&gt; {\n  client.connect(<span class=\"hljs-string\">\"hostname\"</span>, <span class=\"hljs-number\">5672</span>, connectResult -&gt; {\n    <span class=\"hljs-comment\">// In this case the context will be 'myContext' from earlier</span>\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the case of a ProtonServer connection, a Context is associated with the underlying socket for the connection when\nthe server accepts it. This will be used in any callbacks such as those when the connection initially opens and later\nwhen sessions etc are opened on it and used. Any usage of a given connection outside of its own callbacks, including\nany cross-connection interactions, should again be ensured to run on the connections own Context as outlined above.</p>\n</div>\n</div>\n</div>\n</div>","version":"3.9.6"},"__N_SSG":true}