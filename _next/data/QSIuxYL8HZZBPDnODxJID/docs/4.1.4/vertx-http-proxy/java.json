{"pageProps":{"slug":"4.1.4/vertx-http-proxy/java","title":"Vert.x Http Proxy","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_http_proxy\">使用 Vert.x Http Proxy</a></li>\n<li><a href=\"#_basic_http_proxy\">Http Proxy基础</a></li>\n<li><a href=\"#_origin_server\">源服务器</a></li>\n<li><a href=\"#_proxy_server_with_httpproxy\">使用 <code>HttpProxy</code> 的 <strong>代理服务器</strong></a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Http Proxy</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Http Proxy 是一个基于Vert.x的反向代理服务器，其目的是实现可重用的反向代理逻辑，\n这样，使用者就可以关注更高层面的问题了</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n这个模块处于 <em>Tech Preview</em> 阶段，这意味着在不同版本之间API可能会不太一样\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_http_proxy\"><a class=\"anchor\" href=\"#_using_vert_x_http_proxy\"></a>使用 Vert.x Http Proxy</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用 Vert.x Http Proxy之前，请把以下的依赖放到您的构建描述文件的 <em>依赖</em> 部分中</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven （在您的 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-http-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle （在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-http-proxy:4.1.4&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_basic_http_proxy\"><a class=\"anchor\" href=\"#_basic_http_proxy\"></a>Http Proxy基础</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了使用Vert.x Http Proxy实现一个反向代理，您需要了解这些名词：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><strong>代理服务器</strong> 会处理出站请求，然后使用 <code>HttpProxy</code> 实例把他们转发到 <strong>源服务器</strong></p>\n</li>\n<li>\n<p><strong>源服务器</strong> 会处理从*代理服务器*来的请求，然后处理相对应的响应</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>现在，您已经了解了相应的整体概念。\n让我们来深入实现，先从 <strong>源服务器</strong> 再到使用 <code>HttpProxy</code> 的 <strong>代理服务器</strong> ：</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_origin_server\"><a class=\"anchor\" href=\"#_origin_server\"></a>源服务器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>我们先简单创建一个监听 <code>7070</code> 端口的 <strong>源服务器</strong></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServer originServer = vertx.createHttpServer();\n\noriginServer.requestHandler(req -&gt; {\n  req.response()\n    .putHeader(<span class=\"hljs-string\">&quot;content-type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>)\n    .end(<span class=\"hljs-string\">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;I&#x27;m the target resource!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);\n}).listen(<span class=\"hljs-number\">7070</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_proxy_server_with_httpproxy\"><a class=\"anchor\" href=\"#_proxy_server_with_httpproxy\"></a>使用 <code>HttpProxy</code> 的 <strong>代理服务器</strong></h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>创建一个监听在 <code>8080</code> 端口的使用 <code>HttpProxy</code> 实例的 <strong>代理服务器</strong>\n处理相应的反向代理逻辑</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient proxyClient = vertx.createHttpClient();\n\nHttpProxy proxy = HttpProxy.reverseProxy(proxyClient);\nproxy.origin(<span class=\"hljs-number\">7070</span>, <span class=\"hljs-string\">&quot;origin&quot;</span>);\n\nHttpServer proxyServer = vertx.createHttpServer();\n\nproxyServer.requestHandler(proxy).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>最后，所有的出站请求都被轻松的反向代理转发到 <strong>源服务器</strong></p>\n</div>\n</div>\n</div>","version":"4.1.4"},"__N_SSG":true}