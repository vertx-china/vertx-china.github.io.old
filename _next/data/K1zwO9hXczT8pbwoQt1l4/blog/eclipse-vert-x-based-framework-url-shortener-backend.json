{"pageProps":{"categories":["releases","guides","news"],"post":{"meta":{"title":"Eclipse Vert.x based Framework URL Shortener Backend","category":"guides","authors":[{"name":"Lazar BuliÄ‡","github_id":"pendula95"}],"summary":"We combine Vert.x with the serverless framework to write a microservice that runs on AWS Lambda."},"date":"2017-12-21","slug":"eclipse-vert-x-based-framework-url-shortener-backend","readingTime":{"text":"5 min read","minutes":4.65,"time":279000,"words":930},"content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Re\\xADcently, I stum\\xADbled upon \", mdx(Link, {\n    href: \"/\",\n    passHref: true,\n    mdxType: \"Link\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Vertx\"))), \". \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Event-\\u200Bdriven, asyn\\xADchro\\xADnized, light\\xADweight, re\\xADac\\xADtive, highly per\\xADfor\\xADmant, poly\\xADglot\"), \" ap\\xADpli\\xADca\\xADtion frame\\xADwork. Ideal for writ\\xADing \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"micro-\\u200Bservices\"), \". I played around with it for a while and re\\xADally en\\xADjoyed the con\\xADcept of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"server\\xADless\"), \" ap\\xADpli\\xADca\\xADtions.\"), mdx(\"p\", null, \"I de\\xADvel\\xADoped a few apps and cases and started to won\\xADder how to run and de\\xADploy them so that I get a 100% re\\xADli\\xADable ser\\xADvice. I sud\\xADdenly re\\xADmem\\xADbered the tech sem\\xADi\\xADnar that I at\\xADtended re\\xADcently, specif\\xADi\\xADcally ses\\xADsion about server\\xADless apps with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://aws.amazon.com/\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"AWS\")), \" (Ama\\xADzon Web Ser\\xADvices) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lambda\"), \". Lambda is a server\\xADless com\\xADpute ser\\xADvice that runs your code in re\\xADsponse to events and au\\xADto\\xADmat\\xADi\\xADcally man\\xADages the un\\xADder\\xADly\\xADing com\\xADpute re\\xADsources for you. Fairly sim\\xADi\\xADlar con\\xADcepts \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Vertx\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AWS Lambda\"), \", so maybe they com\\xADple\\xADment each other? As it turns out they do, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Vertx\"), \" can get most of your \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lamb\\xADdas\"), \"\\u2026\"), mdx(\"p\", null, \"Using the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://serverless.com/\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Server\\xADless Frame\\xADwork\")), \" to cre\\xADate, man\\xADage and de\\xADploy your new \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lamb\\xADdas\"), \" I was able to get this \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"micro-\\u200Bservice\"), \" up and run\\xADning in no time.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Enough with the talk, lets see the im\\xADple\\xADmen\\xADta\\xADtion.\")), mdx(\"h2\", {\n    \"id\": \"code\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#code\"\n  })), \"Code\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Han\\xADdler Class, entry point of AWS Re\\xADquest.\")), mdx(\"p\", null, \"The first issue that I had was the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sync\"), \" Event Han\\xADdler that is pro\\xADvided by AWS. So I had to by pass it with Fu\\xADture. In the Han\\xADdler class I first ini\\xADti\\xADate Vertx in\\xADstance in a sta\\xADtic block and de\\xADploy few Ver\\xADti\\xADcles that will do the work. This class only re\\xADceives the event, ex\\xADtracts needed data from the re\\xADquest and passes the data to Vertx Event\\xADBus. After the Con\\xADsumers han\\xADdle the re\\xADquest, Han\\xADdler class will gen\\xADer\\xADate a proper re\\xADsponse and fin\\xADish the AWS re\\xADquest.\"), mdx(Gist, {\n    url: \"https://gist.github.com/pendula95/583eb45bd0a7990136fba029bdcd555b\",\n    mdxType: \"Gist\"\n  }), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Line 4-18:\"), \" This is where Vertx in\\xADstance is cre\\xADated, Ver\\xADti\\xADcles are de\\xADployed and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Async JDBC\"), \" client is cre\\xADated. I fig\\xADured out that it is bet\\xADter to cre\\xADated JDBC client here as in some cases I was time\\xADout when that logic was in the Ver\\xADti\\xADcle start method.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Line 27-36:\"), \" These are helper lines, pars\\xADing and for\\xADmat\\xADting the data so I can pass it to the Ver\\xADti\\xADcles.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Line 38-45:\"), \" I have de\\xADcided to map the con\\xADsumers to the ad\\xADdress that is made of re\\xADquest method and url path, ex\\xADam\\xADple POST/api. This means each API re\\xADquest is mapped to its own con\\xADsumer in Ver\\xADti\\xADcle class.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Line 47-77:\"), \" This is noth\\xADing but a block of code that han\\xADdles the re\\xADsponse that was passed from Ver\\xADti\\xADcles to the Fu\\xADture and gen\\xADer\\xADates the final re\\xADsponse that will be re\\xADturn to API Gate\\xADway.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UrlSer\\xADvice, Vertx Ver\\xADti\\xADcle.\")), mdx(\"p\", null, \"Ver\\xADti\\xADcle class is pretty for\\xADward. Con\\xADsumers that will process the mes\\xADsage, meth\\xADods for work\\xADing with JDBC and helper meth\\xADods for hash\\xADing/de\\xADhash\\xADing id. The logic be\\xADhind url short\\xADen\\xADing is fairly sim\\xADple here. Each long url is stored in data\\xADbase with a unique id and few ad\\xADdi\\xADtional columns. Row id is hashed and re\\xADturned as short url. When re\\xADtriev\\xADing long url hash is de\\xADcoded to row id and long url is re\\xADtrieved. Later user is redi\\xADrected to long url. With this im\\xADple\\xADmen\\xADta\\xADtion, on 6 char short url (char\\xADac\\xADters after the do\\xADmain) you get 62^6 com\\xADbi\\xADna\\xADtions which is 56 800 235 584 rows for stor\\xADing your urls. TinyURL is cur\\xADrently at 6 long char urls (char\\xADac\\xADters after do\\xADmain). You can of course im\\xADple\\xADment meth\\xADods for reusing and re\\xADcy\\xADcling ids.\"), mdx(Gist, {\n    url: \"https://gist.github.com/pendula95/aeb4479162e6e33504add2af9fa68bc5\",\n    mdxType: \"Gist\"\n  }), mdx(\"p\", null, \"As said, this is all fairly straight for\\xADward, if you are al\\xADready fa\\xADmil\\xADiar with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Vertx\"), \". If you are think\\xADing why have I re\\xADpeated the code for es\\xADtab\\xADlish a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"JDBC\"), \" con\\xADnec\\xADtion, here is the ex\\xADpla\\xADna\\xADtion \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(line: 10-16)\"), \". I was get\\xADting Time\\xADouts when cre\\xADat\\xADing JDBC con\\xADnec\\xADtion in Ver\\xADti\\xADcles. To avoid this I also added this code to my Han\\xADdler class. This way con\\xADnec\\xADtion is cre\\xADated there and be\\xADcause of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Vertx\"), \" im\\xADple\\xADmen\\xADta\\xADtion any later at\\xADtempt to cre\\xADate it again will re\\xADsult in just get\\xADting the in\\xADstances from the first in\\xADvo\\xADca\\xADtion. This es\\xADcaped the need to pass the in\\xADstances di\\xADrectly from the Han\\xADdler class when cre\\xADat\\xADing Ver\\xADti\\xADcle in\\xADstances.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Server\\xADless con\\xADfig\\xADu\\xADra\\xADtion.\")), mdx(\"p\", null, \"Lastly I would like to share the server\\xADless.yml, con\\xADfir\\xADma\\xADtion file that al\\xADlows seam\\xADlessly de\\xADploy and man\\xADage\\xADment of AWS Lambda. With just a few com\\xADmands and lines of con\\xADfig\\xADu\\xADra\\xADtion you are able to con\\xADfig\\xADure all nec\\xADes\\xADsary steps for de\\xADploy\\xADing your AWS Lambda. Frame\\xADwork takes care of mak\\xADing con\\xADfig\\xADu\\xADra\\xADtion of Api-\\u200BGateway and other AWS has\\xADsle that would oth\\xADer\\xADwise needed to be done by hand. In this case Lambda is in\\xADvoked by HTTP events.\"), mdx(Gist, {\n    url: \"https://gist.github.com/pendula95/33adc47265072ed930c7df98c9ace7be\",\n    mdxType: \"Gist\"\n  }), mdx(\"h2\", {\n    \"id\": \"performance-and-tests\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#performance-and-tests\"\n  })), \"Performance and Tests\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Vertx\"), \" async ca\\xADpa\\xADbil\\xADi\\xADties eased the stress and mem\\xADory needs of tra\\xADdi\\xADtional \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AWS Lamb\\xADdas\"), \" with sync meth\\xADods. After per\\xADform\\xADing load tests Lamb\\xADdas that were writ\\xADten using Vertx frame\\xADwork pre\\xADformed \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"10% faster and con\\xADsumed 40% less mem\\xADory\"), \". As I have read some\\xADwhere in Vertx doc\\xADu\\xADmen\\xADta\\xADtion, Sync meth\\xADods will def\\xADi\\xADnitely fin\\xADish the first re\\xADquest faster but in total Async will be faster in the end. This sav\\xADings in mem\\xADory and time will def\\xADi\\xADnitely re\\xADduce the cost of run\\xADning your Lamb\\xADdas and the lit\\xADtle over\\xADhead with ad\\xADdi\\xADtional code is for sure worth it.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#conclusion\"\n  })), \"Conclusion\"), mdx(\"p\", null, \"To fol\\xADlow the pace of de\\xADmand\\xADing needs for fast and re\\xADsilient ser\\xADvices we need to move from tra\\xADdi\\xADtional Mono\\xADliths. Em\\xADbrac\\xADing the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"micro ser\\xADvice\"), \" ar\\xADchi\\xADtec\\xADture alone will not cut it, not any\\xADmore. With the rise and rapid ad\\xADvance\\xADment of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cloud\"), \" so\\xADlu\\xADtions it has never been so easy to make a truly \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Server\\xADless\"), \" sys\\xADtems build upon net\\xADwork of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"micro ser\\xADvices\"), \".\\nAs you have seen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Vertx\"), \" with its async API makes the full ad\\xADvan\\xADtage of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AWS Lamb\\xADdas\"), \", em\\xADbrac\\xADing them while also im\\xADprov\\xADing the per\\xADfor\\xADmance and low\\xADer\\xADing the costs. With the help from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Server\\xADless Frame\\xADwork\"), \" writ\\xADing, de\\xADploy\\xADing and man\\xADag\\xADing your \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lamb\\xADdas\"), \" has never been so easy.\"), mdx(\"p\", null, \"If you are in\\xADter\\xADested in the whole project, you can find it on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/pendula95/vertx-aws-url-shortener-service/tree/master\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"GitHub\")), \".\"), mdx(Alert, {\n    info: true,\n    mdxType: \"Alert\"\n  }, mdx(\"p\", null, \"This is a re-\\u200Bpublication of the fol\\xADlow\\xADing \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://lazarbulic.com/blog/2017/11/10/aws-lambda-vertx-framework-url-shortener-backend/\"\n  }), \"blog post\"))));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>ReÂ­cently, I stumÂ­bled upon <a href=\"/\"><strong>Vertx</strong></a>. <strong>Event-â€‹driven, asynÂ­chroÂ­nized, lightÂ­weight, reÂ­acÂ­tive, highly perÂ­forÂ­mant, polyÂ­glot</strong> apÂ­pliÂ­caÂ­tion frameÂ­work. Ideal for writÂ­ing <strong>micro-â€‹services</strong>. I played around with it for a while and reÂ­ally enÂ­joyed the conÂ­cept of <strong>serverÂ­less</strong> apÂ­pliÂ­caÂ­tions.</p><p>I deÂ­velÂ­oped a few apps and cases and started to wonÂ­der how to run and deÂ­ploy them so that I get a 100% reÂ­liÂ­able serÂ­vice. I sudÂ­denly reÂ­memÂ­bered the tech semÂ­iÂ­nar that I atÂ­tended reÂ­cently, specifÂ­iÂ­cally sesÂ­sion about serverÂ­less apps with <a href=\"https://aws.amazon.com/\"><strong>AWS</strong></a> (AmaÂ­zon Web SerÂ­vices) <strong>Lambda</strong>. Lambda is a serverÂ­less comÂ­pute serÂ­vice that runs your code in reÂ­sponse to events and auÂ­toÂ­matÂ­iÂ­cally manÂ­ages the unÂ­derÂ­lyÂ­ing comÂ­pute reÂ­sources for you. Fairly simÂ­iÂ­lar conÂ­cepts <strong>Vertx</strong> and <strong>AWS Lambda</strong>, so maybe they comÂ­pleÂ­ment each other? As it turns out they do, <strong>Vertx</strong> can get most of your <strong>LambÂ­das</strong>â€¦</p><p>Using the <a href=\"https://serverless.com/\"><strong>ServerÂ­less FrameÂ­work</strong></a> to creÂ­ate, manÂ­age and deÂ­ploy your new <strong>LambÂ­das</strong> I was able to get this <strong>micro-â€‹service</strong> up and runÂ­ning in no time.</p><p><em>Enough with the talk, lets see the imÂ­pleÂ­menÂ­taÂ­tion.</em></p><h2 id=\"code\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#code\"></a>Code</h2><p><em>HanÂ­dler Class, entry point of AWS ReÂ­quest.</em></p><p>The first issue that I had was the <strong>sync</strong> Event HanÂ­dler that is proÂ­vided by AWS. So I had to by pass it with FuÂ­ture. In the HanÂ­dler class I first iniÂ­tiÂ­ate Vertx inÂ­stance in a staÂ­tic block and deÂ­ploy few VerÂ­tiÂ­cles that will do the work. This class only reÂ­ceives the event, exÂ­tracts needed data from the reÂ­quest and passes the data to Vertx EventÂ­Bus. After the ConÂ­sumers hanÂ­dle the reÂ­quest, HanÂ­dler class will genÂ­erÂ­ate a proper reÂ­sponse and finÂ­ish the AWS reÂ­quest.</p><div>...waiting for Gist...</div><p><em>Line 4-18:</em> This is where Vertx inÂ­stance is creÂ­ated, VerÂ­tiÂ­cles are deÂ­ployed and <strong>Async JDBC</strong> client is creÂ­ated. I figÂ­ured out that it is betÂ­ter to creÂ­ated JDBC client here as in some cases I was timeÂ­out when that logic was in the VerÂ­tiÂ­cle start method.</p><p><em>Line 27-36:</em> These are helper lines, parsÂ­ing and forÂ­matÂ­ting the data so I can pass it to the VerÂ­tiÂ­cles.</p><p><em>Line 38-45:</em> I have deÂ­cided to map the conÂ­sumers to the adÂ­dress that is made of reÂ­quest method and url path, exÂ­amÂ­ple POST/api. This means each API reÂ­quest is mapped to its own conÂ­sumer in VerÂ­tiÂ­cle class.</p><p><em>Line 47-77:</em> This is nothÂ­ing but a block of code that hanÂ­dles the reÂ­sponse that was passed from VerÂ­tiÂ­cles to the FuÂ­ture and genÂ­erÂ­ates the final reÂ­sponse that will be reÂ­turn to API GateÂ­way.</p><p><em>UrlSerÂ­vice, Vertx VerÂ­tiÂ­cle.</em></p><p>VerÂ­tiÂ­cle class is pretty forÂ­ward. ConÂ­sumers that will process the mesÂ­sage, methÂ­ods for workÂ­ing with JDBC and helper methÂ­ods for hashÂ­ing/deÂ­hashÂ­ing id. The logic beÂ­hind url shortÂ­enÂ­ing is fairly simÂ­ple here. Each long url is stored in dataÂ­base with a unique id and few adÂ­diÂ­tional columns. Row id is hashed and reÂ­turned as short url. When reÂ­trievÂ­ing long url hash is deÂ­coded to row id and long url is reÂ­trieved. Later user is rediÂ­rected to long url. With this imÂ­pleÂ­menÂ­taÂ­tion, on 6 char short url (charÂ­acÂ­ters after the doÂ­main) you get 62^6 comÂ­biÂ­naÂ­tions which is 56 800 235 584 rows for storÂ­ing your urls. TinyURL is curÂ­rently at 6 long char urls (charÂ­acÂ­ters after doÂ­main). You can of course imÂ­pleÂ­ment methÂ­ods for reusing and reÂ­cyÂ­cling ids.</p><div>...waiting for Gist...</div><p>As said, this is all fairly straight forÂ­ward, if you are alÂ­ready faÂ­milÂ­iar with <strong>Vertx</strong>. If you are thinkÂ­ing why have I reÂ­peated the code for esÂ­tabÂ­lish a <strong>JDBC</strong> conÂ­necÂ­tion, here is the exÂ­plaÂ­naÂ­tion <em>(line: 10-16)</em>. I was getÂ­ting TimeÂ­outs when creÂ­atÂ­ing JDBC conÂ­necÂ­tion in VerÂ­tiÂ­cles. To avoid this I also added this code to my HanÂ­dler class. This way conÂ­necÂ­tion is creÂ­ated there and beÂ­cause of the <strong>Vertx</strong> imÂ­pleÂ­menÂ­taÂ­tion any later atÂ­tempt to creÂ­ate it again will reÂ­sult in just getÂ­ting the inÂ­stances from the first inÂ­voÂ­caÂ­tion. This esÂ­caped the need to pass the inÂ­stances diÂ­rectly from the HanÂ­dler class when creÂ­atÂ­ing VerÂ­tiÂ­cle inÂ­stances.</p><p><em>ServerÂ­less conÂ­figÂ­uÂ­raÂ­tion.</em></p><p>Lastly I would like to share the serverÂ­less.yml, conÂ­firÂ­maÂ­tion file that alÂ­lows seamÂ­lessly deÂ­ploy and manÂ­ageÂ­ment of AWS Lambda. With just a few comÂ­mands and lines of conÂ­figÂ­uÂ­raÂ­tion you are able to conÂ­figÂ­ure all necÂ­esÂ­sary steps for deÂ­ployÂ­ing your AWS Lambda. FrameÂ­work takes care of makÂ­ing conÂ­figÂ­uÂ­raÂ­tion of Api-â€‹Gateway and other AWS hasÂ­sle that would othÂ­erÂ­wise needed to be done by hand. In this case Lambda is inÂ­voked by HTTP events.</p><div>...waiting for Gist...</div><h2 id=\"performance-and-tests\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#performance-and-tests\"></a>Performance and Tests</h2><p><strong>Vertx</strong> async caÂ­paÂ­bilÂ­iÂ­ties eased the stress and memÂ­ory needs of traÂ­diÂ­tional <strong>AWS LambÂ­das</strong> with sync methÂ­ods. After perÂ­formÂ­ing load tests LambÂ­das that were writÂ­ten using Vertx frameÂ­work preÂ­formed <strong>10% faster and conÂ­sumed 40% less memÂ­ory</strong>. As I have read someÂ­where in Vertx docÂ­uÂ­menÂ­taÂ­tion, Sync methÂ­ods will defÂ­iÂ­nitely finÂ­ish the first reÂ­quest faster but in total Async will be faster in the end. This savÂ­ings in memÂ­ory and time will defÂ­iÂ­nitely reÂ­duce the cost of runÂ­ning your LambÂ­das and the litÂ­tle overÂ­head with adÂ­diÂ­tional code is for sure worth it.</p><h2 id=\"conclusion\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#conclusion\"></a>Conclusion</h2><p>To folÂ­low the pace of deÂ­mandÂ­ing needs for fast and reÂ­silient serÂ­vices we need to move from traÂ­diÂ­tional MonoÂ­liths. EmÂ­bracÂ­ing the <strong>micro serÂ­vice</strong> arÂ­chiÂ­tecÂ­ture alone will not cut it, not anyÂ­more. With the rise and rapid adÂ­vanceÂ­ment of <strong>Cloud</strong> soÂ­luÂ­tions it has never been so easy to make a truly <strong>ServerÂ­less</strong> sysÂ­tems build upon netÂ­work of <strong>micro serÂ­vices</strong>.\nAs you have seen <strong>Vertx</strong> with its async API makes the full adÂ­vanÂ­tage of <strong>AWS LambÂ­das</strong>, emÂ­bracÂ­ing them while also imÂ­provÂ­ing the perÂ­forÂ­mance and lowÂ­erÂ­ing the costs. With the help from <strong>ServerÂ­less FrameÂ­work</strong> writÂ­ing, deÂ­ployÂ­ing and manÂ­agÂ­ing your <strong>LambÂ­das</strong> has never been so easy.</p><p>If you are inÂ­terÂ­ested in the whole project, you can find it on <a href=\"https://github.com/pendula95/vertx-aws-url-shortener-service/tree/master\"><strong>GitHub</strong></a>.</p><div class=\"alert info\"><p>This is a re-â€‹publication of the folÂ­lowÂ­ing <a href=\"http://lazarbulic.com/blog/2017/11/10/aws-lambda-vertx-framework-url-shortener-backend/\">blog post</a></p></div>","scope":{}}},"prevPost":{"meta":{"title":"Eclipse Vert.x 3.5.1 released!","category":"releases","authors":[{"name":"Julien Viet","github_id":"vietj"}],"summary":"We have just released Vert.x 3.5.1!"},"date":"2018-02-13","slug":"eclipse-vert-x-3-5-1-released"},"nextPost":{"meta":{"title":"TCP Client using Eclipse Vert.x, Kotlin and Gradle build","category":"guides","authors":[{"name":"Usman Saleem","github_id":"usmansaleem"}],"summary":"In this blog post, I demonstrate how to write a very simple TCP client that keeps a connection open to a custom-written server in cloud."},"date":"2017-12-20","slug":"tcp-client-using-eclipse-vert-x-kotlin-and-gradle-build"},"relatedPosts":[{"meta":{"title":"Real-time bidding with Websockets and Vert.x","category":"guides","authors":[{"name":"Marcin Warczyglowa","github_id":"mwarc"}],"summary":"The expectations of users for interactivity with web applications have changed over the past few years.\n    Users during bidding in auction no longer want to press the refresh button."},"date":"2016-01-15","slug":"real-time-bidding-with-websockets-and-vert-x"},{"meta":{"title":"Some Rest with Vert.x","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"This post is part of the Introduction to Vert.x series. Letâ€™s go a bit further this time and develop a CRUD-ish application"},"date":"2015-07-27","slug":"some-rest-with-vert-x"},{"meta":{"title":"Building services and APIs with AMQP 1.0","category":"guides","authors":[{"name":"Jakub Scholz","github_id":"scholzj"}],"summary":"Microservices and APIs are everywhere. Everyone talks about them, presentation slides are full of them ... some people are actually even building them."},"date":"2017-01-25","slug":"building-services-and-apis-with-amqp-1-0"}]},"__N_SSG":true}