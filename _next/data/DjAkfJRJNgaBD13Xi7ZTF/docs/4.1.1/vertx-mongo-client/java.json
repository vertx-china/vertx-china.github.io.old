{"pageProps":{"slug":"4.1.1/vertx-mongo-client/java","title":"Vert.x MongoDB 客户端","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_mongodb_client\">使用 Vert.x MongoDB Client</a></li>\n<li><a href=\"#_creating_a_client\">创建客户端</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_the_default_shared_pool\">使用默认的共享连接池</a></li>\n<li><a href=\"#_specifying_a_pool_source_name\">指定 连接池方式数据源的名称</a></li>\n<li><a href=\"#_creating_a_client_with_a_non_shared_data_pool\">创建非共享数据源的客户端对象</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_api\">使用客户端 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_saving_documents\">保存文档</a></li>\n<li><a href=\"#_inserting_documents\">插入文档</a></li>\n<li><a href=\"#_updating_documents\">更新文档</a></li>\n<li><a href=\"#_replacing_documents\">替换文档</a></li>\n<li><a href=\"#_bulk_operations\">批量操作</a></li>\n<li><a href=\"#_finding_documents\">查找文档</a></li>\n<li><a href=\"#_finding_documents_in_batches\">批量查询文档</a></li>\n<li><a href=\"#_finding_a_single_document\">查询单个文档</a></li>\n<li><a href=\"#_removing_documents\">删除文档</a></li>\n<li><a href=\"#_removing_a_single_documents\">删除单个文档</a></li>\n<li><a href=\"#_counting_documents\">文档计数</a></li>\n<li><a href=\"#_managing_mongodb_collections\">管理 MongoDB 集合</a></li>\n<li><a href=\"#_running_other_mongodb_commands\">执行 <code>MongoDB</code> 的其他命令</a></li>\n<li><a href=\"#_mongodb_extended_json_support\">MongoDB的JSON扩展支持</a></li>\n<li><a href=\"#_getting_distinct_values\">获取 distinct 后的值</a></li>\n</ul>\n</li>\n<li><a href=\"#_storing_retrieving_files_and_binary_data\">存储/检索文件和二进制数据</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_get_the_mongogridfsclient_to_interact_with_gridfs\">获取一个可与GridFS交互的MongoGridFsClient。</a></li>\n<li><a href=\"#_drop_an_entire_file_bucket_from_gridfs\">从GridFS中，删除整个文件bucket。</a></li>\n<li><a href=\"#_find_all_file_ids_in_a_gridfs_bucket\">在一个GridFS的bucket中，查询所有文件ID。</a></li>\n<li><a href=\"#_find_file_ids_in_a_gridfs_bucket_matching_a_query\">在一个与查询匹配的GridFS bucket中，查询文件ID。</a></li>\n<li><a href=\"#_delete_file_ids_in_gridfs_based_its_id\">在GridFS中，根据文件的ID来删除文件。</a></li>\n<li><a href=\"#_upload_a_file_in_gridfs\">在GridFS中上传文件</a></li>\n<li><a href=\"#_upload_a_file_in_gridfs_with_options\">上传文件时携带配置参数。</a></li>\n<li><a href=\"#_download_a_file_previously_stored_in_gridfs\">下载存储在GridFS中的文件</a></li>\n<li><a href=\"#_download_a_file_previously_stored_in_gridfs_given_its_id\">使用文件ID来下载存储在GridFS中的文件</a></li>\n<li><a href=\"#_download_a_file_from_gridfs_to_a_new_name\">从GridFS下载文件，并且重新命名文件名称</a></li>\n<li><a href=\"#_upload_a_stream_to_gridfs\">将数据流上传到GridFS</a></li>\n<li><a href=\"#_upload_a_stream_to_gridfs_with_options\">上传数据流时携带配置参数</a></li>\n<li><a href=\"#_download_a_stream_from_gridfs_using_file_name\">使用文件名称从GridFS中下载数据流</a></li>\n<li><a href=\"#_download_a_stream_with_options_from_gridfs_using_file_name\">使用文件名称并携带配置参数，从GridFS中下载数据流</a></li>\n<li><a href=\"#_download_a_stream_from_gridfs_using_id\">使用ID下载数据流</a></li>\n</ul>\n</li>\n<li><a href=\"#_configuring_the_client\">客户端参数配置</a></li>\n<li><a href=\"#_rxjava_3_api\">RxJava 3 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_an_rxified_client\">创建一个RX化的客户端</a></li>\n<li><a href=\"#_finding_documents_in_batches\">批量查询文档</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x MongoDB 客户端</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您的 Vert.x 应用可使用 Vert.x MongoDB Client（以下简称客户端）与 MongoDB 互动，\n包括保存，获取，搜索和删除文档。MongoDB 是在 Vert.x 应用进行数据持久化时的最佳选择，\n因为 MongoDB 天生就是处理 JSON（BSON）格式的文档数据库。</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>特点</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>完全非阻塞</p>\n</li>\n<li>\n<p>支持自定义编解码器，从而实现 Vert.x JSON 快速序列化和反序列化</p>\n</li>\n<li>\n<p>支持 MongoDB Java 驱动大部分配置项</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>本客户端基于\n<a href=\"https://mongodb.github.io/mongo-java-driver/4.1/driver-reactive/getting-started/quick-start/\">MongoDB ReactiveStreams Driver</a> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_mongodb_client\"><a class=\"anchor\" href=\"#_using_vert_x_mongodb_client\"></a>使用 Vert.x MongoDB Client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>使用此客户端，需要添加下列依赖：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在 <code>pom.xml</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mongo-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-mongo-client:4.1.1&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_client\"><a class=\"anchor\" href=\"#_creating_a_client\"></a>创建客户端</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可用以下几种方式创建客户端：</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_the_default_shared_pool\"><a class=\"anchor\" href=\"#_using_the_default_shared_pool\"></a>使用默认的共享连接池</h3>\n<div class=\"paragraph\">\n<p>大部分情况下，您希望不同的客户端之间共享一个连接池。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：我们通过部署多个verticle实例来扩展你的程序的时候，我们会希望每个verticle实例都共用同一个连接池，\n而不是多个verticle实例使用多个连接池。</p>\n</div>\n<div class=\"paragraph\">\n<p>要想用最简单的方法去使用共享连接池，我们可以这么做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MongoClient client = MongoClient.createShared(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>只有第一次调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">MongoClient.createShared</a></code>\n才会真正的根据您指定的 config 配置创建连接池。</p>\n</div>\n<div class=\"paragraph\">\n<p>之后再调用此方法，只会返回一个新的客户端对象，但使用的是相同的数据源。因此这时 config 参数不再有作用。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_specifying_a_pool_source_name\"><a class=\"anchor\" href=\"#_specifying_a_pool_source_name\"></a>指定 连接池方式数据源的名称</h3>\n<div class=\"paragraph\">\n<p>您还可以像下面这样，在创建一个客户端的时候指定连接池方式数据源的名称：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MongoClient client = MongoClient.createShared(vertx, config, <span class=\"hljs-string\">&quot;MyPoolName&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用相同Vert.x实例创建了不同客户端，同时指定了相同的连接池名称，\n那么这些客户端将共享这个相同的连接池数据源。</p>\n</div>\n<div class=\"paragraph\">\n<p>同样的（与使用默认的共享数据源相同），只有第一次调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">MongoClient.createShared</a></code>\n才会真正的根据 您指定的config创建一个连接池。</p>\n</div>\n<div class=\"paragraph\">\n<p>之后再调用此方法，只会返回一个新的客户端对象，但使用的是相同的数据源。因此这时config参数不再有作用。</p>\n</div>\n<div class=\"paragraph\">\n<p>当您希望不同groups的客户端，使用不同的连接池时，可以使用这种方式。\n举个使用场景的例子，比如这些客户端需要与不同数据源进行交互的时候，可以使用这种方式。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_client_with_a_non_shared_data_pool\"><a class=\"anchor\" href=\"#_creating_a_client_with_a_non_shared_data_pool\"></a>创建非共享数据源的客户端对象</h3>\n<div class=\"paragraph\">\n<p>在大部分情况下，您希望在不同客户端实例间共享一个连接池。\n但是，在有些情况下，您可能想要使用一个不与其它客户端共享连接的连接池，以创建一个客户端实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>此时您可使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#create-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">MongoClient.create</a></code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MongoClient client = MongoClient.create(vertx, config);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>每次调用此方法，就相当于在调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-java.lang.String-\">MongoClient.createShared</a></code>\n方法时，加上了具有唯一名称的数据源参数。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_api\"><a class=\"anchor\" href=\"#_using_the_api\"></a>使用客户端 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\">MongoClient</a></code> 接口定义了操作客户端的API 方法。您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\">MongoClient</a></code> 来使用调用 API 方法。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_saving_documents\"><a class=\"anchor\" href=\"#_saving_documents\"></a>保存文档</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#save-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">save</a></code> 方法以保存文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果文档中没有 <code>\\_id</code> 字段，文档会被保存。若有，将执行 upserted。\nUpserted 意思是，如果此文档不存在，就保存此文档，此文档存在就更新。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果被保存的文档没有 <code>\\_id</code> 字段，回调方法中可以获得保存后生成的 id。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>);\nmongoClient.save(<span class=\"hljs-string\">&quot;books&quot;</span>, document, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    String id = res.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Saved book with id &quot;</span> + id);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>下面的例子，文档已有 <code>\\_id</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;_id&quot;</span>, <span class=\"hljs-string\">&quot;123244&quot;</span>);\nmongoClient.save(<span class=\"hljs-string\">&quot;books&quot;</span>, document, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// ...</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_inserting_documents\"><a class=\"anchor\" href=\"#_inserting_documents\"></a>插入文档</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#insert-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">insert</a></code> 方法来插入文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果被插入的文档没有包含 id，回调方法中可以获得保存后生成的 id。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>);\nmongoClient.insert(<span class=\"hljs-string\">&quot;books&quot;</span>, document, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    String id = res.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Inserted book with id &quot;</span> + id);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果被插入的文档包含 id，但是此 id 代表的文档已经存在，插入就会失败：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;_id&quot;</span>, <span class=\"hljs-string\">&quot;123244&quot;</span>);\nmongoClient.insert(<span class=\"hljs-string\">&quot;books&quot;</span>, document, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">//...</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Will fail if the book with that id already exists.</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_updating_documents\"><a class=\"anchor\" href=\"#_updating_documents\"></a>更新文档</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#updateCollection-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">updateCollection</a></code> 方法来更新文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>此方法可以更新集合（译者注：MongoDB 中的集合概念对应 SQL 中的数据库表）中的一个或多个文档。\n在 <code>updateCollection</code> 方法中被当成参数传递的JSON对象，\n必须包含 <a href=\"http://docs.mongodb.org/manual/reference/operator/update-field/\">Update Operators</a>，\n因为由它决定更新的方式。</p>\n</div>\n<div class=\"paragraph\">\n<p>其中作为 <code>query</code> 参数的 json对象决定更新集合中的哪个文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如更新 books 集合中的一个文档：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>);\n<span class=\"hljs-comment\">// Set the author field</span>\nJsonObject update = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$set&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>));\nmongoClient.updateCollection(<span class=\"hljs-string\">&quot;books&quot;</span>, query, update, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Book updated !&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果您希望更新操作是 upsert（upsert 意思是，如果此文档不存在，就保存此文档；此文档存在就更新）或者 是更新多个文档，\n那么就使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#updateCollectionWithOptions-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.json.JsonObject-io.vertx.ext.mongo.UpdateOptions-io.vertx.core.Handler-\">updateCollectionWithOptions</a></code>\n方法，传递一个 <code><a href=\"../../apidocs/io/vertx/ext/mongo/UpdateOptions.html\">UpdateOptions</a></code> 的实例，去定制化您的更新操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>参数 <code>UpdateOptions</code> 有以下选项：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>multi</code></dt>\n<dd>\n<p>若设置为 true，则可以更新多个文档</p>\n</dd>\n<dt class=\"hdlist1\"><code>upsert</code></dt>\n<dd>\n<p>若设置为 true，则可以在没有查询到要更新的文档时，新增该文档</p>\n</dd>\n<dt class=\"hdlist1\"><code>writeConcern</code></dt>\n<dd>\n<p>写操作的可靠性（译者注：源码中是用 writeOption 枚举类型来代表的）</p>\n</dd>\n</dl>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">  <span class=\"hljs-comment\">//译者注：MongoDB 默认写操作级别是 WriteOption.ACKNOWLEDGED</span>\nJsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>);\n  <span class=\"hljs-comment\">// Set the author field</span>\nJsonObject update = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$set&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>));\nUpdateOptions options = <span class=\"hljs-keyword\">new</span> UpdateOptions().setMulti(<span class=\"hljs-keyword\">true</span>);\nmongoClient.updateCollectionWithOptions(<span class=\"hljs-string\">&quot;books&quot;</span>, query, update, options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Book updated !&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_replacing_documents\"><a class=\"anchor\" href=\"#_replacing_documents\"></a>替换文档</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#replaceDocuments-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">replaceDocuments</a></code> 方法来替换文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>替换操作和更新操作相似，但替换不需要任何操作符。\n因为它是用您提供的文档去替换整个文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如替换 books 集合中的一个文档：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>);\nJsonObject replace = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Lord of the Rings&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>);\nmongoClient.replaceDocuments(<span class=\"hljs-string\">&quot;books&quot;</span>, query, replace, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Book replaced !&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_bulk_operations\"><a class=\"anchor\" href=\"#_bulk_operations\"></a>批量操作</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#bulkWrite-java.lang.String-java.util.List-io.vertx.core.Handler-\">bulkWrite</a></code> 来一次执行多个新增、更新、替换或者删除的操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 <code>bulkWrite</code> 方法中，您可以传递一系列 <code><a href=\"../../apidocs/io/vertx/ext/mongo/BulkOperation.html\">BulkOperations</a></code>，而且每个 <code>BulkOperations</code> 运作方式和单个操作类似。\n您可以根据需要传递多个操作，即使这些操作都是同一类型的。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您希望 批量操作可以按照顺序执行，那么可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#bulkWriteWithOptions-java.lang.String-java.util.List-io.vertx.ext.mongo.BulkWriteOptions-io.vertx.core.Handler-\">bulkWriteWithOptions</a></code>\n将自定义的配置写入其中，然后传递一个 <code><a href=\"../../apidocs/io/vertx/ext/mongo/BulkWriteOptions.html\">BulkWriteOptions</a></code> 的实例。\n更多关于有序批量写操作的描述，见\n<a href=\"https://docs.mongodb.com/manual/reference/method/db.collection.bulkWrite/#execution-of-operations\">Execution of Operations</a></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_finding_documents\"><a class=\"anchor\" href=\"#_finding_documents\"></a>查找文档</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#find-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">find</a></code> 方法查找文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>其中 <code>query</code> 参数用来匹配集合中的文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如匹配所有文档：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject();\nmongoClient.find(<span class=\"hljs-string\">&quot;books&quot;</span>, query, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-keyword\">for</span> (JsonObject json : res.result()) {\n      System.out.println(json.encodePrettily());\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>又例如匹配 books 集合中某一个作者的所有文档：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>);\nmongoClient.find(<span class=\"hljs-string\">&quot;books&quot;</span>, query, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-keyword\">for</span> (JsonObject json : res.result()) {\n      System.out.println(json.encodePrettily());\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>查询的结果包装成了 JSON 对象的 List 集合。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您希望在查询中指定一些内容，比如指定返回的字段，或者指定返回多少条数据，可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#findWithOptions-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.ext.mongo.FindOptions-io.vertx.core.Handler-\">findWithOptions</a></code> 方法，\n在参数 <code><a href=\"../../apidocs/io/vertx/ext/mongo/FindOptions.html\">FindOptions</a></code> 中指定这些查询要求。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>FindOptions</code> 中可以设置以下参数：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>fields</code></dt>\n<dd>\n<p>返回的字段。默认为 <code>null</code>，意味着查询结果会返回所有字段。</p>\n</dd>\n<dt class=\"hdlist1\"><code>sort</code></dt>\n<dd>\n<p>指定排序字段。默认为 null。</p>\n</dd>\n<dt class=\"hdlist1\"><code>limit</code></dt>\n<dd>\n<p>指定返回的数据条数。默认值为 -1，意味着查询结果会返回所有数据。</p>\n</dd>\n<dt class=\"hdlist1\"><code>skip</code></dt>\n<dd>\n<p>在返回查询结果之前，指定跳过的数据数量。默认值为 0 。</p>\n</dd>\n<dt class=\"hdlist1\"><code>hint</code></dt>\n<dd>\n<p>要使用的索引。默认为空字符串。</p>\n</dd>\n</dl>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_finding_documents_in_batches\"><a class=\"anchor\" href=\"#_finding_documents_in_batches\"></a>批量查询文档</h3>\n<div class=\"paragraph\">\n<p>当我们在处理大量的数据集合的时候，不建议使用\n<code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#find-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">find</a></code> 方法或者\n<code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#findWithOptions-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.ext.mongo.FindOptions-io.vertx.core.Handler-\">findWithOptions</a></code> 方法。\n为了避免响应结果数据量太大导致内存溢出，建议使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#findBatch-java.lang.String-io.vertx.core.json.JsonObject-\">findBatch</a></code> :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>);\nmongoClient.findBatch(<span class=\"hljs-string\">&quot;book&quot;</span>, query)\n  .exceptionHandler(throwable -&gt; throwable.printStackTrace())\n  .endHandler(v -&gt; System.out.println(<span class=\"hljs-string\">&quot;End of research&quot;</span>))\n  .handler(doc -&gt; System.out.println(<span class=\"hljs-string\">&quot;Found doc: &quot;</span> + doc.encodePrettily()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>被匹配到的文档会被 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code> 处理器挨个返回。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 <code><a href=\"../../apidocs/io/vertx/ext/mongo/FindOptions.html\">FindOptions</a></code> 中有一个额外的参数 <code>batchSize</code>，您可以通过设置这个参数，来设置 <code>ReadStream</code> 处理器一次加载的文档的数量。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>);\nFindOptions options = <span class=\"hljs-keyword\">new</span> FindOptions().setBatchSize(<span class=\"hljs-number\">100</span>);\nmongoClient.findBatchWithOptions(<span class=\"hljs-string\">&quot;book&quot;</span>, query, options)\n  .exceptionHandler(throwable -&gt; throwable.printStackTrace())\n  .endHandler(v -&gt; System.out.println(<span class=\"hljs-string\">&quot;End of research&quot;</span>))\n  .handler(doc -&gt; System.out.println(<span class=\"hljs-string\">&quot;Found doc: &quot;</span> + doc.encodePrettily()));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下， <code>batchSize</code> 的值是20。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_finding_a_single_document\"><a class=\"anchor\" href=\"#_finding_a_single_document\"></a>查询单个文档</h3>\n<div class=\"paragraph\">\n<p>要查询单个文档，您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#findOne-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">findOne</a></code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>这有点类似 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#find-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">find</a></code> 方法，但是仅仅返回 find 方法查询命中的第一条数据。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_removing_documents\"><a class=\"anchor\" href=\"#_removing_documents\"></a>删除文档</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#removeDocuments-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">removeDocuments</a></code> 方法来删除文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>其中 <code>query</code> 参数决定了要删除集合中的哪些文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如删除作者为 Tolkien 的所有文档：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>);\nmongoClient.removeDocuments(<span class=\"hljs-string\">&quot;books&quot;</span>, query, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Never much liked Tolkien stuff!&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_removing_a_single_documents\"><a class=\"anchor\" href=\"#_removing_a_single_documents\"></a>删除单个文档</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#removeDocument-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">removeDocument</a></code> 方法来删除文档。</p>\n</div>\n<div class=\"paragraph\">\n<p>这有点类似于 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#removeDocuments-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">removeDocuments</a></code> 方法，只是 <code>removeDocument</code> 方法仅删除匹配到的第一个文档。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_counting_documents\"><a class=\"anchor\" href=\"#_counting_documents\"></a>文档计数</h3>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#count-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">count</a></code> 方法去计算文档数量。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如计算 作者为 Tolkien 的书的数量，结果包装在回调方法中。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>);\nmongoClient.count(<span class=\"hljs-string\">&quot;books&quot;</span>, query, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-keyword\">long</span> num = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_managing_mongodb_collections\"><a class=\"anchor\" href=\"#_managing_mongodb_collections\"></a>管理 MongoDB 集合</h3>\n<div class=\"paragraph\">\n<p>MongoDB 的所有文档数据都存储在集合中。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#getCollections-io.vertx.core.Handler-\">getCollections</a></code> 来获取所有集合的列表</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mongoClient.getCollections(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    List&lt;String&gt; collections = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#createCollection-java.lang.String-io.vertx.core.Handler-\">createCollection</a></code> 方法来创建一个新的集合。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mongoClient.createCollection(<span class=\"hljs-string\">&quot;mynewcollectionr&quot;</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Created ok!</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#dropCollection-java.lang.String-io.vertx.core.Handler-\">dropCollection</a></code> 方法来删除一个集合。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意：删除一个集合将会删除集合中所有的文档！</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mongoClient.dropCollection(<span class=\"hljs-string\">&quot;mynewcollectionr&quot;</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">// Dropped ok!</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_running_other_mongodb_commands\"><a class=\"anchor\" href=\"#_running_other_mongodb_commands\"></a>执行 <code>MongoDB</code> 的其他命令</h3>\n<div class=\"paragraph\">\n<p>您可以通过 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#runCommand-java.lang.String-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">runCommand</a></code> 方法执行任何 `MongoDB`命令。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用这种方式，可以发挥出MongoDB更多优点，比如使用MapReduce。\n更多详情，请参考说明文档 <a href=\"http://docs.mongodb.org/manual/reference/command\">Commands</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如执行 aggregate（译者注：聚合）命令。请注意，命令的名称要做为 runCommand 方法的一个参数，\n并且同时也必须包含在包装命令的 JSON 参数中。这么做是因为 JSON 不是有序的，但 BSON 却是，\n而且 MongoDB 期望 BSON 参数的第一个键值对是命令的名称。所以，为了明确 JSON 中的哪个键值对是命令名称，\n我们也就必须把命令名称单独设置为一个参数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject command = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;aggregate&quot;</span>, <span class=\"hljs-string\">&quot;collection_name&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;pipeline&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonArray());\nmongoClient.runCommand(<span class=\"hljs-string\">&quot;aggregate&quot;</span>, command, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    JsonArray resArr = res.result().getJsonArray(<span class=\"hljs-string\">&quot;result&quot;</span>);\n    <span class=\"hljs-comment\">// etc</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mongodb_extended_json_support\"><a class=\"anchor\" href=\"#_mongodb_extended_json_support\"></a>MongoDB的JSON扩展支持</h3>\n<div class=\"paragraph\">\n<p>目前，MongoDB 只支持 <code>date</code> ， <code>oid</code> 和 <code>binary</code> 类型\n（请参考：http://docs.mongodb.org/manual/reference/mongodb-extended-json[MongoDB Extended JSON] ）</p>\n</div>\n<div class=\"paragraph\">\n<p>例如插入含有 <code>date</code> 类型字段的文档：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>)\n  <span class=\"hljs-comment\">//ISO-8601 date</span>\n  .put(<span class=\"hljs-string\">&quot;publicationDate&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$date&quot;</span>, <span class=\"hljs-string\">&quot;1937-09-21T00:00:00+00:00&quot;</span>));\nmongoService.save(<span class=\"hljs-string\">&quot;publishedBooks&quot;</span>, document).compose(id -&gt; {\n  <span class=\"hljs-keyword\">return</span> mongoService.findOne(<span class=\"hljs-string\">&quot;publishedBooks&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;_id&quot;</span>, id), <span class=\"hljs-keyword\">null</span>);\n}).onComplete(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;To retrieve ISO-8601 date : &quot;</span>\n      + res.result().getJsonObject(<span class=\"hljs-string\">&quot;publicationDate&quot;</span>).getString(<span class=\"hljs-string\">&quot;$date&quot;</span>));\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>例如，插入一个包含二进制的字段的文档并且读取这个字段：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">byte</span>[] binaryObject = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">byte</span>[<span class=\"hljs-number\">40</span>];\nJsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;Alan Turing&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;binaryStuff&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$binary&quot;</span>, binaryObject));\nmongoService.save(<span class=\"hljs-string\">&quot;smartPeople&quot;</span>, document).compose(id -&gt; {\n  <span class=\"hljs-keyword\">return</span> mongoService.findOne(<span class=\"hljs-string\">&quot;smartPeople&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;_id&quot;</span>, id), <span class=\"hljs-keyword\">null</span>);\n}).onComplete(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-keyword\">byte</span>[] reconstitutedBinaryObject = res.result().getJsonObject(<span class=\"hljs-string\">&quot;binaryStuff&quot;</span>).getBinary(<span class=\"hljs-string\">&quot;$binary&quot;</span>);\n    <span class=\"hljs-comment\">//This could now be de-serialized into an object in real life</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>例如保存一个 base 64 编码的字符串，将这个字符串作为 binary 字段插入。并且读取这个字段：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String base64EncodedString = <span class=\"hljs-string\">&quot;a2FpbHVhIGlzIHRoZSAjMSBiZWFjaCBpbiB0aGUgd29ybGQ=&quot;</span>;\nJsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;Alan Turing&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;binaryStuff&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$binary&quot;</span>, base64EncodedString));\nmongoService.save(<span class=\"hljs-string\">&quot;smartPeople&quot;</span>, document).compose(id -&gt; {\n  <span class=\"hljs-keyword\">return</span> mongoService.findOne(<span class=\"hljs-string\">&quot;smartPeople&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;_id&quot;</span>, id), <span class=\"hljs-keyword\">null</span>);\n}).onComplete(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    String reconstitutedBase64EncodedString = res.result().getJsonObject(<span class=\"hljs-string\">&quot;binaryStuff&quot;</span>).getString(<span class=\"hljs-string\">&quot;$binary&quot;</span>);\n    <span class=\"hljs-comment\">//This could now converted back to bytes from the base 64 string</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>例如插入一个 object ID 并且读取它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String individualId = <span class=\"hljs-keyword\">new</span> ObjectId().toHexString();\nJsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;Stephen Hawking&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;individualId&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$oid&quot;</span>, individualId));\nmongoService.save(<span class=\"hljs-string\">&quot;smartPeople&quot;</span>, document).compose(id -&gt; {\n  JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;_id&quot;</span>, id);\n  <span class=\"hljs-keyword\">return</span> mongoService.findOne(<span class=\"hljs-string\">&quot;smartPeople&quot;</span>, query, <span class=\"hljs-keyword\">null</span>);\n}).onComplete(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    String reconstitutedIndividualId = res.result().getJsonObject(<span class=\"hljs-string\">&quot;individualId&quot;</span>).getString(<span class=\"hljs-string\">&quot;$oid&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_getting_distinct_values\"><a class=\"anchor\" href=\"#_getting_distinct_values\"></a>获取 distinct 后的值</h3>\n<div class=\"paragraph\">\n<p>例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>);\nmongoClient.save(<span class=\"hljs-string\">&quot;books&quot;</span>, document).compose(v -&gt; {\n  <span class=\"hljs-keyword\">return</span> mongoClient.distinct(<span class=\"hljs-string\">&quot;books&quot;</span>, <span class=\"hljs-string\">&quot;title&quot;</span>, String.class.getName());\n}).onComplete(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Title is : &quot;</span> + res.result().getJsonArray(<span class=\"hljs-number\">0</span>));\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>例如：在批量模式下， 获取 distinct 后的值：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>);\nmongoClient.save(<span class=\"hljs-string\">&quot;books&quot;</span>, document, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    mongoClient.distinctBatch(<span class=\"hljs-string\">&quot;books&quot;</span>, <span class=\"hljs-string\">&quot;title&quot;</span>, String.class.getName())\n      .handler(book -&gt; System.out.println(<span class=\"hljs-string\">&quot;Title is : &quot;</span> + book.getString(<span class=\"hljs-string\">&quot;title&quot;</span>)));\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>例如查询 distinct 后的值</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;publicationDate&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$date&quot;</span>, <span class=\"hljs-string\">&quot;1937-09-21T00:00:00+00:00&quot;</span>));\nJsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;publicationDate&quot;</span>,\n    <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$gte&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$date&quot;</span>, <span class=\"hljs-string\">&quot;1937-09-21T00:00:00+00:00&quot;</span>)));\nmongoClient.save(<span class=\"hljs-string\">&quot;books&quot;</span>, document).compose(v -&gt; {\n  <span class=\"hljs-keyword\">return</span> mongoClient.distinctWithQuery(<span class=\"hljs-string\">&quot;books&quot;</span>, <span class=\"hljs-string\">&quot;title&quot;</span>, String.class.getName(), query);\n}).onComplete(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;Title is : &quot;</span> + res.result().getJsonArray(<span class=\"hljs-number\">0</span>));\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>例如：在批量查询模式下，获取 distinct 后的值。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject document = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;The Hobbit&quot;</span>)\n  .put(<span class=\"hljs-string\">&quot;publicationDate&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$date&quot;</span>, <span class=\"hljs-string\">&quot;1937-09-21T00:00:00+00:00&quot;</span>));\nJsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;publicationDate&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">&quot;$gte&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;$date&quot;</span>, <span class=\"hljs-string\">&quot;1937-09-21T00:00:00+00:00&quot;</span>)));\nmongoClient.save(<span class=\"hljs-string\">&quot;books&quot;</span>, document, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    mongoClient.distinctBatchWithQuery(<span class=\"hljs-string\">&quot;books&quot;</span>, <span class=\"hljs-string\">&quot;title&quot;</span>, String.class.getName(), query)\n      .handler(book -&gt; System.out.println(<span class=\"hljs-string\">&quot;Title is : &quot;</span> + book.getString(<span class=\"hljs-string\">&quot;title&quot;</span>)));\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_storing_retrieving_files_and_binary_data\"><a class=\"anchor\" href=\"#_storing_retrieving_files_and_binary_data\"></a>存储/检索文件和二进制数据</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>客户端可以使用 MongoDB 的 GridFS 模块来存储或检索文件和二进制数据。（译者注：GridFS是MongoDB的一个子模块，主要用于在MongoDB中存储文件，相当于MongoDB内置的一个分布式文件系统。）\n<code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html\">MongoGridFsClient</a></code> 可以用来上传文件以及数据流到GridFS，\n以及从GridFS下载文件和数据流。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_get_the_mongogridfsclient_to_interact_with_gridfs\"><a class=\"anchor\" href=\"#_get_the_mongogridfsclient_to_interact_with_gridfs\"></a>获取一个可与GridFS交互的MongoGridFsClient。</h3>\n<div class=\"paragraph\">\n<p>通过调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#createGridFsBucketService-java.lang.String-io.vertx.core.Handler-\">createGridFsBucketService</a></code> 方法，\n并且给方法提供一个 bucket 名称，可创建一个 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html\">MongoGridFsClient</a></code> 客户端。\n在 GridFS 中，bucket 名称最终是一个集合，该集合包含对所有存储对象的引用。\n您可以通过提供一个唯一的名称将对象隔离到不同的bucket中。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>bucketName</code> : 要创建的 bucket 的名称</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：使用自定义的bucket名称，\n获取 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html\">MongoGridFsClient</a></code> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mongoClient.createGridFsBucketService(<span class=\"hljs-string\">&quot;bakeke&quot;</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">//Interact with the GridFS client...</span>\n    MongoGridFsClient client = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>GridFS使用 \"fs\" 作为默认的 bucket 名称。如果您想要获取默认的bucket，而不是自定义一个，\n那么请调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html#createDefaultGridFsBucketService-io.vertx.core.Handler-\">createDefaultGridFsBucketService</a></code> 方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：使用默认bucket名称，获取 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html\">MongoGridFsClient</a></code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">mongoClient.createDefaultGridFsBucketService( res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">//Interact with the GridFS client...</span>\n    MongoGridFsClient client = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_drop_an_entire_file_bucket_from_gridfs\"><a class=\"anchor\" href=\"#_drop_an_entire_file_bucket_from_gridfs\"></a>从GridFS中，删除整个文件bucket。</h3>\n<div class=\"paragraph\">\n<p>整个文件bucket及其所有内容都可以使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#drop-io.vertx.core.Handler-\">drop</a></code> 来进行删除。\n该方法可以删除创建`MongoGridFsClient`时指定的bucket。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：删除一个文件bucket。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">gridFsClient.drop(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">//The file bucket is dropped and all files in it, erased</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_find_all_file_ids_in_a_gridfs_bucket\"><a class=\"anchor\" href=\"#_find_all_file_ids_in_a_gridfs_bucket\"></a>在一个GridFS的bucket中，查询所有文件ID。</h3>\n<div class=\"paragraph\">\n<p>调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#findAllIds-io.vertx.core.Handler-\">findAllIds</a></code> 方法，可以查询到在bucket中的所有文件ID。\n可以凭借文件ID,通过使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadFileByID-java.lang.String-java.lang.String-io.vertx.core.Handler-\">downloadFileByID</a></code> 方法，来下载文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：检索文件ID列表。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">gridFsClient.findAllIds(res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    List&lt;String&gt; ids = res.result(); <span class=\"hljs-comment\">//List of file IDs</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_find_file_ids_in_a_gridfs_bucket_matching_a_query\"><a class=\"anchor\" href=\"#_find_file_ids_in_a_gridfs_bucket_matching_a_query\"></a>在一个与查询匹配的GridFS bucket中，查询文件ID。</h3>\n<div class=\"paragraph\">\n<p>可以指定查询以匹配GridFS <code>bucket</code> 中的文件。调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#findIds-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">findIds</a></code> 方法\n可以返回与查询匹配的文件ID列表。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>query</code> : 这是一个可以使用标准MongoDB查询运算符来匹配任何文件元数据的json对象。\n该json对象为空，会匹配所有文档。您可以按照GridFS手册中所述内容，来查询GridFS文件集合的属性。\n<a href=\"https://docs.mongodb.com/manual/core/gridfs/#the-files-collection\" class=\"bare\">https://docs.mongodb.com/manual/core/gridfs/#the-files-collection</a></p>\n</div>\n<div class=\"paragraph\">\n<p>您可以调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadFileByID-java.lang.String-java.lang.String-io.vertx.core.Handler-\">downloadFileByID</a></code> 方法，通过ID来下载文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：基于元数据查询来检索文件ID列表</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;metadata.nick_name&quot;</span>, <span class=\"hljs-string\">&quot;Puhi the eel&quot;</span>);\ngridFsClient.findIds(query, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    List&lt;String&gt; ids = res.result(); <span class=\"hljs-comment\">//List of file IDs</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_delete_file_ids_in_gridfs_based_its_id\"><a class=\"anchor\" href=\"#_delete_file_ids_in_gridfs_based_its_id\"></a>在GridFS中，根据文件的ID来删除文件。</h3>\n<div class=\"paragraph\">\n<p>通过提供文件ID参数，来调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#delete-java.lang.String-io.vertx.core.Handler-\">delete</a></code> 方法，可以删除以前存储在GridFS中的文件。\n可以通过使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#findIds-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">findIds</a></code> 方法，来检索文件ID。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：\n<code>id</code> : 当文件存储到GridFS时，ID会自动生成。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：通过ID删除文件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String id = <span class=\"hljs-string\">&quot;56660b074cedfd000570839c&quot;</span>; <span class=\"hljs-comment\">//The GridFS ID of the file</span>\ngridFsClient.delete(id, (AsyncResult&lt;Void&gt; res) -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    <span class=\"hljs-comment\">//File deleted</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">//Something went wrong</span>\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_upload_a_file_in_gridfs\"><a class=\"anchor\" href=\"#_upload_a_file_in_gridfs\"></a>在GridFS中上传文件</h3>\n<div class=\"paragraph\">\n<p>通过 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#uploadFile-java.lang.String-io.vertx.core.Handler-\">uploadFile</a></code> 方法，文件可以使用文件名称进行存储。\n当文件存储成功时，GridFS会返回自动生成的文件ID。这个ID可以被用来之后检索文件。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>fileName</code> :  这是被存储文件的名称。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">gridFsClient.uploadFile(<span class=\"hljs-string\">&quot;file.name&quot;</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    String id = res.result();\n    <span class=\"hljs-comment\">//The ID of the stored object in Grid FS</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_upload_a_file_in_gridfs_with_options\"><a class=\"anchor\" href=\"#_upload_a_file_in_gridfs_with_options\"></a>上传文件时携带配置参数。</h3>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#uploadFileWithOptions-java.lang.String-io.vertx.ext.mongo.GridFsUploadOptions-io.vertx.core.Handler-\">uploadFileWithOptions</a></code> 方法，\n并传入一个 `<a href=\"../../apidocs/io/vertx/ext/mongo/GridFsUploadOptions.html\">GridFsUploadOptions</a>`的实例，文件可以在存储时，携带额外的配置参数。\n当文件存储成功时，GridFS会返回文件ID。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>metadata</code> : 这是一个json对象，它包含了以后的搜索中可能有用的任何元数据\n<code>chunkSizeBytes</code> : GridFS会将文件分解这个字段数值的数个数据块。（译者注：数据块类似于数据库的分区，数值太大和太小都会影响性能。具体详见官方文档: <a href=\"https://docs.mongodb.com/manual/core/sharding-data-partitioning/）\" class=\"bare\">https://docs.mongodb.com/manual/core/sharding-data-partitioning/）</a></p>\n</div>\n<div class=\"paragraph\">\n<p>例如： 通过文件名上传一个文件，并且携带元数据参数以及指定数据块的大小。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject metadata = <span class=\"hljs-keyword\">new</span> JsonObject();\nmetadata.put(<span class=\"hljs-string\">&quot;nick_name&quot;</span>, <span class=\"hljs-string\">&quot;Puhi the Eel&quot;</span>);\n\nGridFsUploadOptions options = <span class=\"hljs-keyword\">new</span> GridFsUploadOptions();\noptions.setChunkSizeBytes(<span class=\"hljs-number\">1024</span>);\noptions.setMetadata(metadata);\n\ngridFsClient.uploadFileWithOptions(<span class=\"hljs-string\">&quot;file.name&quot;</span>, options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    String id = res.result();\n    <span class=\"hljs-comment\">//The ID of the stored object in Grid FS</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_download_a_file_previously_stored_in_gridfs\"><a class=\"anchor\" href=\"#_download_a_file_previously_stored_in_gridfs\"></a>下载存储在GridFS中的文件</h3>\n<div class=\"paragraph\">\n<p>通过调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadFile-java.lang.String-io.vertx.core.Handler-\">downloadFile</a></code> 方法，可以凭借文件的原始名称来下载文件。\n下载完成后，将返回下载的文件长度，该数值是 <code>Long</code> 类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>fileName</code></dt>\n<dd>\n<p>文件在存储时使用的文件名称</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>例如：凭借文件名称下载存储在GridFS中的文件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">gridFsClient.downloadFile(<span class=\"hljs-string\">&quot;file.name&quot;</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Long fileLength = res.result();\n    <span class=\"hljs-comment\">//The length of the file stored in fileName</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_download_a_file_previously_stored_in_gridfs_given_its_id\"><a class=\"anchor\" href=\"#_download_a_file_previously_stored_in_gridfs_given_its_id\"></a>使用文件ID来下载存储在GridFS中的文件</h3>\n<div class=\"paragraph\">\n<p>通过调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadFileByID-java.lang.String-java.lang.String-io.vertx.core.Handler-\">downloadFileByID</a></code> 方法，可以凭借文件ID来下载文件。\n下载完成后，将返回下载的文件长度，该数值是`Long`类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>id</code> : 文件在存储后生成的文件ID</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：凭借文件ID下载存储在GridFS中的文件。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String id = <span class=\"hljs-string\">&quot;56660b074cedfd000570839c&quot;</span>;\nString filename = <span class=\"hljs-string\">&quot;puhi.fil&quot;</span>;\ngridFsClient.downloadFileByID(id, filename, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Long fileLength = res.result();\n    <span class=\"hljs-comment\">//The length of the file stored in fileName</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_download_a_file_from_gridfs_to_a_new_name\"><a class=\"anchor\" href=\"#_download_a_file_from_gridfs_to_a_new_name\"></a>从GridFS下载文件，并且重新命名文件名称</h3>\n<div class=\"paragraph\">\n<p>在解析文件的时候，可以使用文件的原始名称。而在下载文件时，\n您可以通过调用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadFileAs-java.lang.String-java.lang.String-io.vertx.core.Handler-\">downloadFileAs</a></code> 方法，来重命名文件。\n下载完成后，将返回下载的文件长度，该数值是`Long`类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>fileName</code> : 文件之前存储的旧名称\n<code>newFileName</code> : 文件将被保存的新名称</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">gridFsClient.downloadFileAs(<span class=\"hljs-string\">&quot;file.name&quot;</span>, <span class=\"hljs-string\">&quot;new_file.name&quot;</span>, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Long fileLength = res.result();\n    <span class=\"hljs-comment\">//The length of the file stored in fileName</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    res.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_upload_a_stream_to_gridfs\"><a class=\"anchor\" href=\"#_upload_a_stream_to_gridfs\"></a>将数据流上传到GridFS</h3>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#uploadByFileName-io.vertx.core.streams.ReadStream-java.lang.String-io.vertx.core.Handler-\">uploadByFileName</a></code> 方法，您可以将数据流上传到GridFS。\n当数据流上传成功后，将返回GridFS生成的文件ID。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>stream</code> : 将要被上传的 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code>\n<code>fileName</code> : 将被存储的数据流的名称</p>\n</div>\n<div class=\"paragraph\">\n<p>例如： 上传文件数据流到GridFS。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">gridFsStreamClient.uploadByFileName(asyncFile, <span class=\"hljs-string\">&quot;kanaloa&quot;</span>, stringAsyncResult -&gt; {\n  String id = stringAsyncResult.result();\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_upload_a_stream_to_gridfs_with_options\"><a class=\"anchor\" href=\"#_upload_a_stream_to_gridfs_with_options\"></a>上传数据流时携带配置参数</h3>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#uploadByFileNameWithOptions-io.vertx.core.streams.ReadStream-java.lang.String-io.vertx.ext.mongo.GridFsUploadOptions-io.vertx.core.Handler-\">uploadByFileNameWithOptions</a></code> 方法，\n并传入 <code><a href=\"../../apidocs/io/vertx/ext/mongo/GridFsUploadOptions.html\">GridFsUploadOptions</a></code> 实例，您可以将数据流上传到GridFS。\n当数据流上传成功后，将返回GridFS生成的文件ID。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>stream</code> : 将要被上传的 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html\">ReadStream</a></code>\n<code>fileName</code> : 将被存储的数据流的名称\n`options' : 上传时携带的配置参数</p>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/mongo/GridFsUploadOptions.html\">GridFsUploadOptions</a></code> 具有以下字段:</p>\n</div>\n<div class=\"paragraph\">\n<p><code>metadata</code> : 这是一个json对象，它包含了以后的搜索中可能有用的任何元数据\n<code>chunkSizeBytes</code> : GridFS会将文件分解这个字段数值的数个数据块。（译者注：数据块类似于数据库的分区，数值太大和太小都会影响性能。具体详见mongodb官方文档: <a href=\"https://docs.mongodb.com/manual/core/sharding-data-partitioning/）\" class=\"bare\">https://docs.mongodb.com/manual/core/sharding-data-partitioning/）</a></p>\n</div>\n<div class=\"paragraph\">\n<p>例如： 携带配置参数将一个文件流上传到GridFS。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GridFsUploadOptions options = <span class=\"hljs-keyword\">new</span> GridFsUploadOptions();\noptions.setChunkSizeBytes(<span class=\"hljs-number\">2048</span>);\noptions.setMetadata(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;catagory&quot;</span>, <span class=\"hljs-string\">&quot;Polynesian gods&quot;</span>));\ngridFsStreamClient.uploadByFileNameWithOptions(asyncFile, <span class=\"hljs-string\">&quot;kanaloa&quot;</span>, options, stringAsyncResult -&gt; {\n  String id = stringAsyncResult.result();\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_download_a_stream_from_gridfs_using_file_name\"><a class=\"anchor\" href=\"#_download_a_stream_from_gridfs_using_file_name\"></a>使用文件名称从GridFS中下载数据流</h3>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadByFileName-io.vertx.core.streams.WriteStream-java.lang.String-io.vertx.core.Handler-\">downloadByFileName</a></code> 方法，您可以使用文件名称从GridFS中下载数据流。\n下载完成后，将返回下载的数据流长度，该数值是 <code>Long</code> 类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>stream</code> : 将要被下载的 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>\n<code>fileName</code> : 将被下载的数据流的名称。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如： 下载文件流。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">gridFsStreamClient.downloadByFileName(asyncFile, <span class=\"hljs-string\">&quot;kamapuaa.fil&quot;</span>, longAsyncResult -&gt; {\n  Long length = longAsyncResult.result();\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_download_a_stream_with_options_from_gridfs_using_file_name\"><a class=\"anchor\" href=\"#_download_a_stream_with_options_from_gridfs_using_file_name\"></a>使用文件名称并携带配置参数，从GridFS中下载数据流</h3>\n<div class=\"paragraph\">\n<p>使用 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadByFileNameWithOptions-io.vertx.core.streams.WriteStream-java.lang.String-io.vertx.ext.mongo.GridFsDownloadOptions-io.vertx.core.Handler-\">downloadByFileNameWithOptions</a></code> 方法，\n并传入 <code><a href=\"../../apidocs/io/vertx/ext/mongo/GridFsDownloadOptions.html\">GridFsDownloadOptions</a></code> 实例，您可以使用文件名称并携带配置参数，从GridFS中下载数据流。\n下载完成后，将返回下载的数据流长度，该数值是`Long`类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>stream</code> : 将被下载的`<a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a>`\n<code>fileName</code> : 将被下载的数据流名称\n<code>options</code> : `<a href=\"../../apidocs/io/vertx/ext/mongo/GridFsDownloadOptions.html\">GridFsDownloadOptions</a>`实例</p>\n</div>\n<div class=\"paragraph\">\n<p>DownloadOptions 具有以下字段:</p>\n</div>\n<div class=\"paragraph\">\n<p><code>revision</code> : 要下载文件的版本（译者注：版本字段仅显示文件更改的频率。值为0，代表未经过修改的原始存储的文件）</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：携带配置参数下载文件流。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GridFsDownloadOptions options = <span class=\"hljs-keyword\">new</span> GridFsDownloadOptions();\noptions.setRevision(<span class=\"hljs-number\">0</span>);\ngridFsStreamClient.downloadByFileNameWithOptions(asyncFile, <span class=\"hljs-string\">&quot;kamapuaa.fil&quot;</span>, options, longAsyncResult -&gt; {\n  Long length = longAsyncResult.result();\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_download_a_stream_from_gridfs_using_id\"><a class=\"anchor\" href=\"#_download_a_stream_from_gridfs_using_id\"></a>使用ID下载数据流</h3>\n<div class=\"paragraph\">\n<p>通过调用 `<a href=\"../../apidocs/io/vertx/ext/mongo/MongoGridFsClient.html#downloadById-io.vertx.core.streams.WriteStream-java.lang.String-io.vertx.core.Handler-\">downloadById</a>`方法，您可以使用GridFS生成的ID来下载数据流。\n下载完成后，将返回下载的数据流长度，该数值是`Long`类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>它具有以下字段：</p>\n</div>\n<div class=\"paragraph\">\n<p><code>stream</code> : 将要下载的 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>\n<code>id</code> : GridFS生成的id</p>\n</div>\n<div class=\"paragraph\">\n<p>例如：使用对象的ID下载文件流</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String id = <span class=\"hljs-string\">&quot;58f61bf84cedfd000661af06&quot;</span>;\ngridFsStreamClient.downloadById(asyncFile, id, longAsyncResult -&gt; {\n  Long length = longAsyncResult.result();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_the_client\"><a class=\"anchor\" href=\"#_configuring_the_client\"></a>客户端参数配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x MongoDB 客户端把配置参数放在 JSON 对象中。</p>\n</div>\n<div class=\"paragraph\">\n<p>客户端支持以下这些参数：</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>db_name</code></dt>\n<dd>\n<p>mongoDB 实例的数据库名称。默认是 <code>default_db</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>useObjectId</code></dt>\n<dd>\n<p>此参数用来支持 ObjectId 的持久化和检索。如果设置为 true ，\n将会在集合的文档中，以 16 进制的字符串来保存 MongoDB 的 ObjectId 类型的字段。而且在设置为 true 后，可以让文档基于创建时间排序（译者注：前4个字节用来存储创建的时的时间戳，精确到秒）。\n您也可以通过使用 ObjectId::getDate() 方法，从这个 16进制的字符串中获取创建时间。若您选择其他类型作为 _id ，则设置此参数为 false 。\n如果您保存的文档中，没有设置 _id 字段的值，将会默认的生成 16进制的字符串作为 _id 。\n此参数默认为 false 。</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>此客户端尝试着支持驱动所支持的大多数参数配置。\n有两种配置方式，一种是连接字符串，另一种是驱动配置选项。</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>connection_string</code></dt>\n<dd>\n<p>连接字符串，指的是创建客户端的字符串，例如： <code>mongodb://localhost:27017</code> 。\n有关连接字符串格式的更多信息，请参考驱动程序文档。</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p><strong>驱动配置的具体选项</strong></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-js\" data-lang=\"js\">{\n <span class=\"hljs-comment\">// Single Cluster Settings</span>\n <span class=\"hljs-string\">&quot;host&quot;</span> : <span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>, <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-string\">&quot;port&quot;</span> : <span class=\"hljs-number\">27017</span>,      <span class=\"hljs-comment\">// int</span>\n\n <span class=\"hljs-comment\">// Multiple Cluster Settings</span>\n <span class=\"hljs-string\">&quot;hosts&quot;</span> : [\n   {\n     <span class=\"hljs-string\">&quot;host&quot;</span> : <span class=\"hljs-string\">&quot;cluster1&quot;</span>, <span class=\"hljs-comment\">// string</span>\n     <span class=\"hljs-string\">&quot;port&quot;</span> : <span class=\"hljs-number\">27000</span>       <span class=\"hljs-comment\">// int</span>\n   },\n   {\n     <span class=\"hljs-string\">&quot;host&quot;</span> : <span class=\"hljs-string\">&quot;cluster2&quot;</span>, <span class=\"hljs-comment\">// string</span>\n     <span class=\"hljs-string\">&quot;port&quot;</span> : <span class=\"hljs-number\">28000</span>       <span class=\"hljs-comment\">// int</span>\n   },\n   ...\n ],\n <span class=\"hljs-string\">&quot;replicaSet&quot;</span> :  <span class=\"hljs-string\">&quot;foo&quot;</span>,    <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-string\">&quot;serverSelectionTimeoutMS&quot;</span> : <span class=\"hljs-number\">30000</span>, <span class=\"hljs-comment\">// long</span>\n\n <span class=\"hljs-comment\">// Connection Pool Settings</span>\n <span class=\"hljs-string\">&quot;maxPoolSize&quot;</span> : <span class=\"hljs-number\">50</span>,                <span class=\"hljs-comment\">// int</span>\n <span class=\"hljs-string\">&quot;minPoolSize&quot;</span> : <span class=\"hljs-number\">25</span>,                <span class=\"hljs-comment\">// int</span>\n <span class=\"hljs-string\">&quot;maxIdleTimeMS&quot;</span> : <span class=\"hljs-number\">300000</span>,          <span class=\"hljs-comment\">// long</span>\n <span class=\"hljs-string\">&quot;maxLifeTimeMS&quot;</span> : <span class=\"hljs-number\">3600000</span>,         <span class=\"hljs-comment\">// long</span>\n <span class=\"hljs-string\">&quot;waitQueueTimeoutMS&quot;</span> : <span class=\"hljs-number\">10000</span>,      <span class=\"hljs-comment\">// long</span>\n <span class=\"hljs-string\">&quot;maintenanceFrequencyMS&quot;</span> : <span class=\"hljs-number\">2000</span>,   <span class=\"hljs-comment\">// long</span>\n <span class=\"hljs-string\">&quot;maintenanceInitialDelayMS&quot;</span> : <span class=\"hljs-number\">500</span>, <span class=\"hljs-comment\">// long</span>\n\n <span class=\"hljs-comment\">// Credentials / Auth</span>\n <span class=\"hljs-string\">&quot;username&quot;</span>   : <span class=\"hljs-string\">&quot;john&quot;</span>,     <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-string\">&quot;password&quot;</span>   : <span class=\"hljs-string\">&quot;passw0rd&quot;</span>, <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-string\">&quot;authSource&quot;</span> : <span class=\"hljs-string\">&quot;some.db&quot;</span>   <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-comment\">// Auth mechanism</span>\n <span class=\"hljs-string\">&quot;authMechanism&quot;</span>     : <span class=\"hljs-string\">&quot;GSSAPI&quot;</span>,        <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-string\">&quot;gssapiServiceName&quot;</span> : <span class=\"hljs-string\">&quot;myservicename&quot;</span>, <span class=\"hljs-comment\">// string</span>\n\n <span class=\"hljs-comment\">// Socket Settings</span>\n <span class=\"hljs-string\">&quot;connectTimeoutMS&quot;</span> : <span class=\"hljs-number\">300000</span>, <span class=\"hljs-comment\">// int</span>\n <span class=\"hljs-string\">&quot;socketTimeoutMS&quot;</span>  : <span class=\"hljs-number\">100000</span>, <span class=\"hljs-comment\">// int</span>\n <span class=\"hljs-string\">&quot;sendBufferSize&quot;</span>    : <span class=\"hljs-number\">8192</span>,  <span class=\"hljs-comment\">// int</span>\n <span class=\"hljs-string\">&quot;receiveBufferSize&quot;</span> : <span class=\"hljs-number\">8192</span>,  <span class=\"hljs-comment\">// int</span>\n\n <span class=\"hljs-comment\">// Server Settings</span>\n <span class=\"hljs-string\">&quot;heartbeatFrequencyMS&quot;</span>    : <span class=\"hljs-number\">1000</span>, <span class=\"hljs-comment\">// long</span>\n <span class=\"hljs-string\">&quot;minHeartbeatFrequencyMS&quot;</span> :  <span class=\"hljs-number\">500</span>, <span class=\"hljs-comment\">// long</span>\n\n <span class=\"hljs-comment\">// SSL Settings</span>\n <span class=\"hljs-string\">&quot;ssl&quot;</span> : <span class=\"hljs-literal\">false</span>,                       <span class=\"hljs-comment\">// boolean</span>\n <span class=\"hljs-string\">&quot;sslInvalidHostNameAllowed&quot;</span> : <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// boolean</span>\n <span class=\"hljs-string\">&quot;trustAll&quot;</span> : <span class=\"hljs-literal\">false</span>,                  <span class=\"hljs-comment\">// boolean</span>\n <span class=\"hljs-string\">&quot;keyPath&quot;</span> : <span class=\"hljs-string\">&quot;key.pem&quot;</span>,               <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-string\">&quot;certPath&quot;</span> : <span class=\"hljs-string\">&quot;cert.pem&quot;</span>,             <span class=\"hljs-comment\">// string</span>\n <span class=\"hljs-string\">&quot;caPath&quot;</span> : <span class=\"hljs-string\">&quot;ca.pem&quot;</span>                  <span class=\"hljs-comment\">// string</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><strong>驱动参数说明</strong></p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>host</code></dt>\n<dd>\n<p>mongoDB 实例运行的地址。默认是 <code>127.0.0.1</code>。 如果设置了 <code>hosts</code> 参数，就会忽略 <code>host</code> 参数</p>\n</dd>\n<dt class=\"hdlist1\"><code>port</code></dt>\n<dd>\n<p>mongoDB 实例监听的端口。默认是 <code>127.0.0.1</code>。 如果设置了 <code>hosts</code> 参数，就会忽略 <code>host</code> 参数</p>\n</dd>\n<dt class=\"hdlist1\"><code>hosts</code></dt>\n<dd>\n<p>表示支持 MongoDB 集群（分片／复制）的一组地址和端口</p>\n</dd>\n<dt class=\"hdlist1\"><code>host</code></dt>\n<dd>\n<p>集群中某个运行实例的地址</p>\n</dd>\n<dt class=\"hdlist1\"><code>port</code></dt>\n<dd>\n<p>集群中某个运行实例监听的端口</p>\n</dd>\n<dt class=\"hdlist1\"><code>replicaSet</code></dt>\n<dd>\n<p>某个 mongoDB 实例作为副本集的名称</p>\n</dd>\n<dt class=\"hdlist1\"><code>serverSelectionTimeoutMS</code></dt>\n<dd>\n<p>驱动选择服务器的最大时间，单位毫秒</p>\n</dd>\n<dt class=\"hdlist1\"><code>maxPoolSize</code></dt>\n<dd>\n<p>连接池最大连接数。默认为 <code>100</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>minPoolSize</code></dt>\n<dd>\n<p>连接池最小连接数。默认为 <code>0</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>maxIdleTimeMS</code></dt>\n<dd>\n<p>连接池的连接最大空闲时间。默认为 <code>0</code>，表示一直存在</p>\n</dd>\n<dt class=\"hdlist1\"><code>maxLifeTimeMS</code></dt>\n<dd>\n<p>连接池的连接最大存活时间。默认为 <code>0</code>，表示永远存活</p>\n</dd>\n<dt class=\"hdlist1\"><code>waitQueueTimeoutMS</code></dt>\n<dd>\n<p>线程等待作为连接的最长等待时间。默认为 <code>120000</code>（2分钟）</p>\n</dd>\n<dt class=\"hdlist1\"><code>maintenanceFrequencyMS</code></dt>\n<dd>\n<p>维护任务进行循环检查连接的时间间隔（译者注：维护任务会定时检查连接的状态，直到连接池剩下最小连接数）。默认为 <code>0</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>maintenanceInitialDelayMS</code></dt>\n<dd>\n<p>连接池启动后，维护任务第一次启动的时间。默认为 <code>0</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>username</code></dt>\n<dd>\n<p>授权的用户名。默认为 <code>null</code>（意味着不需要授权）</p>\n</dd>\n<dt class=\"hdlist1\"><code>password</code></dt>\n<dd>\n<p>授权的密码</p>\n</dd>\n<dt class=\"hdlist1\"><code>authSource</code></dt>\n<dd>\n<p>与授权用户关联的数据库名称。默认值为 <code>db_name</code></p>\n</dd>\n<dt class=\"hdlist1\"><code>authMechanism</code></dt>\n<dd>\n<p>所使用的授权认证机制。请参考 [Authentication](<a href=\"http://docs.mongodb.org/manual/core/authentication/\" class=\"bare\">http://docs.mongodb.org/manual/core/authentication/</a> 来获取更多信息。</p>\n</dd>\n<dt class=\"hdlist1\"><code>gssapiServiceName</code></dt>\n<dd>\n<p>当使用`GSSAPI`的授权机制时，所使用的 Kerberos 服务名。</p>\n</dd>\n<dt class=\"hdlist1\"><code>connectTimeoutMS</code></dt>\n<dd>\n<p>打开连接超时的时间，单位毫秒。默认为`10000`（10 秒）</p>\n</dd>\n<dt class=\"hdlist1\"><code>socketTimeoutMS</code></dt>\n<dd>\n<p>在 socket 上接收或者发送超时的时间。默认为`0`，意味着永远不超时（译者注：这是客户端的超时时间。如果一个 insert 达到了 socketTimeoutMS， 将无法得知服务器是否已写入）。</p>\n</dd>\n<dt class=\"hdlist1\"><code>sendBufferSize</code></dt>\n<dd>\n<p>设置 socket 发送缓冲区大小（SO_SNDBUF）。默认为`0`，这将使用操作系统默认大小。</p>\n</dd>\n<dt class=\"hdlist1\"><code>receiveBufferSize</code></dt>\n<dd>\n<p>设置 socket 接收缓冲区大小（SO_RCVBUF）。默认为`0`，这将使用操作系统默认大小。</p>\n</dd>\n<dt class=\"hdlist1\"><code>heartbeatFrequencyMS</code></dt>\n<dd>\n<p>集群监视器访问每个集群服务器的频率。默认为`5000`（5s）</p>\n</dd>\n<dt class=\"hdlist1\"><code>minHeartbeatFrequencyMS</code></dt>\n<dd>\n<p>最小心跳频率。默认为`1000`（1s）</p>\n</dd>\n<dt class=\"hdlist1\"><code>ssl</code></dt>\n<dd>\n<p>在mongo客户端 和 mongo之间，启用ssl</p>\n</dd>\n<dt class=\"hdlist1\"><code>sslInvalidHostNameAllowed</code></dt>\n<dd>\n<p>接受服务器证书中未包含的主机名（译者注：当你启用ssl时，这个配置用来设置是否关闭域名检查。true 为允许，即关闭域名检查）。</p>\n</dd>\n<dt class=\"hdlist1\"><code>trustAll</code></dt>\n<dd>\n<p>当启用ssl时，信任所有证书。<strong>警告</strong> - 开启这个配置将会让您面临一些潜在的安全问题，例如MITM攻击。</p>\n</dd>\n<dt class=\"hdlist1\"><code>keyPath</code></dt>\n<dd>\n<p>设置客户端私钥的路径。客户端私钥是用于在与mongo建立SSL连接时，对服务器进行身份验证。</p>\n</dd>\n<dt class=\"hdlist1\"><code>certPath</code></dt>\n<dd>\n<p>设置客户端证书的路径。客户端证书是用来在与mongo建立SSL连接时，对服务器进行身份验证。</p>\n</dd>\n<dt class=\"hdlist1\"><code>caPath</code></dt>\n<dd>\n<p>设置CA证书的路径。CA证书是用于在与mongo建立SSL连接时，当做一个信任源。</p>\n</dd>\n</dl>\n</div>\n<div class=\"paragraph\">\n<p>请注意：上面提到的各类参数的默认值，都是 MongoDB Java 驱动的默认值。\n请参考驱动文档来获取最新信息。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_3_api\"><a class=\"anchor\" href=\"#_rxjava_3_api\"></a>RxJava 3 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Mongo客户端提供了RX化的原始版本API。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_an_rxified_client\"><a class=\"anchor\" href=\"#_creating_an_rxified_client\"></a>创建一个RX化的客户端</h3>\n<div class=\"paragraph\">\n<p>要想创建一个RX化的Mongo客户端，需要您确保导入了 <code><a href=\"../../apidocs/io/vertx/rxjava3/ext/mongo/MongoClient.html\">MongoClient</a></code> 类。\n创建并获取一个客户端实例的方法有很多，例如下面：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MongoClient client = MongoClient.createShared(vertx, config);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_finding_documents_in_batches\"><a class=\"anchor\" href=\"#_finding_documents_in_batches\"></a>批量查询文档</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava3/core/streams/ReadStream.html\">ReadStream</a></code> 可以被转换成 <code><a href=\"../../apidocs/io/reactivex/rxjava3/core/Flowable.html\">Flowable</a></code> 。这个功能会方便您处理大型数据集。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject query = <span class=\"hljs-keyword\">new</span> JsonObject()\n  .put(<span class=\"hljs-string\">&quot;author&quot;</span>, <span class=\"hljs-string\">&quot;J. R. R. Tolkien&quot;</span>);\n\nReadStream&lt;JsonObject&gt; books = mongoClient.findBatch(<span class=\"hljs-string\">&quot;book&quot;</span>, query);\n\n<span class=\"hljs-comment\">// Convert the stream to a Flowable</span>\nFlowable&lt;JsonObject&gt; flowable = books.toFlowable();\n\nflowable.subscribe(doc -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;Found doc: &quot;</span> + doc.encodePrettily());\n}, throwable -&gt; {\n  throwable.printStackTrace();\n}, () -&gt; {\n  System.out.println(<span class=\"hljs-string\">&quot;End of research&quot;</span>);\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.1.1"},"__N_SSG":true}