{"pageProps":{"slug":"4.1.8/vertx-rx/java2","title":"Vert.x RxJava","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_vert_x_api_for_rxjava2\">用于 RxJava2 的 Vert.x API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_api_for_rxjava2\">在 RxJava2 中使用 Vert.x API</a></li>\n<li><a href=\"#_read_stream_support\">可读流支持</a></li>\n<li><a href=\"#_write_stream_support\">可写流支持</a></li>\n<li><a href=\"#_async_result_support\">异步结果支持</a></li>\n<li><a href=\"#_scheduler_support\">调度器支持</a></li>\n<li><a href=\"#_json_unmarshalling\">JSON解码</a></li>\n<li><a href=\"#_deploying_a_verticle\">部署Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxified_api\">Rx化的 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_embedding_rxfified_vert.x\">嵌入Rx化的 Vert.x</a></li>\n<li><a href=\"#_as_a_verticle\">作为 Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_api_examples\">API 例子</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_eventBus_message_stream\">EventBus 消息流</a></li>\n<li><a href=\"#_timers\">定时器Timers</a></li>\n<li><a href=\"#_http_client_requests\">HTTP客户端请求</a></li>\n<li><a href=\"#_http_server_requests\">HTTP服务端请求</a></li>\n<li><a href=\"#_websocket_client\">WebSocket客户端</a></li>\n<li><a href=\"#_websocket_server\">WebSocket服务端</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x RxJava</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_vert_x_api_for_rxjava2\"><a class=\"anchor\" href=\"#_vert_x_api_for_rxjava2\"></a>用于 RxJava2 的 Vert.x API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> 是一个流行的库，\n旨在使用 Java VM 的可观察序列来编写异步和基于事件的程序。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 与 RxJava 集成起来很自然：它使得无论什么时候，只要我们能使用流和异步结果，就能使用 RxJava。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_api_for_rxjava2\"><a class=\"anchor\" href=\"#_using_vert_x_api_for_rxjava2\"></a>在 RxJava2 中使用 Vert.x API</h3>\n<div class=\"paragraph\">\n<p>要在 RxJava2 中使用 Vert.x API，请将以下依赖项添加到构建描述符的 <em>dependencies</em> 部分中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code>）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-rx-java2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-rx-java2:4.1.8&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>要使用 Vert.x 的 RxJava2 API，有两种方式：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>通过原始的 Vert.x API 辅以辅助类， 这些辅助类提供了提供了用于 Vert.x Core API 和\nRxJava2 API 之间互相转化的静态方法。</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/RxHelper.html\">RxHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/ObservableHelper.html\">ObservableHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/FlowableHelper.html\">FlowableHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/SingleHelper.html\">SingleHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/MaybeHelper.html\">MaybeHelper</a></code></p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/CompletableHelper.html\">CompletableHelper</a></code></p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>通过基于 Vert.x Core API 增强的 <em>Rx化的</em> Vert.x API。</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_read_stream_support\"><a class=\"anchor\" href=\"#_read_stream_support\"></a>可读流支持</h3>\n<div class=\"paragraph\">\n<p>RxJava 中 <code>Flowable</code> 的概念和 Vert.x 中 <code>ReadStream</code> 类是一对完美的匹配：都提供了一个对象流。</p>\n</div>\n<div class=\"paragraph\">\n<p>静态方法 <code><a href=\"../../apidocs/io/vertx/reactivex/FlowableHelper.html#toFlowable-io.vertx.core.streams.ReadStream-\">FlowableHelper.toFlowable</a></code> 用于将\nVert.x 可读流转换为 <code>Flowable</code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fileSystem = vertx.fileSystem();\nfileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Flowable&lt;Buffer&gt; observable = FlowableHelper.toFlowable(file);\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>而 <em>Rx化的</em> Vert.x API 在 <code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/ReadStream.html\">ReadStream</a></code> 类上提供了\n<code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/ReadStream.html#toFlowable--\">toFlowable</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\nfs.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Flowable&lt;Buffer&gt; observable = file.toFlowable();\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这样的 Flowable 是所谓 <strong>hot</strong> Flowable，即不管是否有订阅，它们都会产生通知。\n<code>ReadStream</code> 是否能自发地发射数据，这取决于它的具体实现：</p>\n</div>\n<div class=\"paragraph\">\n<p>当订阅动作发生时，适配器会调用 <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-\">handler</a></code>\n来设置它的 handler 。</p>\n</div>\n<div class=\"paragraph\">\n<p>某些 <code>ReadStream</code> 实现会在这个调用之后开始发射事件，而其他的则与\nhandler 是否设置无关：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>AsyncFile</code> 在 handler 设置后开始产生 buffer 事件</p>\n</li>\n<li>\n<p><code>HttpServerRequest</code> 则不依赖于此（即 如果 handler 未设置，buffer 可能会丢失）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>在上述两种情形中，订阅 <code>Flowable</code> 都是安全的。原因在于不管 event loop 还是 worker\nverticle 都不会被并发执行，所以订阅一定是在 handler\n开始发射数据之前发生。</p>\n</div>\n<div class=\"paragraph\">\n<p>当你想延迟订阅时，需要先 <code>暂停（pause）</code> <code>ReadStream</code> ，并在之后 <code>恢复（resume）</code> 它，\n这与使用 <code>ReadStream</code> 一样。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.POST) {\n\n    <span class=\"hljs-comment\">// 暂停接收 buffer</span>\n    request.pause();\n\n    checkAuth(res -&gt; {\n\n      <span class=\"hljs-comment\">// 现在可以重新接收 buffer</span>\n      request.resume();\n\n      <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n        Flowable&lt;Buffer&gt; flowable = request.toFlowable();\n        flowable.subscribe(buff -&gt; {\n          <span class=\"hljs-comment\">// 获得 buffer</span>\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>同样的，将一个 <code>Flowable</code> 转变为 Vert.x <code>ReadStream</code> 也是可以的。</p>\n</div>\n<div class=\"paragraph\">\n<p>静态方法 <code><a href=\"../../apidocs/io/vertx/reactivex/FlowableHelper.html#toReadStream-io.reactivex.Flowable-\">FlowableHelper.toReadStream</a></code>  用于将\n<code>Flowable</code> 转换为 Vert.x 可读流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Flowable&lt;Buffer&gt; observable = getFlowable();\nReadStream&lt;Buffer&gt; readStream = FlowableHelper.toReadStream(observable);\nPump pump = Pump.pump(readStream, response);\npump.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_write_stream_support\"><a class=\"anchor\" href=\"#_write_stream_support\"></a>可写流支持</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> 类似于 <code>org.reactivestreams.Subscriber</code> ，它会消费数据，并且在消费速度无法跟上生产速度时与生产者协作，以避免积压的情况不断增加。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 提供了 <code><a href=\"../../apidocs/io/vertx/reactivex/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> 适配器，它可以发送 <code>Flowable</code> 对象到任意 <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">将 buffer 发送到 HTTP 服务响应</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nWriteStreamSubscriber&lt;io.vertx.core.buffer.Buffer&gt; subscriber = io.vertx.reactivex.RxHelper.toSubscriber(response);\nflowable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n另外也存在用于非背压的 <code>io.reactivex.Observable</code> 使用的 <code>io.vertx.reactivex.WriteStreamObserver</code> 适配器。\nThe difference is that this adapter will send items to the <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code> even when it can&#8217;t keep-up with the producer rate.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用 <em>Rx化的</em> Vert.x API 进行编程，<code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/WriteStream.html\">WriteStream</a></code> 的实现提供了一个 <code>toSubscriber</code> 方法。\n这样一来，上面的例子可以变得更直接明了：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nflowable.subscribe(response.toSubscriber());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n当 <code>Flowable</code> 成功结束时，该适配器会调用 <code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/WriteStream.html#end--\">end</a></code> 方法。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n该适配器会设置 <code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/WriteStream.html\">WriteStream</a></code> 的 <code>drain</code> 和 <code>exception</code> handler，所以订阅后请不要使用它们。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> 适配器在下述情况下会调用回调方法：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Flowable</code> 错误地结束，或</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/WriteStream.html\">WriteStream</a></code> 失败（如 HTTP 连接被关闭，或文件系统已满），或</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/WriteStream.html\">WriteStream</a></code> 结束（即，所有写入已完成，且文件已关闭），或</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/WriteStream.html\">WriteStream</a></code> 错误地结束（即，所有写入已结束，当关闭文件时发生了错误）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这样不但可以设计更健壮的程序，而且可以在处理完流之后安排其他任务：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\nWriteStreamSubscriber&lt;Buffer&gt; subscriber = response.toSubscriber();\n\nsubscriber.onError(throwable -&gt; {\n  <span class=\"hljs-keyword\">if</span> (!response.headWritten() &amp;&amp; response.closed()) {\n    response.setStatusCode(<span class=\"hljs-number\">500</span>).end(<span class=\"hljs-string\">&quot;oops&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 错误日志</span>\n  }\n});\n\nsubscriber.onWriteStreamError(throwable -&gt; {\n  <span class=\"hljs-comment\">// 错误日志</span>\n});\n\nsubscriber.onWriteStreamEnd(() -&gt; {\n  <span class=\"hljs-comment\">// 将事务结束记录到审计系统...</span>\n});\n\nflowable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果 <code><a href=\"../../apidocs/io/vertx/reactivex/core/streams/WriteStream.html\">WriteStream</a></code> 失败，则该是配置取消订阅 <code>org.reactivestreams.Subscription</code> 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_async_result_support\"><a class=\"anchor\" href=\"#_async_result_support\"></a>异步结果支持</h3>\n<div class=\"paragraph\">\n<p>以一个现有的 Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 对象为基础，你可以创建一个 RxJava <code>Observer</code>，\n并订阅它：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;String&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// 订阅 Single</span>\nSingle.just(<span class=\"hljs-string\">&quot;hello&quot;</span>).subscribe(SingleHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;String&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// 订阅 Single</span>\nMaybe.just(<span class=\"hljs-string\">&quot;hello&quot;</span>).subscribe(MaybeHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;AsyncResult&lt;Void&gt;&gt; handler = getHandler();\n\n<span class=\"hljs-comment\">// 订阅 Single</span>\nCompletable.complete().subscribe(CompletableHelper.toObserver(handler));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化的</em> Vert.x API 复制了类似的每一个方法，并冠以 <code>rx</code> 的前缀，它们都返回 RxJava 的 <code>Single</code> 、\n<code>Maybe</code> 或 <code>Completable</code> 对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpServer&gt; single = vertx\n  .createHttpServer()\n  .rxListen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>);\n\n<span class=\"hljs-comment\">// 订阅绑定端口的事件</span>\nsingle.\n    subscribe(\n        server -&gt; {\n          <span class=\"hljs-comment\">// 服务器在监听</span>\n        },\n        failure -&gt; {\n          <span class=\"hljs-comment\">// 服务器无法启动</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这样的 Single 是 <strong>“冷的”(cold)</strong> ，对应的 API 方法将在注册时被调用。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>Maybe</code> 对象可能有结果、也可能没有结果：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DnsClient client = vertx.createDnsClient(dnsPort, dnsHost);\n\n<span class=\"hljs-comment\">// 此处会返回一个 Maybe 对象，用于订阅实际执行反向DNS查询的结果</span>\nMaybe&lt;String&gt; maybe = client.rxReverseLookup(ipAddress);\n\n<span class=\"hljs-comment\">// 订阅，以执行DNS查询</span>\nmaybe.\n  subscribe(\n    name -&gt; {\n      <span class=\"hljs-comment\">// DNS反向查询返回结果</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// DNS反向查询失败</span>\n    },\n    () -&gt; {\n      <span class=\"hljs-comment\">// DNS反向查询没返回结果</span>\n    }\n  );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>Completable</code> 一般对应 <code>Handler&lt;AsyncResult&lt;Void&gt;&gt;</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Completable single = server.rxClose();\n\n<span class=\"hljs-comment\">// 订阅，以绑定服务端</span>\nsingle.\n  subscribe(\n    () -&gt; {\n      <span class=\"hljs-comment\">// 服务端关闭</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// 服务端关闭，但遇到故障</span>\n    }\n  );</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>如果您不能使用 <em>Rx化的</em> Vert.x API，或您有自己的基于回调的异步方法，Vert.x 提供了下述的适配器：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/SingleHelper.html#toSingle-java.util.function.Consumer-\">SingleHelper.toSingle</a></code> ，</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/MaybeHelper.html#toMaybe-java.util.function.Consumer-\">MaybeHelper.toMaybe</a></code> 以及</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/CompletableHelper.html#toCompletable-java.util.function.Consumer-\">CompletableHelper.toCompletable</a></code> 。</p>\n</li>\n</ul>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Adapting Vert.x core <em>executeBlocking</em> method</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Maybe&lt;String&gt; maybe = MaybeHelper.toMaybe(handler -&gt; {\n  vertx.executeBlocking(fut -&gt; fut.complete(invokeBlocking()), handler);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scheduler_support\"><a class=\"anchor\" href=\"#_scheduler_support\"></a>调度器支持</h3>\n<div class=\"paragraph\">\n<p>有时候 Reactive 扩展库需要执行一些可调度的操作，例如 <code>Flowable#timer</code>\n方法将创建一个能周期性发射事件的定时器并返回之。缺省情况下，这些可调度的操作由 RxJava 管理，\n这意味着定时器线程并非 Vert.x 线程，因此（这些操作）并不是在 Vert.x Event Loop 线程上执行的。</p>\n</div>\n<div class=\"paragraph\">\n<p>在 RxJava 中，有些操作通常会有接受一个 <code>io.reactivex.Scheduler</code> 参数的重载方法用于设定 Scheduler。\n<code>RxHelper</code> 类提供了一个 <code><a href=\"../../apidocs/io/vertx/reactivex/RxHelper.html#scheduler-io.vertx.core.Vertx-\">RxHelper.scheduler</a></code> 方法，其返回的调度器可供 RxJava\n的这些方法使用。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于阻塞型的可调度操作（blocking scheduled actions），我们可以通过 <code><a href=\"../../apidocs/io/vertx/reactivex/RxHelper.html#blockingScheduler-io.vertx.core.Vertx-\">RxHelper.blockingScheduler</a></code>\n方法获得适用的调度器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.blockingScheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava 也能被配置成使用 Vert.x 的调度器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaPlugins.setComputationSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));\nRxJavaPlugins.setIoSchedulerHandler(s -&gt; RxHelper.blockingScheduler(vertx));\nRxJavaPlugins.setNewThreadSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\nRxJava使用 <em>computation</em> 表示非阻塞任务，使用 <em>io</em> 表示阻塞任务，\n这与 Vert.x 术语相反\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化的</em> Vert.x API 在 <code><a href=\"../../apidocs/io/vertx/reactivex/core/RxHelper.html\">RxHelper</a></code> 类中也提供了相似的方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaPlugins.setComputationSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));\nRxJavaPlugins.setIoSchedulerHandler(s -&gt; RxHelper.blockingScheduler(vertx));\nRxJavaPlugins.setNewThreadSchedulerHandler(s -&gt; RxHelper.scheduler(vertx));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>基于一个命名的工作线程池（named worker pool）创建调度器也是可以的，\n如果你想为了调度阻塞操作复用特定的线程池，这将会很有帮助：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.blockingScheduler(workerExecutor);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_unmarshalling\"><a class=\"anchor\" href=\"#_json_unmarshalling\"></a>JSON解码</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/FlowableHelper.html#unmarshaller-java.lang.Class-\">FlowableHelper.unmarshaller</a></code> 方法创建了一个 <code>io.reactivex.rxjava2.FlowableOperator</code> 对象，\n它可以将json格式的 <code>Flowable&lt;Buffer&gt;</code> 转换为对象的 flowable</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Flowable&lt;Buffer&gt; observable = FlowableHelper.toFlowable(file);\n  observable.compose(FlowableHelper.unmarshaller(MyPojo.class)).subscribe(\n      mypojo -&gt; {\n        <span class=\"hljs-comment\">// 处理对象</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><em>Rx化</em> 的辅助类也能做同样的事情：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = file.toObservable();\n  observable.compose(ObservableHelper.unmarshaller((MyPojo.class))).subscribe(\n    mypojo -&gt; {\n      <span class=\"hljs-comment\">// 处理对象</span>\n    }\n  );\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_a_verticle\"><a class=\"anchor\" href=\"#_deploying_a_verticle\"></a>部署Verticle</h3>\n<div class=\"paragraph\">\n<p>部署一个已经存在的 Verticle 实例可以使用 <code><a href=\"../../apidocs/io/vertx/reactivex/core/RxHelper.html#deployVerticle-io.vertx.reactivex.core.Vertx-io.vertx.core.Verticle-\">RxHelper.deployVerticle</a></code> 方法，\n它会部署一个 <code>Verticle</code> 并返回包含部署ID 的 <code>Single&lt;String&gt;</code>。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; deployment = RxHelper.deployVerticle(vertx, verticle);\n\ndeployment.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// 部署成功</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// 部署失败</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxified_api\"><a class=\"anchor\" href=\"#_rxified_api\"></a>Rx化的 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><em>Rx化的</em> API 是 Vert.x API 的一个代码自动生成版本，就像 Vert.x 的 <em>JavaScript</em> 或 <em>Groovy</em> 版本一样。\n这些 API 以 <code>io.vertx.rxjava</code> 为包名前缀，例如 <code>io.vertx.core.Vertx</code> 类对应为\n<code><a href=\"../../apidocs/io/vertx/reactivex/core/Vertx.html\">Vertx</a></code> 类。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_embedding_rxfified_vert.x\"><a class=\"anchor\" href=\"#_embedding_rxfified_vert.x\"></a>嵌入Rx化的 Vert.x</h3>\n<div class=\"paragraph\">\n<p>只需使用 <code><a href=\"../../apidocs/io/vertx/reactivex/core/Vertx.html#vertx--\">Vertx.vertx</a></code> 方法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = io.vertx.reactivex.core.Vertx.vertx();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_as_a_verticle\"><a class=\"anchor\" href=\"#_as_a_verticle\"></a>作为 Verticle</h3>\n<div class=\"paragraph\">\n<p>通过继承 <code><a href=\"../../apidocs/io/vertx/reactivex/core/AbstractVerticle.html\">AbstractVerticle</a></code> 类，它会做一些包装（您将获得一个 RxJava Verticle）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">reactivex</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// 在此可使用Rx化的Vert.x了</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>部署一个 RxJava Verticle 不需要特别的部署器，使用 Java\n部署器即可。</p>\n</div>\n<div class=\"paragraph\">\n<p>支持异步启动的 Verticle 可以重写 <code>rxStart</code> 方法并返回一个 <code>Completable</code> 实例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">reactivex</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Completable <span class=\"hljs-title\">rxStart</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Hello World&quot;</span>))\n      .rxListen()\n      .toCompletable();\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_api_examples\"><a class=\"anchor\" href=\"#_api_examples\"></a>API 例子</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>让我们通过研究一些例子来了解相关 API 吧。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_eventBus_message_stream\"><a class=\"anchor\" href=\"#_eventBus_message_stream\"></a>EventBus 消息流</h3>\n<div class=\"paragraph\">\n<p>很自然地， <code><a href=\"../../apidocs/io/vertx/reactivex/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 类提供了相关的 <code>Observable&lt;Message&lt;T&gt;&gt;</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nObservable&lt;Message&lt;String&gt;&gt; observable = consumer.toObservable();\nDisposable sub = observable.subscribe(msg -&gt; {\n  <span class=\"hljs-comment\">// 获得消息</span>\n});\n\n<span class=\"hljs-comment\">// 10秒后注销</span>\nvertx.setTimer(<span class=\"hljs-number\">10000</span>, id -&gt; {\n  sub.dispose();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> 类提供了 <code><a href=\"../../apidocs/io/vertx/reactivex/core/eventbus/Message.html\">Message</a></code> 的流。\n如果需要，还可以通过 <code><a href=\"../../apidocs/io/vertx/reactivex/core/eventbus/Message.html#body--\">body</a></code> 方法获得消息体组成的新流：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nObservable&lt;String&gt; observable = consumer.bodyStream().toObservable();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava 的 map/reduce 组合风格在这里是相当有用的：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Double&gt; observable = vertx.eventBus().\n    &lt;Double&gt;consumer(<span class=\"hljs-string\">&quot;heat-sensor&quot;</span>).\n    bodyStream().\n    toObservable();\n\nobservable.\n    buffer(<span class=\"hljs-number\">1</span>, TimeUnit.SECONDS).\n    map(samples -&gt; samples.\n        stream().\n        collect(Collectors.averagingDouble(d -&gt; d))).\n    subscribe(heat -&gt; {\n      vertx.eventBus().send(<span class=\"hljs-string\">&quot;news-feed&quot;</span>, <span class=\"hljs-string\">&quot;Current heat is &quot;</span> + heat);\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timers\"><a class=\"anchor\" href=\"#_timers\"></a>定时器Timers</h3>\n<div class=\"paragraph\">\n<p>定时器任务可以通过 <code><a href=\"../../apidocs/io/vertx/reactivex/core/Vertx.html#timerStream-long-\">timerStream</a></code>  方法来创建：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.timerStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback after 1 second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>周期性的任务可以通过 <code><a href=\"../../apidocs/io/vertx/reactivex/core/Vertx.html#periodicStream-long-\">periodicStream</a></code> 方法来创建：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback every second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>通过注销操作可以取消对 Observable 的订阅：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(<span class=\"hljs-keyword\">new</span> Observer&lt;Long&gt;() {\n      <span class=\"hljs-keyword\">private</span> Disposable sub;\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onSubscribe</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Disposable d)</span> </span>{\n        sub = d;\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(Long aLong)</span> </span>{\n        <span class=\"hljs-comment\">// 回调</span>\n        sub.dispose();\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{}\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onComplete</span><span class=\"hljs-params\">()</span> </span>{}\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_client_requests\"><a class=\"anchor\" href=\"#_http_client_requests\"></a>HTTP客户端请求</h3>\n<div class=\"paragraph\">\n<p>建议结合 RxJava 使用 <a href=\"http://vertx.io/docs/vertx-web-client/java/#_rxjava_api\">Vert.x Web Client</a> 。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_server_requests\"><a class=\"anchor\" href=\"#_http_server_requests\"></a>HTTP服务端请求</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/core/http/HttpServer.html#requestStream--\">requestStream</a></code>\n方法对到达的每个请求都提供了回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  <span class=\"hljs-comment\">// 处理请求</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> 可以被适配为 <code>Observable&lt;Buffer&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;Buffer&gt; observable = request.toObservable();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/ObservableHelper.html#unmarshaller-java.lang.Class-\">ObservableHelper.unmarshaller</a></code> 方法可以用来解析 JSON 格式的请求，\n并将其映射为对象：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;MyPojo&gt; observable = request.\n    toObservable().\n    compose(io.vertx.reactivex.core.ObservableHelper.unmarshaller(MyPojo.class));\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_client\"><a class=\"anchor\" href=\"#_websocket_client\"></a>WebSocket客户端</h3>\n<div class=\"paragraph\">\n<p>当 WebSocket 连接成功或失败时， <code><a href=\"../../apidocs/io/vertx/reactivex/core/http/HttpClient.html#rxWebSocket-int-java.lang.String-java.lang.String-\">rxWebSocket</a></code>\n方法对此提供了一次性的回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nclient.rxWebSocket(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>).subscribe(\n    ws -&gt; {\n      <span class=\"hljs-comment\">// 使用 websocket</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// 连接失败</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/reactivex/core/http/WebSocket.html\">WebSocket</a></code>  对象可以轻松地转换为 <code>Observable&lt;Buffer&gt;</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Flowable&lt;Buffer&gt; dataObs = socket.toFlowable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_server\"><a class=\"anchor\" href=\"#_websocket_server\"></a>WebSocket服务端</h3>\n<div class=\"paragraph\">\n<p>每当有新连接到达时， <code><a href=\"../../apidocs/io/vertx/reactivex/core/http/HttpServer.html#webSocketStream--\">webSocketStream</a></code>\n方法都会提供一次回调：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;ServerWebSocket&gt; socketObservable = server.webSocketStream().toObservable();\nsocketObservable.subscribe(\n    socket -&gt; System.out.println(<span class=\"hljs-string\">&quot;Web socket connect&quot;</span>),\n    failure -&gt; System.out.println(<span class=\"hljs-string\">&quot;Should never be called&quot;</span>),\n    () -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Subscription ended or server closed&quot;</span>);\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> 对象可以轻松地转换为 <code>Observable&lt;Buffer&gt;</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.1.8"},"__N_SSG":true}