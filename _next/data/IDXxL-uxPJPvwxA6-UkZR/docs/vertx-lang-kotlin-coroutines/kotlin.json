{"pageProps":{"slug":"vertx-lang-kotlin-coroutines/kotlin","title":"vertx-lang-kotlin-coroutines","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_introduction\">介绍</a></li>\n<li><a href=\"#_running_a_coroutine_from_a_vert_x_context\">在 Vert.x 上下文中运行协程</a></li>\n<li><a href=\"#_extending_coroutineverticle\">继承 CoroutineVerticle</a></li>\n<li><a href=\"#_getting_one_shot_asynchronous_results\">单次获取异步执行的结果</a></li>\n<li><a href=\"#_getting_one_shot_events\">单次获取事件</a></li>\n<li><a href=\"#_getting_one_shot_worker_results\">单次获取 worker 结果</a></li>\n<li><a href=\"#_streams_of_events\">事件流</a></li>\n<li><a href=\"#_awaiting_the_completion_of_vert_x_asynchronous_results\">获取 Vert.x 异步操作的完成结果</a></li>\n<li><a href=\"#_suspending_extension_methods\">suspend（可挂起）的扩展方法</a></li>\n<li><a href=\"#_channels\">channels（通道）</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_receiving_data\">接收数据</a></li>\n<li><a href=\"#_sending_data\">发送数据</a></li>\n</ul>\n</li>\n<li><a href=\"#_delay_cancellation_and_timeouts\">延迟，取消和超时</a></li>\n<li><a href=\"#_coroutine_builders\">协程构建器</a></li>\n<li><a href=\"#_coroutine_interoperability\">协程互操作性</a></li>\n<li><a href=\"#_rxjava_interoperability\">RxJava 互操作性</a></li>\n</ul>\n</div>","contents":"<h1>vertx-lang-kotlin-coroutines</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><code>vertx-lang-kotlin-coroutines</code> 集成了 Kotlin <em>协程</em> 以执行异步操作和处理事件。\n以便在不阻塞内核线程的情况下使用类似顺序代码的编程模型。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_introduction\"><a class=\"anchor\" href=\"#_introduction\"></a>介绍</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 不同于许多经典应用平台的一个关键优势是它几乎是完全非阻塞的\n(指内核线程)。\n这允许基于 Vert.x 的应用程序使用极小数量的内核线程处理极高的并发（比如许多连接和消息），\n这为强大的扩容能力扫除了障碍。</p>\n</div>\n<div class=\"paragraph\">\n<p>非阻塞的特性促生了异步的API，异步API存在很多种变种形式，比如 callbacks, promises, fibers 和 reactive 扩展。在核心API中，Vert.x\n使用了callback风格，但它也支持其他模型比如\nRxJava 1 和 2。</p>\n</div>\n<div class=\"paragraph\">\n<p>在一些情况下，使用异步 API 编程要比使用经典的/顺序风格更加富有挑战性，\n特别是当几个操作需要以顺序的形式完成时。\n同理，当使用异步 API 时，错误传递通常也更加复杂。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx-lang-kotlin-coroutines</code> 使用 <em>协程</em> 。协程是一种非常轻量级的、不对应到内核线程的线程，\n因此当一个 <em>协程</em> 需要“阻塞”时，它会 <em>挂起</em> 并释放当前的内核线程，\n使另一个协程可以处理事件。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx-lang-kotlin-coroutines</code> 使用 <a href=\"https://github.com/Kotlin/kotlinx.coroutines\">kotlinx.coroutines</a> 来实现协程。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<code>vertx-lang-kotlin-coroutines</code> 目前仅在 Kotlin 下工作，并且将在 Kotlin 1.3\n脱离 <a href=\"https://kotlinlang.org/docs/reference/coroutines.html#experimental-status-of-coroutines\">Experimental（实验性）</a> 状态\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_a_coroutine_from_a_vert_x_context\"><a class=\"anchor\" href=\"#_running_a_coroutine_from_a_vert_x_context\"></a>在 Vert.x 上下文中运行协程</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>导入 <code>io.vertx.kotlin.coroutines.VertxCoroutine</code> 后，通过 <code>GlobalScope.launch</code> 方法可以在 \"Global\" 作用域（生命周期与应用一致）\n中运行一个协程代码块，</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">val</span> vertx = Vertx.vertx()\n\nGlobalScope.launch(vertx.dispatcher()) {\n  <span class=\"hljs-keyword\">val</span> timerId = awaitEvent&lt;<span class=\"hljs-built_in\">Long</span>&gt; { handler -&gt;\n    vertx.setTimer(<span class=\"hljs-number\">1000</span>, handler)\n  }\n  println(<span class=\"hljs-string\">\"Event fired from timer with id <span class=\"hljs-variable\">$timerId</span>\"</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx.dispatcher()</code> 返回了一个协程调度器，以便让协程运行在 Vert.x 的事件循环上。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>awaitEvent</code> 函数挂起了协程，当定时器超时时协程会通过被提供的 handler\n恢复执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>下一章节会提供更多有关 handler, 事件和流事件的信息。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_extending_coroutineverticle\"><a class=\"anchor\" href=\"#_extending_coroutineverticle\"></a>继承 CoroutineVerticle</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>你可以在代码中编写一个继承于 <code>io.vertx.kotlin.coroutines.CoroutineVerticle</code> 的实例，这是专为 Kotlin 协程准备的一个特殊类型的 Verticle。\n<code>CoroutineVerticle</code> 类实现了 <code>kotlinx.coroutines.experimental.CoroutineScope</code> 接口，所有协程构建器都默认绑定到 Verticle 的上下文。\n你应当重写 Verticle 中的suspend方法 <code>start()</code> ，\n以及 <code>stop()</code>（可选的）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> : <span class=\"hljs-type\">CoroutineVerticle</span></span>() {\n  <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n\n  <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以上所有的代码都将会被运行在一个 <code>CoroutineVerticle</code> 实例中，但是你也可以把所有的 <code>&lt;builder&gt; { .. }</code> 都替换为\n<code>GlobalScope.&lt;builder&gt; { .. }</code> 以使代码运行在应用内自定义的作用域。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_one_shot_asynchronous_results\"><a class=\"anchor\" href=\"#_getting_one_shot_asynchronous_results\"></a>单次获取异步执行的结果</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 中的许多异步操作的最后一个参数是一个 <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 。\n比如在通过 Vert.x Mongo 客户端获取一个对象，或者在事件总线上发送一条消息并等待回复的时候。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以通过 <code>awaitResult</code> 方法来返回值或者抛出一个异常。</p>\n</div>\n<div class=\"paragraph\">\n<p>协程将被挂起直到事件被处理，内核线程不会被阻塞。</p>\n</div>\n<div class=\"paragraph\">\n<p>该方法通过指定一个会在运行时被传入 handler 的异步操作代码块来运行。</p>\n</div>\n<div class=\"paragraph\">\n<p>示例如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitResultExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> consumer = vertx.eventBus().localConsumer&lt;String&gt;(<span class=\"hljs-string\">\"a.b.c\"</span>)\n  consumer.handler { message -&gt;\n    println(<span class=\"hljs-string\">\"Consumer received: <span class=\"hljs-subst\">${message.body()}</span>\"</span>)\n    message.reply(<span class=\"hljs-string\">\"pong\"</span>)\n  }\n\n  <span class=\"hljs-comment\">// 发送一条消息并等待回复</span>\n  <span class=\"hljs-keyword\">val</span> reply = awaitResult&lt;Message&lt;String&gt;&gt; { h -&gt;\n    vertx.eventBus().request(<span class=\"hljs-string\">\"a.b.c\"</span>, <span class=\"hljs-string\">\"ping\"</span>, h)\n  }\n  println(<span class=\"hljs-string\">\"Reply received: <span class=\"hljs-subst\">${reply.body()}</span>\"</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当块中的代码产生了一个异常时，调用者可以像处理一个普通的异常一样，使用\n<code>try</code>/<code>catch</code> 来处理异常：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitResultFailureExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> consumer = vertx.eventBus().localConsumer&lt;String&gt;(<span class=\"hljs-string\">\"a.b.c\"</span>)\n  consumer.handler { message -&gt;\n    <span class=\"hljs-comment\">// consumer会接收到一个失败</span>\n    message.fail(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"it failed!!!\"</span>)\n  }\n\n  <span class=\"hljs-comment\">// 发送一条消息并等待回复</span>\n  <span class=\"hljs-keyword\">try</span> {\n    awaitResult&lt;Message&lt;String&gt;&gt; { h -&gt;\n      vertx.eventBus().request(<span class=\"hljs-string\">\"a.b.c\"</span>, <span class=\"hljs-string\">\"ping\"</span>, h)\n    }\n  } <span class=\"hljs-keyword\">catch</span> (e: ReplyException) {\n    <span class=\"hljs-comment\">// 在这里处理特定的异常回复</span>\n    println(<span class=\"hljs-string\">\"Reply failure: <span class=\"hljs-subst\">${e.message}</span>\"</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_one_shot_events\"><a class=\"anchor\" href=\"#_getting_one_shot_events\"></a>单次获取事件</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>可以使用函数 <code>awaitEvent</code> 来处理一个单次事件（如果事件再次发生，它将不会继续被处理）。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitEventExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> id = awaitEvent&lt;<span class=\"hljs-built_in\">Long</span>&gt; { h -&gt; vertx.setTimer(<span class=\"hljs-number\">2000L</span>, h) }\n  println(<span class=\"hljs-string\">\"This should be fired in 2s by some time with id=<span class=\"hljs-variable\">$id</span>\"</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_one_shot_worker_results\"><a class=\"anchor\" href=\"#_getting_one_shot_worker_results\"></a>单次获取 worker 结果</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>处理阻塞计算的结果可以使用函数 <code>awaitBlocking</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitBlockingExample</span><span class=\"hljs-params\">()</span></span> {\n  awaitBlocking {\n    Thread.sleep(<span class=\"hljs-number\">1000</span>)\n    <span class=\"hljs-string\">\"some-string\"</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_streams_of_events\"><a class=\"anchor\" href=\"#_streams_of_events\"></a>事件流</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x API 有许多地方使用处理器（handlers）处理事件流。\n以下示例包含了处理事件总线消息和 HTTP 服务请求。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>ReceiveChannelHandler</code> 类允许通过suspend方法 <code>receive</code> 接收事件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">streamExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> adapter = vertx.receiveChannelHandler&lt;Message&lt;<span class=\"hljs-built_in\">Int</span>&gt;&gt;()\n  vertx.eventBus().localConsumer&lt;<span class=\"hljs-built_in\">Int</span>&gt;(<span class=\"hljs-string\">\"a.b.c\"</span>).handler(adapter)\n\n  <span class=\"hljs-comment\">// 发送15条消息</span>\n  <span class=\"hljs-keyword\">for</span> (i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">15</span>) vertx.eventBus().send(<span class=\"hljs-string\">\"a.b.c\"</span>, i)\n\n  <span class=\"hljs-comment\">// 接收前面10条消息</span>\n  <span class=\"hljs-keyword\">for</span> (i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">10</span>) {\n    <span class=\"hljs-keyword\">val</span> message = adapter.receive()\n    println(<span class=\"hljs-string\">\"Received: <span class=\"hljs-subst\">${message.body()}</span>\"</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_awaiting_the_completion_of_vert_x_asynchronous_results\"><a class=\"anchor\" href=\"#_awaiting_the_completion_of_vert_x_asynchronous_results\"></a>获取 Vert.x 异步操作的完成结果</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 4 提供了 future 模型并且 <code>Future</code> 包含一个可用来异步获取结果的suspend方法 <code>await()</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 异步结果实例上的 <code>await</code> 扩展方法挂起协程直到异步操作完成，并返回一个关联的 <code>AsyncResult&lt;T&gt;</code> 对象。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitingFuture</span><span class=\"hljs-params\">(anotherFuture: <span class=\"hljs-type\">Future</span>&lt;<span class=\"hljs-type\">String</span>&gt;)</span></span> {\n  <span class=\"hljs-comment\">// 获取一个 future</span>\n  <span class=\"hljs-keyword\">val</span> httpServerFuture = vertx.createHttpServer()\n    .requestHandler { req -&gt; req.response().end(<span class=\"hljs-string\">\"Hello!\"</span>) }\n    .listen(<span class=\"hljs-number\">8000</span>)\n\n  <span class=\"hljs-keyword\">val</span> httpServer = httpServerFuture.await()\n  println(<span class=\"hljs-string\">\"HTTP server port: <span class=\"hljs-subst\">${httpServer.actualPort()}</span>\"</span>)\n\n  <span class=\"hljs-comment\">// 对于 composite futures 也一样</span>\n  <span class=\"hljs-keyword\">val</span> result = CompositeFuture.all(httpServerFuture, anotherFuture).await()\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    println(<span class=\"hljs-string\">\"The server is now running!\"</span>)\n  } <span class=\"hljs-keyword\">else</span> {\n    result.cause().printStackTrace()\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_suspending_extension_methods\"><a class=\"anchor\" href=\"#_suspending_extension_methods\"></a>suspend（可挂起）的扩展方法</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>为了简化使用 Vert.x 异步 API 的协程编写，Vert.x 3 生成了扩展方法。\n它让用户不必使用 <code>awaitResult</code> ，这使得代码更加简洁和可读。</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 4 提供了基于 future 的 API，但那些扩展方法仍会存在，\n但将被 <em>弃用</em> 。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">generatedSuspendingExtensionMethod</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-comment\">// 使用扩展方法代替 awaitResult</span>\n  <span class=\"hljs-keyword\">val</span> client = vertx.createNetClient()\n  <span class=\"hljs-keyword\">val</span> socket = client.connect(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>).await()\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_channels\"><a class=\"anchor\" href=\"#_channels\"></a>channels（通道）</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>channel类似于 Java 的 <code>BlockingQueue</code> ，不同之处在于它不是阻塞的，而是在如下情况中挂起协程：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>向一个满的channel中写入值</p>\n</li>\n<li>\n<p>从一个空的channel中读取值</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>可以通过使用 <code>toChannel</code> 扩展方法使 Vert.x 的 <code>ReadStream</code> 和 <code>WriteStream</code> 适配到channel</p>\n</div>\n<div class=\"paragraph\">\n<p>这些适配器将会管理背压和流终止</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>ReadStream&lt;T&gt;</code> 适配到 <code>ReceiveChannel&lt;T&gt;</code></p>\n</li>\n<li>\n<p><code>WriteStream&lt;T&gt;</code> 适配到 <code>SendChannel&lt;T&gt;</code></p>\n</li>\n</ul>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_receiving_data\"><a class=\"anchor\" href=\"#_receiving_data\"></a>接收数据</h3>\n<div class=\"paragraph\">\n<p>当你需要处理一系列互相关联的值时，channel非常有用:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">handleTemperatureStream</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> stream = vertx.eventBus().consumer&lt;<span class=\"hljs-built_in\">Double</span>&gt;(<span class=\"hljs-string\">\"temperature\"</span>)\n  <span class=\"hljs-keyword\">val</span> channel = stream.toChannel(vertx)\n\n  <span class=\"hljs-keyword\">var</span> min = <span class=\"hljs-built_in\">Double</span>.MAX_VALUE\n  <span class=\"hljs-keyword\">var</span> max = <span class=\"hljs-built_in\">Double</span>.MIN_VALUE\n\n  <span class=\"hljs-comment\">// 迭代直到 stream 被关闭</span>\n  <span class=\"hljs-comment\">// 非阻塞的</span>\n  <span class=\"hljs-keyword\">for</span> (msg <span class=\"hljs-keyword\">in</span> channel) {\n    <span class=\"hljs-keyword\">val</span> temperature = msg.body()\n    min = Math.min(min, temperature)\n    max = Math.max(max, temperature)\n  }\n\n  <span class=\"hljs-comment\">// stream 现在被关闭了</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>解析协议时，channel也非常有用，下面我们将构建一个非阻塞的 HTTP 请求解析器来展示channel的强大功能。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们将依靠 <a href=\"http://vertx.io/docs/apidocs/io/vertx/core/parsetools/RecordParser.html\"><code>RecordParser</code></a> 来根据 <code>\\r\\n</code> 切分缓冲流。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面是这个解析器的一个初始版本，它仅处理 HTTP 的请求行</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">vertx.createNetServer().connectHandler { socket -&gt;\n\n  <span class=\"hljs-comment\">// 记录解析器提供了一个以\\r\\n分隔的缓冲流</span>\n  <span class=\"hljs-keyword\">val</span> stream = RecordParser.newDelimited(<span class=\"hljs-string\">\"\\r\\n\"</span>, socket)\n\n  <span class=\"hljs-comment\">// 将 stream 转换为一个 Kotlin channel</span>\n  <span class=\"hljs-keyword\">val</span> channel = stream.toChannel(vertx)\n\n  <span class=\"hljs-comment\">// 启动协程</span>\n  launch {\n\n    <span class=\"hljs-comment\">// 接收请求行</span>\n    <span class=\"hljs-comment\">// 非阻塞</span>\n    <span class=\"hljs-keyword\">val</span> line = channel.receive().toString().split(<span class=\"hljs-string\">\" \"</span>)\n    <span class=\"hljs-keyword\">val</span> method = line[<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">val</span> uri = line[<span class=\"hljs-number\">1</span>]\n\n    println(<span class=\"hljs-string\">\"Received HTTP request (<span class=\"hljs-variable\">$method</span>, <span class=\"hljs-variable\">$uri</span>)\"</span>)\n\n    <span class=\"hljs-comment\">// 仍然需要解析标题和正文……</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>解析请求行只需简单地在channel上调用 <code>receive</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>下一步是通过接收分块来解析 HTTP 头，直到遇到一个空白行。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">// 接收 HTTP 头</span>\n<span class=\"hljs-keyword\">val</span> headers = HashMap&lt;String, String&gt;()\n<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n\n  <span class=\"hljs-comment\">// 非阻塞</span>\n  <span class=\"hljs-keyword\">val</span> header = channel.receive().toString()\n\n  <span class=\"hljs-comment\">// 完成头解析</span>\n  <span class=\"hljs-keyword\">if</span> (header.isEmpty()) {\n    <span class=\"hljs-keyword\">break</span>\n  }\n\n  <span class=\"hljs-keyword\">val</span> pos = header.indexOf(<span class=\"hljs-string\">':'</span>)\n  headers[header.substring(<span class=\"hljs-number\">0</span>, pos).toLowerCase()] = header.substring(pos + <span class=\"hljs-number\">1</span>).trim()\n}\n\nprintln(<span class=\"hljs-string\">\"Received HTTP request (<span class=\"hljs-variable\">$method</span>, <span class=\"hljs-variable\">$uri</span>) with headers <span class=\"hljs-subst\">${headers.keys}</span>\"</span>)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>最终我们用处理一个可选的请求体来终止解析器</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">// 接收请求体</span>\n<span class=\"hljs-keyword\">val</span> transferEncoding = headers[<span class=\"hljs-string\">\"transfer-encoding\"</span>]\n<span class=\"hljs-keyword\">val</span> contentLength = headers[<span class=\"hljs-string\">\"content-length\"</span>]\n\n<span class=\"hljs-keyword\">val</span> body: Buffer?\n<span class=\"hljs-keyword\">if</span> (transferEncoding == <span class=\"hljs-string\">\"chunked\"</span>) {\n\n  <span class=\"hljs-comment\">// 处理分块编码，例如</span>\n  <span class=\"hljs-comment\">// 5\\r\\n</span>\n  <span class=\"hljs-comment\">// HELLO\\r\\n</span>\n  <span class=\"hljs-comment\">// 0\\r\\n</span>\n  <span class=\"hljs-comment\">// \\r\\n</span>\n\n  body = Buffer.buffer()\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n\n    <span class=\"hljs-comment\">// 解析长度块</span>\n    <span class=\"hljs-comment\">// 非阻塞</span>\n    <span class=\"hljs-keyword\">val</span> len = channel.receive().toString().toInt(<span class=\"hljs-number\">16</span>)\n    <span class=\"hljs-keyword\">if</span> (len == <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">break</span>\n    }\n\n    <span class=\"hljs-comment\">// 翻转stream以解析确切大小的块</span>\n    stream.fixedSizeMode(len + <span class=\"hljs-number\">2</span>)\n\n    <span class=\"hljs-comment\">// 接收数据块并添加到末尾</span>\n    <span class=\"hljs-comment\">// 非阻塞</span>\n    <span class=\"hljs-keyword\">val</span> chunk = channel.receive()\n    body.appendBuffer(chunk, <span class=\"hljs-number\">0</span>, chunk.length() - <span class=\"hljs-number\">2</span>)\n\n    <span class=\"hljs-comment\">// stream被翻转回\\r\\n分隔符以解析下一个块</span>\n    stream.delimitedMode(<span class=\"hljs-string\">\"\\r\\n\"</span>)\n  }\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (contentLength != <span class=\"hljs-literal\">null</span>) {\n\n  <span class=\"hljs-comment\">// 翻转stream以解析确切大小的块</span>\n  stream.fixedSizeMode(contentLength.toInt())\n\n  <span class=\"hljs-comment\">// 非阻塞</span>\n  body = channel.receive()\n} <span class=\"hljs-keyword\">else</span> {\n  body = <span class=\"hljs-literal\">null</span>\n}\n\n<span class=\"hljs-keyword\">val</span> bodySize = body?.length() ?: <span class=\"hljs-number\">0</span>\nprintln(<span class=\"hljs-string\">\"Received HTTP request (<span class=\"hljs-variable\">$method</span>, <span class=\"hljs-variable\">$uri</span>) with headers <span class=\"hljs-subst\">${headers.keys}</span> and body with size <span class=\"hljs-variable\">$bodySize</span>\"</span>)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sending_data\"><a class=\"anchor\" href=\"#_sending_data\"></a>发送数据</h3>\n<div class=\"paragraph\">\n<p>使用channel发送数据非常简单清晰：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">sendChannel</span><span class=\"hljs-params\">(httpResponse: <span class=\"hljs-type\">HttpServerResponse</span>)</span></span> {\n  <span class=\"hljs-keyword\">val</span> channel = httpResponse.toChannel(vertx)\n\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">val</span> buffer = readBuffer()\n\n    <span class=\"hljs-comment\">// 广播 temperature</span>\n    <span class=\"hljs-comment\">// 非阻塞但是可以被挂起</span>\n    channel.send(buffer)\n\n    <span class=\"hljs-comment\">//等待1秒</span>\n    awaitEvent&lt;<span class=\"hljs-built_in\">Long</span>&gt; { vertx.setTimer(<span class=\"hljs-number\">1000</span>, it) }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>SendChannel#send</code> 和 <code>WriteStream#write</code> 都是非阻塞操作，然而不同于\n<code>SendChannel#send</code> 可以在channel满时暂停执行，不使用channel的情况看起来像</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">broadcastTemperature</span><span class=\"hljs-params\">(httpResponse: <span class=\"hljs-type\">HttpServerResponse</span>)</span></span> {\n<span class=\"hljs-comment\">// 检查是否可以向 stream 中写入</span>\n  <span class=\"hljs-keyword\">if</span> (httpResponse.writeQueueFull()) {\n\n    <span class=\"hljs-comment\">// 这时我们不能写入，所以我们设置了一个引流处理程序，当我们可以再次写的时候被调用</span>\n    httpResponse.drainHandler { broadcastTemperature(httpResponse) }\n  } <span class=\"hljs-keyword\">else</span> {\n\n    <span class=\"hljs-comment\">// 读入 temperature</span>\n    <span class=\"hljs-keyword\">val</span> temperature = readBuffer()\n\n    <span class=\"hljs-comment\">// 将它写回 stream</span>\n    httpResponse.write(temperature)\n\n    <span class=\"hljs-comment\">// 等待1秒</span>\n    vertx.setTimer(<span class=\"hljs-number\">1000</span>) {\n      broadcastTemperature()\n    }\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_delay_cancellation_and_timeouts\"><a class=\"anchor\" href=\"#_delay_cancellation_and_timeouts\"></a>延迟，取消和超时</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vertx 调度器通过Vert.x timers为协程的 <code>delay</code> 函数提供了完整的支持：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">launch {\n  <span class=\"hljs-comment\">// 设置一个1秒的 Vertx timer计时器</span>\n  delay(<span class=\"hljs-number\">1000</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>定时器支持取消</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">val</span> job = launch {\n  <span class=\"hljs-comment\">// 设置一个1秒的 Vertx timer计时器</span>\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    delay(<span class=\"hljs-number\">1000</span>)\n    <span class=\"hljs-comment\">// 做一些周期性的工作</span>\n  }\n}\n\n<span class=\"hljs-comment\">// 一段时间后</span>\njob.cancel()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>取消操作是 <a href=\"https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#cancellation-is-cooperative\">协作的</a></p>\n</div>\n<div class=\"paragraph\">\n<p>你也可以使用 <code>withTimeout</code> 来设定一个超时值</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">launch {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">val</span> id = withTimeout&lt;String&gt;(<span class=\"hljs-number\">1000</span>) {\n      awaitEvent { anAsyncMethod(it) }\n    }\n  } <span class=\"hljs-keyword\">catch</span> (e: TimeoutCancellationException) {\n    <span class=\"hljs-comment\">// 被取消</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_coroutine_builders\"><a class=\"anchor\" href=\"#_coroutine_builders\"></a>协程构建器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 适用于任何协程构建器，如 <code>launch</code> ， <code>async</code> ， <code>produce</code> …… ，只要 <code>CoroutineScope</code> 实例是有效的。\n下面是几个注意事项：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>不要在 Vert.x 事件循环线程中使用`runBlocking`，因为这个方法不需要提供 <code>CoroutineScope</code> 。</p>\n</li>\n<li>\n<p>为了避免内存泄漏，请始终使用 <code>coroutineScope {..}</code> 来定义一个子作用域。这样，如果作用域中的一个协程失败，所有在该作用域中的协程也都会被取消。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_coroutine_interoperability\"><a class=\"anchor\" href=\"#_coroutine_interoperability\"></a>协程互操作性</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 集成被设计成可与 Kotlin 协程全面互通</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当使用 vertx 调度器时，<code>kotlinx.coroutines.experimental.sync.Mutex</code> 将在事件循环线程上执行</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_interoperability\"><a class=\"anchor\" href=\"#_rxjava_interoperability\"></a>RxJava 互操作性</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>模块 <code>vertx-lang-kotlin-coroutines</code> 没有提供与 RxJava 的特定集成，然而 Kotlin 协程提供与 RxJava 的集成，\n它可以很好地和 <code>vertx-lang-kotlin-coroutines</code> 一起工作。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以在这里了解更多： <a href=\"https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive\">Coroutines for reactive streams</a> 。</p>\n</div>\n</div>\n</div>"},"__N_SSG":true}