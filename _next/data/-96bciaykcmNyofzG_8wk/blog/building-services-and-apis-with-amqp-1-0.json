{"pageProps":{"categories":["releases","guides","news"],"post":{"meta":{"title":"Building services and APIs with AMQP 1.0","category":"guides","authors":[{"name":"Jakub Scholz","github_id":"scholzj"}],"summary":"Microservices and APIs are everywhere. Everyone talks about them, presentation slides are full of them ... some people are actually even building them."},"date":"2017-01-25","slug":"building-services-and-apis-with-amqp-1-0","readingTime":{"text":"8 min read","minutes":7.475,"time":448500,"words":1495},"content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Mi\\xADcroser\\xADvices and APIs are every\\xADwhere. Every\\xADone talks about them, pre\\xADsen\\xADta\\xADtion slides are full of them \\u2026 some peo\\xADple are ac\\xADtu\\xADally even build\\xADing them. Mi\\xADcroser\\xADvices and APIs are of course not com\\xADpletely new con\\xADcepts and they are a bit over-\\u200Bhyped. But in gen\\xADeral the ideas be\\xADhind them are not bad. Un\\xADfor\\xADtu\\xADnately, many peo\\xADple seem to be\\xADlieve that the only way how to im\\xADple\\xADment an API in mi\\xADcroser\\xADvice is to use HTTP and REST. That is of course not true. Mi\\xADcroser\\xADvices and APIs can be based on many dif\\xADfer\\xADent pro\\xADto\\xADcols and tech\\xADnolo\\xADgies. My fa\\xADvorite one is of course \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.amqp.org\"\n  }), \"AMQP\"), \". Don\\u2019t take me wrong, HTTP and REST is not nec\\xADes\\xADsar\\xADily bad. But in some cases AMQP is sim\\xADply bet\\xADter and cre\\xADat\\xADing AMQP based APIs does not need to be com\\xADpli\\xADcated.\"), mdx(Alert, {\n    info: true,\n    mdxType: \"Alert\"\n  }, mdx(\"p\", null, \"This is a re-\\u200Bpublication of the fol\\xADlow\\xADing \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://blog.effectivemessaging.com/2017/01/building-services-and-apis-with-amqp-10.html\"\n  }), \"blog post\"))), mdx(\"h2\", {\n    \"id\": \"livescore-service\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#livescore-service\"\n  })), \"LiveScore service\"), mdx(\"p\", null, \"For demon\\xADstra\\xADtion, I will use a very sim\\xADple ser\\xADvice for keep\\xADing scores of foot\\xADball games. It has very basic API. It has only three calls:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Add a new game\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Up\\xADdate a score of ex\\xADist\\xADing game\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"List the scores\\nThe AMQP vari\\xADants will be ad\\xADdi\\xADtion\\xADally able to push live up\\xADdates to the clients.\")), mdx(\"p\", null, \"The demo is using Java and Vert.x toolkit. \", mdx(Link, {\n    href: \"/\",\n    passHref: true,\n    mdxType: \"Link\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }), \"Vert.x\")), \" is cool and I def\\xADi\\xADnitely rec\\xADom\\xADmend it to every\\xADone. But most of the stuff from the demo should be pos\\xADsi\\xADble also in any other pro\\xADgram\\xADming lan\\xADguages and/or frame\\xADwork.\"), mdx(\"h2\", {\n    \"id\": \"http-api\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#http-api\"\n  })), \"HTTP API\"), mdx(\"p\", null, \"HTTP im\\xADple\\xADmen\\xADta\\xADtion of my ser\\xADvice is a typ\\xADi\\xADcal REST API. Since it is very sim\\xADple, it ac\\xADcepts re\\xADquests only on one end\\xADpoint \\u2013 /api/v1.0/scores. New games are added as POST op\\xADer\\xADa\\xADtions, scores are up\\xADdated with PUT op\\xADer\\xADa\\xADtions and list of all scores can be ob\\xADtained with GET.\"), mdx(\"p\", null, \"With Vert.x, cre\\xADat\\xADing HTTP/REST API is very easy. First the web router has to be cre\\xADated with all planned API calls:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), \"router = Router.router(vertx);  \\nrouter.route(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"/api/v1.0/*\\\"\"), \").handler(BodyHandler.create());  \\nrouter.get(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"/api/v1.0/scores\\\"\"), \").handler(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"this\"), \"::getScores);  \\nrouter.post(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"/api/v1.0/scores\\\"\"), \").handler(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"this\"), \"::addGame);  \\nrouter.put(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"/api/v1.0/scores\\\"\"), \").handler(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"this\"), \"::setScore);  \\n\")), mdx(\"p\", null, \"Then the HTTP server has to be cre\\xADated and linked with the router:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), \"HttpServerOptions httpOptions = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" HttpServerOptions();  \\nserver = vertx.createHttpServer(httpOptions)  \\n   .requestHandler(router::accept)  \\n   .listen(httpPort);  \\n\")), mdx(\"p\", null, \"And fi\\xADnally the han\\xADdlers which will be trig\\xADgered for each API call have to be im\\xADple\\xADmented as well. The full code is on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/scholzj/livescore-demo-vertx-http\"\n  }), \"GitHub\"), \".\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"/images/blog/services-and-apis-with-amqp/HTTP-API.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"The HTTP API doesn\\u2019t pro\\xADvide any way how to au\\xADto\\xADmat\\xADi\\xADcally push the score up\\xADdates to the clients. The clients sim\\xADply have to poll the ser\\xADvice pe\\xADri\\xADod\\xADi\\xADcally to get the up\\xADdates. HTTP has of course some ways how to push live up\\xADdates to clients. For ex\\xADam\\xADple, with Web\\xADSock\\xADets or with chun\\xADked trans\\xADfers. How\\xADever, these are not that easy to im\\xADple\\xADment. The ser\\xADvice would also need to keep sep\\xADa\\xADrate con\\xADnec\\xADtion with every client and push the up\\xADdates for each of them sep\\xADa\\xADrately.\"), mdx(\"h2\", {\n    \"id\": \"amqp-api\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#amqp-api\"\n  })), \"AMQP API\"), mdx(\"p\", null, \"Cre\\xADat\\xADing the HTTP API was re\\xADally easy. Cre\\xADat\\xADing an AMQP API has to be more com\\xADpli\\xADcated, right? We would need an AMQP server, which will lis\\xADten on some port, ac\\xADcept the con\\xADnec\\xADtions, ses\\xADsions, links and so on. There are usu\\xADally no nice and sim\\xADple to use li\\xADbraries for this.\"), mdx(\"p\", null, \"Sure, this is one way how to do it. There is ac\\xADtu\\xADally a nice li\\xADbrary called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://qpid.apache.org/proton/index.html\"\n  }), \"Apache Qpid Pro\\xADton\"), \". It has Java and C ver\\xADsions and bind\\xADings into many other lan\\xADguages (Go, C++, Python, \\u2026). It makes cre\\xADat\\xADing your own AMQP server lot eas\\xADier. It will take care of de\\xADcod\\xADing and en\\xADcod\\xADing the AMQP pro\\xADto\\xADcol, han\\xADdling the con\\xADnec\\xADtions, ses\\xADsions etc. But still, Qpid Pro\\xADton is not even nearly as easy to use as the HTTP router used for the HTTP API.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"/images/blog/services-and-apis-with-amqp/AMQP-Server-API.png\",\n    \"alt\": \"API with AMQP server\"\n  }))), mdx(\"p\", null, \"Are there any eas\\xADier op\\xADtions? What if all what is needed to cre\\xADate AMQP based API is a sim\\xADple AMQP client? Nor\\xADmally, that should not be a pos\\xADsi\\xADble be\\xADcause we need the API to lis\\xADten on some port for the clients to con\\xADnect to it and send re\\xADquests. And clients usu\\xADally don\\u2019t lis\\xADten on any ports. How\\xADever, Apache Qpid has some\\xADthing called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://qpid.apache.org/components/dispatch-router/index.html\"\n  }), \"Dis\\xADpatch\"), \". It works as a light\\xADweight AMQP router. Dis\\xADpatch will serve as the AMQP server which was miss\\xADing. It will take care of han\\xADdling client con\\xADnec\\xADtions, se\\xADcu\\xADrity and shield the ser\\xADvice from the ac\\xADtual clients. All the ser\\xADvice needs to do is to use AMQP client to con\\xADnect to Dis\\xADpatch on pre\\xADde\\xADfined ad\\xADdress and wait for the re\\xADquest.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"/images/blog/services-and-apis-with-amqp/AMQP-API.png\",\n    \"alt\": \"AMQP API with Dispatch router\"\n  }))), mdx(\"p\", null, \"Dis\\xADpatch needs to be con\\xADfig\\xADured with three API entry points as ad\\xADdresses:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-text\"\n  }), \"address {  \\n    prefix: /setScore  \\n    distribution: balanced  \\n}  \\naddress {  \\n    prefix: /getScore  \\n    distribution: balanced  \\n}  \\naddress {  \\n    prefix: /addGame  \\n    distribution: balanced  \\n}  \\n\")), mdx(\"p\", null, \"LiveScore ser\\xADvice will con\\xADnect to these ad\\xADdresses as a re\\xADceiver / con\\xADsumer. Clients will con\\xADnect to them as senders  /pro\\xADduc\\xADers. And Dis\\xADpatch will take care of rout\\xADing the mes\\xADsages be\\xADtween the clients and the ser\\xADvice. Clients can also cre\\xADate ad\\xADdi\\xADtional re\\xADceivers so that the ser\\xADvice is able to re\\xADspond to their re\\xADquests and spec\\xADify the ad\\xADdress of the re\\xADceiver as the reply-\\u200Bto header in the re\\xADquest mes\\xADsage. LiveScore ser\\xADvice will au\\xADto\\xADmat\\xADi\\xADcally send the re\\xADsponse to this ad\\xADdress. But spec\\xADi\\xADfy\\xADing a reply-\\u200Bto is not manda\\xADtory. If the client wants, it can sim\\xADply fire the re\\xADquest and for\\xADget about the re\\xADsponse.\"), mdx(\"p\", null, \"LiveScore ser\\xADvice is using Vert.x AMQP Bridge which al\\xADlows easy in\\xADte\\xADgra\\xADtion be\\xADtween the Vert.x Event Bus and the AMQP con\\xADnec\\xADtion to my router. The ser\\xADvice starts the AMQP Bridge and if it suc\\xADcess\\xADfully con\\xADnects to Dis\\xADpatch it cre\\xADates three re\\xADceivers for the API calls.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), \"AmqpBridgeOptions options = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" AmqpBridgeOptions().addEnabledSaslMechanism(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"ANONYMOUS\\\"\"), \");  \\nbridge = AmqpBridge.create(vertx, options);  \\nbridge.start(amqpHostname, amqpPort, res -> {  \\n   \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (res.succeeded())  \\n   {  \\n     bridge.createConsumer(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"/setScore\\\"\"), \").setMaxBufferedMessages(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"100\"), \").handler(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"this\"), \"::setScore);  \\n     bridge.createConsumer(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"/getScores\\\"\"), \").setMaxBufferedMessages(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"100\"), \").handler(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"this\"), \"::getScores);  \\n     bridge.createConsumer(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"/addGame\\\"\"), \").setMaxBufferedMessages(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"100\"), \").handler(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"this\"), \"::addGame);  \\n     fut.complete();  \\n   }  \\n   \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"else\"), \"  \\n   {  \\n     fut.fail(res.cause());  \\n   }  \\n});  \\n\")), mdx(\"p\", null, \"The only other thing which needs to be done is cre\\xADat\\xADing han\\xADdlers for han\\xADdling the re\\xADquests re\\xADceived from clients:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"public\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"void\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"getScores\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"(Message<Object> msg)\"), \"  \\n\"), \"{  \\n   \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \"(msg.replyAddress() != \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"null\"), \")  \\n   {  \\n     JsonObject response = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" JsonObject();  \\n     response.put(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"application_properties\\\"\"), \", \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" JsonObject().put(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"status\\\"\"), \", \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"200\"), \"));  \\n     response.put(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"body\\\"\"), \", \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" JsonArray(Json.encode(scoreService.getScores())).encode());  \\n     msg.reply(response);  \\n   }  \\n   \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"else\"), \"  \\n   {  \\n     LOG.warn(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"Received LiveScore/getScores request without reply to address\\\"\"), \");  \\n   }  \\n}  \\n\")), mdx(\"p\", null, \"Live broad\\xADcast\\xADing of score up\\xADdates is also very easy. New ad\\xADdress has to be added into Dis\\xADpatch con\\xADfig\\xADu\\xADra\\xADtion. This ad\\xADdress will be used in op\\xADpo\\xADsite di\\xADrec\\xADtion. the ser\\xADvice con\\xADnects to it as sender / pro\\xADducer and clients which want to re\\xADceive the live up\\xADdates cre\\xADate a re\\xADceiver against this ad\\xADdress. What is im\\xADpor\\xADtant, this ad\\xADdress has to be marked as mul\\xADti\\xADcast. Thanks to that every sin\\xADgle mes\\xADsage will be de\\xADliv\\xADered to all con\\xADnected clients and not just to one of them:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-text\"\n  }), \"address {  \\n    prefix: /liveScores  \\n    distribution: multicast  \\n}  \\n\")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"/images/blog/services-and-apis-with-amqp/AMQP-API-multicast.png\",\n    \"alt\": \"Multicasting messages\"\n  }))), mdx(\"p\", null, \"Thanks to the mul\\xADti\\xADcast dis\\xADtri\\xADb\\xADu\\xADtion, the ser\\xADvice doesn\\u2019t need to send a sep\\xADa\\xADrate up\\xADdate to every sin\\xADgle client. It sends the mes\\xADsage only once and dis\\xADpatch takes care of the rest.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-java\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"public\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"void\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"broadcastUpdates\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"(Game game)\"), \"  \\n\"), \"{  \\n   LOG.info(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"Broadcasting game update \\\"\"), \" + game);  \\n   JsonObject message = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" JsonObject();  \\n   message.put(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"body\\\"\"), \", \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"new\"), \" JsonObject(Json.encode(game)).encode());  \\n   producer.send(message);  \\n} \\n\")), mdx(\"p\", null, \"Again, the com\\xADplete source codes of the demo ser\\xADvice are avail\\xADable on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/scholzj/livescore-demo-vertx-amqp-bridge\"\n  }), \"GitHub\"), \".\"), mdx(\"h2\", {\n    \"id\": \"how-to-structure-amqp-apis\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#how-to-structure-amqp-apis\"\n  })), \"How to structure AMQP APIs?\"), mdx(\"p\", null, \"Com\\xADpared to HTTP and REST, AMQP gives its users a lot more free\\xADdom when de\\xADsign\\xADing the API. It isn\\u2019t tied up by the avail\\xADable HTTP meth\\xADods.\"), mdx(\"p\", null, \"My LiveScore ser\\xADvice is using the API end\\xADpoints named ac\\xADcord\\xADing to their func\\xADtion:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"/LiveScore/ad\\xADdGame\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"/LiveScore/setScore\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"/LiveScore/getScores\\nIt also uses HTTP sta\\xADtus codes in ap\\xADpli\\xADca\\xADtion prop\\xADer\\xADties of the dif\\xADfer\\xADent mes\\xADsages to de\\xADscribe the re\\xADsult of the re\\xADquest and JSON as the mes\\xADsage pay\\xADload with the ac\\xADtual re\\xADquest and re\\xADsponse.\")), mdx(\"p\", null, \"Is that the best way? To be hon\\xADest, I don\\u2019t know. Just for the re\\xADquest en\\xADcod\\xADing there are many dif\\xADfer\\xADent op\\xADtions. AMQP has its own en\\xADcod\\xADings which sup\\xADports all pos\\xADsi\\xADble basic as well as more ad\\xADvanced data types and struc\\xADtures. But AMQP can also trans\\xADfer any opaque data - be it JSON, XML, Google Pro\\xADto\\xADcol Buffers or any\\xADthing else. For sim\\xADple re\\xADquest, the pay\\xADload can be com\\xADpletely skipped and ap\\xADpli\\xADca\\xADtion prop\\xADer\\xADties can be used in\\xADstead. And for every\\xADone who re\\xADally loves HTTP/REST, one can also model the API in REST style as I did in an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/scholzj/livescore-demo-vertx-amqp-bridge-rest-style\"\n  }), \"al\\xADter\\xADna\\xADtive im\\xADple\\xADmen\\xADta\\xADtion\"), \" of my demo ser\\xADvice.\"), mdx(\"h2\", {\n    \"id\": \"browser\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#browser\"\n  })), \"Browser\"), mdx(\"p\", null, \"One of the en\\xADvi\\xADron\\xADments where HTTP is so to say \\u201Cat home\\u201D is browser. AMQP will prob\\xADa\\xADbly never be as \\u201Cna\\xADtive\\u201D pro\\xADto\\xADcol for any browser as HTTP is. How\\xADever AMQP can be used even from browsers. It has Web\\xADSocket bind\\xADing and there are Javascript AMQP li\\xADbraries - for ex\\xADam\\xADple rhea. So AMQP can be also used re\\xADally every\\xADwhere.\"), mdx(\"h2\", {\n    \"id\": \"decoupling\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#decoupling\"\n  })), \"Decoupling\"), mdx(\"p\", null, \"It is im\\xADpor\\xADtant to men\\xADtion that the Dis\\xADpatch router doesn\\u2019t de\\xADcou\\xADple the client from the ser\\xADvice. If de\\xADcou\\xADpling is what is needed, it can be eas\\xADily achieved by re\\xADplac\\xADing the Dis\\xADpatch router with some AMQP bro\\xADker. The bro\\xADker would de\\xADcou\\xADple the client from the ser\\xADvice with\\xADout any changes in the ser\\xADvice or clients.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"aria-hidden\": true,\n    \"tabIndex\": -1,\n    \"className\": \"heading-anchor\",\n    \"href\": \"#conclusion\"\n  })), \"Conclusion\"), mdx(\"p\", null, \"While cre\\xADat\\xADing APIs using AMQP can be very easy, it doesn\\u2019t mean that AMQP is the best pro\\xADto\\xADcol for all APIs. There are def\\xADi\\xADnitely APIs where HTTP is more suit\\xADable. But in some use cases, AMQP has clear ad\\xADvan\\xADtages. In my LiveScore ex\\xADam\\xADple it is es\\xADpe\\xADcially one to many com\\xADmu\\xADni\\xADca\\xADtion. It is im\\xADpor\\xADtant to keep the mind open and se\\xADlect the best avail\\xADable for given ser\\xADvice.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>Mi­croser­vices and APIs are every­where. Every­one talks about them, pre­sen­ta­tion slides are full of them … some peo­ple are ac­tu­ally even build­ing them. Mi­croser­vices and APIs are of course not com­pletely new con­cepts and they are a bit over-​hyped. But in gen­eral the ideas be­hind them are not bad. Un­for­tu­nately, many peo­ple seem to be­lieve that the only way how to im­ple­ment an API in mi­croser­vice is to use HTTP and REST. That is of course not true. Mi­croser­vices and APIs can be based on many dif­fer­ent pro­to­cols and tech­nolo­gies. My fa­vorite one is of course <a href=\"http://www.amqp.org\">AMQP</a>. Don’t take me wrong, HTTP and REST is not nec­es­sar­ily bad. But in some cases AMQP is sim­ply bet­ter and cre­at­ing AMQP based APIs does not need to be com­pli­cated.</p><div class=\"alert info\"><p>This is a re-​publication of the fol­low­ing <a href=\"http://blog.effectivemessaging.com/2017/01/building-services-and-apis-with-amqp-10.html\">blog post</a></p></div><h2 id=\"livescore-service\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#livescore-service\"></a>LiveScore service</h2><p>For demon­stra­tion, I will use a very sim­ple ser­vice for keep­ing scores of foot­ball games. It has very basic API. It has only three calls:</p><ul><li>Add a new game</li><li>Up­date a score of ex­ist­ing game</li><li>List the scores\nThe AMQP vari­ants will be ad­di­tion­ally able to push live up­dates to the clients.</li></ul><p>The demo is using Java and Vert.x toolkit. <a href=\"/\">Vert.x</a> is cool and I def­i­nitely rec­om­mend it to every­one. But most of the stuff from the demo should be pos­si­ble also in any other pro­gram­ming lan­guages and/or frame­work.</p><h2 id=\"http-api\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#http-api\"></a>HTTP API</h2><p>HTTP im­ple­men­ta­tion of my ser­vice is a typ­i­cal REST API. Since it is very sim­ple, it ac­cepts re­quests only on one end­point – /api/v1.0/scores. New games are added as POST op­er­a­tions, scores are up­dated with PUT op­er­a­tions and list of all scores can be ob­tained with GET.</p><p>With Vert.x, cre­at­ing HTTP/REST API is very easy. First the web router has to be cre­ated with all planned API calls:</p><pre><code class=\"hljs language-java\">router = Router.router(vertx);  \nrouter.route(<span class=\"hljs-string\">&quot;/api/v1.0/*&quot;</span>).handler(BodyHandler.create());  \nrouter.get(<span class=\"hljs-string\">&quot;/api/v1.0/scores&quot;</span>).handler(<span class=\"hljs-keyword\">this</span>::getScores);  \nrouter.post(<span class=\"hljs-string\">&quot;/api/v1.0/scores&quot;</span>).handler(<span class=\"hljs-keyword\">this</span>::addGame);  \nrouter.put(<span class=\"hljs-string\">&quot;/api/v1.0/scores&quot;</span>).handler(<span class=\"hljs-keyword\">this</span>::setScore);  \n</code></pre><p>Then the HTTP server has to be cre­ated and linked with the router:</p><pre><code class=\"hljs language-java\">HttpServerOptions httpOptions = <span class=\"hljs-keyword\">new</span> HttpServerOptions();  \nserver = vertx.createHttpServer(httpOptions)  \n   .requestHandler(router::accept)  \n   .listen(httpPort);  \n</code></pre><p>And fi­nally the han­dlers which will be trig­gered for each API call have to be im­ple­mented as well. The full code is on <a href=\"https://github.com/scholzj/livescore-demo-vertx-http\">GitHub</a>.</p><p><img src=\"/images/blog/services-and-apis-with-amqp/HTTP-API.png\"/></p><p>The HTTP API doesn’t pro­vide any way how to au­to­mat­i­cally push the score up­dates to the clients. The clients sim­ply have to poll the ser­vice pe­ri­od­i­cally to get the up­dates. HTTP has of course some ways how to push live up­dates to clients. For ex­am­ple, with Web­Sock­ets or with chun­ked trans­fers. How­ever, these are not that easy to im­ple­ment. The ser­vice would also need to keep sep­a­rate con­nec­tion with every client and push the up­dates for each of them sep­a­rately.</p><h2 id=\"amqp-api\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#amqp-api\"></a>AMQP API</h2><p>Cre­at­ing the HTTP API was re­ally easy. Cre­at­ing an AMQP API has to be more com­pli­cated, right? We would need an AMQP server, which will lis­ten on some port, ac­cept the con­nec­tions, ses­sions, links and so on. There are usu­ally no nice and sim­ple to use li­braries for this.</p><p>Sure, this is one way how to do it. There is ac­tu­ally a nice li­brary called <a href=\"http://qpid.apache.org/proton/index.html\">Apache Qpid Pro­ton</a>. It has Java and C ver­sions and bind­ings into many other lan­guages (Go, C++, Python, …). It makes cre­at­ing your own AMQP server lot eas­ier. It will take care of de­cod­ing and en­cod­ing the AMQP pro­to­col, han­dling the con­nec­tions, ses­sions etc. But still, Qpid Pro­ton is not even nearly as easy to use as the HTTP router used for the HTTP API.</p><p><img src=\"/images/blog/services-and-apis-with-amqp/AMQP-Server-API.png\" alt=\"API with AMQP server\"/></p><p>Are there any eas­ier op­tions? What if all what is needed to cre­ate AMQP based API is a sim­ple AMQP client? Nor­mally, that should not be a pos­si­ble be­cause we need the API to lis­ten on some port for the clients to con­nect to it and send re­quests. And clients usu­ally don’t lis­ten on any ports. How­ever, Apache Qpid has some­thing called <a href=\"http://qpid.apache.org/components/dispatch-router/index.html\">Dis­patch</a>. It works as a light­weight AMQP router. Dis­patch will serve as the AMQP server which was miss­ing. It will take care of han­dling client con­nec­tions, se­cu­rity and shield the ser­vice from the ac­tual clients. All the ser­vice needs to do is to use AMQP client to con­nect to Dis­patch on pre­de­fined ad­dress and wait for the re­quest.</p><p><img src=\"/images/blog/services-and-apis-with-amqp/AMQP-API.png\" alt=\"AMQP API with Dispatch router\"/></p><p>Dis­patch needs to be con­fig­ured with three API entry points as ad­dresses:</p><pre><code class=\"hljs language-text\">address {  \n    prefix: /setScore  \n    distribution: balanced  \n}  \naddress {  \n    prefix: /getScore  \n    distribution: balanced  \n}  \naddress {  \n    prefix: /addGame  \n    distribution: balanced  \n}  \n</code></pre><p>LiveScore ser­vice will con­nect to these ad­dresses as a re­ceiver / con­sumer. Clients will con­nect to them as senders  /pro­duc­ers. And Dis­patch will take care of rout­ing the mes­sages be­tween the clients and the ser­vice. Clients can also cre­ate ad­di­tional re­ceivers so that the ser­vice is able to re­spond to their re­quests and spec­ify the ad­dress of the re­ceiver as the reply-​to header in the re­quest mes­sage. LiveScore ser­vice will au­to­mat­i­cally send the re­sponse to this ad­dress. But spec­i­fy­ing a reply-​to is not manda­tory. If the client wants, it can sim­ply fire the re­quest and for­get about the re­sponse.</p><p>LiveScore ser­vice is using Vert.x AMQP Bridge which al­lows easy in­te­gra­tion be­tween the Vert.x Event Bus and the AMQP con­nec­tion to my router. The ser­vice starts the AMQP Bridge and if it suc­cess­fully con­nects to Dis­patch it cre­ates three re­ceivers for the API calls.</p><pre><code class=\"hljs language-java\">AmqpBridgeOptions options = <span class=\"hljs-keyword\">new</span> AmqpBridgeOptions().addEnabledSaslMechanism(<span class=\"hljs-string\">&quot;ANONYMOUS&quot;</span>);  \nbridge = AmqpBridge.create(vertx, options);  \nbridge.start(amqpHostname, amqpPort, res -&gt; {  \n   <span class=\"hljs-keyword\">if</span> (res.succeeded())  \n   {  \n     bridge.createConsumer(<span class=\"hljs-string\">&quot;/setScore&quot;</span>).setMaxBufferedMessages(<span class=\"hljs-number\">100</span>).handler(<span class=\"hljs-keyword\">this</span>::setScore);  \n     bridge.createConsumer(<span class=\"hljs-string\">&quot;/getScores&quot;</span>).setMaxBufferedMessages(<span class=\"hljs-number\">100</span>).handler(<span class=\"hljs-keyword\">this</span>::getScores);  \n     bridge.createConsumer(<span class=\"hljs-string\">&quot;/addGame&quot;</span>).setMaxBufferedMessages(<span class=\"hljs-number\">100</span>).handler(<span class=\"hljs-keyword\">this</span>::addGame);  \n     fut.complete();  \n   }  \n   <span class=\"hljs-keyword\">else</span>  \n   {  \n     fut.fail(res.cause());  \n   }  \n});  \n</code></pre><p>The only other thing which needs to be done is cre­at­ing han­dlers for han­dling the re­quests re­ceived from clients:</p><pre><code class=\"hljs language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getScores</span><span class=\"hljs-params\">(Message&lt;Object&gt; msg)</span>  \n</span>{  \n   <span class=\"hljs-keyword\">if</span>(msg.replyAddress() != <span class=\"hljs-keyword\">null</span>)  \n   {  \n     JsonObject response = <span class=\"hljs-keyword\">new</span> JsonObject();  \n     response.put(<span class=\"hljs-string\">&quot;application_properties&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;status&quot;</span>, <span class=\"hljs-number\">200</span>));  \n     response.put(<span class=\"hljs-string\">&quot;body&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonArray(Json.encode(scoreService.getScores())).encode());  \n     msg.reply(response);  \n   }  \n   <span class=\"hljs-keyword\">else</span>  \n   {  \n     LOG.warn(<span class=\"hljs-string\">&quot;Received LiveScore/getScores request without reply to address&quot;</span>);  \n   }  \n}  \n</code></pre><p>Live broad­cast­ing of score up­dates is also very easy. New ad­dress has to be added into Dis­patch con­fig­u­ra­tion. This ad­dress will be used in op­po­site di­rec­tion. the ser­vice con­nects to it as sender / pro­ducer and clients which want to re­ceive the live up­dates cre­ate a re­ceiver against this ad­dress. What is im­por­tant, this ad­dress has to be marked as mul­ti­cast. Thanks to that every sin­gle mes­sage will be de­liv­ered to all con­nected clients and not just to one of them:</p><pre><code class=\"hljs language-text\">address {  \n    prefix: /liveScores  \n    distribution: multicast  \n}  \n</code></pre><p><img src=\"/images/blog/services-and-apis-with-amqp/AMQP-API-multicast.png\" alt=\"Multicasting messages\"/></p><p>Thanks to the mul­ti­cast dis­tri­b­u­tion, the ser­vice doesn’t need to send a sep­a­rate up­date to every sin­gle client. It sends the mes­sage only once and dis­patch takes care of the rest.</p><pre><code class=\"hljs language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">broadcastUpdates</span><span class=\"hljs-params\">(Game game)</span>  \n</span>{  \n   LOG.info(<span class=\"hljs-string\">&quot;Broadcasting game update &quot;</span> + game);  \n   JsonObject message = <span class=\"hljs-keyword\">new</span> JsonObject();  \n   message.put(<span class=\"hljs-string\">&quot;body&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject(Json.encode(game)).encode());  \n   producer.send(message);  \n} \n</code></pre><p>Again, the com­plete source codes of the demo ser­vice are avail­able on <a href=\"https://github.com/scholzj/livescore-demo-vertx-amqp-bridge\">GitHub</a>.</p><h2 id=\"how-to-structure-amqp-apis\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#how-to-structure-amqp-apis\"></a>How to structure AMQP APIs?</h2><p>Com­pared to HTTP and REST, AMQP gives its users a lot more free­dom when de­sign­ing the API. It isn’t tied up by the avail­able HTTP meth­ods.</p><p>My LiveScore ser­vice is using the API end­points named ac­cord­ing to their func­tion:</p><ul><li>/LiveScore/ad­dGame</li><li>/LiveScore/setScore</li><li>/LiveScore/getScores\nIt also uses HTTP sta­tus codes in ap­pli­ca­tion prop­er­ties of the dif­fer­ent mes­sages to de­scribe the re­sult of the re­quest and JSON as the mes­sage pay­load with the ac­tual re­quest and re­sponse.</li></ul><p>Is that the best way? To be hon­est, I don’t know. Just for the re­quest en­cod­ing there are many dif­fer­ent op­tions. AMQP has its own en­cod­ings which sup­ports all pos­si­ble basic as well as more ad­vanced data types and struc­tures. But AMQP can also trans­fer any opaque data - be it JSON, XML, Google Pro­to­col Buffers or any­thing else. For sim­ple re­quest, the pay­load can be com­pletely skipped and ap­pli­ca­tion prop­er­ties can be used in­stead. And for every­one who re­ally loves HTTP/REST, one can also model the API in REST style as I did in an <a href=\"https://github.com/scholzj/livescore-demo-vertx-amqp-bridge-rest-style\">al­ter­na­tive im­ple­men­ta­tion</a> of my demo ser­vice.</p><h2 id=\"browser\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#browser\"></a>Browser</h2><p>One of the en­vi­ron­ments where HTTP is so to say “at home” is browser. AMQP will prob­a­bly never be as “na­tive” pro­to­col for any browser as HTTP is. How­ever AMQP can be used even from browsers. It has Web­Socket bind­ing and there are Javascript AMQP li­braries - for ex­am­ple rhea. So AMQP can be also used re­ally every­where.</p><h2 id=\"decoupling\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#decoupling\"></a>Decoupling</h2><p>It is im­por­tant to men­tion that the Dis­patch router doesn’t de­cou­ple the client from the ser­vice. If de­cou­pling is what is needed, it can be eas­ily achieved by re­plac­ing the Dis­patch router with some AMQP bro­ker. The bro­ker would de­cou­ple the client from the ser­vice with­out any changes in the ser­vice or clients.</p><h2 id=\"conclusion\"><a aria-hidden=\"true\" tabindex=\"-1\" class=\"heading-anchor\" href=\"#conclusion\"></a>Conclusion</h2><p>While cre­at­ing APIs using AMQP can be very easy, it doesn’t mean that AMQP is the best pro­to­col for all APIs. There are def­i­nitely APIs where HTTP is more suit­able. But in some use cases, AMQP has clear ad­van­tages. In my LiveScore ex­am­ple it is es­pe­cially one to many com­mu­ni­ca­tion. It is im­por­tant to keep the mind open and se­lect the best avail­able for given ser­vice.</p>","scope":{}}},"prevPost":{"meta":{"title":"An Introduction to the Vert.x Context Object","category":"guides","authors":[{"name":"Jez Prime","github_id":"millross"}],"summary":"Under the hood, the vert.x Context class plays a critical part in maintaining the thread-safety guarantees of verticles. Most of the time, vert.x coders don't need to make use of Context objects directly."},"date":"2017-01-31","slug":"an-introduction-to-the-vert-x-context-object"},"nextPost":{"meta":{"title":"Internet of Things - Reactive and Asynchronous with Vert.x","category":"guides","authors":[{"name":"Paolo Patierno","github_id":"ppatierno"}],"summary":"I have to admit … before joining Red Hat I didn’t know about the Eclipse Vert.x project but it took me few days to fall in love with it!"},"date":"2016-12-29","slug":"internet-of-things-reactive-and-asynchronous-with-vert-x"},"relatedPosts":[{"meta":{"title":"Some Rest with Vert.x","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"This post is part of the Introduction to Vert.x series. Let’s go a bit further this time and develop a CRUD-ish application"},"date":"2015-07-27","slug":"some-rest-with-vert-x"},{"meta":{"title":"Vert.x Web API Service Introduction","category":"guides","authors":[{"name":"Francesco Guardiani","github_id":"slinkydeveloper"}],"summary":"This blog post teaches you how to use the new module vertx-web-api-service to combine the Web Router and the OpenAPI Router Factory with service proxies."},"date":"2018-12-13","slug":"vert-x-web-api-service-introduction"},{"meta":{"title":"Unit and Integration Tests","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"Let’s refresh our mind about what we developed so far in the introduction to vert.x series. We forgot an important task. We didn’t test the API."},"date":"2015-08-03","slug":"unit-and-integration-tests"}]},"__N_SSG":true}