{"pageProps":{"slug":"4.0.0/vertx-service-discovery/java","title":"Vert.x 服务发现","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_the_service_discovery\">使用服务发现</a></li>\n<li><a href=\"#_overall_concepts\">概念总览</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_service_records\">服务记录</a></li>\n<li><a href=\"#_service_provider_and_publisher\">提供者和发布者</a></li>\n<li><a href=\"#_service_consumer\">服务消费者</a></li>\n<li><a href=\"#_service_object\">服务对象</a></li>\n<li><a href=\"#_service_types\">服务类型</a></li>\n<li><a href=\"#_service_events\">服务事件</a></li>\n<li><a href=\"#_backend\">后台</a></li>\n</ul>\n</li>\n<li><a href=\"#_creating_a_service_discovery_instance\">创建服务发现实例</a></li>\n<li><a href=\"#_publishing_services\">发布服务</a></li>\n<li><a href=\"#_withdrawing_services\">回收服务</a></li>\n<li><a href=\"#_looking_for_services\">寻找服务</a></li>\n<li><a href=\"#_retrieving_a_service_reference\">获取服务引用</a></li>\n<li><a href=\"#_types_of_services\">服务类型</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_services_with_no_type\">无类型的服务</a></li>\n<li><a href=\"#_implementing_your_own_service_type\">实现您自己的服务类型</a></li>\n<li><a href=\"#_http_endpoints\">HTTP 节点</a></li>\n<li><a href=\"#_event_bus_services\">Event bus 服务</a></li>\n<li><a href=\"#_message_source\">消息源服务</a></li>\n<li><a href=\"#_jdbc_data_source\">JDBC数据源</a></li>\n<li><a href=\"#_redis_data_source\">Redis 数据源</a></li>\n<li><a href=\"#_mongo_data_source\">Mongo数据源</a></li>\n</ul>\n</li>\n<li><a href=\"#_listening_for_service_arrivals_and_departures\">监听服务的注册和注销</a></li>\n<li><a href=\"#_listening_for_service_usage\">监听服务使用状况</a></li>\n<li><a href=\"#_service_discovery_bridges\">服务发现桥接器</a></li>\n<li><a href=\"#_additional_bridges\">其他的桥接器支持</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_consul_bridge\">Consul 网桥</a></li>\n<li><a href=\"#_kubernetes_bridge\">Kubernetes 桥接器</a></li>\n<li><a href=\"#_docker_links_bridge\">Docker Links 桥接器</a></li>\n</ul>\n</li>\n<li><a href=\"#_additional_backends\">其他的后台支持</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_redis_backend\">Redis backend</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x 服务发现</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 服务发现组件提供了一套用于对各种资源服务的发布、发现的基础组件，例如 服务代理、HTTP服务节点（HTTP endpoint）、数据源（data source）&#8230;&#8203; 这些资源统称为 <code>服务</code> 。一个 <code>服务</code> 即是一个可被发现的功能性模块。它可以用类型、元数据、位置来区分，所以一个 <code>服务</code> 可以是一个数据库、服务代理、HTTP节点或者其他任何您能够描述、发现、交互的服务资源。它不一定是一个vert.x对象，它可以是任何组件。每个 <code>服务</code> 都被描述成一个 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> （即：下述 <code>服务记录</code> ）。</p>\n</div>\n<div class=\"paragraph\">\n<p><code>服务发现</code> 组件实现了面向服务计算中定义的服务交互。此外，在某种程度上，还提供了动态的面向服务计算交互，这样应用程序可以对各种服务的上线、下线作出处理。</p>\n</div>\n<div class=\"paragraph\">\n<p>一个服务提供者可以做如下事情：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>发布一个服务的 <code>服务记录</code></p>\n</li>\n<li>\n<p>下线一个已发布的 <code>服务记录</code></p>\n</li>\n<li>\n<p>更新线上服务的状态 (下线、暂停服务&#8230;&#8203;)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>一个服务消费者可以做如下事情：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>寻找服务</p>\n</li>\n<li>\n<p>选择绑定到某个服务（获取一个 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\">ServiceReference</a></code>) 并使用）</p>\n</li>\n<li>\n<p>当服务消费者停止后立即释放服务提供者资源</p>\n</li>\n<li>\n<p>监听服务的注册、注销、更新</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>服务消费者将：1)寻找符合自己需求的 <code>服务记录</code>； 2) 接收提供访问入口的 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\">ServiceReference</a></code> ；3) 获得一个提供访问入口的 <code>服务</code> 对象；4) 停止后立即释放服务对象</p>\n</div>\n<div class=\"paragraph\">\n<p>这个过程可以用 <em>服务类型</em> （service type） 来简化，如果你知道服务的类型(JDBC client, Http client&#8230;&#8203;)，那么你可以直接获取到这个服务对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>综上所述，服务提供者和消费者之间共享的核心信息都存放在 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">records</a></code> 当中。</p>\n</div>\n<div class=\"paragraph\">\n<p>提供者和消费者必须创建自己的 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html\">ServiceDiscovery</a></code> 实例。这些实例在后台（分布式架构）进行协作，以使服务之间信息保持同步。</p>\n</div>\n<div class=\"paragraph\">\n<p>vert.x的服务发现通过桥接方式 支持对其他服务发现技术的导入和导出。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_service_discovery\"><a class=\"anchor\" href=\"#_using_the_service_discovery\"></a>使用服务发现</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用Vert.x 服务发现组件，需要将下列依赖加入到依赖配置中文件：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (<code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-discovery<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (<code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-service-discovery:4.0.0'</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_overall_concepts\"><a class=\"anchor\" href=\"#_overall_concepts\"></a>概念总览</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>服务发现机制基于以下章节的几个概念。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_service_records\"><a class=\"anchor\" href=\"#_service_records\"></a>服务记录</h3>\n<div class=\"paragraph\">\n<p>一个服务 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> 是服务提供者发布的一个服务描述对象。它包含了名称、元数据、位置对象（描述服务发布在哪里）。这个 <code>服务记录</code> 是提供者（发布 <code>服务记录</code> ）和消费者（寻找服务时获取 <code>服务记录</code> ）之间仅有的共享对象。</p>\n</div>\n<div class=\"paragraph\">\n<p>元数据和位置格式由 <code>服务类型（service type）</code> 决定（见下述）。</p>\n</div>\n<div class=\"paragraph\">\n<p>服务提供方准备好之后，一个 <code>服务记录</code> 就被发布了，服务停止时 <code>服务记录</code> 被回收</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_service_provider_and_publisher\"><a class=\"anchor\" href=\"#_service_provider_and_publisher\"></a>提供者和发布者</h3>\n<div class=\"paragraph\">\n<p>服务提供者是一个提供 <em>服务</em> 的对象。发布者负责发布描述提供者的 <code>服务记录</code> 。它可能是同一个对象（提供者仅仅发布自己）也可能是个不同的对象。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_service_consumer\"><a class=\"anchor\" href=\"#_service_consumer\"></a>服务消费者</h3>\n<div class=\"paragraph\">\n<p>服务消费者在服务发现模块中检索服务。每次检索都会得到 <code>0..n</code> 个\n<code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> ，从这些 <code>服务记录</code> 当中，服务消费者可以获取到 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\">ServiceReference</a></code> ，这个 <code>服务引用</code> 绑定了提供方和消费方，它允许消费方获取到 <em>服务对象（service object）</em> （用来使用服务）或释放服务。</p>\n</div>\n<div class=\"paragraph\">\n<p>释放 <code>服务引用</code> 是一件很重要的事情，这清除了 <code>服务引用</code> 对象并更新了服务的使用状态</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_service_object\"><a class=\"anchor\" href=\"#_service_object\"></a>服务对象</h3>\n<div class=\"paragraph\">\n<p><code>服务对象</code> 是一个提供了服务入口的对象。它可以是各种形式，例如 代理、客户端、甚至是一些不存在的服务类型。服务对象的性质取决于服务类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>注意：因为Vert.x多语言的性质，所以如果你在java、groovy或其他语言获取的 <code>服务对象</code> 会不一样。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_service_types\"><a class=\"anchor\" href=\"#_service_types\"></a>服务类型</h3>\n<div class=\"paragraph\">\n<p>服务仅仅是一些 <code>资源（resource）</code> 或不同类型的 <code>服务</code>。他们可以是功能服务组件、数据库、REST-Api等等。Vert.x服务发现模块定义 <code>服务类型</code> 来处理各类型的差异。每个类型定义了：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>服务是如何定位的（URI, event bus address, IP / DNS&#8230;&#8203;）- <em>location</em></p>\n</li>\n<li>\n<p>服务对象的性质（service proxy, HTTP client, message consumer&#8230;&#8203;）<em>client</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>服务发现组件提供了一些现成的服务类型，但是你可以添加你自己的类型。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_service_events\"><a class=\"anchor\" href=\"#_service_events\"></a>服务事件</h3>\n<div class=\"paragraph\">\n<p>每当发布或注销一个服务，event-bus上就会触发一个事件(event),这个事件包含了被更新的服务记录。</p>\n</div>\n<div class=\"paragraph\">\n<p>另外，为了追踪谁调用谁，每当调用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getReference-io.vertx.servicediscovery.Record-\">getReference</a></code> 则获取reference或者 调用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html#release--\">release</a></code> 释放reference的时候，事件都在event-bus上被发出 用以跟踪服务的使用情况。</p>\n</div>\n<div class=\"paragraph\">\n<p>关于事件的更多详细信息如下。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_backend\"><a class=\"anchor\" href=\"#_backend\"></a>后台</h3>\n<div class=\"paragraph\">\n<p>服务发现模块使用了Vert.x的分布式数据结构来存储 <code>服务记录</code> 。所以所有的集群成员都能获取到所有的 <code>服务记录</code> 。这是后台默认的实现。你可以实现 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html\">ServiceDiscoveryBackend</a></code> SPI 来实现自己的Backend。例如，Vert.x提供了一个基于Redis的基础实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>注意：服务发现不要求必须是Vert.x集群。在单节点模式下，这个数据结构存储于本地。它可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html\">ServiceImporter</a></code> 实现。从3.5.0版本开始，你可以在集群模式下用本地结构的event，这可以设置系统参数 <code>vertx-service-discovery-backend-local</code> 为 <code>true</code> (或者设置环境变量 <code>VERTX-SERVICE-DISCOVERY-BACKEND-LOCAL</code> 为 <code>true</code>) 来实现。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_service_discovery_instance\"><a class=\"anchor\" href=\"#_creating_a_service_discovery_instance\"></a>创建服务发现实例</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>提供者和消费者必须创建他们自己的 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html\">ServiceDiscovery</a></code> 实例来使用服务发现组件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceDiscovery discovery = ServiceDiscovery.create(vertx);\n\n<span class=\"hljs-comment\">// 自定义配置</span>\ndiscovery = ServiceDiscovery.create(vertx,\n    <span class=\"hljs-keyword\">new</span> ServiceDiscoveryOptions()\n        .setAnnounceAddress(<span class=\"hljs-string\">\"service-announce\"</span>)\n        .setName(<span class=\"hljs-string\">\"my-name\"</span>));\n\n<span class=\"hljs-comment\">// Do something...</span>\n\ndiscovery.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>默认情况下，公告地址(发送事件的event-bus地址)是 <code>vertx.discovery.announce</code>。你也可以为service usage（见service usage章节）配置一个名称。</p>\n</div>\n<div class=\"paragraph\">\n<p>当你再也不需要服务发现对象时，不要忘记去关闭它。它关闭了您已配置的发现导入器和导出器，并释放服务引用。</p>\n</div>\n<div class=\"paragraph\">\n<p>您应该避免共享服务发现实例，因此service usage 将代表正确的“usage”</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_publishing_services\"><a class=\"anchor\" href=\"#_publishing_services\"></a>发布服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>一旦你拥有了服务发现实例，你可以发布服务。步骤如下：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>为这个服务提供者创建一个服务记录</p>\n</li>\n<li>\n<p>发布这个服务记录</p>\n</li>\n<li>\n<p>持有这个服务记录，以便于后续的注销和更改操作</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>为了创建服务记录，你可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> 类，或者用不同服务类型提供的便捷方式。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record = <span class=\"hljs-keyword\">new</span> Record()\n    .setType(<span class=\"hljs-string\">\"eventbus-service-proxy\"</span>)\n    .setLocation(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"endpoint\"</span>, <span class=\"hljs-string\">\"the-service-address\"</span>))\n    .setName(<span class=\"hljs-string\">\"my-service\"</span>)\n    .setMetadata(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"some-label\"</span>, <span class=\"hljs-string\">\"some-value\"</span>));\n\ndiscovery.publish(record, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 发布成功</span>\n    Record publishedRecord = ar.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发布失败</span>\n  }\n});\n\n<span class=\"hljs-comment\">// 由一个类型创建的record</span>\nrecord = HttpEndpoint.createRecord(<span class=\"hljs-string\">\"some-rest-api\"</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"/api\"</span>);\ndiscovery.publish(record, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// 发布成功</span>\n    Record publishedRecord = ar.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 发布失败</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>持有服务记录的引用是很重要的事情，因为服务记录中拥有一个 <code>注册 id</code>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_withdrawing_services\"><a class=\"anchor\" href=\"#_withdrawing_services\"></a>回收服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要回收(下线)一个record，使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.unpublish(record.getRegistration(), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Ok</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 无法下线服务，可能是因为已经被移除或者 record根本没有被发布</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_looking_for_services\"><a class=\"anchor\" href=\"#_looking_for_services\"></a>寻找服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><em>本章解释了获取服务的底层原理，每个服务类型都提供了便捷的方式来整合各个的步骤</em></p>\n</div>\n<div class=\"paragraph\">\n<p>在消费方，第一件事就是要寻找服务记录。您可以检索单个服务记录或者所有符合条件的服务记录。第一种情况，第一个符合条件的服务记录被返回。</p>\n</div>\n<div class=\"paragraph\">\n<p>消费方可以提供一个过滤器(filter)来选择服务。有两种方式来描述过滤器：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>一个以 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> 为参数并以布尔类型（这是一个断言）作为返回值的函数</p>\n</li>\n<li>\n<p>这个过滤器是一个JSON-obejct。每一个给出的filter过滤条件都会检查record，所有的过滤条件都必须满足record。过滤条件可以用 <code>*</code> 通配符来表示对key的要求，而不是精准匹配。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>我们来看看JSON过滤器的一个例子：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{ \"name\" = \"a\" } =&gt; 筛选出名称是\"a\"的record\n{ \"color\" = \"*\" } =&gt; 筛选出存在\"color\"字段的record\n{ \"color\" = \"red\" } =&gt; 筛选出\"color\"字段是\"red\"的record\n{ \"color\" = \"red\", \"name\" = \"a\"} =&gt; 筛选出\"color\"字段是\"red\" 且 \"name\"字段是\"a\"的record</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果没有设置JSON过滤器(<code>null</code> 或 empty) ，则筛选出所有的服务记录。当用函数来过滤时，如果你想获取到所有的服务记录，那无论是什么样的服务记录，你必须要返回 <em>true</em></p>\n</div>\n<div class=\"paragraph\">\n<p>示例如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(r -&gt; <span class=\"hljs-keyword\">true</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-keyword\">if</span> (ar.result() != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 获取到一个record</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 寻找成功但是没有符合条件的服务</span>\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 查找失败</span>\n  }\n});\n\ndiscovery.getRecord((JsonObject) <span class=\"hljs-keyword\">null</span>, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-keyword\">if</span> (ar.result() != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 获取到一个record</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 寻找成功但是没有符合条件的服务</span>\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 查找失败</span>\n  }\n});\n\n\n<span class=\"hljs-comment\">// 通过名称获取record</span>\ndiscovery.getRecord(r -&gt; r.getName().equals(<span class=\"hljs-string\">\"some-name\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-keyword\">if</span> (ar.result() != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 获取到一个record</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 寻找成功但是没有符合条件的服务</span>\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 查找失败</span>\n  }\n});\n\ndiscovery.getRecord(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-service\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-keyword\">if</span> (ar.result() != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 获取到一个record</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 寻找成功但是没有符合条件的服务</span>\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 查找失败</span>\n  }\n});\n\n<span class=\"hljs-comment\">// 获取所有符合过滤器条件的record</span>\ndiscovery.getRecords(r -&gt; <span class=\"hljs-string\">\"some-value\"</span>.equals(r.getMetadata().getString(<span class=\"hljs-string\">\"some-label\"</span>)), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;Record&gt; results = ar.result();\n    <span class=\"hljs-comment\">// 如果获取到非空list，那么我们获取到了record</span>\n    <span class=\"hljs-comment\">// 否则说明寻找成功但是没有符合条件的服务</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 查找失败</span>\n  }\n});\n\n\ndiscovery.getRecords(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"some-label\"</span>, <span class=\"hljs-string\">\"some-value\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    List&lt;Record&gt; results = ar.result();\n    <span class=\"hljs-comment\">// 如果获取到非空list，那么我们获取到了record</span>\n    <span class=\"hljs-comment\">// 否则说明寻找成功但是没有符合条件的服务</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 查找失败</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>我们可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">getRecords</a></code> 来获取单条服务记录或者所有符合条件的服务记录。默认情况下，对于服务记录的查找仅仅包含 <code>status</code> 是 <code>UP</code> 的情况。这可以被重写：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>当使用JSON过滤器时，设置 <code>status</code> 为你的期望值（或者 <code>*</code> 来接收所有的状态）</p>\n</li>\n<li>\n<p>当使用函数时，在 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-java.util.function.Function-boolean-io.vertx.core.Handler-\">getRecords</a></code> 函数 设置 <code>includeOutOfService</code> 参数为 <code>true</code>。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_retrieving_a_service_reference\"><a class=\"anchor\" href=\"#_retrieving_a_service_reference\"></a>获取服务引用</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>一旦你选择了 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> ，你可以获取一个 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\">ServiceReference</a></code> 和 <code>服务对象</code> :</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceReference reference1 = discovery.getReference(record1);\nServiceReference reference2 = discovery.getReference(record2);\n\n<span class=\"hljs-comment\">// 获取到service object，返回服务引用的类型取决于 service type</span>\n<span class=\"hljs-comment\">// Http 节点</span>\nHttpClient client = reference1.getAs(HttpClient<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n<span class=\"hljs-comment\">// 消息源</span>\nMessageConsumer consumer = reference2.getAs(MessageConsumer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n<span class=\"hljs-comment\">// 当服务使用完毕</span>\nreference1.release();\nreference2.release();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>切记处理完毕之后释放服务引用资源</p>\n</div>\n<div class=\"paragraph\">\n<p>一个服务引用代表了一个对服务提供者的绑定关系。</p>\n</div>\n<div class=\"paragraph\">\n<p>获取服务引用时，你可以传一个包含了各种数据的 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> 用来配置 <code>服务对象</code> 。某些服务类型不需要额外的配置，如下是一些必要的配置（数据源为例）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceReference reference = discovery.getReferenceWithConfiguration(record, conf);\n\n<span class=\"hljs-comment\">// 获取到service object，返回服务引用的类型取决于 service type</span>\n<span class=\"hljs-comment\">// JDBC 节点</span>\nJDBCClient client = reference.getAs(JDBCClient<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n<span class=\"hljs-comment\">// Do something with the client...</span>\n\n<span class=\"hljs-comment\">// 当服务使用完毕</span>\nreference.release();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在前述例子当中，代码用了 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html#getAs-java.lang.Class-\">getAs</a></code> 函数，其参数是你期望得到的服务类型。如果你用java语言，你可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html#get--\">get</a></code> 函数。然而其他语言 你必须传一个你期望的类型值。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_types_of_services\"><a class=\"anchor\" href=\"#_types_of_services\"></a>服务类型</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如上所述，服务发现有 <code>服务类型</code> 的概念来管理不同类型的服务。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些类型默认通过如下方式提供：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html\">HttpEndpoint</a></code> - 对于 REST API&#8217;来讲, 服务对象是一个由 <code>host</code>、<code>port</code>（位置是 <code>url</code> 参数）配置的\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> .</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\">EventBusService</a></code> - 对于服务代理，服务对象是一个proxy。它的类型是`proxies interface`（服务所在位置是地址）</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\">MessageSource</a></code> - 对于消息源（发送者），服务对象是一个 <code><a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> （服务所在位置是地址）。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html\">JDBCDataSource</a></code> - 对于 JDBC 数据源, 服务对象是一个 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\">JDBCClient</a></code> （客户端配置从 location，metadata和消费方配置来解析）。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html\">RedisDataSource</a></code> - 对于 Redis 数据源, 服务对象是一个 <code><a href=\"../../apidocs/io/vertx/redis/client/Redis.html\">Redis</a></code> (客户端配置从 location，metadata和消费方配置来解析).</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html\">MongoDataSource</a></code> - 对于 Mongo 数据源, 服务对象是一个 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\">MongoClient</a></code> (客户端配置从 location，metadata和消费方配置来解析).</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>本节总体上给出有关服务类型的详细信息，并介绍如何使用默认服务类型。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_services_with_no_type\"><a class=\"anchor\" href=\"#_services_with_no_type\"></a>无类型的服务</h3>\n<div class=\"paragraph\">\n<p>一些record也许没有类型(<code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html#UNKNOWN\">ServiceType.UNKNOWN</a></code>)。所以不可能从这些record里面获取到服务对象，但是你可以通过 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> 对象的 <code>location</code> 和 <code>metadata</code> 来构建连接的具体信息。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用这些服务不会触发 <code>service usage</code> 事件</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_implementing_your_own_service_type\"><a class=\"anchor\" href=\"#_implementing_your_own_service_type\"></a>实现您自己的服务类型</h3>\n<div class=\"paragraph\">\n<p>你可以通过实现 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html\">ServiceType</a></code> SPI 的方式来创建你自己的服务类型:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>(可选) 创建一个public interface 继承 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html\">ServiceType</a></code> 。这个interface仅仅用来提供辅助函数来简化你自定义类型的用法，例如 <code>createRecord</code> 函数, <code>getX</code> ， <code>X</code> 是你获取到的服务对象的类型。可以查看 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html\">HttpEndpoint</a></code> 或者 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\">MessageSource</a></code> 等接口例子来了解这种设计</p>\n</li>\n<li>\n<p>创建一个类来实现 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html\">ServiceType</a></code> ，或者实现你在第一步创建的类型。 这个类型有 <code>name</code> 和一个为这个类型创建 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceReference.html\">ServiceReference</a></code> 的函数。这个name必须匹配 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> 类的 <code>type</code> 字段，这个record的type就是您自己定义的服务类型。</p>\n</li>\n<li>\n<p>创建一个类继承 <code>io.vertx.ext.discovery.types.AbstractServiceReference</code> ，您可以参数化您将要返回的带有服务对象类型的类，你必须实现 <code>AbstractServiceReference#retrieve()</code> 函数来创建服务对象。这个函数只能被调用一次。如果需要清除服务对象，也要重写 <code>AbstractServiceReference#onClose()</code> 函数</p>\n</li>\n<li>\n<p>在打包jar时在jar内创建一个 <code>META-INF/services/io.vertx.servicediscovery.spi.ServiceType</code> 文件。这个文件仅仅包含您在第二步创建的类的全名。</p>\n</li>\n<li>\n<p>创建一个包含service type interface（步骤1）的jar，实现类（步骤2，步骤3）和服务描述文件（步骤4）。把这个jar放在你应用的classpath下，然后您的服务类型现在就已经可用了。</p>\n</li>\n</ol>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_endpoints\"><a class=\"anchor\" href=\"#_http_endpoints\"></a>HTTP 节点</h3>\n<div class=\"paragraph\">\n<p>一个HTTP节点代表一个REST API或者可用HTTP请求访问的服务。HTTP节点服务对象是一个由host、port、ssl所配置的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> 对象</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publishing_a_http_endpoint\"><a class=\"anchor\" href=\"#_publishing_a_http_endpoint\"></a>发布一个HTTP节点</h4>\n<div class=\"paragraph\">\n<p>要发布一个HTTP节点，你需要一个 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> ，你可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#createRecord-java.lang.String-java.lang.String-int-java.lang.String-io.vertx.core.json.JsonObject-\">HttpEndpoint.createRecord</a></code> 来创建服务记录。</p>\n</div>\n<div class=\"paragraph\">\n<p>下面一段阐述如何用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html\">HttpEndpoint</a></code> 创建 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record1 = HttpEndpoint.createRecord(\n  <span class=\"hljs-string\">\"some-http-service\"</span>, <span class=\"hljs-comment\">// 服务名称</span>\n  <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-comment\">//  host</span>\n  <span class=\"hljs-number\">8433</span>, <span class=\"hljs-comment\">// port</span>\n  <span class=\"hljs-string\">\"/api\"</span> <span class=\"hljs-comment\">// 服务的根路由</span>\n);\n\ndiscovery.publish(record1, ar -&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n});\n\nRecord record2 = HttpEndpoint.createRecord(\n  <span class=\"hljs-string\">\"some-other-name\"</span>, <span class=\"hljs-comment\">// 服务名称</span>\n  <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-comment\">// 是否要求 HTTPs</span>\n  <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-comment\">// host</span>\n  <span class=\"hljs-number\">8433</span>, <span class=\"hljs-comment\">// port</span>\n  <span class=\"hljs-string\">\"/api\"</span>, <span class=\"hljs-comment\">// 服务的根路由</span>\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"some-metadata\"</span>, <span class=\"hljs-string\">\"some value\"</span>)\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当你在容器或者云启动你的服务时，也许并不知道服务的公网IP和端口，所以发布操作必须要通过另一个对象来获取这个信息，通常它是一个 <em>桥接对象</em> （ <code>bridge</code> ）。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_consuming_a_http_endpoint\"><a class=\"anchor\" href=\"#_consuming_a_http_endpoint\"></a>消费一个HTTP服务节点</h4>\n<div class=\"paragraph\">\n<p>一旦HTTP节点发布，一个消费者可以获取到它。这个服务对象是一个配置了host和port的 <code><a href=\"../../apidocs/io/vertx/core/http/HttpClient.html\">HttpClient</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-http-service\"</span>), ar1 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar1.succeeded() &amp;&amp; ar1.result() != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-comment\">// 获取服务引用</span>\n    ServiceReference reference = discovery.getReference(ar1.result());\n    <span class=\"hljs-comment\">// 获取服务对象</span>\n    HttpClient client = reference.getAs(HttpClient<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n    <span class=\"hljs-comment\">// 定义完整的path</span>\n    client.request(HttpMethod.GET, <span class=\"hljs-string\">\"/api/persons\"</span>).compose(request -&gt;\n      request\n        .send()\n        .compose(HttpClientResponse::body))\n      .onComplete(ar2 -&gt; {\n      <span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\n      reference.release();\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你也可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#getClient-io.vertx.servicediscovery.ServiceDiscovery-io.vertx.core.json.JsonObject-io.vertx.core.Handler-\">HttpEndpoint.getClient</a></code> 函数，通过一次函数调用来同时完成服务查找和服务对象获取的操作。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpEndpoint.getClient(discovery, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-http-service\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    HttpClient client = ar.result();\n\n    <span class=\"hljs-comment\">// 你需要提供完整的path</span>\n    client.request(HttpMethod.GET, <span class=\"hljs-string\">\"/api/persons\"</span>).compose(request -&gt;\n      request\n        .send()\n        .compose(HttpClientResponse::body))\n      .onComplete(ar2 -&gt; {\n        <span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\n        ServiceDiscovery.releaseServiceObject(discovery, client);\n      });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这第二个写法里，用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#releaseServiceObject-io.vertx.servicediscovery.ServiceDiscovery-java.lang.Object-\">ServiceDiscovery.releaseServiceObject</a></code> 来释放服务对象，所以你不需要持有服务引用。</p>\n</div>\n<div class=\"paragraph\">\n<p>从Vert.x 3.4.0开始，提供了另一个客户端。这个更高层次封装的客户端名字叫 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code>，这个客户端用起来更容易。你可以通过如下方式获取 <code><a href=\"../../apidocs/io/vertx/ext/web/client/WebClient.html\">WebClient</a></code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-http-service\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-comment\">// 获取服务引用</span>\n    ServiceReference reference = discovery.getReference(ar.result());\n    <span class=\"hljs-comment\">// 获取服务对象</span>\n    WebClient client = reference.getAs(WebClient<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n    <span class=\"hljs-comment\">// 你需要提供完整的path</span>\n    client.get(<span class=\"hljs-string\">\"/api/persons\"</span>).send(\n      response -&gt; {\n\n        <span class=\"hljs-comment\">// ...</span>\n\n        <span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\n        reference.release();\n\n      });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>另外，如果你更倾向于用服务类型的方式：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpEndpoint.getWebClient(discovery, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-http-service\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    WebClient client = ar.result();\n\n    <span class=\"hljs-comment\">// 你需要提供完整的path</span>\n    client.get(<span class=\"hljs-string\">\"/api/persons\"</span>)\n      .send(response -&gt; {\n\n        <span class=\"hljs-comment\">// ...</span>\n\n        <span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\n        ServiceDiscovery.releaseServiceObject(discovery, client);\n\n      });\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_event_bus_services\"><a class=\"anchor\" href=\"#_event_bus_services\"></a>Event bus 服务</h3>\n<div class=\"paragraph\">\n<p>Event bus服务是服务代理，它基于event bus实现了异步RPC服务。当从event bus服务获取一个服务对象，你获取到对应类型的服务代理。你可以从 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\">EventBusService</a></code> 获取辅助函数。</p>\n</div>\n<div class=\"paragraph\">\n<p>注意：服务代理（服务的实现和服务接口）是由java实现的</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publishing_an_event_bus_service\"><a class=\"anchor\" href=\"#_publishing_an_event_bus_service\"></a>发布一个event bus服务</h4>\n<div class=\"paragraph\">\n<p>发布event bus服务，你需要创建一个 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code>：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record = EventBusService.createRecord(\n    <span class=\"hljs-string\">\"some-eventbus-service\"</span>, <span class=\"hljs-comment\">// 服务名称</span>\n    <span class=\"hljs-string\">\"address\"</span>, <span class=\"hljs-comment\">// 服务地址,</span>\n    <span class=\"hljs-string\">\"examples.MyService\"</span>, <span class=\"hljs-comment\">// 字符串格式的服务接口类名</span>\n    <span class=\"hljs-keyword\">new</span> JsonObject()\n        .put(<span class=\"hljs-string\">\"some-metadata\"</span>, <span class=\"hljs-string\">\"some value\"</span>)\n);\n\ndiscovery.publish(record, ar -&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你也可以传服务接口类：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record = EventBusService.createRecord(\n<span class=\"hljs-string\">\"some-eventbus-service\"</span>, <span class=\"hljs-comment\">// 服务名称</span>\n<span class=\"hljs-string\">\"address\"</span>, <span class=\"hljs-comment\">// 服务地址,</span>\nMyService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span> // 接口类\n)</span>;\n\ndiscovery.publish(record, ar -&gt; {\n<span class=\"hljs-comment\">// ...</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_consuming_an_event_bus_service\"><a class=\"anchor\" href=\"#_consuming_an_event_bus_service\"></a>消费event bus服务</h4>\n<div class=\"paragraph\">\n<p>要消费一个event bus服务，你可以先获取服务记录，再通过服务记录获取服务引用；或者用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\">EventBusService</a></code> 接口通过一次调用来完成这两个操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>当使用服务引用是，你应该这样做：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-eventbus-service\"</span>), ar -&gt; {\n<span class=\"hljs-keyword\">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class=\"hljs-keyword\">null</span>) {\n<span class=\"hljs-comment\">// 获取服务引用</span>\nServiceReference reference = discovery.getReference(ar.result());\n<span class=\"hljs-comment\">// 获取服务对象</span>\nMyService service = reference.getAs(MyService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n<span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\nreference.release();\n}\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/EventBusService.html\">EventBusService</a></code> 类，你可以像下述获取代理：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBusService.getProxy(discovery, MyService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">ar</span> -&gt; </span>{\n<span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\nMyService service = ar.result();\n\n<span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\nServiceDiscovery.releaseServiceObject(discovery, service);\n}\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_message_source\"><a class=\"anchor\" href=\"#_message_source\"></a>消息源服务</h3>\n<div class=\"paragraph\">\n<p>消息源是一个往event bus地址发送消息的组件，消息源客户端是 `<a href=\"../../apidocs/io/vertx/core/eventbus/MessageConsumer.html\">MessageConsumer</a>`类。</p>\n</div>\n<div class=\"paragraph\">\n<p>消息被发送给到eventBus的 <em>location</em> 或 消息源服务上。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publishing_a_message_source\"><a class=\"anchor\" href=\"#_publishing_a_message_source\"></a>推送消息</h4>\n<div class=\"paragraph\">\n<p>就像其他类型的服务，推送一个消息分2步走：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\">MessageSource</a></code> 创建一个服务对象。</p>\n</li>\n<li>\n<p>推送消息</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record = MessageSource.createRecord(\n    <span class=\"hljs-string\">\"some-message-source-service\"</span>, <span class=\"hljs-comment\">// 服务名</span>\n    <span class=\"hljs-string\">\"some-address\"</span> <span class=\"hljs-comment\">// event bus 地址</span>\n);\n\ndiscovery.publish(record, ar -&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n});\n\nrecord = MessageSource.createRecord(\n    <span class=\"hljs-string\">\"some-other-message-source-service\"</span>, <span class=\"hljs-comment\">// 服务名</span>\n    <span class=\"hljs-string\">\"some-address\"</span>, <span class=\"hljs-comment\">// event bus 地址</span>\n    <span class=\"hljs-string\">\"examples.MyData\"</span> <span class=\"hljs-comment\">// 消息体类型</span>\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在上述第二个record当中，我们同时指明了消息体（payload）的类型，这个参数是可选的。</p>\n</div>\n<div class=\"paragraph\">\n<p>在Java当中，你可以用 <code><a href=\"../../apidocs/java/lang/Class.html\">Class</a></code> 参数：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record1 = MessageSource.createRecord(\n<span class=\"hljs-string\">\"some-message-source-service\"</span>, <span class=\"hljs-comment\">// 服务名</span>\n<span class=\"hljs-string\">\"some-address\"</span>, <span class=\"hljs-comment\">// 服务地址</span>\nJsonObject<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span> // 消息体类型\n)</span>;\n\nRecord record2 = MessageSource.createRecord(\n<span class=\"hljs-string\">\"some-other-message-source-service\"</span>, <span class=\"hljs-comment\">// 服务名</span>\n<span class=\"hljs-string\">\"some-address\"</span>, <span class=\"hljs-comment\">// 服务地址</span>\nJsonObject<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, // 消息体类型\n<span class=\"hljs-title\">new</span> <span class=\"hljs-title\">JsonObject</span>().<span class=\"hljs-title\">put</span>(\"<span class=\"hljs-title\">some</span>-<span class=\"hljs-title\">metadata</span>\", \"<span class=\"hljs-title\">some</span> <span class=\"hljs-title\">value</span>\")\n)</span>;</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_consuming_a_message_source\"><a class=\"anchor\" href=\"#_consuming_a_message_source\"></a>消费消息服务</h4>\n<div class=\"paragraph\">\n<p>在消费者端，你可以获取服务记录从而获取服务引用，或者用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\">MessageSource</a></code> 通过一次调用合两步为一。</p>\n</div>\n<div class=\"paragraph\">\n<p>通过第一种方式，代码如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(<span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-message-source-service\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-comment\">// 获取服务引用</span>\n    ServiceReference reference = discovery.getReference(ar.result());\n    <span class=\"hljs-comment\">// 获取服务对象</span>\n    MessageConsumer&lt;JsonObject&gt; consumer = reference.getAs(MessageConsumer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n    <span class=\"hljs-comment\">// 指定消息处理器</span>\n    consumer.handler(message -&gt; {\n      <span class=\"hljs-comment\">// 消息处理器逻辑</span>\n      JsonObject payload = message.body();\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当使用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MessageSource.html\">MessageSource</a></code> 时，代码就变成了如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MessageSource.&lt;JsonObject&gt;getConsumer(discovery, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-message-source-service\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    MessageConsumer&lt;JsonObject&gt; consumer = ar.result();\n\n    <span class=\"hljs-comment\">// 指定消息处理器</span>\n    consumer.handler(message -&gt; {\n      <span class=\"hljs-comment\">// 消息处理器逻辑</span>\n      JsonObject payload = message.body();\n    });\n    <span class=\"hljs-comment\">// ...</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_jdbc_data_source\"><a class=\"anchor\" href=\"#_jdbc_data_source\"></a>JDBC数据源</h3>\n<div class=\"paragraph\">\n<p>数据源代表数据库或数据仓储。而JDBC数据源特指用JDBC驱动访问数据库。JDBC数据源客户端是 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\">JDBCClient</a></code> 类。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publishing_a_jdbc_service\"><a class=\"anchor\" href=\"#_publishing_a_jdbc_service\"></a>发布JDBC服务</h4>\n<div class=\"paragraph\">\n<p>类似其他类型的服务，发布JDBC服务需要2步：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html\">JDBCDataSource</a></code> 创建record</p>\n</li>\n<li>\n<p>推送record</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record = JDBCDataSource.createRecord(\n    <span class=\"hljs-string\">\"some-data-source-service\"</span>, <span class=\"hljs-comment\">// 服务名</span>\n    <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"url\"</span>, <span class=\"hljs-string\">\"some jdbc url\"</span>), <span class=\"hljs-comment\">// 服务地址</span>\n    <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"some-metadata\"</span>, <span class=\"hljs-string\">\"some-value\"</span>) <span class=\"hljs-comment\">// 元数据</span>\n);\n\ndiscovery.publish(record, ar -&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>因为JDBC数据源可以使用很多数据库，并且访问方式经常不一样，所以服务记录是没有标准结构定义的，<code>location</code> 是访问数据库配置而提供的一个通用JSONObject属性，用于访问数据源(JDBC url，username&#8230;&#8203;)。其他字段的定义依赖于数据库以及所用连接池决定。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_consuming_a_jdbc_service\"><a class=\"anchor\" href=\"#_consuming_a_jdbc_service\"></a>消费一个JDBC服务</h4>\n<div class=\"paragraph\">\n<p>由前所述，如何获取数据源取决于数据源本身。要创建 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\">JDBCClient</a></code> ，你可以同时提供：<code>record location</code>，元数据和一个有消费方提供的一个Json object：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(\n    <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-data-source-service\"</span>),\n    ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// 获取服务引用</span>\n        ServiceReference reference = discovery.getReferenceWithConfiguration(\n            ar.result(), <span class=\"hljs-comment\">// record</span>\n            <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"username\"</span>, <span class=\"hljs-string\">\"clement\"</span>).put(<span class=\"hljs-string\">\"password\"</span>, <span class=\"hljs-string\">\"*****\"</span>)); <span class=\"hljs-comment\">// 一些额外的元数据</span>\n\n        <span class=\"hljs-comment\">// 获取service object</span>\n        JDBCClient client = reference.getAs(JDBCClient<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n        <span class=\"hljs-comment\">// ...</span>\n\n        <span class=\"hljs-comment\">// 完毕</span>\n        reference.release();\n      }\n    });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你可以用 <code><a href=\"../../apidocs/io/vertx/ext/jdbc/JDBCClient.html\">JDBCClient</a></code> 通过一次调用来发现和获取服务。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JDBCDataSource.&lt;JsonObject&gt;getJDBCClient(discovery,\n    <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-data-source-service\"</span>),\n    <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"username\"</span>, <span class=\"hljs-string\">\"clement\"</span>).put(<span class=\"hljs-string\">\"password\"</span>, <span class=\"hljs-string\">\"*****\"</span>), <span class=\"hljs-comment\">// 一些额外的元数据</span>\n    ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n        JDBCClient client = ar.result();\n\n        <span class=\"hljs-comment\">// ...</span>\n\n        <span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\n        ServiceDiscovery.releaseServiceObject(discovery, client);\n\n      }\n    });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_redis_data_source\"><a class=\"anchor\" href=\"#_redis_data_source\"></a>Redis 数据源</h3>\n<div class=\"paragraph\">\n<p>Redis数据源是Redis持久性数据库的一种特殊实现。</p>\n</div>\n<div class=\"paragraph\">\n<p>Redis数据源客户端是 <code><a href=\"../../apidocs/io/vertx/redis/client/Redis.html\">Redis</a></code> 类</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publishing_a_redis_service\"><a class=\"anchor\" href=\"#_publishing_a_redis_service\"></a>发布Redis服务</h4>\n<div class=\"paragraph\">\n<p>发布Redis服务需要2步：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html\">RedisDataSource</a></code> 创建服务记录</p>\n</li>\n<li>\n<p>推送record</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record = RedisDataSource.createRecord(\n  <span class=\"hljs-string\">\"some-redis-data-source-service\"</span>, <span class=\"hljs-comment\">// 服务名</span>\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"url\"</span>, <span class=\"hljs-string\">\"localhost\"</span>), <span class=\"hljs-comment\">// 服务地址</span>\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"some-metadata\"</span>, <span class=\"hljs-string\">\"some-value\"</span>) <span class=\"hljs-comment\">// 一些元数据</span>\n);\n\ndiscovery.publish(record, ar -&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>location</code> 是一个简单的JSON对象，应提供用于访问Redis数据源的字段(url,port&#8230;&#8203;.)</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_consuming_a_redis_service\"><a class=\"anchor\" href=\"#_consuming_a_redis_service\"></a>消费Redis服务</h4>\n<div class=\"paragraph\">\n<p>由前所述，如何访问数据源决定于数据源本身。创建一个 <code><a href=\"../../apidocs/io/vertx/redis/client/Redis.html\">Redis</a></code> 对象，你可以同时提供：record地址，元数据和由消费方提供的Json object。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-redis-data-source-service\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 获取服务引用</span>\n      ServiceReference reference = discovery.getReference(ar.result());\n\n      <span class=\"hljs-comment\">// 获取服务实例</span>\n      Redis client = reference.getAs(Redis<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n      <span class=\"hljs-comment\">// ...</span>\n\n      <span class=\"hljs-comment\">// 完毕 释放资源</span>\n      reference.release();\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你也可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html\">RedisDataSource</a></code> 通过一次调用完成服务发现和获取。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RedisDataSource.getRedisClient(discovery,\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-redis-data-source-service\"</span>),\n  ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      Redis client = ar.result();\n\n      <span class=\"hljs-comment\">// ...</span>\n\n      <span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\n      ServiceDiscovery.releaseServiceObject(discovery, client);\n\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mongo_data_source\"><a class=\"anchor\" href=\"#_mongo_data_source\"></a>Mongo数据源</h3>\n<div class=\"paragraph\">\n<p>Mongo数据源是MongoDB数据库的专用化实现。\nMongo数据源服务的客户端是 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\">MongoClient</a></code> 类</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_publishing_a_mongo_service\"><a class=\"anchor\" href=\"#_publishing_a_mongo_service\"></a>发布Mongo服务</h4>\n<div class=\"paragraph\">\n<p>发布Mongo服务需要2步：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html\">MongoDataSource</a></code> 创建服务记录</p>\n</li>\n<li>\n<p>推送record</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Record record = MongoDataSource.createRecord(\n  <span class=\"hljs-string\">\"some-data-source-service\"</span>, <span class=\"hljs-comment\">// 服务名</span>\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"connection_string\"</span>, <span class=\"hljs-string\">\"some mongo connection\"</span>), <span class=\"hljs-comment\">// 服务地址</span>\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"some-metadata\"</span>, <span class=\"hljs-string\">\"some-value\"</span>) <span class=\"hljs-comment\">// 元数据</span>\n);\n\ndiscovery.publish(record, ar -&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>location</code> 是一个简单的JSON对象，应提供用于访问Mongo数据源的字段(url, port&#8230;&#8203;)</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_consuming_a_mongo_service\"><a class=\"anchor\" href=\"#_consuming_a_mongo_service\"></a>消费Mongo服务</h4>\n<div class=\"paragraph\">\n<p>由前所述，如何访问数据源取决于数据源本身。创建 <code><a href=\"../../apidocs/io/vertx/ext/mongo/MongoClient.html\">MongoClient</a></code> ，你可以同时提供：<code>record location</code> ,元数据和consumer提供的json object：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">discovery.getRecord(\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-data-source-service\"</span>),\n  ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded() &amp;&amp; ar.result() != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 获取服务引用</span>\n      ServiceReference reference = discovery.getReferenceWithConfiguration(\n        ar.result(), <span class=\"hljs-comment\">// record</span>\n        <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"username\"</span>, <span class=\"hljs-string\">\"clement\"</span>).put(<span class=\"hljs-string\">\"password\"</span>, <span class=\"hljs-string\">\"*****\"</span>)); <span class=\"hljs-comment\">// 额外的元数据</span>\n\n      <span class=\"hljs-comment\">// 获取服务对象</span>\n      MongoClient client = reference.get();\n\n      <span class=\"hljs-comment\">// ...</span>\n\n      <span class=\"hljs-comment\">// 完毕 释放资源</span>\n      reference.release();\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你也可以用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html\">MongoDataSource</a></code> 类通过一次调用来完成服务查找和获取：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MongoDataSource.&lt;JsonObject&gt;getMongoClient(discovery,\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"some-data-source-service\"</span>),\n  <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"username\"</span>, <span class=\"hljs-string\">\"clement\"</span>).put(<span class=\"hljs-string\">\"password\"</span>, <span class=\"hljs-string\">\"*****\"</span>), <span class=\"hljs-comment\">// 一些额外的元数据</span>\n  ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      MongoClient client = ar.result();\n\n      <span class=\"hljs-comment\">// ...</span>\n\n      <span class=\"hljs-comment\">// 不要忘记释放服务资源</span>\n      ServiceDiscovery.releaseServiceObject(discovery, client);\n\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_listening_for_service_arrivals_and_departures\"><a class=\"anchor\" href=\"#_listening_for_service_arrivals_and_departures\"></a>监听服务的注册和注销</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>每当服务提供方被发布或移除， <em>vertx.discovery.announce</em> 地址上会推送一个事件。\n这个地址可以在 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html\">ServiceDiscoveryOptions</a></code> 配置</p>\n</div>\n<div class=\"paragraph\">\n<p>收到的record会有一个 <code>status</code> 字段，它描述了record的新状态：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>UP</code> : 服务可获取，您可以开启并使用它</p>\n</li>\n<li>\n<p><code>DOWN</code> : 服务不可获取，你不应该再使用它</p>\n</li>\n<li>\n<p><code>OUT_OF_SERVICE</code> : 服务不在运行状态，你不该再用它，但是可能过一会可能会恢复</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_listening_for_service_usage\"><a class=\"anchor\" href=\"#_listening_for_service_usage\"></a>监听服务使用状况</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>每当获取或释放服务引用时 <em>vertx.discovery.usage</em> 地址上会推送一个event。这个地址可以由 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html\">ServiceDiscoveryOptions</a></code> 配置。</p>\n</div>\n<div class=\"paragraph\">\n<p>这会让您监听服务的使用情况并映射服务的绑定情况。</p>\n</div>\n<div class=\"paragraph\">\n<p>收到的消息是一个包含如下信息的 <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>record</code> 属性指服务记录对象</p>\n</li>\n<li>\n<p><code>type</code> 属性是事件的类型，它有两个值：<code>bind</code> ，<code>release</code></p>\n</li>\n<li>\n<p><code>id</code> 属性是服务发现的id（名称或者node id）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这个 <code>id</code> 可以通过 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html\">ServiceDiscoveryOptions</a></code> 配置。默认情况下 单节点是\"localhost\"，集群模式下是node id。</p>\n</div>\n<div class=\"paragraph\">\n<p>你可以禁用服务使用情况的功能，这可以通过 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html#setUsageAddress-java.lang.String-\">setUsageAddress</a></code> 设置 <code>usage address</code> 为 <code>null</code> 来实现。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_service_discovery_bridges\"><a class=\"anchor\" href=\"#_service_discovery_bridges\"></a>服务发现桥接器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>桥接器 可以让你从其他服务发现机制(Docker，Kubernetes，Consul&#8230;&#8203;)里导入导出服务\n每个桥接器决定了服务如何导入导出。这不一定是双向操作。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以实现 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html\">ServiceImporter</a></code> 接口，并用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#registerServiceImporter-io.vertx.servicediscovery.spi.ServiceImporter-io.vertx.core.json.JsonObject-\">registerServiceImporter</a></code> 来注册的方式，为自己提供桥接器。</p>\n</div>\n<div class=\"paragraph\">\n<p>第二个参数是可选的，它可以配置桥接器。</p>\n</div>\n<div class=\"paragraph\">\n<p>当桥接器被注册时，<code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html#start-io.vertx.core.Vertx-io.vertx.servicediscovery.spi.ServicePublisher-io.vertx.core.json.JsonObject-io.vertx.core.Promise-\">start</a></code> 函数被调用。\n它让您可以配置桥接器。当桥接器被配置时，准备就绪并导入/导出初始服务后，它让给定的 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code> 处于 <code>completed</code> 状态；如果bridge starts函数正在阻塞，则它必须使用 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\">executeBlocking</a></code> 构造，并设置给定的future对象为 <code>completed</code> 状态。</p>\n</div>\n<div class=\"paragraph\">\n<p>当服务发现组件停止，桥接器也随即停止。</p>\n</div>\n<div class=\"paragraph\">\n<p>调用 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html#close-io.vertx.core.Handler-\">close</a></code> 函数会清除资源，移除已经导入/导出的服务。这个函数必须设置返回的 <code><a href=\"../../apidocs/io/vertx/core/Future.html\">Future</a></code> 对象为 <code>completed</code> 状态,目的在于提醒调用者处理完成事件。</p>\n</div>\n<div class=\"paragraph\">\n<p>注意：在集群当中，只需要注册服务记录当中一个成员的桥接器即可，因为所有的服务记录都是互通的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_additional_bridges\"><a class=\"anchor\" href=\"#_additional_bridges\"></a>其他的桥接器支持</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 服务发现组件除了支持桥接器机制以外，还提供了一些现成的桥接器。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_consul_bridge\"><a class=\"anchor\" href=\"#_consul_bridge\"></a>Consul 网桥</h3>\n<div class=\"paragraph\">\n<p>Consul服务发现网桥从 <a href=\"http://consul.io\">Consul</a> 导入服务到Vert.x服务发现。这个网桥链接了 Consul agent 服务 并周期性扫描以下服务：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>新导入的服务</p>\n</li>\n<li>\n<p>移除 处于 <code>maintenance</code> 模式的服务或已经从consul中被移除的服务</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>这个桥接器使用的是 Consul 的HTTP API接口。它不能将服务导出到Consul，并且也不支持服务的修改。</p>\n</div>\n<div class=\"paragraph\">\n<p>服务的类型是通过 <code>tags</code> 推断出来的，如果有一个 <code>tag</code> 和已知的服务类型一样，那么就使用这种服务类型，如果没有匹配的，那么服务导入后将标记为unknown类型。目前暂时只支持http-endpoint类型。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_the_bridge\"><a class=\"anchor\" href=\"#_using_the_bridge\"></a>桥接器的使用</h4>\n<div class=\"paragraph\">\n<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (<code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-discovery-bridge-consul<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (<code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-service-discovery-bridge-consul:4.0.0'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>然后，在创建服务发现对象的时候，像下面这样注册桥接器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceDiscovery.create(vertx)\n    .registerServiceImporter(<span class=\"hljs-keyword\">new</span> ConsulServiceImporter(),\n        <span class=\"hljs-keyword\">new</span> JsonObject()\n            .put(<span class=\"hljs-string\">\"host\"</span>, <span class=\"hljs-string\">\"localhost\"</span>)\n            .put(<span class=\"hljs-string\">\"port\"</span>, <span class=\"hljs-number\">8500</span>)\n            .put(<span class=\"hljs-string\">\"scan-period\"</span>, <span class=\"hljs-number\">2000</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>你可以做一些配置：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>host</code> 属性，配置 agent 的地址，默认是 <code>localhost</code></p>\n</li>\n<li>\n<p><code>port</code> 属性，配置 agent 的端口，默认的端口是 8500</p>\n</li>\n<li>\n<p><code>acl_token</code> 属性，配置 agent 的访问控制令牌，默认值是 null</p>\n</li>\n<li>\n<p><code>scan-period</code> 属性，配置扫描的频率，扫描的单位是毫秒（ms），默认是 2000 ms</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_kubernetes_bridge\"><a class=\"anchor\" href=\"#_kubernetes_bridge\"></a>Kubernetes 桥接器</h3>\n<div class=\"paragraph\">\n<p>Kubernetes 桥接器可以从Kubernetes（或者 Openshift v3）中导入服务到Vert.x的服务发现组件中。\nKubernetes的所有服务，都将映射为一条 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> ，目前桥接器只支持将服务从Kubernetes中导入到Vert.x中（反过来不行）。</p>\n</div>\n<div class=\"paragraph\">\n<p>Kubernetes中的服务，在导入到Vert.x后都会创建对应的 <code><a href=\"../../apidocs/io/vertx/servicediscovery/Record.html\">Record</a></code> ，服务类型是通过 <code>service-type</code> 标签推断出来，或者通过服务暴露的端口推断出来。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_the_bridge_2\"><a class=\"anchor\" href=\"#_using_the_bridge_2\"></a>桥接器的使用</h4>\n<div class=\"paragraph\">\n<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (<code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-discovery-bridge-kubernetes<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle ( <code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-service-discovery-bridge-kubernetes:4.0.0'</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_configuring_the_bridge\"><a class=\"anchor\" href=\"#_configuring_the_bridge\"></a>桥接器的配置</h4>\n<div class=\"paragraph\">\n<p>桥接器的配置项有：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>OAuth token（默认是使用 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 中的内容）</p>\n</li>\n<li>\n<p>服务搜索的命名空间（默认是`default`）</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>请注意，应用程序必须能够访问 Kubernetes 并且能够读取所选择的命名空间。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_the_service_to_record_mapping\"><a class=\"anchor\" href=\"#_the_service_to_record_mapping\"></a>服务记录的映射</h4>\n<div class=\"paragraph\">\n<p>服务记录按照如下的步骤进行创建：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>从 <code>service.type</code> 中推断出服务类型；如果没有设置，那么服务类型被设置为 <code>unknown</code></p>\n</li>\n<li>\n<p>服务记录的名称就是服务的名称</p>\n</li>\n<li>\n<p>服务的标签（label）都被映射为服务记录的元数据</p>\n</li>\n<li>\n<p>此外还会加上：<code>kubernetes.uuid</code> , <code>kubernetes.namespace</code> , <code>kubernetes.name</code></p>\n</li>\n<li>\n<p><code>location</code> 信息将从服务的第一个端口推断出来</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>对于 HTTP 端点，如果服务带有值为 <code>true</code> 的 <code>ssl</code> (<code>https</code>) 标签的话，那么服务记录的 <code>ssl</code> (<code>https</code>)属性将被设置为 <code>true</code>。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_dynamics\"><a class=\"anchor\" href=\"#_dynamics\"></a>动态性</h4>\n<div class=\"paragraph\">\n<p>Kubernetes 桥接器将会在启动(<code>start</code>)的时候导入所有的服务，在停止(<code>stop</code>)的时候移除所有的服务。在运行期间，它将监听 Kubernetes 的服务，并且动态地导入新加入的服务，移除被删除的服务。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_supported_types\"><a class=\"anchor\" href=\"#_supported_types\"></a>支持的类型</h4>\n<div class=\"paragraph\">\n<p>桥接器使用 <code>service-type</code> 标签来指定类型。另外，它还检查服务的端口，支持如下：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>80，443，8080-9000： HTTP端点</p>\n</li>\n<li>\n<p>5432，5433：JDBC数据源（PostGreSQL）</p>\n</li>\n<li>\n<p>3306，13306：JDBC数据源（MySql）</p>\n</li>\n<li>\n<p>6379: Redis 数据源</p>\n</li>\n<li>\n<p>ports 27017, 27018 和 27019: MongoDB 数据源</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>如果 <code>service-type</code> 存在，那么将覆盖端口的默认配置</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in index.adoc - include::zookeeper-bridge.adoc[]</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_docker_links_bridge\"><a class=\"anchor\" href=\"#_docker_links_bridge\"></a>Docker Links 桥接器</h3>\n<div class=\"paragraph\">\n<p>Docker Links 桥接器可以从 Docker Links 中导入服务到 Vert.x 的服务发现组件中。当你将一个Docker容器与另外一个Docker容器链接在一起(link)的时候，Docker将会注入一组环境变量。该桥接器将分析这些环境变量，并且针对每个链接(link)，生成一个服务记录。服务记录的类型从 <code>service.type</code> 属性中推断；如果没有设置，那么服务类型将被设置为 <code>unknown</code> 。目前暂时只支持 <code>http-endpoint</code> 服务类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>由于Docker容器只在启动的时候创建链接，所以这个桥接器只会在启动的时候导入服务记录，然后此后就都不改变了。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_the_bridge_3\"><a class=\"anchor\" href=\"#_using_the_bridge_3\"></a>桥接器的使用</h4>\n<div class=\"paragraph\">\n<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (<code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-discovery-bridge-docker<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle ( <code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-service-discovery-bridge-docker:4.0.0'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>创建服务发现对象时，注册桥接器的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceDiscovery.create(vertx)\n    .registerServiceImporter(<span class=\"hljs-keyword\">new</span> DockerLinksServiceImporter(), <span class=\"hljs-keyword\">new</span> JsonObject());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这种桥接器不需要进一步的配置。</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_additional_backends\"><a class=\"anchor\" href=\"#_additional_backends\"></a>其他的后台支持</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>除了此库支持的后台之外，Vert.x服务发现还提供了其他后台以供您在自己的应用程序中使用。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_redis_backend\"><a class=\"anchor\" href=\"#_redis_backend\"></a>Redis backend</h3>\n<div class=\"paragraph\">\n<p>服务发现组件通过实现 <code><a href=\"../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html\">ServiceDiscoveryBackend</a></code> SPI提供了一种可插拔的存储后端扩展机制，这是以Redis为基础的SPI的实现。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_the_redis_backend\"><a class=\"anchor\" href=\"#_using_the_redis_backend\"></a>使用 Redis 存储后端</h4>\n<div class=\"paragraph\">\n<p>要使用 Redis 存储后端，需要将如下的依赖包加入到依赖配置文件中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven ( <code>pom.xml</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-discovery-backend-redis<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle ( <code>build.gradle</code> 文件):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-service-discovery-backend-redis:4.0.0'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>需要注意的是，你只能在 <code>classpath</code> 中指定一个SPI的实现；如果没有指定，那么将使用默认的存储后端。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>配置</h4>\n<div class=\"paragraph\">\n<p>Redis存储后端是基于 <a href=\"http://vertx.io/docs/vertx-redis-client/java\">vertx-redis-client</a> 实现的，这个配置是客户端配置以及在Redis上 <code>key</code> 的存储记录</p>\n</div>\n<div class=\"paragraph\">\n<p>下面是一个示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceDiscovery.create(vertx, <span class=\"hljs-keyword\">new</span> ServiceDiscoveryOptions()\n    .setBackendConfiguration(\n        <span class=\"hljs-keyword\">new</span> JsonObject()\n            .put(<span class=\"hljs-string\">\"connectionString\"</span>, <span class=\"hljs-string\">\"redis://localhost:6379\"</span>)\n            .put(<span class=\"hljs-string\">\"key\"</span>, <span class=\"hljs-string\">\"records\"</span>)\n    ));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>值得注意的一点是，配置是在 <code>setBackendConfiguration</code> 方法中传入的（如果使用JSON，则传递给 <code>backendConfiguration</code> 对象:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceDiscovery.create(vertx,\n  <span class=\"hljs-keyword\">new</span> ServiceDiscoveryOptions(<span class=\"hljs-keyword\">new</span> JsonObject()\n    .put(<span class=\"hljs-string\">\"backendConfiguration\"</span>,\n      <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">\"connectionString\"</span>, <span class=\"hljs-string\">\"redis://localhost:6379\"</span>).put(<span class=\"hljs-string\">\"key\"</span>, <span class=\"hljs-string\">\"my-records\"</span>)\n)));</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}