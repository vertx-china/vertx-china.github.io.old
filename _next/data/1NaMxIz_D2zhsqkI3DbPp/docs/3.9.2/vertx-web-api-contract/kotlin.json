{"pageProps":{"slug":"3.9.2/vertx-web-api-contract/kotlin","title":"Vert.x Web API Contract","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_api_contract\">Using Vert.x API Contract</a></li>\n<li><a href=\"#_http_requests_validation\">HTTP Requests validation</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_types_of_request_parameters\">Types of request parameters</a></li>\n<li><a href=\"#_handling_parameters\">Handling parameters</a></li>\n<li><a href=\"#_manage_validation_failures\">Manage validation failures</a></li>\n</ul>\n</li>\n<li><a href=\"#_openapi_3\">OpenAPI 3</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_the_router_factory\">The Router Factory</a></li>\n<li><a href=\"#_create_a_new_router_factory\">Create a new router factory</a></li>\n<li><a href=\"#_mount_the_handlers\">Mount the handlers</a></li>\n<li><a href=\"#_define_security_handlers\">Define security handlers</a></li>\n<li><a href=\"#_not_implemented_error\">Not Implemented Error</a></li>\n<li><a href=\"#_response_content_type_handler\">Response Content Type Handler</a></li>\n<li><a href=\"#_operation_model\">Operation model</a></li>\n<li><a href=\"#_body_handler\">Body Handler</a></li>\n<li><a href=\"#_multipartform_data_validation\"><code>multipart/form-data</code> validation</a></li>\n<li><a href=\"#_custom_global_handlers\">Custom global handlers</a></li>\n<li><a href=\"#_router_factory_handlers_mount_order\">Router factory handlers mount order</a></li>\n<li><a href=\"#_generate_the_router\">Generate the router</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Web API Contract</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web API Contract extends Vert.x Web to support <a href=\"https://www.openapis.org/\">OpenAPI 3</a>, bringing to you a simple interface to build your router and mount security and validation handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are interested in building an application that routes API Requests to event bus, check out <a href=\"https://vertx.io/docs/vertx-web-api-service/java/\">Vert.x Web API Service</a></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_api_contract\"><a class=\"anchor\" href=\"#_using_vert_x_api_contract\"></a>Using Vert.x API Contract</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use Vert.x API Contract, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-api-contract<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-web-api-contract:3.9.2'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_http_requests_validation\"><a class=\"anchor\" href=\"#_http_requests_validation\"></a>HTTP Requests validation</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x provides a validation framework that will validate requests for you and will put results of validation inside a container. To define a <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/HTTPRequestValidationHandler.html\">HTTPRequestValidationHandler</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">// Create Validation Handler with some stuff</span>\n<span class=\"hljs-keyword\">var</span> validationHandler = HTTPRequestValidationHandler.create().addQueryParam(<span class=\"hljs-string\">\"parameterName\"</span>, ParameterType.INT, <span class=\"hljs-literal\">true</span>).addFormParamWithPattern(<span class=\"hljs-string\">\"formParameterName\"</span>, <span class=\"hljs-string\">\"a{4}\"</span>, <span class=\"hljs-literal\">true</span>).addPathParam(<span class=\"hljs-string\">\"pathParam\"</span>, ParameterType.FLOAT)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then you can mount your validation handler:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">// BodyHandler is required to manage body parameters like forms or json body</span>\nrouter.route().handler(BodyHandler.create())\n\nrouter.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">\"/awesome/:pathParam\"</span>).handler(validationHandler).handler({ routingContext -&gt;\n  <span class=\"hljs-comment\">// Get Request parameters container</span>\n  <span class=\"hljs-keyword\">var</span> params = routingContext.<span class=\"hljs-keyword\">get</span>&lt;Any&gt;(<span class=\"hljs-string\">\"parsedParameters\"</span>)\n\n  <span class=\"hljs-comment\">// Get parameters</span>\n  <span class=\"hljs-keyword\">var</span> parameterName = params.queryParameter(<span class=\"hljs-string\">\"parameterName\"</span>).getInteger()\n  <span class=\"hljs-keyword\">var</span> formParameterName = params.formParameter(<span class=\"hljs-string\">\"formParameterName\"</span>).getString()\n  <span class=\"hljs-keyword\">var</span> pathParam = params.pathParameter(<span class=\"hljs-string\">\"pathParam\"</span>).getFloat()\n}).failureHandler({ routingContext -&gt;\n  <span class=\"hljs-keyword\">var</span> failure = routingContext.failure()\n  <span class=\"hljs-keyword\">if</span> (failure <span class=\"hljs-keyword\">is</span> io.vertx.ext.web.api.validation.ValidationException) {\n    <span class=\"hljs-comment\">// Something went wrong during validation!</span>\n    <span class=\"hljs-keyword\">var</span> validationErrorMessage = failure.getMessage()\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If validation succeeds, It returns request parameters inside <code><a href=\"../../apidocs/io/vertx/ext/web/api/RequestParameters.html\">RequestParameters</a></code>,\notherwise It will throw a fail inside <code>RoutingContext</code> with 400 status code and <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ValidationException.html\">ValidationException</a></code> failure.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_types_of_request_parameters\"><a class=\"anchor\" href=\"#_types_of_request_parameters\"></a>Types of request parameters</h3>\n<div class=\"paragraph\">\n<p>Every parameter has a type validator, a class that describes the expected type of parameter.\nA type validator validates the value, casts it in required language type and then loads it inside a <code><a href=\"../../apidocs/io/vertx/ext/web/api/RequestParameter.html\">RequestParameter</a></code> object. There are three ways to describe the type of your parameter:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>There is a set of prebuilt types that you can use: <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ParameterType.html\">ParameterType</a></code></p>\n</li>\n<li>\n<p>You can instantiate a custom instance of prebuilt type validators using static methods of <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ParameterTypeValidator.html\">ParameterTypeValidator</a></code> and then load it into <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/HTTPRequestValidationHandler.html\">HTTPRequestValidationHandler</a></code> using functions ending with <code>WithCustomTypeValidator</code></p>\n</li>\n<li>\n<p>You can create your own <code>ParameterTypeValidator</code> implementing <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ParameterTypeValidator.html\">ParameterTypeValidator</a></code> interface</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_parameters\"><a class=\"anchor\" href=\"#_handling_parameters\"></a>Handling parameters</h3>\n<div class=\"paragraph\">\n<p>Now you can handle parameter values:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">var</span> params = routingContext.<span class=\"hljs-keyword\">get</span>&lt;Any&gt;(<span class=\"hljs-string\">\"parsedParameters\"</span>)\n<span class=\"hljs-keyword\">var</span> awesomeParameter = params.queryParameter(<span class=\"hljs-string\">\"awesomeParameter\"</span>)\n<span class=\"hljs-keyword\">if</span> (awesomeParameter != <span class=\"hljs-literal\">null</span>) {\n  <span class=\"hljs-keyword\">if</span> (!awesomeParameter.isEmpty()) {\n    <span class=\"hljs-comment\">// Parameter exists and isn't empty</span>\n    <span class=\"hljs-comment\">// ParameterTypeValidator mapped the parameter in equivalent language object</span>\n    <span class=\"hljs-keyword\">var</span> awesome = awesomeParameter.getInteger()\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Parameter exists, but it's empty</span>\n  }\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">// Parameter doesn't exist (it's not required)</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As you can see, every parameter is mapped in respective language objects. You can also get a json body:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">var</span> body = params.body()\n<span class=\"hljs-keyword\">if</span> (body != <span class=\"hljs-literal\">null</span>) {\n  <span class=\"hljs-keyword\">var</span> jsonBody = body.getJsonObject()\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_manage_validation_failures\"><a class=\"anchor\" href=\"#_manage_validation_failures\"></a>Manage validation failures</h3>\n<div class=\"paragraph\">\n<p>A validation error fails the <code>RoutingContext</code> with 400 status code and <code><a href=\"../../apidocs/io/vertx/ext/web/api/validation/ValidationException.html\">ValidationException</a></code> failure.\nYou can manage these failures both at route level using <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html#failureHandler-io.vertx.core.Handler-\">failureHandler</a></code> or at router level using <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">router.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">\"/awesome/:pathParam\"</span>).handler(validationHandler).handler({ routingContext -&gt;\n  <span class=\"hljs-comment\">// Your logic</span>\n}).failureHandler({ routingContext -&gt;\n  <span class=\"hljs-keyword\">var</span> failure = routingContext.failure()\n  <span class=\"hljs-keyword\">if</span> (failure <span class=\"hljs-keyword\">is</span> io.vertx.ext.web.api.validation.ValidationException) {\n    <span class=\"hljs-comment\">// Something went wrong during validation!</span>\n    <span class=\"hljs-keyword\">var</span> validationErrorMessage = failure.getMessage()\n  }\n})\n\n<span class=\"hljs-comment\">// Manage the validation failure for all routes in the router</span>\nrouter.errorHandler(<span class=\"hljs-number\">400</span>, { routingContext -&gt;\n  <span class=\"hljs-keyword\">if</span> (routingContext.failure() <span class=\"hljs-keyword\">is</span> io.vertx.ext.web.api.validation.ValidationException) {\n    <span class=\"hljs-comment\">// Something went wrong during validation!</span>\n    <span class=\"hljs-keyword\">var</span> validationErrorMessage = routingContext.failure().getMessage()\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Unknown 400 failure happened</span>\n    routingContext.response().setStatusCode(<span class=\"hljs-number\">400</span>).end()\n  }\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_openapi_3\"><a class=\"anchor\" href=\"#_openapi_3\"></a>OpenAPI 3</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x allows you to use your OpenAPI 3 specification directly inside your code using the design first approach. Vert.x-Web API Contract provides:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>OpenAPI 3 compliant API specification validation with automatic <strong>loading of external Json schemas</strong></p>\n</li>\n<li>\n<p>Automatic request validation</p>\n</li>\n<li>\n<p>Automatic mount of security validation handlers</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>You can also use the community project <a href=\"https://github.com/pmlopes/vertx-starter\"><code>vertx-starter</code></a> to generate server code from your OpenAPI 3 specification.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_router_factory\"><a class=\"anchor\" href=\"#_the_router_factory\"></a>The Router Factory</h3>\n<div class=\"paragraph\">\n<p>You can create your web service based on OpenAPI 3 specification with <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html\">OpenAPI3RouterFactory</a></code>.\nThis class, as name says, is a router factory based on your OpenAPI 3 specification.\n<code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html\">OpenAPI3RouterFactory</a></code> is intended to give you a really simple user interface to use OpenAPI 3 related features. It includes:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Async loading of specification and its schema dependencies</p>\n</li>\n<li>\n<p>Mount path with operationId or with combination of path and HTTP method</p>\n</li>\n<li>\n<p>Automatic generation of validation handlers</p>\n</li>\n<li>\n<p>Automatic conversion between OpenAPI style paths and Vert.x style paths</p>\n</li>\n<li>\n<p>Lazy methods: operations are mounted in declaration order inside specification</p>\n</li>\n<li>\n<p>Automatic mount of security handlers</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_create_a_new_router_factory\"><a class=\"anchor\" href=\"#_create_a_new_router_factory\"></a>Create a new router factory</h3>\n<div class=\"paragraph\">\n<p>To create a new router factory, use method <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html#create-io.vertx.core.Vertx-java.lang.String-io.vertx.core.Handler-\">OpenAPI3RouterFactory.create</a></code>.\nAs location It accepts absolute paths, local paths and local or remote URLs (HTTP or file protocol).</p>\n</div>\n<div class=\"paragraph\">\n<p>For example to load a spec from the local filesystem:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">OpenAPI3RouterFactory.create(vertx, <span class=\"hljs-string\">\"src/main/resources/petstore.yaml\"</span>, { ar -&gt;\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Spec loaded with success</span>\n    <span class=\"hljs-keyword\">var</span> routerFactory = ar.result()\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Something went wrong during router factory initialization</span>\n    <span class=\"hljs-keyword\">var</span> exception = ar.cause()\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also construct a router factory from a remote spec:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">OpenAPI3RouterFactory.create(vertx, <span class=\"hljs-string\">\"https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml\"</span>, { ar -&gt;\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Spec loaded with success</span>\n    <span class=\"hljs-keyword\">var</span> routerFactory = ar.result()\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Something went wrong during router factory initialization</span>\n    <span class=\"hljs-keyword\">var</span> exception = ar.cause()\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or, you can also access a private remote spec by passing one or more <a href=\"https://github.com/swagger-api/swagger-parser#usage\">AuthorizationValue</a>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">Code not translatable</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also modify the behaviours of the router factory with <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html\">RouterFactoryOptions</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_mount_the_handlers\"><a class=\"anchor\" href=\"#_mount_the_handlers\"></a>Mount the handlers</h3>\n<div class=\"paragraph\">\n<p>Now load your first operation handlers.\nTo load an handler use <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html#addHandlerByOperationId-java.lang.String-io.vertx.core.Handler-\">addHandlerByOperationId</a></code>.\nTo load a failure handler use <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/openapi3/OpenAPI3RouterFactory.html#addFailureHandlerByOperationId-java.lang.String-io.vertx.core.Handler-\">addFailureHandlerByOperationId</a></code></p>\n</div>\n<div class=\"paragraph\">\n<p>You can, of course, <strong>add multiple handlers to same operation</strong>, without overwrite the existing ones.</p>\n</div>\n<div class=\"paragraph\">\n<p>For example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">routerFactory.addHandlerByOperationId(<span class=\"hljs-string\">\"awesomeOperation\"</span>, { routingContext -&gt;\n  <span class=\"hljs-keyword\">var</span> params = routingContext.<span class=\"hljs-keyword\">get</span>&lt;Any&gt;(<span class=\"hljs-string\">\"parsedParameters\"</span>)\n  <span class=\"hljs-keyword\">var</span> body = params.body()\n  <span class=\"hljs-keyword\">var</span> jsonBody = body.getJsonObject()\n  <span class=\"hljs-comment\">// Do something with body</span>\n})\nrouterFactory.addFailureHandlerByOperationId(<span class=\"hljs-string\">\"awesomeOperation\"</span>, { routingContext -&gt;\n  <span class=\"hljs-comment\">// Handle failure</span>\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Now you can use parameter values as described above</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_define_security_handlers\"><a class=\"anchor\" href=\"#_define_security_handlers\"></a>Define security handlers</h3>\n<div class=\"paragraph\">\n<p>A security handler is defined by a combination of schema name and scope. You can mount only one security handler for a combination.\nFor example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">routerFactory.addSecurityHandler(<span class=\"hljs-string\">\"security_scheme_name\"</span>, securityHandler)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can of course use included Vert.x security handlers, for example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">routerFactory.addSecurityHandler(<span class=\"hljs-string\">\"jwt_auth\"</span>, JWTAuthHandler.create(jwtAuthProvider))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you generate the <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html\">Router</a></code> the Router Factory fails if For debugging/testing purpose</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_not_implemented_error\"><a class=\"anchor\" href=\"#_not_implemented_error\"></a>Not Implemented Error</h3>\n<div class=\"paragraph\">\n<p>Router Factory automatically mounts a default handler for operations without a specified handler.\nThis default handler fails the routing context with 501 <code>Not Implemented</code> error.\nYou can enable/disable it with <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html#setMountNotImplementedHandler-boolean-\">setMountNotImplementedHandler</a></code>\nand you can customize this error handling with <code><a href=\"../../apidocs/io/vertx/ext/web/Router.html#errorHandler-int-io.vertx.core.Handler-\">errorHandler</a></code></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_response_content_type_handler\"><a class=\"anchor\" href=\"#_response_content_type_handler\"></a>Response Content Type Handler</h3>\n<div class=\"paragraph\">\n<p>Router Factory automatically mounts a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/ResponseContentTypeHandler.html\">ResponseContentTypeHandler</a></code> handler when contract requires it.\nYou can disable this feature with <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html#setMountResponseContentTypeHandler-boolean-\">setMountResponseContentTypeHandler</a></code></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_operation_model\"><a class=\"anchor\" href=\"#_operation_model\"></a>Operation model</h3>\n<div class=\"paragraph\">\n<p>If you need to access to your operation contract while handling the request,\nyou can configure the router factory to push it inside the <code>RoutingContext</code> with <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryOptions.html#setOperationModelKey-java.lang.String-\">setOperationModelKey</a></code>. For example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">// Configure the operation model key and set options in router factory</span>\noptions.operationModelKey = <span class=\"hljs-string\">\"operationPOJO\"</span>\nrouterFactory.setOptions(options)\n\n<span class=\"hljs-comment\">// Add an handler that uses the operation model</span>\nrouterFactory.addHandlerByOperationId(<span class=\"hljs-string\">\"listPets\"</span>, { routingContext -&gt;\n  <span class=\"hljs-keyword\">var</span> operation = routingContext.<span class=\"hljs-keyword\">get</span>&lt;Any&gt;(<span class=\"hljs-string\">\"operationPOJO\"</span>)\n\n  routingContext.response().setStatusCode(<span class=\"hljs-number\">200</span>).setStatusMessage(<span class=\"hljs-string\">\"OK\"</span>).end(operation.getOperationId())\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_body_handler\"><a class=\"anchor\" href=\"#_body_handler\"></a>Body Handler</h3>\n<div class=\"paragraph\">\n<p>Router Factory automatically mounts a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> to manage request bodies.\nYou can configure the instance of <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> (e.g. to change upload directory) with <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactory.html#setBodyHandler-io.vertx.ext.web.handler.BodyHandler-\">setBodyHandler</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_multipartform_data_validation\"><a class=\"anchor\" href=\"#_multipartform_data_validation\"></a><code>multipart/form-data</code> validation</h3>\n<div class=\"paragraph\">\n<p>The validation handler separates file uploads and form attributes as explained:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>If the parameter doesn&#8217;t have an encoding associated field:</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>If the parameter has <code>type: string</code> and <code>format: base64</code> or <code>format: binary</code> is a file upload with content-type <code>application/octet-stream</code></p>\n</li>\n<li>\n<p>Otherwise is a form attribute</p>\n</li>\n</ul>\n</div>\n</li>\n<li>\n<p>If the parameter has the encoding associated field is a file upload</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The form attributes are parsed and validated as other request parameters,\nwhile for file uploads the validation handler just checks the existence and the content type.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_custom_global_handlers\"><a class=\"anchor\" href=\"#_custom_global_handlers\"></a>Custom global handlers</h3>\n<div class=\"paragraph\">\n<p>If you need to mount handlers that must be executed for each operationin your router before the operation specific handlers, you can use <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactory.html#addGlobalHandler-io.vertx.core.Handler-\">addGlobalHandler</a></code></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_router_factory_handlers_mount_order\"><a class=\"anchor\" href=\"#_router_factory_handlers_mount_order\"></a>Router factory handlers mount order</h3>\n<div class=\"paragraph\">\n<p>Handlers are loaded by the router factory in this order:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Body handler</p>\n</li>\n<li>\n<p>Custom global handlers</p>\n</li>\n<li>\n<p>Global security handlers defined in upper spec level</p>\n</li>\n<li>\n<p>Operation specific security handlers</p>\n</li>\n<li>\n<p>Generated validation handler</p>\n</li>\n<li>\n<p>User handlers or \"Not implemented\" handler (if enabled)</p>\n</li>\n</ol>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_generate_the_router\"><a class=\"anchor\" href=\"#_generate_the_router\"></a>Generate the router</h3>\n<div class=\"paragraph\">\n<p>When you are ready, generate the router and use it:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">var</span> router = routerFactory.getRouter()\n\n<span class=\"hljs-keyword\">var</span> server = vertx.createHttpServer(HttpServerOptions(\n  port = <span class=\"hljs-number\">8080</span>,\n  host = <span class=\"hljs-string\">\"localhost\"</span>))\nserver.requestHandler(router).listen()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This method can fail with a <code><a href=\"../../apidocs/io/vertx/ext/web/api/contract/RouterFactoryException.html\">RouterFactoryException</a></code> if you didn&#8217;t provide the required security handlers.</p>\n</div>\n</div>\n</div>\n</div>","version":"3.9.2"},"__N_SSG":true}