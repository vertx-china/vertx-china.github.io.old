{"pageProps":{"slug":"4.0.0/vertx-sockjs-service-proxy/java","title":"Vert.x SockJS 服务代理","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_sockjs_service_proxy\">使用Vert.x SockJS 服务代理</a></li>\n<li><a href=\"#_consuming_your_service_from_a_browser_or_from_node_js\">在浏览器或者Node.js应用中调用您的服务</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x SockJS 服务代理</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当您编写一个Vert.x应用时，可能会需要在某个地方隔离一个功能，并且让这个功能在程序中的其他部分也可用。这就是服务代理的主要目的。\n服务代理能在事件总线上公开一个 <em>服务</em> ，只要知道发布服务的 <em>地址</em> ，就能在任何的Vert.x组件中使用这个服务。这就是Vert.x服务代理可以实现的功能。\n但是，Vert.x服务代理生成的客户端没办法直接在浏览器或Node.js应用中使用。\n而Vert.x SockJS服务代理生成的客户端就可以在浏览器或Node.js应用中使用。\n这些客户端依赖SockJS桥来将Vert.x事件总线中的事件传出/传入SockJS。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_sockjs_service_proxy\"><a class=\"anchor\" href=\"#_using_vert_x_sockjs_service_proxy\"></a>使用Vert.x SockJS 服务代理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>要使用Vert.x SockJS 服务代理，需要添加如下依赖</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven（在您的 <code>pom.xml</code> 文件中添加）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-sockjs-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${vertx.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle（在您的 <code>build.gradle</code> 文件中添加）：</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-sockjs-service-proxy:4.0.0'</span>\ncompile <span class=\"hljs-string\">'io.vertx:vertx-service-proxy:${vertx.version}'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>请注意！由于服务代理机制依赖于代码生成，所以对 <em>服务接口</em> 进行修改后需要先重新编译源码让代码生成器重新生成代理类代码。</p>\n</div>\n<div class=\"paragraph\">\n<p>在更进一步之前，我们建议您去查阅 <a href=\"http://vertx.io/docs/vertx-service-proxy/java\">服务代理文档</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_consuming_your_service_from_a_browser_or_from_node_js\"><a class=\"anchor\" href=\"#_consuming_your_service_from_a_browser_or_from_node_js\"></a>在浏览器或者Node.js应用中调用您的服务</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>上一节展示了如何在Java中创建服务代理。然而，您可以使用基于SockJS的代理直接在浏览器或node.js应用中调用服务。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先，您需要配置SockJS桥，让服务代理与服务进行通信。关于SockJS桥的更多详细内容请参考\n<a href=\"http://vertx.io/docs/vertx-web/java/#_sockjs_event_bus_bridge\">vertx-web</a>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-keyword\">new</span> ServiceBinder(vertx)\n  .setAddress(<span class=\"hljs-string\">\"database-service-address\"</span>)\n  .register(SomeDatabaseService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">service</span>)</span>;\n\nRouter router = Router.router(vertx);\n<span class=\"hljs-comment\">// 允许指定地址的事件通过EventBus桥输入/输出</span>\nSockJSBridgeOptions opts = <span class=\"hljs-keyword\">new</span> SockJSBridgeOptions()\n    .addInboundPermitted(<span class=\"hljs-keyword\">new</span> PermittedOptions()\n        .setAddress(<span class=\"hljs-string\">\"database-service-address\"</span>))\n    .addOutboundPermitted(<span class=\"hljs-keyword\">new</span> PermittedOptions()\n        .setAddress(<span class=\"hljs-string\">\"database-service-address\"</span>));\n\n<span class=\"hljs-comment\">// 创建EventBus桥并添加到路由中</span>\nrouter.mountSubRouter(<span class=\"hljs-string\">\"/eventbus\"</span>, SockJSHandler.create(vertx).bridge(opts));\n\nvertx.createHttpServer().requestHandler(router).listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>一旦配置了SockJS桥，使用JavaScript开发的其他程序就可以直接与您的服务进行交互。在服务编译期间，将生成一个JS代理模块，其名称如下：\n<code>module_name-js/server-interface_simple_name</code> + <code>-proxy.js</code>。 举个例子，如您的接口命名为 <code>MyService</code>，代理模块就会被命名为 <code>my_service-proxy.js</code>。\n复述一次，您可以从浏览器或node.js使用此代理模块。</p>\n</div>\n<div class=\"paragraph\">\n<p>生成的代理是一个与CommonJS，AMD和Webpack兼容的JavaScript模块。使用该代理只需EventBus桥和服务EventBus地址实例化即可。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-js\" data-lang=\"js\">&lt;script src=<span class=\"hljs-string\">\"http://cdn.sockjs.org/sockjs-0.3.4.min.js\"</span>&gt;&lt;<span class=\"hljs-regexp\">/script&gt;\n&lt;script src=\"https:/</span><span class=\"hljs-regexp\">/cdnjs.cloudflare.com/</span>ajax/libs/vertx/<span class=\"hljs-number\">3.4</span><span class=\"hljs-number\">.2</span>/vertx-eventbus.min.js<span class=\"hljs-string\">\"&gt;&lt;/script&gt;\n&lt;!-- 这是生成出来的服务代理 --&gt;\n&lt;script src=\"</span>vertx-database-js/some_database_service-proxy.js<span class=\"hljs-string\">\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  var eb = new EventBus('http://localhost:8080/eventbus');\n  eb.onopen = function () {\n    var svc = new SomeDatabaseService(eb, \"</span>database-service-address<span class=\"hljs-string\">\");\n    // 使用服务\n  };\n&lt;/script&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于node.js应用，请按照下述方式使用：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-js\" data-lang=\"js\"><span class=\"hljs-keyword\">var</span> EventBus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'vertx3-eventbus-client'</span>);\n<span class=\"hljs-keyword\">var</span> SomeDatabaseService = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../some_database_service-proxy'</span>);\n\n<span class=\"hljs-keyword\">var</span> eb = <span class=\"hljs-keyword\">new</span> EventBus(<span class=\"hljs-string\">'http://localhost:8080/eventbus/'</span>);\neb.onopen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> svc = <span class=\"hljs-keyword\">new</span> SomeDatabaseService(eb, <span class=\"hljs-string\">\"database-service-address\"</span>);\n  <span class=\"hljs-comment\">// 使用服务</span>\n};</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}