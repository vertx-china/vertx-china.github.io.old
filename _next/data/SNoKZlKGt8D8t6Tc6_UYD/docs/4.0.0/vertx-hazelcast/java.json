{"pageProps":{"slug":"4.0.0/vertx-hazelcast/java","title":"Hazelcast 集群管理器","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_this_cluster_manager\">使用集群管理器</a></li>\n<li><a href=\"#configcluster\">配置集群管理器</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_configuring_with_xml\">使用XML文件配置</a></li>\n<li><a href=\"#_configuring_programmatically\">通过编程配置</a></li>\n<li><a href=\"#_discovery_options\">发现配置</a></li>\n<li><a href=\"#_changing_local_and_public_address_with_system_properties\">通过系统配置改变本地地址及公共地址</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_an_existing_hazelcast_cluster\">使用已存在的 Hazelcast 集群</a></li>\n<li><a href=\"#_changing_timeout_for_failed_nodes\">修改故障节点的超时配置</a></li>\n<li><a href=\"#_trouble_shooting_clustering\">集群故障排除</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_multicast_not_enabled_on_the_machine\">机器禁用组播</a></li>\n<li><a href=\"#_using_wrong_network_interface\">使用错误的网络接口</a></li>\n<li><a href=\"#_using_a_vpn\">使用VPN</a></li>\n<li><a href=\"#_when_multicast_is_not_available\">组播不可用</a></li>\n<li><a href=\"#_enabling_logging\">开启日志</a></li>\n</ul>\n</li>\n<li><a href=\"#_hazelcast_logging\">Hazelcast 日志配置</a></li>\n<li><a href=\"#_using_a_different_hazelcast_version\">使用其他 Hazelcast 版本</a></li>\n<li><a href=\"#_configuring_for_kubernetes\">配置 Kubernetes</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_rolling_updates\">滚动更新</a></li>\n</ul>\n</li>\n<li><a href=\"#_cluster_administration\">集群管理</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_partitioning\">分区数据</a></li>\n<li><a href=\"#_split_brain_syndrome\">脑裂</a></li>\n<li><a href=\"#_recommendations\">建议</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Hazelcast 集群管理器</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x 基于 <a href=\"https://hazelcast.com\">Hazelcast</a> 实现了一个集群管理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是 Vert.x CLI默认的集群管理器。由于 Vert.x 集群管理器的可插拔性，可轻易切换至其它的集群管理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个集群管理器由以下依赖引入：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-hazelcast<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 集群管理器包含以下几项功能：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>发现并管理集群中的节点</p>\n</li>\n<li>\n<p>管理集群的 EventBus 地址订阅清单（这样就可以轻松得知集群中的哪些节点订阅了哪些 EventBus 地址）</p>\n</li>\n<li>\n<p>分布式 Map 支持</p>\n</li>\n<li>\n<p>分布式锁</p>\n</li>\n<li>\n<p>分布式计数器</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x 集群器 <strong>并不</strong> 处理节点之间的通信。在 Vert.x 中，集群节点间通信是直接由 TCP 连接处理的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_this_cluster_manager\"><a class=\"anchor\" href=\"#_using_this_cluster_manager\"></a>使用集群管理器</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果通过命令行来使用 Vert.x，对应集群管理器的 <code>jar</code> 包（名为 <code>vertx-hazelcast-4.0.0.jar</code> ）\n应该在 Vert.x 中安装路径的 <code>lib</code> 目录中。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果在 Maven 或者 Gradle 工程中使用 Vert.x， 只需要在工程依赖中加上依赖：\n<code>io.vertx:vertx-hazelcast:4.0.0</code>。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果（集群管理器的）jar 包在 classpath 中，Vert.x将自动检测到并将其作为集群管理器。\n需要注意的是，要确保 Vert.x 的 classpath 中没有其它的集群管理器实现，\n否则会使用错误的集群管理器。</p>\n</div>\n<div class=\"paragraph\">\n<p>编程内嵌 Vert.x 时，可以在创建 Vert.x 实例时，\n通过编程的方式显式配置 Vert.x 集群管理器，例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ClusterManager mgr = <span class=\"hljs-keyword\">new</span> HazelcastClusterManager();\n\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions().setClusterManager(mgr);\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 失败</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"configcluster\"><a class=\"anchor\" href=\"#configcluster\"></a>配置集群管理器</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_configuring_with_xml\"><a class=\"anchor\" href=\"#_configuring_with_xml\"></a>使用XML文件配置</h3>\n<div class=\"paragraph\">\n<p>通常情况下，集群管理器的相关配置默认是通过打包在jar中的配置文件\n<a href=\"https://github.com/vert-x3/vertx-hazelcast/blob/master/src/main/resources/default-cluster.xml\"><code>default-cluster.xml</code></a>\n配置的。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果要覆盖此配置，可以在 classpath 中添加一个 <code>cluster.xml</code> 文件。如果想在 fat jar 中内嵌 <code>cluster.xml</code> ，此文件必须在 fat jar 的根目录中。如果此文件是一个外部文件，则必须将其所在的 <strong>目录</strong> 添加至 classpath 中。举个例子，如果使用 Vert.x 的 <em>launcher</em> 启动应用，则 classpath 应该设置为：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code># 如果 cluster.xml 在当前目录：\njava -jar ... -cp . -cluster\nvertx run MyVerticle -cp . -cluster\n\n# 如果 cluster.xml 在 conf 目录：\njava -jar ... -cp conf -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>还可以通过配置系统属性 <code>vertx.hazelcast.config</code>\n来覆盖默认的配置文件：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code># 指定一个外部文件为自定义配置文件\njava -Dvertx.hazelcast.config=./config/my-cluster-config.xml -jar ... -cluster\n\n# 从 classpath 中加载一个文件为自定义配置文件\njava -Dvertx.hazelcast.config=classpath:my/package/config/my-cluster-config.xml -jar ... -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>如果 <code>vertx.hazelcast.config</code> 值不为空时，将用其覆盖 classpath 中所有的 <code>cluster.xml</code> 文件；\n但是如果加载 <code>vertx.hazelcast.config</code> 系统配置失败时，\n系统将选取 classpath 任意一个 <code>cluster.xml</code> ，甚至直接使用默认配置。</p>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\nVert.x 并不支持 <code>-Dhazelcast.config</code> 设置方式，\n请不要使用。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>这里的 xml 是 Hazelcast 的配置文件， 可以在 Hazelcast 官网找到详细的配置文档。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_programmatically\"><a class=\"anchor\" href=\"#_configuring_programmatically\"></a>通过编程配置</h3>\n<div class=\"paragraph\">\n<p>您也可以通过编程的形式配置集群管理器：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Config hazelcastConfig = <span class=\"hljs-keyword\">new</span> Config();\n\n<span class=\"hljs-comment\">// 设置相关的hazlcast配置，在这里省略掉，不再赘述</span>\n\nClusterManager mgr = <span class=\"hljs-keyword\">new</span> HazelcastClusterManager(hazelcastConfig);\n\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions().setClusterManager(mgr);\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 失败！</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您也可以对已存在的XML配置进行修改。\n比如修改集群名：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Config hazelcastConfig = ConfigUtil.loadConfig();\n\nhazelcastConfig.setClusterName(<span class=\"hljs-string\">\"my-cluster-name\"</span>);\n\nClusterManager mgr = <span class=\"hljs-keyword\">new</span> HazelcastClusterManager(hazelcastConfig);\n\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions().setClusterManager(mgr);\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 失败！</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code>ConfigUtil#loadConfig</code> 方法会加载 Hazelcast 的XML配置文件，并将其转换为 <code>Config</code> 对象。\n读取的XML配置文件来自：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><code>vertx.hazelcast.config</code> 系统配置指定的文件，若不存在则</p>\n</li>\n<li>\n<p>classpath 内的 <code>cluster.xml</code> 文件，若不存在则</p>\n</li>\n<li>\n<p>默认的配置文件</p>\n</li>\n</ol>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_discovery_options\"><a class=\"anchor\" href=\"#_discovery_options\"></a>发现配置</h3>\n<div class=\"paragraph\">\n<p>Hazelcast 支持几种不同的发现配置。\nHazelcast 默认配置使用多播，因此您必须在网络上启用多播才能正常工作。</p>\n</div>\n<div class=\"paragraph\">\n<p>关于如何配置不同的发现方式，请查阅 Hazelcast 文档。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_changing_local_and_public_address_with_system_properties\"><a class=\"anchor\" href=\"#_changing_local_and_public_address_with_system_properties\"></a>通过系统配置改变本地地址及公共地址</h3>\n<div class=\"paragraph\">\n<p>有时，集群节点必须绑定到其他集群成员无法访问的地址。\n例如，节点不在同一网络区域中，或在某些具有特定防火墙配置的云服务中时，可能会发生这种情况。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以使用以下系统属性设置绑定的本地地址和公共地址（向其他成员发布的地址）：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Dhazelcast.local.localAddress=172.16.5.131 -Dhazelcast.local.publicAddress=104.198.78.81</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_an_existing_hazelcast_cluster\"><a class=\"anchor\" href=\"#_using_an_existing_hazelcast_cluster\"></a>使用已存在的 Hazelcast 集群</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>可以向集群管理器传入 <code>HazelcastInstance</code> 来复用现有集群：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ClusterManager mgr = <span class=\"hljs-keyword\">new</span> HazelcastClusterManager(hazelcastInstance);\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions().setClusterManager(mgr);\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 失败！</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>在这种情况下，Vert.x不是 Hazelcast 集群的所有者，所以不要关闭 Vert.x 时关闭 Hazlecast 集群。</p>\n</div>\n<div class=\"paragraph\">\n<p>请注意，自定义 Hazelcast 实例需要以下配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">multimap</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__vertx.subs\"</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">backup-count</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">backup-count</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value-collection-type</span>&gt;</span>SET<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">value-collection-type</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">multimap</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">map</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__vertx.haInfo\"</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">backup-count</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">backup-count</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">map</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">map</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__vertx.nodeInfo\"</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">backup-count</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">backup-count</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">map</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cp-subsystem</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cp-member-count</span>&gt;</span>0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">cp-member-count</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">semaphores</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">semaphore</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>__vertx.*<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">jdk-compatible</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">jdk-compatible</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">initial-permits</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">initial-permits</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">semaphore</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">semaphores</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">cp-subsystem</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n不支持 Hazelcast 客户端及智能客户端。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n要确保 Hazelcast 集群 先于 Vert.x 集群启动，后于 Vert.x 集群关闭。\n同时需要禁用 <code>shutdown hook</code> （参考上述的 xml 配置，或通过系统变量来实现）。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_changing_timeout_for_failed_nodes\"><a class=\"anchor\" href=\"#_changing_timeout_for_failed_nodes\"></a>修改故障节点的超时配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>缺省情况下，Hazelcast 会移除集群中超过300秒没收到心跳的节点。\n通过系统配置 <code>hazelcast.max.no.heartbeat.seconds</code> 可以修改这个超时时间，如:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Dhazelcast.max.no.heartbeat.seconds=5</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>修改后，超过5秒没发出心跳的节点会被移出集群。</p>\n</div>\n<div class=\"paragraph\">\n<p>请参考 <a href=\"https://docs.hazelcast.org/docs/latest/manual/html-single/#system-properties\">Hazelcast 系统配置</a> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_trouble_shooting_clustering\"><a class=\"anchor\" href=\"#_trouble_shooting_clustering\"></a>集群故障排除</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>如果默认的组播配置不能正常运行，通常有以下原因：</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_multicast_not_enabled_on_the_machine\"><a class=\"anchor\" href=\"#_multicast_not_enabled_on_the_machine\"></a>机器禁用组播</h3>\n<div class=\"paragraph\">\n<p>通常来说，OSX 默认禁用组播。\n请自行Google一下如何启用组播。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_wrong_network_interface\"><a class=\"anchor\" href=\"#_using_wrong_network_interface\"></a>使用错误的网络接口</h3>\n<div class=\"paragraph\">\n<p>如果机器上有多个网络接口（也有可能是在运行 VPN 的情况下），\n那么 Hazelcast 很有可能使用错误的网络接口。</p>\n</div>\n<div class=\"paragraph\">\n<p>为了确保 Hazelcast 使用正确的网络接口，在配置文件中将 <code>interface</code> 设置为指定IP地址。\n同时确保 <code>enabled</code> 属性设置为 <code>true</code> 。例如：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>&lt;interfaces enabled=\"true\"&gt;\n &lt;interface&gt;192.168.1.20&lt;/interface&gt;\n&lt;/interfaces&gt;</pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_a_vpn\"><a class=\"anchor\" href=\"#_using_a_vpn\"></a>使用VPN</h3>\n<div class=\"paragraph\">\n<p>VPN 软件工作时通常会创建虚拟网络接口，但往往不支持组播。\n在 VPN 环境中，如果 Hazelcast 与 Vert.x 没有配置正确的话，\n将会选择 VPN 创建的网络接口，而不是正确的网络接口。</p>\n</div>\n<div class=\"paragraph\">\n<p>所以，如果您的应用运行在 VPN 环境中，请参考上述章节，\n设置正确的网络接口。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_when_multicast_is_not_available\"><a class=\"anchor\" href=\"#_when_multicast_is_not_available\"></a>组播不可用</h3>\n<div class=\"paragraph\">\n<p>在某些情况下，因为特殊的运行环境，可能无法使用组播。\n在这种情况下，应该配置其他网络传输，例如使用 TCP 套接字，或在亚马逊云 EC2 上使用AWS。</p>\n</div>\n<div class=\"paragraph\">\n<p>有关 Hazelcast 更多传输方式，以及如何配置它们，\n请查询 Hazelcast 文档。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_enabling_logging\"><a class=\"anchor\" href=\"#_enabling_logging\"></a>开启日志</h3>\n<div class=\"paragraph\">\n<p>在排除故障时，开启 Hazelcast 日志很有帮助，可以观察是否组成了集群。\n使用默认的 JUL 日志时，在 classpath 中添加 <code>vertx-default-jul-logging.properties</code> 文件可开启 Hazelcast 日志。\n这是一个标准 java.util.logging（JUL） 配置文件。\n具体配置如下：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>com.hazelcast.level=INFO</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>以及</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>java.util.logging.ConsoleHandler.level=INFO\njava.util.logging.FileHandler.level=INFO</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_hazelcast_logging\"><a class=\"anchor\" href=\"#_hazelcast_logging\"></a>Hazelcast 日志配置</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Hazelcast 的日志默认采用 <code>JDK</code> 的实现（即 JUL）。\n如果想切换至其他日志库，通过设置系统配置 <code>hazelcast.logging.type</code> 即可：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>-Dhazelcast.logging.type=slf4j</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>详细文档请参考 <a href=\"http://docs.hazelcast.org/docs/3.6.1/manual/html-single/index.html#logging-configuration\">hazelcast 文档</a> 。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_a_different_hazelcast_version\"><a class=\"anchor\" href=\"#_using_a_different_hazelcast_version\"></a>使用其他 Hazelcast 版本</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>当前的 Vert.x HazelcastClusterManager 使用的 Hazelcast 版本为 <code>4.0.2</code> 。\n如果开发者想使用其他版本的 Hazelcast，需要做以下工作：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>将目标版本的 Hazelcast 依赖添加至 classpath 中</p>\n</li>\n<li>\n<p>如果是 fat jar 的形式，在构建工具中使用正确的版本</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>使用 Maven 时可参考下面代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.hazelcast<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>hazelcast<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>ENTER_YOUR_VERSION_HERE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-hazelcast<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>对于某些版本，您可能需要排除掉一些（冲突的）依赖。</p>\n</div>\n<div class=\"paragraph\">\n<p>对于 Gradle 可以使用下面代码:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>dependencies {\ncompile (\"io.vertx:vertx-hazelcast:4.0.0\"){\n  exclude group: 'com.hazelcast', module: 'hazelcast'\n}\ncompile \"com.hazelcast:hazelcast:ENTER_YOUR_VERSION_HERE\"\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_for_kubernetes\"><a class=\"anchor\" href=\"#_configuring_for_kubernetes\"></a>配置 Kubernetes</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Kubernetes 上的 Hazelcast 要配置为使用 <a href=\"https://github.com/hazelcast/hazelcast-kubernetes\">Hazelcast Kubernetes</a> 插件。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先在项目中增加依赖： <code>io.vertx:vertx-hazelcast:${vertx.version}</code> 和 <code>com.hazelcast:hazelcast-kubernetes:${hazelcast-kubernetes.version}</code> 。\n对于 Maven，参考下面代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-hazelcast<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${vertx.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.hazelcast<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>hazelcast-kubernetes<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${hazelcast-kubernetes.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n如果你使用了其他版本的 Hazelcast core 依赖，请确保兼容 Kubernetes discovery 插件。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>然后在 Hazelcast 配置中配置 Kubernetes discovery 插件，可以通过自定义的 <code>cluster.xml</code> 文件进行配置，或通过编程方式配置（参考 <a href=\"#configcluster\">配置集群管理器</a>）。</p>\n</div>\n<div class=\"paragraph\">\n<p>Kubernetes discovery 插件提供了两种可选的 <a href=\"https://github.com/hazelcast/hazelcast-kubernetes#understanding-discovery-modes\">发现模式</a>： <em>Kubernetes API</em> 和 <em>DNS Lookup</em> 。\n关于这两种模式的利弊，请参阅该插件的项目网站。</p>\n</div>\n<div class=\"paragraph\">\n<p>在本文中，我们使用 <em>DNS Lookup</em> 发现模式。请修改/增加以下的配置：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">hazelcast</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"hazelcast.discovery.enabled\"</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span> <b class=\"conum\">(1)</b>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">network</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">join</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">multicast</span> <span class=\"hljs-attr\">enabled</span>=<span class=\"hljs-string\">\"false\"</span>/&gt;</span> <b class=\"conum\">(2)</b>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tcp-ip</span> <span class=\"hljs-attr\">enabled</span>=<span class=\"hljs-string\">\"false\"</span> /&gt;</span>\n\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">discovery-strategies</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">discovery-strategy</span> <span class=\"hljs-attr\">enabled</span>=<span class=\"hljs-string\">\"true\"</span>&gt;</span> <b class=\"conum\">(3)</b>\n           class=\"com.hazelcast.kubernetes.HazelcastKubernetesDiscoveryStrategy\"&gt;\n         <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"service-dns\"</span>&gt;</span>MY-SERVICE-DNS-NAME<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span> <b class=\"conum\">(4)</b>\n         <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">discovery-strategy</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">discovery-strategies</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">join</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">network</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">hazelcast</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>启用 Discovery SPI</p>\n</li>\n<li>\n<p>停用其他发现模式</p>\n</li>\n<li>\n<p>启用 Kubernetes 插件</p>\n</li>\n<li>\n<p>服务DNS，通常以 <code>MY-SERVICE-NAME.MY-NAMESPACE.svc.cluster.local</code> 的形式出现，视乎 Kubernetes 的分布配置</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p><code>MY-SERVICE-DNS-NAME</code> 的取值必须是 Kubernetes 的一个 <strong>无头</strong> 服务（Headless Services），Hazelcast 将用其识别所有集群成员节点。\n无头服务的创建配置可参考下面代码：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-yaml\" data-lang=\"yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Service</span>\n<span class=\"hljs-attr\">metadata:</span>\n <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">MY-NAMESPACE</span>\n <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">MY-SERVICE-NAME</span>\n<span class=\"hljs-attr\">spec:</span>\n <span class=\"hljs-attr\">selector:</span>\n   <span class=\"hljs-attr\">component:</span> <span class=\"hljs-string\">MY-SERVICE-NAME</span> <b class=\"conum\">(1)</b>\n <span class=\"hljs-attr\">clusterIP:</span> <span class=\"hljs-string\">None</span>\n <span class=\"hljs-attr\">ports:</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">hz-port-name</span>\n   <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">5701</span>\n   <span class=\"hljs-attr\">protocol:</span> <span class=\"hljs-string\">TCP</span></code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>按标签选择的集群成员</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>最终，属于集群的所有 Kubernetes 部署需要追加 <code>component</code> 标签：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-yaml\" data-lang=\"yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">extensions/v1beta1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Deployment</span>\n<span class=\"hljs-attr\">metadata:</span>\n <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">MY-NAMESPACE</span>\n<span class=\"hljs-attr\">spec:</span>\n <span class=\"hljs-attr\">template:</span>\n   <span class=\"hljs-attr\">metadata:</span>\n     <span class=\"hljs-attr\">labels:</span>\n       <span class=\"hljs-attr\">component:</span> <span class=\"hljs-string\">MY-SERVICE-NAME</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>更多关于配置的详情请参考 <a href=\"https://github.com/hazelcast/hazelcast-kubernetes\">Hazelcast Kubernetes 插件页面</a>。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rolling_updates\"><a class=\"anchor\" href=\"#_rolling_updates\"></a>滚动更新</h3>\n<div class=\"paragraph\">\n<p>在滚动更新期间，建议逐一更换 Pod。</p>\n</div>\n<div class=\"paragraph\">\n<p>为此，我们必须将 Kubernetes 配置为：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>不要同时启动多个新 Pod</p>\n</li>\n<li>\n<p>在滚动更新过程中，不可用的 Pod 不能多于一个</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-yaml\" data-lang=\"yaml\"><span class=\"hljs-attr\">spec:</span>\n <span class=\"hljs-attr\">strategy:</span>\n   <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">Rolling</span>\n   <span class=\"hljs-attr\">rollingParams:</span>\n     <span class=\"hljs-attr\">updatePeriodSeconds:</span> <span class=\"hljs-number\">10</span>\n     <span class=\"hljs-attr\">intervalSeconds:</span> <span class=\"hljs-number\">20</span>\n     <span class=\"hljs-attr\">timeoutSeconds:</span> <span class=\"hljs-number\">600</span>\n     <span class=\"hljs-attr\">maxUnavailable:</span> <span class=\"hljs-number\">1</span> <b class=\"conum\">(1)</b>\n     <span class=\"hljs-attr\">maxSurge:</span> <span class=\"hljs-number\">1</span> <b class=\"conum\">(2)</b></code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>在升级过程中允许 不可用的最大 Pod 数</p>\n</li>\n<li>\n<p>允许超过预期创建数量的最大 Pod 数（译者注：即，实际创建的 Pod 数量 ≤ 预期 Pod 数量 + maxSurge）</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>同样地，Pod 的准备情况探针（readiness probe）必须考虑集群状态。\n请参阅 <a href=\"#one-by-one\">集群管理</a> 章节，了解如何使用 <a href=\"../../vertx-health-check/java/\">Vert.x 健康检查</a> 实现准备情况探针。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cluster_administration\"><a class=\"anchor\" href=\"#_cluster_administration\"></a>集群管理</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Hazelcast 集群管理器的工作原理是将 Vert.x 节点作为 Hazelcast 集群的成员。\n因此，Vert.x 使用 Hazelcast 集群管理器时，应遵循 Hazelcast 的管理准则。</p>\n</div>\n<div class=\"paragraph\">\n<p>首先介绍下分区数据和脑裂。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_data_partitioning\"><a class=\"anchor\" href=\"#_data_partitioning\"></a>分区数据</h3>\n<div class=\"paragraph\">\n<p>每个 Vert.x 节点都包含部分集群数据，包括：EventBus 订阅，异步 Map，分布式计数器等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>当有节点加入或离开集群时，Hazelcast 会迁移分区数据。\n换句话说，它可以移动数据以适应新的集群拓扑。\n此过程可能需要一些时间，具体取决于集群数据量和节点数量。</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_split_brain_syndrome\"><a class=\"anchor\" href=\"#_split_brain_syndrome\"></a>脑裂</h3>\n<div class=\"paragraph\">\n<p>在理想环境中，不会出现网络设备故障。\n实际上，集群早晚会被分成多个小组，彼此之间不可见。</p>\n</div>\n<div class=\"paragraph\">\n<p>Hazelcast 能够将节点合并回单个集群。\n但是，就像数据分区迁移一样，此过程可能需要一些时间。\n在集群变回可用之前，某些 EventBus 的消费者可能无法获取到消息。\n否则，重新部署故障的 Verticle 过程中无法保证高可用。</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>很难（或者说基本不可能）区分脑裂和:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>长时间的GC暂停 （导致错过了心跳检查），</p>\n</li>\n<li>\n<p>部署新版本应用时，同时强制关闭了很多节点</p>\n</li>\n</ul>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_recommendations\"><a class=\"anchor\" href=\"#_recommendations\"></a>建议</h3>\n<div class=\"paragraph\">\n<p>考虑到上面讨论的常见集群问题，建议遵循下述的最佳实践。</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_graceful_shutdown\"><a class=\"anchor\" href=\"#_graceful_shutdown\"></a>优雅地关闭</h4>\n<div class=\"paragraph\">\n<p>应该避免强行停止集群成员节点（例如，对节点进程使用 <code>kill -9</code> ）。</p>\n</div>\n<div class=\"paragraph\">\n<p>当然，进程崩溃是不可避免的，但是优雅地关闭进程有助于其余节点更快地恢复稳定状态。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"one-by-one\"><a class=\"anchor\" href=\"#one-by-one\"></a>逐个添加或移除节点</h4>\n<div class=\"paragraph\">\n<p>滚动更新新版本应用时，或扩大/缩小集群时，应该一个接一个地添加或移除节点。</p>\n</div>\n<div class=\"paragraph\">\n<p>逐个停止节点可避免集群误以为发生了脑裂。\n逐个添加节点可以进行干净的增量数据分区迁移。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以使用 <a href=\"../../vertx-health-check/java/\">Vert.x 运行状况检查</a> 来验证集群安全性：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Handler&lt;Promise&lt;Status&gt;&gt; procedure = ClusterHealthCheck.createProcedure(vertx);\nHealthChecks checks = HealthChecks.create(vertx).register(<span class=\"hljs-string\">\"cluster-health\"</span>, procedure);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>完成集群创建后，可以通过 <a href=\"../../vertx-web/java/\">Vert.x Web</a> 路由 Handler 编写的HTTP程序进行健康检查：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Router router = Router.router(vertx);\nrouter.get(<span class=\"hljs-string\">\"/readiness\"</span>).handler(HealthCheckHandler.createWithHealthChecks(checks));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_lite_members\"><a class=\"anchor\" href=\"#_using_lite_members\"></a>使用轻量级成员（Lite Members）</h4>\n<div class=\"paragraph\">\n<p>为了尽量减少 Vert.x 集群适应新拓扑的时间，您可以使用外部数据节点，并将 Vert.x 节点标记为 <a href=\"https://docs.hazelcast.org/docs/latest/manual/html-single/#enabling-lite-members\"><em>轻量级成员</em></a>。</p>\n</div>\n<div class=\"paragraph\">\n<p><em>轻量级成员</em> 像普通成员一样加入 Hazelcast 集群，但是他们不拥有任何数据分区。\n因此，添加或删除此类成员时，Hazelcast 不需要迁移数据分区。</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">重要</div>\n</td>\n<td class=\"content\">\n您必须事先启动外部数据节点，因为 Hazelcast 不会只使用 <em>轻量级成员</em> 节点创建集群。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>启动外部数据节点可以使用 Hazelcast 分发启动脚本，或以编程方式进行。</p>\n</div>\n<div class=\"paragraph\">\n<p>可以在XML配置中将Vert.x节点标记为 <em>轻量级成员</em> 节点：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">lite-member</span> <span class=\"hljs-attr\">enabled</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>还可以通过编程实现：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Config hazelcastConfig = ConfigUtil.loadConfig()\n  .setLiteMember(<span class=\"hljs-keyword\">true</span>);\n\nClusterManager mgr = <span class=\"hljs-keyword\">new</span> HazelcastClusterManager(hazelcastConfig);\n\nVertxOptions options = <span class=\"hljs-keyword\">new</span> VertxOptions().setClusterManager(mgr);\n\nVertx.clusteredVertx(options, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    Vertx vertx = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// failed!</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.0.0"},"__N_SSG":true}