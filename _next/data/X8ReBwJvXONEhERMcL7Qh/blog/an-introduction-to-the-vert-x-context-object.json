{"pageProps":{"categories":["releases","guides","security","news"],"post":{"meta":{"title":"An Introduction to the Vert.x Context Object","category":"guides","authors":[{"name":"Jez Prime","github_id":"millross"}],"summary":"Under the hood, the vert.x Context class plays a critical part in maintaining the thread-safety guarantees of verticles. Most of the time, vert.x coders don't need to make use of Context objects directly."},"date":"2017-01-31","slug":"an-introduction-to-the-vert-x-context-object","readingTime":{"text":"6 min read","minutes":5.915,"time":354900,"words":1183},"content":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      h2: \"h2\",\n      img: \"img\",\n      h3: \"h3\",\n      pre: \"pre\",\n      code: \"code\",\n      span: \"span\"\n    }, props.components), {Alert, Link} = _components;\n    if (!Alert) _missingMdxReference(\"Alert\", true);\n    if (!Link) _missingMdxReference(\"Link\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Under the hood, the vert.x Con­text class plays a crit­i­cal part in main­tain­ing the thread-​safety guar­an­tees of ver­ti­cles. Most of the time, vert.x coders don’t need to make use of Con­text ob­jects di­rectly. How­ever, some­times you may need to. This ar­ti­cle pro­vides a brief in­tro­duc­tion to the vert.x Con­text class, which cov­ers why it’s im­por­tant, and why and when you might wish to make use of the Con­text di­rectly, based on the au­thor’s ex­pe­ri­ence of build­ing a generic async li­brary which can be used with vert.x.\"\n      }), \"\\n\", _jsx(Alert, {\n        info: true,\n        children: _jsxs(_components.p, {\n          children: [\"This is a re-​publication of the fol­low­ing \", _jsx(_components.a, {\n            href: \"http://www.millross-consultants.com/vertx_context_object.html\",\n            children: \"blog post\"\n          })]\n        })\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"introduction\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#introduction\"\n        }), \"Introduction\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Re­cently I’ve been look­ing at the pos­si­bil­ity of build­ing an asyn­chro­nous ver­sion of the \", _jsx(_components.a, {\n          href: \"http://www.pac4j.org\",\n          children: \"pac4j\"\n        }), \" li­brary, with a view to then mi­grat­ing the \", _jsx(_components.a, {\n          href: \"https://github.com/pac4j/vertx-pac4j\",\n          children: \"vertx-​pac4j\"\n        }), \" im­ple­men­ta­tion to use the asyn­chro­nous ver­sion of pac4j by de­fault.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I’m keen (for ob­vi­ous rea­sons) that the async ver­sion of pac4j is not tightly cou­pled to  one par­tic­u­lar asyn­chro­nous/non-​blocking frame­work, I de­cided to ex­pose the API via the \", _jsx(_components.a, {\n          href: \"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\",\n          children: \"Com­pletable­Fu­ture\"\n        }), \" class, using this to wrap val­ues which will be de­ter­mined in the fu­ture. How­ever, I opted to use the \", _jsx(Link, {\n          href: \"/\",\n          passHref: true,\n          children: _jsx(_components.a, {\n            href: \"\",\n            children: \"vert.x\"\n          })\n        }), \" frame­work for my asyn­chro­nous test­ing as a way of test­ing the API as it emerged. This in turn has led me to learn some as­pects of the vert.x \", _jsx(Link, {\n          href: \"/docs/apidocs/io/vertx/core/Context.html\",\n          passHref: true,\n          children: _jsx(_components.a, {\n            href: \"\",\n            children: \"Con­text\"\n          })\n        }), \" class which I didn’t re­ally un­der­stand be­fore.\"]\n      }), \"\\n\", _jsx(Alert, {\n        info: true,\n        children: _jsx(_components.p, {\n          children: \"The in­for­ma­tion pre­sented re­lates to Vert.x ver­sion 3.3.3. It is con­ceiv­able that later ver­sions of vert.x could ren­der as­pects of this ar­ti­cle in­cor­rect.\"\n        })\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"introduction-to-the-context-class\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#introduction-to-the-context-class\"\n        }), \"Introduction to the Context class\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"When­ever a vert.x \", _jsx(Link, {\n          href: \"/docs/apidocs/io/vertx/core/Handler.html\",\n          passHref: true,\n          children: _jsx(_components.a, {\n            href: \"\",\n            children: \"Han­dler\"\n          })\n        }), \" is ex­e­cuted, or the start or step method of a ver­ti­cle is called, then that ex­e­cu­tion is as­so­ci­ated with a spe­cific con­text. Gen­er­ally a con­text is an event-​loop con­text and is there­fore as­so­ci­ated with an event loop thread (ex­cep­tions are cov­ered in the Fur­ther Read­ing ref­er­enced below). Con­texts are prop­a­gated. When a han­dler is set by code run­ning on a spe­cific con­text, then that han­dler will also be ex­e­cuted on the same con­text. This means for ex­am­ple, that if the start method of a ver­ti­cle in­stance sets a num­ber of event bus han­dlers (as many do), then they will all run on the same con­text as the start method for that ver­ti­cle (so all han­dlers for that ver­ti­cle in­stance will share a com­mon con­text).\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"A schematic of the re­la­tion­ships be­tween non-​worker ver­ti­cles, con­texts and event­loop threads is shown in Fig­ure 1.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/images/blog/vertx3-intro-to-context-object/VertxContextRelationships.png\",\n          alt: \"Vertx Context/Thread/Verticle Relationships\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Note that each ver­ti­cle ef­fec­tively has only one con­text for han­dlers cre­ated by its start method, and each con­text is bound to a sin­gle event-​loop thread. A given event-​loop thread can, how­ever, have mul­ti­ple con­texts bound to it.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"when-are-contexts-not-propagated\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#when-are-contexts-not-propagated\"\n        }), \"When are contexts not propagated?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When a ver­ti­cle’s start method is called, a new con­text is cre­ated. If 4 iden­ti­cal ver­ti­cles are de­ployed via the in­stances pa­ra­me­ter on De­ploy­men­tOp­tions, the start method of each will be on a new con­text. This is log­i­cal as we may not want all non-​worker ver­ti­cles to be bound to a sin­gle event­loop thread when mul­ti­ple event­loop threads are avail­able.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"threading-guarantees\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#threading-guarantees\"\n        }), \"Threading Guarantees\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There are cer­tain con­se­quences of the prop­a­ga­tion of con­texts to han­dlers as men­tioned above. The most im­por­tant one is that since all han­dlers in a given event­loop ver­ti­cle run on the same con­text (the one on which its start method ran), they all run on the same event­loop thread. This gives rise to the thread­ing guar­an­tee within vert.x, that as long as a given ver­ti­cle is the only one to ever ac­cess a piece of state, then that state is being ac­cessed by only one thread, so no syn­chro­niza­tion will be nec­es­sary.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"exception-handling\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#exception-handling\"\n        }), \"Exception Handling\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Each con­text can have its own ex­cep­tion han­dler at­tached for han­dling ex­cep­tions which occur dur­ing event loop pro­cess­ing.\"\n      }), \"\\n\", _jsxs(_components.h3, {\n        id: \"why-might-you-not-want-the-default-exception-handler\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#why-might-you-not-want-the-default-exception-handler\"\n        }), \"Why might you not want the default exception handler?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"As one ex­am­ple, you might have some ver­ti­cles run­ning whose job it is to mon­i­tor other ver­ti­cles, and if some­thing ap­pears to go wrong with them, un­de­ploy and restart them, a fre­quent pat­tern in an actor-​ or microservices-​ style archic­tec­ture. So one op­tion could be that when a su­per­vised ver­ti­cle en­coun­ters an un­re­cov­er­able error, it could sim­ply no­tify its su­per­vi­sor that it has gone wrong via an event­bus mes­sage, and its su­per­vi­sor could then un­de­ploy and re­de­ploy (and after a num­ber of fail­ures in rapid suc­ces­sion pos­si­bly give up hope or es­ca­late to its own su­per­vi­sor.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"going-off-context-and-getting-back-onto-a-particular-context\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#going-off-context-and-getting-back-onto-a-particular-context\"\n        }), \"Going off-context and getting back onto a particular context\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There are sev­eral rea­sons why you might ex­e­cute code off-​context and then want to op­er­ate back on a vert.x con­text when com­plete. I’ll out­line a cou­ple of sce­nar­ios below\"\n      }), \"\\n\", _jsxs(_components.h3, {\n        id: \"running-code-on-a-separate-thread\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#running-code-on-a-separate-thread\"\n        }), \"Running code on a separate thread\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Firstly you might be using an asyn­chro­nous dri­ver which is en­tirely vertx-​unaware. Its code will run on non-​eventloop threads but it’s pos­si­ble you may then want to use the re­sults of that code to up­date in­for­ma­tion within your ver­ti­cle. If you don’t get back onto the cor­rect con­text, you can’t make any guar­an­tees about thread-​safety, so your sub­se­quent pro­cess­ing needs to be run back on the cor­rect event­loop thread.\"\n      }), \"\\n\", _jsxs(_components.h3, {\n        id: \"using-asynchronous-java-8-apis\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#using-asynchronous-java-8-apis\"\n        }), \"Using asynchronous Java 8 APIs\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"APIs such as Com­pletable­Fu­ture are context-​unaware. In one ex­am­ple, I cre­ated an al­ready com­pleted fu­ture on the vert.x event loop in a test. I then at­tached sub­se­quent pro­cess­ing to it via then run:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@RunWith(VertxUnitRunner.class)\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"ImmediateCompletionTest\"\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Rule\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"RunTestOnContext\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"rule\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"RunTestOnContext\"\n          }), \"();\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Test\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"testImmediateCompletion\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(TestContext context)\"\n          }), \" {\\n\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" context.async();\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Vertx\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"vertx\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" rule.vertx();\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" CompletableFuture<Integer> toComplete = \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"CompletableFuture\"\n          }), \"<>();\\n        \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// delay future completion by 500 ms\"\n          }), \"\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"String\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"threadName\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" Thread.currentThread().getName();\\n        toComplete.complete(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"100\"\n          }), \");\\n        toComplete.thenRun(() -> {\\n            assertThat(Thread.currentThread().getName(), is(threadName));\\n            async.complete();\\n        });\\n    }\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Naively one might ex­pect this to au­to­mat­i­cally run on the con­text, since it hasn’t left the event­loop thread on which the fu­ture was com­pleted, and in­deed it’s prov­able that it is on the cor­rect thread. How­ever, it will not be on the cor­rect con­text. This would mean that it wouldn’t, for ex­am­ple, in­voke any mod­i­fied ex­cep­tion han­dler at­tached to the con­text.\"\n      }), \"\\n\", _jsxs(_components.h3, {\n        id: \"getting-back-on-context\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#getting-back-on-context\"\n        }), \"Getting back on context\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"For­tu­nately, once we’ve left the con­text, it’s quite straight­for­ward to re­turn to it. Prior to de­f­i­n­i­tion of the code block within then­Run, we can use Vertx.cur­rent­Con­text() or vertx.getOr­Cre­ate­Con­text() to get a han­dle to the con­text on which our event­loop code is run­ning, We can then ex­e­cute the code block in­side a call to Con­text::runOn­Con­text, sim­i­lar to\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Context\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"currentContext\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" vertx.getOrCreateContext();\\ntoComplete.thenRun(() -> {\\n        currentContext.runOnContext(v -> {\\n        assertThat(Thread.currentThread().getName(), is(threadName));\\n        async.complete();\\n    }\\n});\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"While get­ting back onto the cor­rect con­text may not be crit­i­cal if you have re­mained on the event loop thread through­out, it is crit­i­cal if you are going to in­voke sub­se­quent vert.x han­dlers, up­date ver­ti­cle state or any­thing sim­i­lar, so it’s a sen­si­ble gen­eral ap­proach.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"further-reading\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#further-reading\"\n        }), \"Further Reading\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The vert.x team them­selves offer an ex­cel­lent blog about the Vert.x event­loop, with ex­cel­lent ma­te­r­ial on the con­text, on \", _jsx(_components.a, {\n          href: \"https://github.com/vietj/vertx-materials/blob/master/src/main/asciidoc/Demystifying_the_event_loop.adoc\",\n          children: \"Github\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        id: \"thanks\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": true,\n          tabIndex: \"-1\",\n          className: \"heading-anchor\",\n          href: \"#thanks\"\n        }), \"Thanks\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Thanks very much to the vert.x core team for their clear github pages on the event­loop, and also to \", _jsx(_components.a, {\n          href: \"https://twitter.com/alexlehm?lang=en\",\n          children: \"Alexan­der Lehmann\"\n        }), \" for his an­swers to my stu­pid and naive ques­tions on the \", _jsx(_components.a, {\n          href: \"https://groups.google.com/forum/#!forum/vertx\",\n          children: \"Vert.x google group\"\n        }), \".\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},"prevPost":{"meta":{"title":"Vert.x 3.4.0.Beta1 release","category":"guides","authors":[{"name":"Julien Viet","github_id":"vietj"}],"summary":"We have released 3.4.0.Beta1, this release is the biggest since Vert.x 3.0.0 with plenty of great features."},"date":"2017-02-09","slug":"vert-x-3-4-0-beta1-release"},"nextPost":{"meta":{"title":"Building services and APIs with AMQP 1.0","category":"guides","authors":[{"name":"Jakub Scholz","github_id":"scholzj"}],"summary":"Microservices and APIs are everywhere. Everyone talks about them, presentation slides are full of them ... some people are actually even building them."},"date":"2017-01-25","slug":"building-services-and-apis-with-amqp-1-0"},"relatedPosts":[{"meta":{"title":"Some Rest with Vert.x","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"This post is part of the Introduction to Vert.x series. Let’s go a bit further this time and develop a CRUD-ish application"},"date":"2015-07-27","slug":"some-rest-with-vert-x"},{"meta":{"title":"My first Vert.x 3 Application","category":"guides","authors":[{"name":"Clement Escoffier","github_id":"cescoffier"}],"summary":"Let's say, you heard someone saying that Vert.x is awesome. Ok great, but you may want to try it by yourself. Well, the next natural question is “where do I start ?”"},"date":"2015-07-14","slug":"my-first-vert-x-3-application"},{"meta":{"title":"Real-time bidding with Websockets and Vert.x","category":"guides","authors":[{"name":"Marcin Warczyglowa","github_id":"mwarc"}],"summary":"The expectations of users for interactivity with web applications have changed over the past few years.\n    Users during bidding in auction no longer want to press the refresh button."},"date":"2016-01-15","slug":"real-time-bidding-with-websockets-and-vert-x"}]},"__N_SSG":true}