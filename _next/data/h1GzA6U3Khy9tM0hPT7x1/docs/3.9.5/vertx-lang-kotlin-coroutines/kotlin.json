{"pageProps":{"slug":"3.9.5/vertx-lang-kotlin-coroutines/kotlin","title":"vertx-lang-kotlin-coroutines","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_introduction\">Introduction</a></li>\n<li><a href=\"#_running_a_coroutine_from_a_vert_x_context\">Running a coroutine from a Vert.x context</a></li>\n<li><a href=\"#_extending_coroutineverticle\">Extending CoroutineVerticle</a></li>\n<li><a href=\"#_getting_one_shot_asynchronous_results\">Getting one-shot asynchronous results</a></li>\n<li><a href=\"#_getting_one_shot_events\">Getting one-shot events</a></li>\n<li><a href=\"#_getting_one_shot_worker_results\">Getting one-shot worker results</a></li>\n<li><a href=\"#_streams_of_events\">Streams of events</a></li>\n<li><a href=\"#_awaiting_the_completion_of_vert_x_asynchronous_results\">Awaiting the completion of Vert.x asynchronous results</a></li>\n<li><a href=\"#_suspending_extension_methods\">Suspending extension methods</a></li>\n<li><a href=\"#_channels\">Channels</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_receiving_data\">Receiving data</a></li>\n<li><a href=\"#_sending_data\">Sending data</a></li>\n</ul>\n</li>\n<li><a href=\"#_delay_cancellation_and_timeouts\">Delay, cancellation and timeouts</a></li>\n<li><a href=\"#_coroutine_builders\">Coroutine builders</a></li>\n<li><a href=\"#_coroutine_interoperability\">Coroutine interoperability</a></li>\n<li><a href=\"#_rxjava_interoperability\">RxJava interoperability</a></li>\n</ul>\n</div>","contents":"<h1>vertx-lang-kotlin-coroutines</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code>vertx-lang-kotlin-coroutines</code> integrates Kotlin <em>coroutines</em> for performing asynchronous operations and processing events.\nThis results in using a programming model that looks like sequential code, yet it does not block kernel threads.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_introduction\"><a class=\"anchor\" href=\"#_introduction\"></a>Introduction</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>One of the key advantages of Vert.x over many legacy application platforms is that it is almost entirely non-blocking\n(of kernel threads).\nThis allows Vert.x-based applications to handle a lot of concurrency (e.g., many connections and messages) using a very\nsmall number of kernel threads, which in turns unlocks great scalability.</p>\n</div>\n<div class=\"paragraph\">\n<p>The non-blocking nature of Vert.x leads to asynchronous APIs. Asynchronous APIs can take various forms including\ncallbacks, promises, fibers or reactive extensions. Vert.x uses the callback style for the core APIs but it\nalso supports other models like RxJava 1 and 2.</p>\n</div>\n<div class=\"paragraph\">\n<p>In some cases, programming using asynchronous APIs can be more challenging than using a classic / sequential style\nof code, in particular with several operations need to be done in sequence. Also, error propagation is often more\ncomplex when using asynchronous APIs.</p>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx-lang-kotlin-coroutines</code> uses <em>coroutines</em>. Coroutines are very lightweight threads that do not correspond\nto underlying kernel threads, so that when a <em>coroutine</em> needs to <em>\"block</em>\" it gets <em>suspended</em> and frees\nits current kernel thread so that another coroutine can process events.</p>\n</div>\n<div class=\"paragraph\">\n<p><code>vertx-lang-kotlin-coroutines</code> uses <a href=\"https://github.com/Kotlin/kotlinx.coroutines\">kotlinx.coroutines</a> to implement the Coroutines.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<code>vertx-lang-kotlin-coroutines</code> currently only works with Kotlin and will be out of the <a href=\"https://kotlinlang.org/docs/reference/coroutines.html#experimental-status-of-coroutines\">experimental</a> status\nin Kotlin 1.3\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_a_coroutine_from_a_vert_x_context\"><a class=\"anchor\" href=\"#_running_a_coroutine_from_a_vert_x_context\"></a>Running a coroutine from a Vert.x context</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Having imported <code>io.vertx.kotlin.coroutines.VertxCoroutine</code>, the <code>GlobalScope.launch</code> method allows to run a block of code as a\ncoroutine in the \"Global\" application scope (bounded on the lifetime of the application):</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">val</span> vertx = Vertx.vertx()\n\nGlobalScope.launch(vertx.dispatcher()) {\n  <span class=\"hljs-keyword\">val</span> timerId = awaitEvent&lt;<span class=\"hljs-built_in\">Long</span>&gt; { handler -&gt;\n    vertx.setTimer(<span class=\"hljs-number\">1000</span>, handler)\n  }\n  println(<span class=\"hljs-string\">\"Event fired from timer with id <span class=\"hljs-variable\">$timerId</span>\"</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>vertx.dispatcher()</code> returns a coroutine dispatcher that execute coroutines using the Vert.x event loop.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code>awaitEvent</code> function suspends the execution of the coroutine until the timer fires and resumes the coroutines\n with the value that was given to the handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>More details are given in the next sections on handlers, events and stream of events.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_extending_coroutineverticle\"><a class=\"anchor\" href=\"#_extending_coroutineverticle\"></a>Extending CoroutineVerticle</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can deploy your code as instances of <code>io.vertx.kotlin.coroutines.CoroutineVerticle</code>, a specialized type of verticle\nfor Kotlin coroutines. The <code>CoroutineVerticle</code> class implements the <code>kotlinx.coroutines.experimental.CoroutineScope</code> interface,\nmaking all coroutines builder methods bounded by default to the verticle context. You should override the suspending <code>start()</code>\nand (optionally) the suspending <code>stop()</code> methods of the verticle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> : <span class=\"hljs-type\">CoroutineVerticle</span></span>() {\n  <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n\n  <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>All code examples below assume to be run inside a <code>CoroutineVerticle</code> implementation, but you can replace all <code>&lt;builder&gt; { .. }</code>\ncalls with <code>GlobalScope.&lt;builder&gt; { .. }</code> to use the application scope instead.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_one_shot_asynchronous_results\"><a class=\"anchor\" href=\"#_getting_one_shot_asynchronous_results\"></a>Getting one-shot asynchronous results</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Many asynchronous operations in Vert.x take a <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> as the last argument.\nAn example would be executing an object retrieval using the Vert.x Mongo client, or sending an event bus message then\nawaiting for a reply.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is achieved by using the <code>awaitResult</code> method which returns the value or throws an exception.</p>\n</div>\n<div class=\"paragraph\">\n<p>The coroutine is being suspended until the event is being processed, and no kernel thread is being blocked.</p>\n</div>\n<div class=\"paragraph\">\n<p>The method is executed by specifying the asynchronous operation that needs to be executed in the form of a block that\nis passed to the handler at run-time.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitResultExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> consumer = vertx.eventBus().localConsumer&lt;String&gt;(<span class=\"hljs-string\">\"a.b.c\"</span>)\n  consumer.handler { message -&gt;\n    println(<span class=\"hljs-string\">\"Consumer received: <span class=\"hljs-subst\">${message.body()}</span>\"</span>)\n    message.reply(<span class=\"hljs-string\">\"pong\"</span>)\n  }\n\n  <span class=\"hljs-comment\">// Send a message and wait for a reply</span>\n  <span class=\"hljs-keyword\">val</span> reply = awaitResult&lt;Message&lt;String&gt;&gt; { h -&gt;\n    vertx.eventBus().send(<span class=\"hljs-string\">\"a.b.c\"</span>, <span class=\"hljs-string\">\"ping\"</span>, h)\n  }\n  println(<span class=\"hljs-string\">\"Reply received: <span class=\"hljs-subst\">${reply.body()}</span>\"</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When the block produces a failure, the caller can handle it as an exception using the usual exception\n<code>try</code>/<code>catch</code> constructs:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitResultFailureExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> consumer = vertx.eventBus().localConsumer&lt;String&gt;(<span class=\"hljs-string\">\"a.b.c\"</span>)\n  consumer.handler { message -&gt;\n    <span class=\"hljs-comment\">// The consumer will get a failure</span>\n    message.fail(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">\"it failed!!!\"</span>)\n  }\n\n  <span class=\"hljs-comment\">// Send a message and wait for a reply</span>\n  <span class=\"hljs-keyword\">try</span> {\n    awaitResult&lt;Message&lt;String&gt;&gt; { h -&gt;\n      vertx.eventBus().send(<span class=\"hljs-string\">\"a.b.c\"</span>, <span class=\"hljs-string\">\"ping\"</span>, h)\n    }\n  } <span class=\"hljs-keyword\">catch</span> (e: ReplyException) {\n    <span class=\"hljs-comment\">// Handle specific reply exception here</span>\n    println(<span class=\"hljs-string\">\"Reply failure: <span class=\"hljs-subst\">${e.message}</span>\"</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_one_shot_events\"><a class=\"anchor\" href=\"#_getting_one_shot_events\"></a>Getting one-shot events</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Processing a one-shot event (and not the next occurrences, if any) is achieved using the <code>awaitEvent</code> function:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitEventExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> id = awaitEvent&lt;<span class=\"hljs-built_in\">Long</span>&gt; { h -&gt; vertx.setTimer(<span class=\"hljs-number\">2000L</span>, h) }\n  println(<span class=\"hljs-string\">\"This should be fired in 2s by some time with id=<span class=\"hljs-variable\">$id</span>\"</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_one_shot_worker_results\"><a class=\"anchor\" href=\"#_getting_one_shot_worker_results\"></a>Getting one-shot worker results</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Processing a blocking computation is achieved using the <code>awaitBlocking</code> function:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitBlockingExample</span><span class=\"hljs-params\">()</span></span> {\n  awaitBlocking {\n    Thread.sleep(<span class=\"hljs-number\">1000</span>)\n    <span class=\"hljs-string\">\"some-string\"</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_streams_of_events\"><a class=\"anchor\" href=\"#_streams_of_events\"></a>Streams of events</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In many places in Vert.x APIs, streams of events are processed through handlers.\nExamples include event bus message consumers and HTTP server requests.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code>ReceiveChannelHandler</code> class allows receiving events through the (suspendable) <code>receive</code> method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">streamExample</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> adapter = vertx.receiveChannelHandler&lt;Message&lt;<span class=\"hljs-built_in\">Int</span>&gt;&gt;()\n  vertx.eventBus().localConsumer&lt;<span class=\"hljs-built_in\">Int</span>&gt;(<span class=\"hljs-string\">\"a.b.c\"</span>).handler(adapter)\n\n  <span class=\"hljs-comment\">// Send 15 messages</span>\n  <span class=\"hljs-keyword\">for</span> (i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">15</span>) vertx.eventBus().send(<span class=\"hljs-string\">\"a.b.c\"</span>, i)\n\n  <span class=\"hljs-comment\">// Receive the first 10 messages</span>\n  <span class=\"hljs-keyword\">for</span> (i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">10</span>) {\n    <span class=\"hljs-keyword\">val</span> message = adapter.receive()\n    println(<span class=\"hljs-string\">\"Received: <span class=\"hljs-subst\">${message.body()}</span>\"</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_awaiting_the_completion_of_vert_x_asynchronous_results\"><a class=\"anchor\" href=\"#_awaiting_the_completion_of_vert_x_asynchronous_results\"></a>Awaiting the completion of Vert.x asynchronous results</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code>await</code> extension method on instances of Vert.x asynchronous results suspend coroutines until they have completed, in\nwhich case the method returns the corresponding <code>AsyncResult&lt;T&gt;</code> object.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">awaitingFuture</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> httpServerFuture = Future.future&lt;HttpServer&gt;()\n  vertx.createHttpServer()\n    .requestHandler { req -&gt; req.response().end(<span class=\"hljs-string\">\"Hello!\"</span>) }\n    .listen(<span class=\"hljs-number\">8000</span>, httpServerFuture)\n\n  <span class=\"hljs-keyword\">val</span> httpServer = httpServerFuture.await()\n  println(<span class=\"hljs-string\">\"HTTP server port: <span class=\"hljs-subst\">${httpServer.actualPort()}</span>\"</span>)\n\n  <span class=\"hljs-keyword\">val</span> result = CompositeFuture.all(httpServerFuture, httpServerFuture).await()\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    println(<span class=\"hljs-string\">\"The server is now running!\"</span>)\n  } <span class=\"hljs-keyword\">else</span> {\n    result.cause().printStackTrace()\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_suspending_extension_methods\"><a class=\"anchor\" href=\"#_suspending_extension_methods\"></a>Suspending extension methods</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Since <code>3.6.0</code>, Vert.x generates suspending extension methods for all its asynchronous methods.</p>\n</div>\n<div class=\"paragraph\">\n<p>It relieves the user from using the idiomatic <code>awaitResult</code> and makes the code more natural and readable.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">generatedSuspendingExtensionMethod</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-comment\">// Suspending extension method</span>\n  <span class=\"hljs-comment\">// This function has been automatically generated from the [io.vertx.core.net.NetClient original] using Vert.x codegen.</span>\n  <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> NetClient.<span class=\"hljs-title\">connectAwait</span><span class=\"hljs-params\">(port : <span class=\"hljs-type\">Int</span>, host : <span class=\"hljs-type\">String</span>)</span></span> : NetSocket {\n    <span class=\"hljs-keyword\">return</span> awaitResult{\n      <span class=\"hljs-keyword\">this</span>.connect(port, host, it)\n    }\n  }\n\n  <span class=\"hljs-comment\">// Use the extension instead of wrapping with awaitResult</span>\n  <span class=\"hljs-keyword\">val</span> client = vertx.createNetClient();\n  <span class=\"hljs-keyword\">val</span> socket = client.connectAwait(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Each asynchronous method has a suspending counterpart, e.g <code>xyz(1, 2, handler)</code> &#8658; <code>xyzAwait(1, 2)</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Such extensions are provided by the <code>io.vertx:vertx-lang-kotlin</code> dependency and covers the Vert.x stack:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>vertx-web</p>\n</li>\n<li>\n<p>vertx-jdbc-client</p>\n</li>\n<li>\n<p>vertx-cassandra-client</p>\n</li>\n<li>\n<p>etc&#8230;&#8203;</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_channels\"><a class=\"anchor\" href=\"#_channels\"></a>Channels</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Channels are similar to Java <code>BlockingQueue</code> except that they do not block and instead suspend the coroutine\ninstead of blocking:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>sending a value to full channel suspends the coroutine</p>\n</li>\n<li>\n<p>receving a value from an empty channels also suspends the coroutine</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x <code>ReadStream</code> and <code>WriteStream</code> can be adapted to channels with the <code>toChannel</code> extension method.</p>\n</div>\n<div class=\"paragraph\">\n<p>These adapters take care of managing the back-pressure and the stream termination</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>ReadStream&lt;T&gt;</code> is adapted to a <code>ReceiveChannel&lt;T&gt;</code></p>\n</li>\n<li>\n<p><code>WriteStream&lt;T&gt;</code> is adapted to a <code>SendChannel&lt;T&gt;</code></p>\n</li>\n</ul>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_receiving_data\"><a class=\"anchor\" href=\"#_receiving_data\"></a>Receiving data</h3>\n<div class=\"paragraph\">\n<p>Channel can be really useful when you need to handle a stream of correlated values:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">handleTemperatureStream</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> stream = vertx.eventBus().consumer&lt;<span class=\"hljs-built_in\">Double</span>&gt;(<span class=\"hljs-string\">\"temperature\"</span>)\n  <span class=\"hljs-keyword\">val</span> channel = stream.toChannel(vertx)\n\n  <span class=\"hljs-keyword\">var</span> min = <span class=\"hljs-built_in\">Double</span>.MAX_VALUE\n  <span class=\"hljs-keyword\">var</span> max = <span class=\"hljs-built_in\">Double</span>.MIN_VALUE\n\n  <span class=\"hljs-comment\">// Iterate until the stream is closed</span>\n  <span class=\"hljs-comment\">// Non-blocking</span>\n  <span class=\"hljs-keyword\">for</span> (msg <span class=\"hljs-keyword\">in</span> channel) {\n    <span class=\"hljs-keyword\">val</span> temperature = msg.body()\n    min = Math.min(min, temperature)\n    max = Math.max(max, temperature)\n  }\n\n  <span class=\"hljs-comment\">// The stream is now closed</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It can also be useful for parsing protocols. We will build a non blocking HTTP request parser to show\nthe power of channels.</p>\n</div>\n<div class=\"paragraph\">\n<p>We will rely on the <a href=\"http://vertx.io/docs/apidocs/io/vertx/core/parsetools/RecordParser.html\"><code>RecordParser</code></a>\nto slice the stream of buffer to a stream of buffer delimited by <code>\\r\\n</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is the initial version of the parser, that handles only the HTTP request-line</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">vertx.createNetServer().connectHandler { socket -&gt;\n\n  <span class=\"hljs-comment\">// The record parser provides a stream of buffers delimited by \\r\\n</span>\n  <span class=\"hljs-keyword\">val</span> stream = RecordParser.newDelimited(<span class=\"hljs-string\">\"\\r\\n\"</span>, socket)\n\n  <span class=\"hljs-comment\">// Convert the stream to a Kotlin channel</span>\n  <span class=\"hljs-keyword\">val</span> channel = stream.toChannel(vertx)\n\n  <span class=\"hljs-comment\">// Run the coroutine</span>\n  launch {\n\n    <span class=\"hljs-comment\">// Receive the request-line</span>\n    <span class=\"hljs-comment\">// Non-blocking</span>\n    <span class=\"hljs-keyword\">val</span> line = channel.receive().toString().split(<span class=\"hljs-string\">\" \"</span>)\n    <span class=\"hljs-keyword\">val</span> method = line[<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">val</span> uri = line[<span class=\"hljs-number\">1</span>]\n\n    println(<span class=\"hljs-string\">\"Received HTTP request (<span class=\"hljs-variable\">$method</span>, <span class=\"hljs-variable\">$uri</span>)\"</span>)\n\n    <span class=\"hljs-comment\">// Still need to parse headers and body...</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Parsing the request-line is as simple as calling <code>receive</code> on the channel.</p>\n</div>\n<div class=\"paragraph\">\n<p>The next step parses HTTP headers by receiving chunks until we get an empty one</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">// Receive HTTP headers</span>\n<span class=\"hljs-keyword\">val</span> headers = HashMap&lt;String, String&gt;()\n<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n\n  <span class=\"hljs-comment\">// Non-blocking</span>\n  <span class=\"hljs-keyword\">val</span> header = channel.receive().toString()\n\n  <span class=\"hljs-comment\">// Done with parsing headers</span>\n  <span class=\"hljs-keyword\">if</span> (header.isEmpty()) {\n    <span class=\"hljs-keyword\">break</span>\n  }\n\n  <span class=\"hljs-keyword\">val</span> pos = header.indexOf(<span class=\"hljs-string\">':'</span>)\n  headers[header.substring(<span class=\"hljs-number\">0</span>, pos).toLowerCase()] = header.substring(pos + <span class=\"hljs-number\">1</span>).trim()\n}\n\nprintln(<span class=\"hljs-string\">\"Received HTTP request (<span class=\"hljs-variable\">$method</span>, <span class=\"hljs-variable\">$uri</span>) with headers <span class=\"hljs-subst\">${headers.keys}</span>\"</span>)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Finally we terminate the parser by handling optional request bodies</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-comment\">// Receive the request body</span>\n<span class=\"hljs-keyword\">val</span> transferEncoding = headers[<span class=\"hljs-string\">\"transfer-encoding\"</span>]\n<span class=\"hljs-keyword\">val</span> contentLength = headers[<span class=\"hljs-string\">\"content-length\"</span>]\n\n<span class=\"hljs-keyword\">val</span> body: Buffer?\n<span class=\"hljs-keyword\">if</span> (transferEncoding == <span class=\"hljs-string\">\"chunked\"</span>) {\n\n  <span class=\"hljs-comment\">// Handle chunked encoding, e.g</span>\n  <span class=\"hljs-comment\">// 5\\r\\n</span>\n  <span class=\"hljs-comment\">// HELLO\\r\\n</span>\n  <span class=\"hljs-comment\">// 0\\r\\n</span>\n  <span class=\"hljs-comment\">// \\r\\n</span>\n\n  body = Buffer.buffer()\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n\n    <span class=\"hljs-comment\">// Parse length chunk</span>\n    <span class=\"hljs-comment\">// Non-blocking</span>\n    <span class=\"hljs-keyword\">val</span> len = channel.receive().toString().toInt(<span class=\"hljs-number\">16</span>)\n    <span class=\"hljs-keyword\">if</span> (len == <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">break</span>\n    }\n\n    <span class=\"hljs-comment\">// The stream is flipped to parse a chunk of the exact size</span>\n    stream.fixedSizeMode(len + <span class=\"hljs-number\">2</span>)\n\n    <span class=\"hljs-comment\">// Receive the chunk and append it</span>\n    <span class=\"hljs-comment\">// Non-blocking</span>\n    <span class=\"hljs-keyword\">val</span> chunk = channel.receive()\n    body.appendBuffer(chunk, <span class=\"hljs-number\">0</span>, chunk.length() - <span class=\"hljs-number\">2</span>)\n\n    <span class=\"hljs-comment\">// The stream is flipped back to the \\r\\n delimiter to parse the next chunk</span>\n    stream.delimitedMode(<span class=\"hljs-string\">\"\\r\\n\"</span>)\n  }\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (contentLength != <span class=\"hljs-literal\">null</span>) {\n\n  <span class=\"hljs-comment\">// The stream is flipped to parse a body of the exact size</span>\n  stream.fixedSizeMode(contentLength.toInt())\n\n  <span class=\"hljs-comment\">// Non-blocking</span>\n  body = channel.receive()\n} <span class=\"hljs-keyword\">else</span> {\n  body = <span class=\"hljs-literal\">null</span>\n}\n\n<span class=\"hljs-keyword\">val</span> bodySize = body?.length() ?: <span class=\"hljs-number\">0</span>\nprintln(<span class=\"hljs-string\">\"Received HTTP request (<span class=\"hljs-variable\">$method</span>, <span class=\"hljs-variable\">$uri</span>) with headers <span class=\"hljs-subst\">${headers.keys}</span> and body with size <span class=\"hljs-variable\">$bodySize</span>\"</span>)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sending_data\"><a class=\"anchor\" href=\"#_sending_data\"></a>Sending data</h3>\n<div class=\"paragraph\">\n<p>Using a channel to send data is quite straightforward:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">sendChannel</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> stream = vertx.eventBus().publisher&lt;<span class=\"hljs-built_in\">Double</span>&gt;(<span class=\"hljs-string\">\"temperature\"</span>)\n  <span class=\"hljs-keyword\">val</span> channel = stream.toChannel(vertx)\n\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">val</span> temperature = readTemperatureSensor()\n\n    <span class=\"hljs-comment\">// Broadcast the temperature</span>\n    <span class=\"hljs-comment\">// Non-blocking but could be suspended</span>\n    channel.send(temperature)\n\n    <span class=\"hljs-comment\">// Wait for one second</span>\n    awaitEvent&lt;<span class=\"hljs-built_in\">Long</span>&gt; { vertx.setTimer(<span class=\"hljs-number\">1000</span>, it) }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Both <code>SendChannel#send</code> and <code>WriteStream#write</code> are non blocking operations, however unlike <code>SendChannel#send</code>\ncan suspend the execution when the channel is full, the equivalent without a channel would look like</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">sendChannel</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">val</span> stream = vertx.eventBus().publisher&lt;<span class=\"hljs-built_in\">Double</span>&gt;(<span class=\"hljs-string\">\"temperature\"</span>)\n  <span class=\"hljs-keyword\">val</span> channel = stream.toChannel(vertx)\n\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">val</span> temperature = readTemperatureSensor()\n\n    <span class=\"hljs-comment\">// Broadcast the temperature</span>\n    <span class=\"hljs-comment\">// Non-blocking but could be suspended</span>\n    channel.send(temperature)\n\n    <span class=\"hljs-comment\">// Wait for one second</span>\n    awaitEvent&lt;<span class=\"hljs-built_in\">Long</span>&gt; { vertx.setTimer(<span class=\"hljs-number\">1000</span>, it) }\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_delay_cancellation_and_timeouts\"><a class=\"anchor\" href=\"#_delay_cancellation_and_timeouts\"></a>Delay, cancellation and timeouts</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vertx dispatcher fully supports coroutine <code>delay</code> function via Vert.x timers:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">launch {\n  <span class=\"hljs-comment\">// Set a one second Vertx timer</span>\n  delay(<span class=\"hljs-number\">1000</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Timers support cancellation</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\"><span class=\"hljs-keyword\">val</span> job = launch {\n  <span class=\"hljs-comment\">// Set a one second Vertx timer</span>\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    delay(<span class=\"hljs-number\">1000</span>)\n    <span class=\"hljs-comment\">// Do something periodically</span>\n  }\n}\n\n<span class=\"hljs-comment\">// Sometimes later</span>\njob.cancel()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>cancellation is <a href=\"https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#cancellation-is-cooperative\">cooperative</a></p>\n</div>\n<div class=\"paragraph\">\n<p>You can also schedule timeout with the <code>withTimeout</code> function</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">launch {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">val</span> id = withTimeout&lt;String&gt;(<span class=\"hljs-number\">1000</span>) {\n      awaitEvent { anAsyncMethod(it) }\n    }\n  } <span class=\"hljs-keyword\">catch</span> (e: TimeoutCancellationException) {\n    <span class=\"hljs-comment\">// Cancelled</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_coroutine_builders\"><a class=\"anchor\" href=\"#_coroutine_builders\"></a>Coroutine builders</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x works will all coroutine builders, as long as an instance of <code>CoroutineScope</code> is available: <code>launch</code>, <code>async</code>,\n`produce', &#8230;&#8203; . A couple of important things to remember:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>The <code>runBlocking</code> doesn&#8217;t need a <code>CoroutineScope</code> and must not be used from a Vert.x event loop thread.</p>\n</li>\n<li>\n<p>To avoid memory leaks, always use <code>coroutineScope {..}</code> to define a child scope. In this way, if a coroutine fails\ninside the scope, all the others, defined inside that scope, will be cancelled too.</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_coroutine_interoperability\"><a class=\"anchor\" href=\"#_coroutine_interoperability\"></a>Coroutine interoperability</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x integration has been designed to be fully interoperable with Kotlin coroutines</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>kotlinx.coroutines.experimental.sync.Mutex</code> are executed on the event loop thread when using the vertx dispatcher</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_interoperability\"><a class=\"anchor\" href=\"#_rxjava_interoperability\"></a>RxJava interoperability</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The module <code>vertx-lang-kotlin-coroutines</code> does not have specific integration with RxJava however Kotlin coroutines\nprovide integration with RxJava, which works out nicely with <code>vertx-lang-kotlin-coroutines</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can read about it in the <a href=\"https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md\">Guide to reactive streams with coroutines</a></p>\n</div>\n</div>\n</div>","version":"3.9.5"},"__N_SSG":true}