{"pageProps":{"slug":"4.2.3/vertx-junit5/java","title":"Vert.x Junit 5 整合","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_use_it_in_your_build\">在您的构建脚本中使用它</a></li>\n<li><a href=\"#_why_testing_asynchronous_code_is_different\">为什么测试异步代码与平常不同</a></li>\n<li><a href=\"#_a_test_context_for_asynchronous_executions\">异步执行过程的测试上下文</a></li>\n<li><a href=\"#_use_any_assertion_library\">使用其他任何断言库</a></li>\n<li><a href=\"#_checkpoint_when_there_are_multiple_success_conditions\">有多个成功条件的Checkpoint</a></li>\n<li><a href=\"#_integration_with_junit_5\">整合JUnit 5</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_test_methods\">测试方法</a></li>\n<li><a href=\"#_lifecycle_methods\">生命周期函数</a></li>\n</ul>\n</li>\n<li><a href=\"#_support_for_additional_parameter_types\">对于其他额外参数类型的支持</a></li>\n<li><a href=\"#_parameter_ordering\">参数顺序</a></li>\n<li><a href=\"#_parameterized_tests_with_methodsource\">用 <code>@MethodSource</code> 做参数化测试</a></li>\n<li><a href=\"#_running_tests_on_a_vert_x_context\">在 Vert.x 的 context 中执行测试</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Junit 5 整合</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>本模块提供了用 JUnit 5 编写 Vert.x 测试的相关整合以及支持。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_use_it_in_your_build\"><a class=\"anchor\" href=\"#_use_it_in_your_build\"></a>在您的构建脚本中使用它</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>groupId</code>: <code>io.vertx</code></p>\n</li>\n<li>\n<p><code>artifactId</code>: <code>vertx-junit5</code></p>\n</li>\n<li>\n<p><code>version</code>: (当前的 Vert.x 的发布版本或快照版本)</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_why_testing_asynchronous_code_is_different\"><a class=\"anchor\" href=\"#_why_testing_asynchronous_code_is_different\"></a>为什么测试异步代码与平常不同</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>测试异步操作需要比 JUnit 之类的测试工具更多的工具。\n让我们考虑一个典型的例子，用 Vert.x 创建 HTTP 服务，并将它放入 Junit 测试：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ATest</span> </span>{\n  Vertx vertx = Vertx.vertx();\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start_server</span><span class=\"hljs-params\">()</span> </span>{\n    vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Ok&quot;</span>))\n      .listen(<span class=\"hljs-number\">16969</span>, ar -&gt; {\n        <span class=\"hljs-comment\">//（在此处检查服务是否已经启动）</span>\n      });\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这里会有一些问题，因为HTTP服务是异步创建的， <code>listen</code> 方法并不阻塞。\n我们不能按常规方式来断定在 <code>listen</code> 方法返回之后，服务就成功启动了。\n况且：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>传到 <code>listen</code> 的回调函数是在 Vert.x event loop 线程上运行的，而不是在执行 Junit 测试的线程上运行的，此外</p>\n</li>\n<li>\n<p>调用 <code>listen</code> 方法之后，单元测试就退出了，并且已经被认为执行成功，此时HTTP服务有可能并没有启动完毕，而且</p>\n</li>\n<li>\n<p>因为 <code>listen</code> 中的回调函数不是运行于单元测试线程上，而是运行于另一线程，所以类似于断言失败等等任何异常都不会被Junit执行器捕获到。</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_a_test_context_for_asynchronous_executions\"><a class=\"anchor\" href=\"#_a_test_context_for_asynchronous_executions\"></a>异步执行过程的测试上下文</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>首先对该模块有贡献的是 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> 对象：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>允许等待其他线程中正在执行的操作，从而触发完成事件。</p>\n</li>\n<li>\n<p>支持接收失败断言用以标记单元测试失败。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>这是一个很基础的用法：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BTest</span> </span>{\n  Vertx vertx = Vertx.vertx();\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start_http_server</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n    VertxTestContext testContext = <span class=\"hljs-keyword\">new</span> VertxTestContext();\n\n    vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end())\n      .listen(<span class=\"hljs-number\">16969</span>)\n      .onComplete(testContext.succeedingThenComplete()); <b class=\"conum\">(1)</b>\n\n    assertThat(testContext.awaitCompletion(<span class=\"hljs-number\">5</span>, TimeUnit.SECONDS)).isTrue(); <b class=\"conum\">(2)</b>\n    <span class=\"hljs-keyword\">if</span> (testContext.failed()) {  <b class=\"conum\">(3)</b>\n      <span class=\"hljs-keyword\">throw</span> testContext.causeOfFailure();\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeedingThenComplete--\">succeedingThenComplete</a></code> 返回一个异步结果处理器，该处理器期望成功结果并使 test context 通过。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#awaitCompletion-long-java.util.concurrent.TimeUnit-\">awaitCompletion</a></code> 具有 <code>java.util.concurrent.CountDownLatch</code> 的语义，并且，如果测试通过之前超时了，会返回 <code>false</code> 值。</p>\n</li>\n<li>\n<p>如果 context 捕获到了一个错误（潜在的异步错误），那么在测试完成之后，我们必须抛出该异常并让测试用例失败。</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_use_any_assertion_library\"><a class=\"anchor\" href=\"#_use_any_assertion_library\"></a>使用其他任何断言库</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>本模块并不要求您使用特定的断言库。\n您可以使用原始的JUnit断言、 <a href=\"http://joel-costigliola.github.io/assertj/\">AssertJ</a> 、等等。</p>\n</div>\n<div class=\"paragraph\">\n<p>想要在异步代码当中做断言并确定 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> 已被潜在失败所通知， 那么您需要将他们包装到 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#verify-io.vertx.junit5.VertxTestContext.ExecutionBlock-\">verify</a></code> 、 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeeding-io.vertx.core.Handler-\">succeeding</a></code> 或者 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failing-io.vertx.core.Handler-\">failing</a></code> 当中：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient();\n\nclient.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n  .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n  .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n    assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n    testContext.completeNow();\n  })));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> 中有用的方法列举如下：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completeNow--\">completeNow</a></code> 和 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failNow-java.lang.Throwable-\">failNow</a></code> 用于通知成功或失败。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeedingThenComplete--\">succeedingThenComplete</a></code> 用来提供 <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 处理器，该处理器期望得到成功结果并完成 test context。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failingThenComplete--\">failingThenComplete</a></code> 提供一个 <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 处理器，该处理器期望得到失败结果并完成 test context。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeeding--\">succeeding</a></code> 用来提供 <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 处理器，该处理器期望成功结果并将该结果传到下一个回调函数中，该过程中从回调函数抛出任何异常都会被认为测试用例失败。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failing--\">failing</a></code> 用来提供 <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> 处理器 ，该处理器期望一个失败结果，并将异常传入下一个回调函数中，该过程中从回调函数抛出任何异常都会被认为测试用例失败。</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#verify-io.vertx.junit5.VertxTestContext.ExecutionBlock-\">verify</a></code> 提供断言功能，代码块中抛出的任何异常都被认为测试用例失败。</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\n与 <code>succeedingThenComplete</code> 和 <code>failingThenComplete</code> 不同，调用 <code>succeeding</code> 或 <code>failing</code> 方法只能让测试用例失败（例如，<code>succeeding</code> 获取到了失败的异步结果）。\n如果想让测试用例通过，您仍然需要调用 <code>completeNow</code> ，或者使用下述的 checkpoints 。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_checkpoint_when_there_are_multiple_success_conditions\"><a class=\"anchor\" href=\"#_checkpoint_when_there_are_multiple_success_conditions\"></a>有多个成功条件的Checkpoint</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在一些特定的执行点调用 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completeNow--\">completeNow</a></code> 可以轻松的将许多测试标记为通过。\n也就是说基于不同的异步结果，一个测试用例在很多种情况下都可以视为成功。</p>\n</div>\n<div class=\"paragraph\">\n<p>您可以用 checkpoint 以标记某些执行点为通过。\n一个 <code><a href=\"../../apidocs/io/vertx/junit5/Checkpoint.html\">Checkpoint</a></code> 可以由单个标记或多个标记来控制。\n当所有的 checkpoint 被标记后， <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> 将通过测试用例。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一个结合 checkpoint 启动 HTTP 服务、创建 10 个 HTTP 客户端请求并响应 10 个 HTTP 请求的示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Checkpoint serverStarted = testContext.checkpoint();\nCheckpoint requestsServed = testContext.checkpoint(<span class=\"hljs-number\">10</span>);\nCheckpoint responsesReceived = testContext.checkpoint(<span class=\"hljs-number\">10</span>);\n\nvertx.createHttpServer()\n  .requestHandler(req -&gt; {\n    req.response().end(<span class=\"hljs-string\">&quot;Ok&quot;</span>);\n    requestsServed.flag();\n  })\n  .listen(<span class=\"hljs-number\">8888</span>)\n  .onComplete(testContext.succeeding(httpServer -&gt; {\n    serverStarted.flag();\n\n    HttpClient client = vertx.createHttpClient();\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n      client.request(HttpMethod.GET, <span class=\"hljs-number\">8888</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n        .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n        .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n          assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Ok&quot;</span>);\n          responsesReceived.flag();\n        })));\n    }\n  }));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">提示</div>\n</td>\n<td class=\"content\">\ncheckpoint只能在测试用例的主线程创建，不能在Vert.x异步事件回调中创建。\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_integration_with_junit_5\"><a class=\"anchor\" href=\"#_integration_with_junit_5\"></a>整合JUnit 5</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Junit 5 相比于之前的版本，它提供了一个不同的模型。</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_test_methods\"><a class=\"anchor\" href=\"#_test_methods\"></a>测试方法</h3>\n<div class=\"paragraph\">\n<p>与Vert.x 的整合主要受益于 <code><a href=\"../../apidocs/io/vertx/junit5/VertxExtension.html\">VertxExtension</a></code> 类，并使用注入的测试参数： <code>Vertx</code> 和 <code>VertxTestContext</code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeTest</span> </span>{\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">some_test</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> </span>{\n    <span class=\"hljs-comment\">// (...)</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\n<code>Vertx</code> 实例默认配置下并非集群模式。如果您需要做一些其他事情，那么请不要使用注入的 <code>Vertx</code> 参数，需要您自己提供 <code>Vertx</code> 对象。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>测试用例会被自动的包装到 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> 生命周期，所以您无需自行注入 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#awaitCompletion-long-java.util.concurrent.TimeUnit-\">awaitCompletion</a></code> ：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeTest</span> </span>{\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">http_server_check_response</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> </span>{\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> HttpServerVerticle(), testContext.succeeding(id -&gt; {\n      HttpClient client = vertx.createHttpClient();\n      client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n        .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n        .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n          assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n          testContext.completeNow();\n        })));\n    }));\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>您可以结合Junit注解（例如 <code>@RepeatedTest</code> 或者其他生命周期回调注解）来使用本模块：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeTest</span> </span>{\n\n  <span class=\"hljs-comment\">// 部署Verticle 并在部署成功之后</span>\n  <span class=\"hljs-comment\">// 执行测试用例方法</span>\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deploy_verticle</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> </span>{\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> HttpServerVerticle(), testContext.succeedingThenComplete());\n  }\n\n  <span class=\"hljs-comment\">// 重复测试3次</span>\n  <span class=\"hljs-meta\">@RepeatedTest(3)</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">http_server_check_response</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> </span>{\n    HttpClient client = vertx.createHttpClient();\n    client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n      .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n      .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n        assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n        testContext.completeNow();\n      })));\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>也可以用在测试类或者测试方法上加  <code><a href=\"../../apidocs/io/vertx/junit5/Timeout.html\">@Timeout</a></code> 注解来自定义 <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> 的超时时间：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeTest</span> </span>{\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@Timeout(value = 10, timeUnit = TimeUnit.SECONDS)</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">some_test</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext context)</span> </span>{\n    <span class=\"hljs-comment\">// (...)</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_lifecycle_methods\"><a class=\"anchor\" href=\"#_lifecycle_methods\"></a>生命周期函数</h3>\n<div class=\"paragraph\">\n<p>JUnit 5 提供了几个注解用于用户定义的生命周期函数，他们分别是 <code>@BeforeAll</code> ， <code>@BeforeEach</code> ， <code>@AfterEach</code> 和 <code>@AfterAll</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>这些方法可以注入 <code>Vertx</code> 对象。\n通过这种做法，它们才可能用 <code>Vertx</code> 对象执行异步操作，所以它们也可以注入 <code>VertxTestContext</code> 对象来保证JUnit执行器等待测试方法执行完毕，并报告执行结果或错误结果。</p>\n</div>\n<div class=\"paragraph\">\n<p>以下是一个示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LifecycleExampleTest</span> </span>{\n\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;Deploy a verticle&quot;)</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepare</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> </span>{\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> SomeVerticle(), testContext.succeedingThenComplete());\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;A first test&quot;)</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> </span>{\n    <span class=\"hljs-comment\">// (...)</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;A second test&quot;)</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> </span>{\n    <span class=\"hljs-comment\">// (...)</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@AfterEach</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;Check that the verticle is still there&quot;)</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lastChecks</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n    assertThat(vertx.deploymentIDs())\n      .isNotEmpty()\n      .hasSize(<span class=\"hljs-number\">1</span>);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_scope_of_vertextestcontext_objects\"><a class=\"anchor\" href=\"#_scope_of_vertextestcontext_objects\"></a><code>VertxTestContext</code> 对象的作用范围</h4>\n<div class=\"paragraph\">\n<p>因为这些对象都协助等待 <em>异步操作</em> 执行结束，所以调用任何 <code>@Test</code> ， <code>@BeforeAll</code> ， <code>@BeforeEach</code> ， <code>@AfterEach</code> 和 <code>@AfterAll</code> 修饰的方法时都会随之创建一个新的 <code>VertxTestContext</code> 对象。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_scope_of_vertx_objects\"><a class=\"anchor\" href=\"#_scope_of_vertx_objects\"></a><code>Vertx</code> 对象的作用范围</h4>\n<div class=\"paragraph\">\n<p><code>Vertx</code> 对象的作用范围取决于声明周期函数在 <a href=\"http://junit.org/junit5/docs/current/user-guide/#extensions-execution-order\">JUnit中相对执行顺序</a> 里第一个创建 <code>Vertx</code> 的那个方法。一般来说，我们遵循JUnit扩展作用范围规则，\n但是这里有一些规范。</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>如果一个父级test context已经持有一个 <code>Vertx</code> 对象， 那么该 <code>Vertx</code> 对象在子级扩展的test context中会被复用。</p>\n</li>\n<li>\n<p>在 <code>@BeforeAll</code> 修饰的方法中注入的 <code>Vertx</code> 对象，会在之后所有的测试方法以及生命周期函数中注入的 <code>Vertx</code> 参数当中共享。</p>\n</li>\n<li>\n<p>在 <code>@BeforeEach</code> 修饰的且没有父级context的方法注入过程中，或者在先前的 <code>@BeforeAll</code> 方法的参数注入过程中，会创建一个新的对象，并共享于相关所有的测试方法以及 <code>AfterEach</code> 方法。</p>\n</li>\n<li>\n<p>当执行测试方法之前没有创建 <code>Vertx</code> 对象时，则会创建一个新的 <code>Vertx</code> 对象（仅仅作用于该方法本身）</p>\n</li>\n</ol>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_configuring_vertx_instances\"><a class=\"anchor\" href=\"#_configuring_vertx_instances\"></a>配置 <code>Vertx</code> 实例</h4>\n<div class=\"paragraph\">\n<p>默认情况下，<code>Vertx</code> 对象使用 <code>Vertx.vertx()</code> 创建，并使用 <code>Vertx</code> 的默认设置。但是，您可以配置 <code>VertxOptions</code> 以满足您的需要。\n一个典型的应用场景是“扩展调试时阻塞超时警告”。为配置 <code>Vertx</code> 对象，您必须：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>创建一个带有 <a href=\"https://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html#VertxOptions-io.vertx.core.json.JsonObject-\">json 格式</a> 的 <code>VertxOptions</code> 的 json 文件</p>\n</li>\n<li>\n<p>创建一个环境变量 <code>vertx.parameter.filename</code> 指向该文件</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>延长超时的配置文件示例：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-json\" data-lang=\"json\">{\n <span class=\"hljs-attr\">&quot;blockedThreadCheckInterval&quot;</span> : <span class=\"hljs-number\">5</span>,\n <span class=\"hljs-attr\">&quot;blockedThreadCheckIntervalUnit&quot;</span> : <span class=\"hljs-string\">&quot;MINUTES&quot;</span>,\n <span class=\"hljs-attr\">&quot;maxEventLoopExecuteTime&quot;</span> : <span class=\"hljs-number\">360</span>,\n <span class=\"hljs-attr\">&quot;maxEventLoopExecuteTimeUnit&quot;</span> : <span class=\"hljs-string\">&quot;SECONDS&quot;</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>当满足这些条件时， <code>Vertx</code> 对象创建时将使用配置中的参数</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_and_removal_of_vertx_objects\"><a class=\"anchor\" href=\"#_closing_and_removal_of_vertx_objects\"></a>关闭和移除 <code>Vertx</code> 对象</h4>\n<div class=\"paragraph\">\n<p>注入的 <code>Vertx</code> 对象会自动被关闭并被移除其作用域。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，如果在一个测试方法的范围内创建一个 <code>Vertx</code> 对象，那么在该测试方法执行完之后，这个 <code>Vertx</code> 对象会被关闭。\n相似地，当在 <code>@BeforeEach</code> 方法中创建 <code>Vertx</code> 对象时，它会在 <code>@AfterEach</code> 方法执行完之后被关闭。</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_warning_on_multiple_methods_for_the_same_lifecycle_events\"><a class=\"anchor\" href=\"#_warning_on_multiple_methods_for_the_same_lifecycle_events\"></a>同一生命周期事件下多方法的警告</h4>\n<div class=\"paragraph\">\n<p>JUnit 5 允许同一个生命周期事件之下存在多个方法。</p>\n</div>\n<div class=\"paragraph\">\n<p>例如，同一个测试可以定义3个 <code>@BeforeEach</code> 方法。\n因为是异步操作，这些方法更可能是并行执行而不是串行执行，这有可能引起不确定的结果状态。</p>\n</div>\n<div class=\"paragraph\">\n<p>这是JUnit 5本身就存在的问题，而不属于 Vert.x JUnit5 模块范畴。如有疑问，也许您一直想知道的是，为什么单个方法不比多个方法更好。</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_support_for_additional_parameter_types\"><a class=\"anchor\" href=\"#_support_for_additional_parameter_types\"></a>对于其他额外参数类型的支持</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Unit 5 模块是可扩展的：\n您可以通过 <code><a href=\"../../apidocs/io/vertx/junit5/VertxExtensionParameterProvider.html\">VertxExtensionParameterProvider</a></code> 服务接口来添加更多的类型。</p>\n</div>\n<div class=\"paragraph\">\n<p>如果您使用的是 RxJava，您可注入以下类以替代 <code>io.vertx.core.Vertx</code> ：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>io.vertx.rxjava3.core.Vertx</code>，或</p>\n</li>\n<li>\n<p><code>io.vertx.reactivex.core.Vertx</code>，或</p>\n</li>\n<li>\n<p><code>io.vertx.rxjava.core.Vertx</code>。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>为此，请将相应库添加到您的项目中：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>io.vertx:vertx-junit5-rx-java3</code>，或</p>\n</li>\n<li>\n<p><code>io.vertx:vertx-junit5-rx-java2</code>，或</p>\n</li>\n<li>\n<p><code>io.vertx:vertx-junit5-rx-java</code>。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>对于响应式库，您可以找到许多 <code>vertx-junit5</code> 的扩展库，\n他们属于 <code>reactiverse-junit5-extensions</code> 项目，而且都整合了Vert.x技术栈，这些扩展库也正在进一步的发展：</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_parameter_ordering\"><a class=\"anchor\" href=\"#_parameter_ordering\"></a>参数顺序</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在某些情况下，可能必须将一个参数类型放置在另一个参数之前。\n例如 Web Client 在 <code>vertx-junit5-extensions</code> 项目中会要求 <code>Vertx</code> 参数在 <code>WebClient</code> 参数之前。\n这是因为只有 <code>Vertx</code> 参数存在的时候，才可以创建 <code>WebClient</code> 。</p>\n</div>\n<div class=\"paragraph\">\n<p>我们期望参数提供者抛出一些有意义的异常来让用户知道参数顺序的要求。</p>\n</div>\n<div class=\"paragraph\">\n<p>然而，任何情况下，我们都建议：将 <code>Vertx</code> 作为第一个参数，并按照您创建的顺序去声明后续参数。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_parameterized_tests_with_methodsource\"><a class=\"anchor\" href=\"#_parameterized_tests_with_methodsource\"></a>用 <code>@MethodSource</code> 做参数化测试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>您可以结合vertx-junit5，用 <code>@MethodSource</code> 做参数化测试。\n因此，您需要在方法定义的vertx测试参数之前声明 method source 参数。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeTest</span> </span>{\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> Stream&lt;Arguments&gt; <span class=\"hljs-title\">testData</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> Stream.of(\n      Arguments.of(<span class=\"hljs-string\">&quot;complex object1&quot;</span>, <span class=\"hljs-number\">4</span>),\n      Arguments.of(<span class=\"hljs-string\">&quot;complex object2&quot;</span>, <span class=\"hljs-number\">0</span>)\n    );\n  }\n\n  <span class=\"hljs-meta\">@ParameterizedTest</span>\n  <span class=\"hljs-meta\">@MethodSource(&quot;testData&quot;)</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">(String obj, <span class=\"hljs-keyword\">int</span> count, Vertx vertx, VertxTestContext testContext)</span> </span>{\n    <span class=\"hljs-comment\">// your test code</span>\n    testContext.completeNow();\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>这同样适用于其它 <code>ArgumentSources</code> 。\n详见 <a href=\"https://junit.org/junit5/docs/current/api/org.junit.jupiter.params/org/junit/jupiter/params/ParameterizedTest.html\">ParameterizedTest</a> 文档的 <code>Formal Parameter List</code> 一节。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_tests_on_a_vert_x_context\"><a class=\"anchor\" href=\"#_running_tests_on_a_vert_x_context\"></a>在 Vert.x 的 context 中执行测试</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>默认情况下，是由 JUnit 线程来调用测试方法。\n可以使用 <code><a href=\"../../apidocs/io/vertx/junit5/RunTestOnContext.html\">RunTestOnContext</a></code> 扩展以选择使用一个 Vert.x event-loop 线程来执行测试方法。</p>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\n您需要注意在使用该扩展时不要阻塞事件循环。\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>为了使用 Vert.x 的线程来执行测试，扩展需要您提供一个 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 的实例。\n默认情况下，扩展会自动创建一个 <code>Vertx</code> 的实例，但您也可以提供配置参数，或是指定一个方法来提供其实例。</p>\n</div>\n<div class=\"paragraph\">\n<p>这个 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 的实例可以在执行测试的方法中获取到。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RunTestOnContextExampleTest</span> </span>{\n\n  <span class=\"hljs-meta\">@RegisterExtension</span>\n  RunTestOnContext rtoc = <span class=\"hljs-keyword\">new</span> RunTestOnContext();\n\n  Vertx vertx;\n\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepare</span><span class=\"hljs-params\">(VertxTestContext testContext)</span> </span>{\n    vertx = rtoc.vertx();\n    <span class=\"hljs-comment\">// 在 Vert.x 的 event-loop 线程上准备测试资源</span>\n    <span class=\"hljs-comment\">// 每次执行测试时该线程都不一样</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(VertxTestContext testContext)</span> </span>{\n    <span class=\"hljs-comment\">// 在同一个 Vert.x 的 event-loop 线程上执行测试</span>\n    <span class=\"hljs-comment\">// 该测试方法和 prepare 方法使用的是同一个线程</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@AfterEach</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">cleanUp</span><span class=\"hljs-params\">(VertxTestContext testContext)</span> </span>{\n    <span class=\"hljs-comment\">// 在同一个 Vert.x 的 event-loop 线程上清理资源</span>\n    <span class=\"hljs-comment\">// 该方法和 prepare 与 foo 方法使用的是同一个线程</span>\n    testContext.completeNow();\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code>@RegisterExtension</code> 注解修饰类的非静态属性时，会为每个测试方法创建新的 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/Context.html\">Context</a></code> 的对象。\n<code>@BeforeEach</code> 和 <code>@AfterEach</code> 注解修饰的方法会在该 context 中执行。</p>\n</div>\n<div class=\"paragraph\">\n<p>使用 <code>@RegisterExtension</code> 注解修饰类的静态属性时，会为所有的测试方法创建一个公用的 <code><a href=\"../../apidocs/io/vertx/core/Vertx.html\">Vertx</a></code> 和 <code><a href=\"../../apidocs/io/vertx/core/Context.html\">Context</a></code> 的对象。\n<code>@BeforeEach</code> 和 <code>@AfterEach</code> 注解修饰的方法也会在该 context 中执行。</p>\n</div>\n</div>\n</div>","version":"4.2.3"},"__N_SSG":true}