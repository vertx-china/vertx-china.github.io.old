{"pageProps":{"slug":"3.9.0/vertx-rx/java","title":"Vert.x RxJava","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_vert_x_api_for_rxjava\">Vert.x API for RxJava</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_api_for_rxjava1\">Using Vert.x API for RxJava1</a></li>\n<li><a href=\"#_read_stream_support\">Read stream support</a></li>\n<li><a href=\"#_write_stream_support\">Write stream support</a></li>\n<li><a href=\"#_handler_support\">Handler support</a></li>\n<li><a href=\"#_async_result_support\">Async result support</a></li>\n<li><a href=\"#_scheduler_support\">Scheduler support</a></li>\n<li><a href=\"#_json_unmarshalling\">Json unmarshalling</a></li>\n<li><a href=\"#_deploying_a_verticle\">Deploying a Verticle</a></li>\n<li><a href=\"#_httpclient_get_on_subscription\">HttpClient GET on subscription</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxified_api\">Rxified API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_embedding_rxfified_vert_x\">Embedding Rxfified Vert.x</a></li>\n<li><a href=\"#_as_a_verticle\">As a Verticle</a></li>\n<li><a href=\"#_api_examples\">Api examples</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_eventbus_message_stream\">EventBus message stream</a></li>\n<li><a href=\"#_timers\">Timers</a></li>\n<li><a href=\"#_http_client_requests\">Http client requests</a></li>\n<li><a href=\"#_http_server_requests\">Http server requests</a></li>\n<li><a href=\"#_websocket_client\">Websocket client</a></li>\n<li><a href=\"#_websocket_server\">Websocket server</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x RxJava</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_vert_x_api_for_rxjava\"><a class=\"anchor\" href=\"#_vert_x_api_for_rxjava\"></a>Vert.x API for RxJava</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> is a popular library for composing asynchronous and event based programs using\nobservable sequences for the Java VM. Vert.x integrates naturally with RxJava, allowing to use\nobservable wherever you can use streams or asynchronous results.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_api_for_rxjava1\"><a class=\"anchor\" href=\"#_using_vert_x_api_for_rxjava1\"></a>Using Vert.x API for RxJava1</h3>\n<div class=\"paragraph\">\n<p>To use Vert.x API for RxJava1, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-rx-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">'io.vertx:vertx-rx-java:3.9.0'</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>There are two ways for using the RxJava API with Vert.x:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>via the original Vert.x API with the <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html\">RxHelper</a></code> helper class that provides static\nmethods for converting objects between Vert.x core API and RxJava API.</p>\n</li>\n<li>\n<p>via the <em>Rxified</em> Vert.x API enhancing the core Vert.x API.</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_read_stream_support\"><a class=\"anchor\" href=\"#_read_stream_support\"></a>Read stream support</h3>\n<div class=\"paragraph\">\n<p>RxJava <code>Observable</code> is a perfect match for Vert.x <code>ReadStream</code> class : both provide a flow of items.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toObservable-io.vertx.core.streams.ReadStream-\">RxHelper.toObservable</a></code> static methods convert\na Vert.x read stream to an <code>rx.Observable</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fileSystem = vertx.fileSystem();\nfileSystem.open(<span class=\"hljs-string\">\"/data.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = RxHelper.toObservable(file);\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">\"Read data: \"</span> + data.toString(<span class=\"hljs-string\">\"UTF-8\"</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API provides a <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/ReadStream.html#toObservable--\">toObservable</a></code>  method on\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/ReadStream.html\">ReadStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\nfs.open(<span class=\"hljs-string\">\"/data.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = file.toObservable();\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">\"Read data: \"</span> + data.toString(<span class=\"hljs-string\">\"UTF-8\"</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Such observables arehot* observables, i.e. they will produce notifications regardless of subscriptions because\na <code>ReadStream</code> can potentially emit items spontaneously or not, depending on the implementation:</p>\n</div>\n<div class=\"paragraph\">\n<p>At subscription time, the adapter calls <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-\">handler</a></code>\nto set its own handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Some <code>ReadStream</code> implementations can start to emit events after this call, others will emit events whether an\nhandler is set or not:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>AsyncFile</code> produces buffer events after the handler is set</p>\n</li>\n<li>\n<p><code>HttpServerRequest</code> produces events independantly of the handler (i.e buffer may be lost if no handler is set)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>In both cases, subscribing to the <code>Observable</code> in the same call is safe because the event loop or the worker\nverticles cannot be called concurrently, so the subscription will always happens before the handler starts emitting\ndata.</p>\n</div>\n<div class=\"paragraph\">\n<p>When you need to delay the subscription, you need to <code>pause</code> the <code>ReadStream</code> and then <code>resume</code> it, which is what\nyou would do with a <code>ReadStream</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.POST) {\n\n    <span class=\"hljs-comment\">// Stop receiving buffers</span>\n    request.pause();\n\n    checkAuth(res -&gt; {\n\n      <span class=\"hljs-comment\">// Now we can receive buffers again</span>\n      request.resume();\n\n      <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n        Observable&lt;Buffer&gt; observable = request.toObservable();\n        observable.subscribe(buff -&gt; {\n          <span class=\"hljs-comment\">// Get buffers</span>\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Likewise it is possible to turn an existing <code>Observable</code> into a Vert.x <code>ReadStream</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toReadStream-rx.Observable-\">RxHelper.toReadStream</a></code>  static methods convert\nan <code>rx.Observable</code> to a Vert.x read stream:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Buffer&gt; observable = getObservable();\nReadStream&lt;Buffer&gt; readStream = RxHelper.toReadStream(observable);\nPump pump = Pump.pump(readStream, response);\npump.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_write_stream_support\"><a class=\"anchor\" href=\"#_write_stream_support\"></a>Write stream support</h3>\n<div class=\"paragraph\">\n<p>A <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>, like a <code>rx.Subscriber</code>, consumes items, and, when it can&#8217;t keep-up, collaborates with the producer to avoid an ever-growing backlog.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x provides the <code><a href=\"../../apidocs/io/vertx/rx/java/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> adapter that you can use to send <code>Observable</code> items to any <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Sending buffers to an HTTP server response</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nWriteStreamSubscriber&lt;io.vertx.core.buffer.Buffer&gt; subscriber = io.vertx.rx.java.RxHelper.toSubscriber(response);\nobservable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If you are progamming with the <em>Rxified</em> Vert.x API, the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> implementations provide a <code>toSubscriber</code> method.\nThe previous example then becomes even more straightforward:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nobservable.subscribe(response.toSubscriber());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nWhen the <code>Observable</code> terminates successfully, the adapter invokes the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html#end--\">end</a></code> method.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">小心</div>\n</td>\n<td class=\"content\">\nThe adapter sets the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> <code>drain</code> and <code>exception</code> handlers, so don&#8217;t use them after subscribing.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> adapter is able to invoke callbacks when:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>the <code>Observable</code> terminates with an error, or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> fails (e.g. HTTP connection is closed or filesystem is full), or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> ends (i.e. all writes done and file is closed), or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> ends with an error (i.e. all writes done and an error occured when closing the file)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This allows for a more robust program design, as well as scheduling other tasks after the stream has been handled:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\nWriteStreamSubscriber&lt;Buffer&gt; subscriber = response.toSubscriber();\n\nsubscriber.onError(throwable -&gt; {\n  <span class=\"hljs-keyword\">if</span> (!response.headWritten() &amp;&amp; response.closed()) {\n    response.setStatusCode(<span class=\"hljs-number\">500</span>).end(<span class=\"hljs-string\">\"oops\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// log error</span>\n  }\n});\n\nsubscriber.onWriteStreamError(throwable -&gt; {\n  <span class=\"hljs-comment\">// log error</span>\n});\n\nsubscriber.onWriteStreamEnd(() -&gt; {\n  <span class=\"hljs-comment\">// log end of transaction to audit system...</span>\n});\n\nobservable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nIf the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> fails, the adapter unsubscribes from the <code>Observable</code>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handler_support\"><a class=\"anchor\" href=\"#_handler_support\"></a>Handler support</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html\">RxHelper</a></code> can create an <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableHandler.html\">ObservableHandler</a></code>: an <code>Observable</code> with a\n<code><a href=\"../../apidocs/io/vertx/rx/java/ObservableHandler.html#toHandler--\">toHandler</a></code> method returning an <code>Handler&lt;T&gt;</code> implementation:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ObservableHandler&lt;Long&gt; observable = RxHelper.observableHandler();\nobservable.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// Fired</span>\n});\nvertx.setTimer(<span class=\"hljs-number\">1000</span>, observable.toHandler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API does not provide a specific API for handler.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_async_result_support\"><a class=\"anchor\" href=\"#_async_result_support\"></a>Async result support</h3>\n<div class=\"paragraph\">\n<p>You can create an RxJava <code>Subscriber</code> from an existing Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> and subscribe\nit to an <code>Observable</code> or a <code>Single</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">observable.subscribe(RxHelper.toSubscriber(handler1));\n\n<span class=\"hljs-comment\">// Subscribe to a Single</span>\nsingle.subscribe(RxHelper.toSubscriber(handler2));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> construct occuring as last parameter of an asynchronous method can\nbe mapped to an observable of a single element:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>when the callback is a success, the observer <code>onNext</code> method is called with the item\nand the <code>onComplete</code> method is immediately invoked after</p>\n</li>\n<li>\n<p>when the callback is a failure, the observer <code>onError</code> method is called</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#observableFuture--\">RxHelper.observableFuture</a></code> method creates an <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableFuture.html\">ObservableFuture</a></code>:\nan <code>Observable</code> with a <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableFuture.html#toHandler--\">toHandler</a></code> method returning a <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>\nimplementation:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ObservableFuture&lt;HttpServer&gt; observable = RxHelper.observableFuture();\nobservable.subscribe(\n    server -&gt; {\n      <span class=\"hljs-comment\">// Server is listening</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// Server could not start</span>\n    }\n);\nvertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions().\n    setPort(<span class=\"hljs-number\">1234</span>).\n    setHost(<span class=\"hljs-string\">\"localhost\"</span>)\n).listen(observable.toHandler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>ObservableFuture&lt;Server&gt;</code> will get a single <code>HttpServer</code> object, if the <code>listen</code> operation fails,\nthe subscriber will be notified with the failure.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toHandler-rx.Observer-\">RxHelper.toHandler</a></code> method adapts an existing <code>Observer</code> into an handler:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observer&lt;HttpServer&gt; observer = <span class=\"hljs-keyword\">new</span> Observer&lt;HttpServer&gt;() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(HttpServer o)</span> </span>{\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{\n  }\n};\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler = RxHelper.toFuture(observer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It also works with just actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Action1&lt;HttpServer&gt; onNext = httpServer -&gt; {};\nAction1&lt;Throwable&gt; onError = httpServer -&gt; {};\nAction0 onComplete = () -&gt; {};\n\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler1 = RxHelper.toFuture(onNext);\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler2 = RxHelper.toFuture(onNext, onError);\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler3 = RxHelper.toFuture(onNext, onError, onComplete);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API duplicates each such method with the <code>rx</code> prefix that returns an RxJava <code>Single</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpServer&gt; single = vertx\n  .createHttpServer()\n  .rxListen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">\"localhost\"</span>);\n\n<span class=\"hljs-comment\">// Subscribe to bind the server</span>\nsingle.\n    subscribe(\n        server -&gt; {\n          <span class=\"hljs-comment\">// Server is listening</span>\n        },\n        failure -&gt; {\n          <span class=\"hljs-comment\">// Server could not start</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Such single arecold* singles, and the corresponding API method is called on subscribe.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">注意</div>\n</td>\n<td class=\"content\">\nthe <code>rx*</code> methods replace the <code>*Observable</code> of the previous <em>Rxified</em> versions with a semantic\nchange to be more in line with RxJava.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scheduler_support\"><a class=\"anchor\" href=\"#_scheduler_support\"></a>Scheduler support</h3>\n<div class=\"paragraph\">\n<p>The reactive extension sometimes needs to schedule actions, for instance <code>Observable#timer</code> creates and returns\na timer that emit periodic events. By default, scheduled actions are managed by RxJava, it means that the\ntimer threads are not Vert.x threads and therefore not executing in a Vert.x event loop.</p>\n</div>\n<div class=\"paragraph\">\n<p>When an RxJava method deals with a scheduler, it accepts an overloaded method accepting an extra <code>rx.Scheduler</code>,\nthe <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#scheduler-io.vertx.core.Vertx-\">RxHelper.scheduler</a></code>  method will return a scheduler that can be used\nin such places.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.timer(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For blocking scheduled actions, a scheduler can be created with the <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#blockingScheduler-io.vertx.core.Vertx-\">RxHelper.blockingScheduler</a></code>\nmethod:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.blockingScheduler(vertx);\nObservable&lt;Integer&gt; obs = blockingObservable.observeOn(scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava can also be reconfigured to use the Vert.x scheduler, thanks to the scheduler hook created with\n<code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#schedulerHook-io.vertx.core.Vertx-\">RxHelper.schedulerHook</a></code>, the returned scheduler hook\nuses a blocking scheduler for IO actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaSchedulersHook hook = RxHelper.schedulerHook(vertx);\nRxJavaHooks.setOnIOScheduler(f -&gt; hook.getIOScheduler());\nRxJavaHooks.setOnNewThreadScheduler(f -&gt; hook.getNewThreadScheduler());\nRxJavaHooks.setOnComputationScheduler(f -&gt; hook.getComputationScheduler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API provides also similar method on the <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html\">RxHelper</a></code> class:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = io.vertx.rxjava.core.RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaSchedulersHook hook = io.vertx.rxjava.core.RxHelper.schedulerHook(vertx);\n  RxJavaHooks.setOnIOScheduler(f -&gt; hook.getIOScheduler());\n  RxJavaHooks.setOnNewThreadScheduler(f -&gt; hook.getNewThreadScheduler());\n  RxJavaHooks.setOnComputationScheduler(f -&gt; hook.getComputationScheduler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is also possible to create a scheduler backed by a named worker pool. This can be useful if you want to re-use\nthe specific thread pool for scheduling blocking actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = io.vertx.rxjava.core.RxHelper.scheduler(workerExecutor);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_unmarshalling\"><a class=\"anchor\" href=\"#_json_unmarshalling\"></a>Json unmarshalling</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code> creates an <code>rx.Observable.Operator</code> that\ntransforms an <code>Observable&lt;Buffer&gt;</code> in json format into an object observable:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">\"/data.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = RxHelper.toObservable(file);\n  observable.lift(RxHelper.unmarshaller(MyPojo<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)).<span class=\"hljs-title\">subscribe</span>(\n      <span class=\"hljs-title\">mypojo</span> -&gt; </span>{\n        <span class=\"hljs-comment\">// Process the object</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same can be done with the <em>Rxified</em> helper:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">\"/data.txt\"</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = file.toObservable();\n  observable.lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)).<span class=\"hljs-title\">subscribe</span>(\n      <span class=\"hljs-title\">mypojo</span> -&gt; </span>{\n        <span class=\"hljs-comment\">// Process the object</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_a_verticle\"><a class=\"anchor\" href=\"#_deploying_a_verticle\"></a>Deploying a Verticle</h3>\n<div class=\"paragraph\">\n<p>The Rxified API cannot deploy an existing Verticle instance, the helper <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#observableFuture--\">RxHelper.observableFuture</a></code> method\nprovides a solution to that.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#deployVerticle-io.vertx.rxjava.core.Vertx-io.vertx.core.Verticle-\">RxHelper.deployVerticle</a></code> does it automatically\nfor you, it deploys a <code>Verticle</code> and returns an <code>Observable&lt;String&gt;</code> of the deployment ID.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;String&gt; deployment = RxHelper.deployVerticle(vertx, verticle);\n\ndeployment.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// Deployed</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// Could not deploy</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_httpclient_get_on_subscription\"><a class=\"anchor\" href=\"#_httpclient_get_on_subscription\"></a>HttpClient GET on subscription</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#get-io.vertx.rxjava.core.http.HttpClient-int-java.lang.String-java.lang.String-\">RxHelper.get</a></code>\nis a convenient helper method that performs an HTTP GET upon subscription:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpClientResponse&gt; get = RxHelper.get(client, <span class=\"hljs-string\">\"http://the-server\"</span>);\n\n<span class=\"hljs-comment\">// Do the request</span>\nget.subscribe(resp -&gt; {\n  <span class=\"hljs-comment\">// Got response</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// Something went wrong</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">警告</div>\n</td>\n<td class=\"content\">\nthis API is different from the HttpClient that performs the GET request when the method is called and returns\na one shot <code>Observable</code>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<h1 id=\"_rxified_api\" class=\"sect0\"><a class=\"anchor\" href=\"#_rxified_api\"></a>Rxified API</h1>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> API is a code generated version of the Vert.x API, just like the <em>JavaScript</em> or <em>Groovy</em>\nlanguage. The API uses the <code>io.vertx.rxjava</code> prefix, for instance the <code>io.vertx.core.Vertx</code> class is\ntranslated to the <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html\">Vertx</a></code> class.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_embedding_rxfified_vert_x\"><a class=\"anchor\" href=\"#_embedding_rxfified_vert_x\"></a>Embedding Rxfified Vert.x</h3>\n<div class=\"paragraph\">\n<p>Just use the <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#vertx--\">Vertx.vertx</a></code> methods:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = io.vertx.rxjava.core.Vertx.vertx();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_as_a_verticle\"><a class=\"anchor\" href=\"#_as_a_verticle\"></a>As a Verticle</h3>\n<div class=\"paragraph\">\n<p>Extend the <code><a href=\"../../apidocs/io/vertx/rxjava/core/AbstractVerticle.html\">AbstractVerticle</a></code> class, it will wrap it for you:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">rxjava</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Use Rxified Vertx here</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Deploying an RxJava verticle is still performed by the Java deployer and does not need a specified\ndeployer.</p>\n</div>\n<div class=\"paragraph\">\n<p>Verticles having an asynchronous start can override instead the <code>rxStart</code> method and return a <code>Completable</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">rxjava</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Completable <span class=\"hljs-title\">rxStart</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">\"Hello World\"</span>))\n      .rxListen()\n      .toCompletable();\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_api_examples\"><a class=\"anchor\" href=\"#_api_examples\"></a>Api examples</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Let&#8217;s study now a few examples of using Vert.x with RxJava.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_eventbus_message_stream\"><a class=\"anchor\" href=\"#_eventbus_message_stream\"></a>EventBus message stream</h3>\n<div class=\"paragraph\">\n<p>The event bus <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> provides naturally an <code>Observable&lt;Message&lt;T&gt;&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">\"the-address\"</span>);\nObservable&lt;Message&lt;String&gt;&gt; observable = consumer.toObservable();\nSubscription sub = observable.subscribe(msg -&gt; {\n  <span class=\"hljs-comment\">// Got message</span>\n});\n\n<span class=\"hljs-comment\">// Unregisters the stream after 10 seconds</span>\nvertx.setTimer(<span class=\"hljs-number\">10000</span>, id -&gt; {\n  sub.unsubscribe();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> provides a stream of <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/Message.html\">Message</a></code>.\nThe <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/Message.html#body--\">body</a></code> gives access to a new stream of message bodies if needed:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">\"the-address\"</span>);\nObservable&lt;String&gt; observable = consumer.bodyStream().toObservable();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava map/reduce composition style can then be used:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Double&gt; observable = vertx.eventBus().\n    &lt;Double&gt;consumer(<span class=\"hljs-string\">\"heat-sensor\"</span>).\n    bodyStream().\n    toObservable();\n\nobservable.\n    buffer(<span class=\"hljs-number\">1</span>, TimeUnit.SECONDS).\n    map(samples -&gt; samples.\n        stream().\n        collect(Collectors.averagingDouble(d -&gt; d))).\n    subscribe(heat -&gt; {\n      vertx.eventBus().send(<span class=\"hljs-string\">\"news-feed\"</span>, <span class=\"hljs-string\">\"Current heat is \"</span> + heat);\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timers\"><a class=\"anchor\" href=\"#_timers\"></a>Timers</h3>\n<div class=\"paragraph\">\n<p>Timer task can be created with <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#timerStream-long-\">timerStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.timerStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">\"Callback after 1 second\"</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Periodic task can be created with <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#periodicStream-long-\">periodicStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">\"Callback every second\"</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The observable can be cancelled with an unsubscription:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(<span class=\"hljs-keyword\">new</span> Subscriber&lt;Long&gt;() {\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(Long aLong)</span> </span>{\n        <span class=\"hljs-comment\">// Callback</span>\n        unsubscribe();\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{}\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{}\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_client_requests\"><a class=\"anchor\" href=\"#_http_client_requests\"></a>Http client requests</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientRequest.html#toObservable--\">toObservable</a></code> provides a one shot callback with the\n<code><a href=\"../../apidocs/io/vertx/core/http/HttpClientResponse.html\">HttpClientResponse</a></code> object. The observable reports a request failure.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nHttpClientRequest request = client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/the_uri\"</span>);\nrequest.toObservable().subscribe(\n    response -&gt; {\n      <span class=\"hljs-comment\">// Process the response</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// Could not connect</span>\n    }\n);\nrequest.end();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The response can be processed as an <code>Observable&lt;Buffer&gt;</code> with the\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientResponse.html#toObservable--\">toObservable</a></code> method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.toObservable().\n    subscribe(\n        response -&gt; {\n          Observable&lt;Buffer&gt; observable = response.toObservable();\n          observable.forEach(\n              buffer -&gt; {\n                <span class=\"hljs-comment\">// Process buffer</span>\n              }\n          );\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same flow can be achieved with the <code>flatMap</code> operation:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.toObservable().\n    flatMap(HttpClientResponse::toObservable).\n    forEach(\n        buffer -&gt; {\n          <span class=\"hljs-comment\">// Process buffer</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>We can also unmarshall the <code>Observable&lt;Buffer&gt;</code> into an object using the <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code>\nstatic method. This method creates an <code>Rx.Observable.Operator</code> unmarshalling buffers to an object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.toObservable().\n    flatMap(HttpClientResponse::toObservable).\n    lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)).\n    <span class=\"hljs-title\">forEach</span>(\n        <span class=\"hljs-title\">pojo</span> -&gt; </span>{\n          <span class=\"hljs-comment\">// Process pojo</span>\n        }\n    );</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_server_requests\"><a class=\"anchor\" href=\"#_http_server_requests\"></a>Http server requests</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpServer.html#requestStream--\">requestStream</a></code> provides a callback for each incoming\nrequest:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  <span class=\"hljs-comment\">// Process request</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> can then be adapted to an <code>Observable&lt;Buffer&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;Buffer&gt; observable = request.toObservable();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code> can be used to parse and map\na json request to an object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;MyPojo&gt; observable = request.\n      toObservable().\n      lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_client\"><a class=\"anchor\" href=\"#_websocket_client\"></a>Websocket client</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClient.html#rxWebSocket-int-java.lang.String-java.lang.String-\">rxWebSocket</a></code> provides a single callback when the websocket\nconnects, otherwise a failure:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nclient.rxWebSocket(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/the_uri\"</span>).subscribe(\n    ws -&gt; {\n      <span class=\"hljs-comment\">// Use the websocket</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// Could not connect</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/WebSocket.html\">WebSocket</a></code> can then be turned into an <code>Observable&lt;Buffer&gt;</code> easily:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"Got message \"</span> + buffer.toString(<span class=\"hljs-string\">\"UTF-8\"</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_server\"><a class=\"anchor\" href=\"#_websocket_server\"></a>Websocket server</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpServer.html#websocketStream--\">websocketStream</a></code> provides a callback for each incoming\nconnection:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;ServerWebSocket&gt; socketObservable = server.websocketStream().toObservable();\nsocketObservable.subscribe(\n    socket -&gt; System.out.println(<span class=\"hljs-string\">\"Web socket connect\"</span>),\n    failure -&gt; System.out.println(<span class=\"hljs-string\">\"Should never be called\"</span>),\n    () -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"Subscription ended or server closed\"</span>);\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> can be turned into an <code>Observable&lt;Buffer&gt;</code> easily:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">\"Got message \"</span> + buffer.toString(<span class=\"hljs-string\">\"UTF-8\"</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"3.9.0"},"__N_SSG":true}